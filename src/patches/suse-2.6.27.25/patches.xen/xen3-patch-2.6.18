From: www.kernel.org
Subject: Linux 2.6.18
Patch-mainline: 2.6.18

Automatically created from "patches.kernel.org/patch-2.6.18" by xen-port-patches.py

Acked-by: jbeulich@novell.com

--- sle11-2009-05-14.orig/arch/x86/Kconfig	2009-02-05 10:20:53.000000000 +0100
+++ sle11-2009-05-14/arch/x86/Kconfig	2009-04-20 11:36:10.000000000 +0200
@@ -44,7 +44,6 @@ config GENERIC_LOCKBREAK
 
 config GENERIC_TIME
 	def_bool y
-	depends on !X86_XEN
 
 config GENERIC_CMOS_UPDATE
 	def_bool y
--- sle11-2009-05-14.orig/arch/x86/kernel/Makefile	2008-12-01 11:14:33.000000000 +0100
+++ sle11-2009-05-14/arch/x86/kernel/Makefile	2009-04-20 11:36:10.000000000 +0200
@@ -124,5 +124,5 @@ ifeq ($(CONFIG_X86_64),y)
 	pci-dma_64-$(CONFIG_XEN)	+= pci-dma_32.o
 endif
 
-disabled-obj-$(CONFIG_XEN) := i8259_$(BITS).o reboot.o smpboot_$(BITS).o
+disabled-obj-$(CONFIG_XEN) := i8253.o i8259_$(BITS).o reboot.o smpboot_$(BITS).o tsc_$(BITS).o
 %/head_$(BITS).o %/head_$(BITS).s: $(if $(CONFIG_XEN),EXTRA_AFLAGS,dummy) :=
--- sle11-2009-05-14.orig/arch/x86/kernel/entry_32-xen.S	2009-05-14 11:01:13.000000000 +0200
+++ sle11-2009-05-14/arch/x86/kernel/entry_32-xen.S	2009-05-14 11:01:46.000000000 +0200
@@ -388,8 +388,10 @@ ENTRY(sysenter_entry_pv)
 	movl %ebp,12(%esp)
 	movl $__USER_CS,4(%esp)
 	addl $4,%esp
+	CFI_ADJUST_CFA_OFFSET -4
 	/* +5*4 is SS:ESP,EFLAGS,CS:EIP. +8 is esp0 setting. */
 	pushl (TI_sysenter_return-THREAD_SIZE+8+4*4)(%esp)
+	CFI_ADJUST_CFA_OFFSET 4
 /*
  * Load the potential sixth argument from user stack.
  * Careful about security.
--- sle11-2009-05-14.orig/arch/x86/kernel/setup64-xen.c	2009-05-14 11:01:13.000000000 +0200
+++ sle11-2009-05-14/arch/x86/kernel/setup64-xen.c	2009-04-20 11:36:10.000000000 +0200
@@ -363,5 +363,7 @@ void __cpuinit cpu_init (void)
 
 	fpu_init(); 
 
-	raw_local_save_flags(kernel_eflags);
+	asm ("pushfq; popq %0" : "=rm" (kernel_eflags));
+	if (raw_irqs_disabled())
+		kernel_eflags &= ~X86_EFLAGS_IF;
 }
--- sle11-2009-05-14.orig/arch/x86/kernel/time_32-xen.c	2009-03-18 12:51:05.000000000 +0100
+++ sle11-2009-05-14/arch/x86/kernel/time_32-xen.c	2009-04-20 11:36:10.000000000 +0200
@@ -76,8 +76,13 @@
 
 #if defined (__i386__)
 #include <asm/i8259.h>
+#include <asm/i8253.h>
+DEFINE_SPINLOCK(i8253_lock);
+EXPORT_SYMBOL(i8253_lock);
 #endif
 
+#define XEN_SHIFT 22
+
 int pit_latch_buggy;              /* extern */
 
 #if defined(__x86_64__)
@@ -97,10 +102,6 @@ extern unsigned long wall_jiffies;
 DEFINE_SPINLOCK(rtc_lock);
 EXPORT_SYMBOL(rtc_lock);
 
-extern struct init_timer_opts timer_tsc_init;
-extern struct timer_opts timer_tsc;
-#define timer_none timer_tsc
-
 /* These are peridically updated in shared_info, and then copied here. */
 struct shadow_time_info {
 	u64 tsc_timestamp;     /* TSC at last update of time vals.  */
@@ -229,14 +230,6 @@ static inline u64 scale_delta(u64 delta,
 	return product;
 }
 
-#if 0 /* defined (__i386__) */
-int read_current_timer(unsigned long *timer_val)
-{
-	rdtscl(*timer_val);
-	return 0;
-}
-#endif
-
 void init_cpu_khz(void)
 {
 	u64 __cpu_khz = 1000000ULL << 32;
@@ -256,6 +249,7 @@ static u64 get_nsec_offset(struct shadow
 	return scale_delta(delta, shadow->tsc_to_nsec_mul, shadow->tsc_shift);
 }
 
+#ifdef CONFIG_X86_64
 static unsigned long get_usec_offset(struct shadow_time_info *shadow)
 {
 	u64 now, delta;
@@ -263,6 +257,7 @@ static unsigned long get_usec_offset(str
 	delta = now - shadow->tsc_timestamp;
 	return scale_delta(delta, shadow->tsc_to_usec_mul, shadow->tsc_shift);
 }
+#endif
 
 static void __update_wallclock(time_t sec, long nsec)
 {
@@ -377,6 +372,8 @@ void rtc_cmos_write(unsigned char val, u
 }
 EXPORT_SYMBOL(rtc_cmos_write);
 
+#ifdef CONFIG_X86_64
+
 /*
  * This version of gettimeofday has microsecond resolution
  * and better than microsecond precision on fast x86 machines with TSC.
@@ -512,6 +509,8 @@ int do_settimeofday(struct timespec *tv)
 
 EXPORT_SYMBOL(do_settimeofday);
 
+#endif
+
 static void sync_xen_wallclock(unsigned long dummy);
 static DEFINE_TIMER(sync_xen_wallclock_timer, sync_xen_wallclock, 0, 0);
 static void sync_xen_wallclock(unsigned long dummy)
@@ -563,11 +562,15 @@ static int set_rtc_mmss(unsigned long no
 	return retval;
 }
 
+#ifdef CONFIG_X86_64
 /* monotonic_clock(): returns # of nanoseconds passed since time_init()
  *		Note: This function is required to return accurate
  *		time even in the absence of multiple timer ticks.
  */
 unsigned long long monotonic_clock(void)
+#else
+unsigned long long sched_clock(void)
+#endif
 {
 	unsigned int cpu = get_cpu();
 	struct shadow_time_info *shadow = &per_cpu(shadow_time, cpu);
@@ -587,9 +590,9 @@ unsigned long long monotonic_clock(void)
 
 	return time;
 }
+#ifdef CONFIG_X86_64
 EXPORT_SYMBOL(monotonic_clock);
 
-#ifdef __x86_64__
 unsigned long long sched_clock(void)
 {
 	return monotonic_clock();
@@ -759,6 +762,89 @@ irqreturn_t timer_interrupt(int irq, voi
 	return IRQ_HANDLED;
 }
 
+#ifndef CONFIG_X86_64
+
+void tsc_init(void)
+{
+	init_cpu_khz();
+	printk(KERN_INFO "Xen reported: %u.%03u MHz processor.\n",
+	       cpu_khz / 1000, cpu_khz % 1000);
+
+	use_tsc_delay();
+}
+
+#include <linux/clocksource.h>
+
+void mark_tsc_unstable(void)
+{
+#ifndef CONFIG_XEN /* XXX Should tell the hypervisor about this fact. */
+	tsc_unstable = 1;
+#endif
+}
+EXPORT_SYMBOL_GPL(mark_tsc_unstable);
+
+static cycle_t xen_clocksource_read(void)
+{
+#ifdef CONFIG_SMP
+	static cycle_t last_ret;
+#ifndef CONFIG_64BIT
+	cycle_t last = cmpxchg64(&last_ret, 0, 0);
+#else
+	cycle_t last = last_ret;
+#define cmpxchg64 cmpxchg
+#endif
+	cycle_t ret = sched_clock();
+
+	if (unlikely((s64)(ret - last) < 0)) {
+		if (last - ret > permitted_clock_jitter
+		    && printk_ratelimit()) {
+			unsigned int cpu = get_cpu();
+			struct shadow_time_info *shadow = &per_cpu(shadow_time, cpu);
+
+			printk(KERN_WARNING "clocksource/%u: "
+			       "Time went backwards: "
+			       "ret=%Lx delta=%Ld shadow=%Lx offset=%Lx\n",
+			       cpu, ret, ret - last, shadow->system_timestamp,
+			       get_nsec_offset(shadow));
+			put_cpu();
+		}
+		return last;
+	}
+
+	for (;;) {
+		cycle_t cur = cmpxchg64(&last_ret, last, ret);
+
+		if (cur == last || (s64)(ret - cur) < 0)
+			return ret;
+		last = cur;
+	}
+#else
+	return sched_clock();
+#endif
+}
+
+static struct clocksource clocksource_xen = {
+	.name			= "xen",
+	.rating			= 400,
+	.read			= xen_clocksource_read,
+	.mask			= CLOCKSOURCE_MASK(64),
+	.mult			= 1 << XEN_SHIFT,		/* time directly in nanoseconds */
+	.shift			= XEN_SHIFT,
+	.is_continuous		= 1,
+};
+
+static int __init init_xen_clocksource(void)
+{
+	clocksource_xen.mult = clocksource_khz2mult(cpu_khz,
+						clocksource_xen.shift);
+
+	return clocksource_register(&clocksource_xen);
+}
+
+module_init(init_xen_clocksource);
+
+#endif
+
 static void init_missing_ticks_accounting(unsigned int cpu)
 {
 	struct vcpu_register_runstate_memory_area area;
@@ -947,11 +1033,11 @@ void __init time_init(void)
 
 	update_wallclock();
 
+#ifdef CONFIG_X86_64
 	init_cpu_khz();
 	printk(KERN_INFO "Xen reported: %u.%03u MHz processor.\n",
 	       cpu_khz / 1000, cpu_khz % 1000);
 
-#if defined(__x86_64__)
 	vxtime.mode = VXTIME_TSC;
 	vxtime.quot = (1000000L << 32) / vxtime_hz;
 	vxtime.tsc_quot = (1000L << 32) / cpu_khz;
--- sle11-2009-05-14.orig/drivers/oprofile/oprofile_files.c	2009-02-16 16:01:39.000000000 +0100
+++ sle11-2009-05-14/drivers/oprofile/oprofile_files.c	2009-04-20 11:36:10.000000000 +0200
@@ -217,7 +217,7 @@ static ssize_t adomain_read(struct file 
 }
 
 
-static struct file_operations active_domain_ops = {
+static const struct file_operations active_domain_ops = {
 	.read		= adomain_read,
 	.write		= adomain_write,
 };
@@ -310,7 +310,7 @@ static ssize_t pdomain_read(struct file 
 	return retval;
 }
 
-static struct file_operations passive_domain_ops = {
+static const struct file_operations passive_domain_ops = {
 	.read		= pdomain_read,
 	.write		= pdomain_write,
 };
--- sle11-2009-05-14.orig/drivers/xen/blktap/blktap.c	2009-04-20 11:35:40.000000000 +0200
+++ sle11-2009-05-14/drivers/xen/blktap/blktap.c	2009-04-20 11:36:10.000000000 +0200
@@ -931,7 +931,7 @@ static int req_increase(void)
 
 static void mmap_req_del(int mmap)
 {
-	BUG_ON(!spin_is_locked(&pending_free_lock));
+	assert_spin_locked(&pending_free_lock);
 
 	kfree(pending_reqs[mmap]);
 	pending_reqs[mmap] = NULL;
--- sle11-2009-05-14.orig/drivers/xen/core/smpboot.c	2009-05-14 11:01:13.000000000 +0200
+++ sle11-2009-05-14/drivers/xen/core/smpboot.c	2009-04-28 16:02:07.000000000 +0200
@@ -48,10 +48,6 @@ cpumask_t cpu_initialized_map;
 struct cpuinfo_x86 cpu_data[NR_CPUS] __cacheline_aligned;
 EXPORT_SYMBOL(cpu_data);
 
-#ifdef CONFIG_HOTPLUG_CPU
-DEFINE_PER_CPU(int, cpu_state) = { 0 };
-#endif
-
 static DEFINE_PER_CPU(int, resched_irq);
 static DEFINE_PER_CPU(int, callfunc_irq);
 static char resched_name[NR_CPUS][15];
--- sle11-2009-05-14.orig/include/asm-x86/mach-xen/asm/pgtable_64.h	2008-12-15 11:13:45.000000000 +0100
+++ sle11-2009-05-14/include/asm-x86/mach-xen/asm/pgtable_64.h	2009-04-20 11:36:10.000000000 +0200
@@ -394,7 +394,6 @@ static inline int pmd_large(pmd_t pte) {
 
 /*
  * Level 4 access.
- * Never use these in the common code.
  */
 #define pgd_page(pgd) ((unsigned long) __va(pgd_val(pgd) & PTE_MASK))
 #define pgd_index(address) (((address) >> PGDIR_SHIFT) & (PTRS_PER_PGD-1))
--- sle11-2009-05-14.orig/include/asm-x86/mach-xen/asm/processor_32.h	2009-05-14 11:01:13.000000000 +0200
+++ sle11-2009-05-14/include/asm-x86/mach-xen/asm/processor_32.h	2009-04-20 11:36:10.000000000 +0200
@@ -23,7 +23,7 @@
 #include <xen/interface/physdev.h>
 
 /* flag for disabling the tsc */
-extern int tsc_disable;
+#define tsc_disable 0
 
 struct desc_struct {
 	unsigned long a,b;
--- sle11-2009-05-14.orig/include/asm-x86/thread_info.h	2009-05-14 11:01:13.000000000 +0200
+++ sle11-2009-05-14/include/asm-x86/thread_info.h	2009-04-20 11:36:10.000000000 +0200
@@ -142,12 +142,16 @@ struct thread_info {
 	(_TIF_SIGPENDING|_TIF_MCE_NOTIFY|_TIF_NOTIFY_RESUME|_TIF_PERFMON_WORK)
 
 /* flags to check in __switch_to() */
+#ifndef CONFIG_XEN
 #define _TIF_WORK_CTXSW							\
 	(_TIF_IO_BITMAP|_TIF_DEBUGCTLMSR|_TIF_DS_AREA_MSR|_TIF_BTS_TRACE_TS| \
 	 _TIF_NOTSC|_TIF_PERFMON_CTXSW)
 
 #define _TIF_WORK_CTXSW_PREV _TIF_WORK_CTXSW
 #define _TIF_WORK_CTXSW_NEXT (_TIF_WORK_CTXSW|_TIF_DEBUG)
+#else
+#define _TIF_WORK_CTXSW _TIF_DEBUG
+#endif
 
 #define PREEMPT_ACTIVE		0x10000000
 
