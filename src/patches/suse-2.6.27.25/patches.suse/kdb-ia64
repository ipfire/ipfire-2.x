From: SGI KDB Development <kdb@oss.sgi.com>
Subject:/kdb-v4.4-2.6.27-rc8-ia64-1
References: FATE#303971
X-URL: ftp://oss.sgi.com/www/projects/kdb/download/v4.4/

The KDB IA64 code.

Acked-by: Bernhard Walle <bwalle@suse.de>

---
 arch/ia64/Kconfig.debug            |   97 
 arch/ia64/Makefile                 |    1 
 arch/ia64/include/asm/ansidecl.h   |  383 +
 arch/ia64/include/asm/bfd.h        | 5089 +++++++++++++++++++++
 arch/ia64/include/asm/kdb.h        |   45 
 arch/ia64/include/asm/kdb_break.h  |   24 
 arch/ia64/include/asm/kdbprivate.h |  124 
 arch/ia64/include/asm/kmap_types.h |    3 
 arch/ia64/include/asm/kregs.h      |    2 
 arch/ia64/kdb/ChangeLog            | 1085 ++++
 arch/ia64/kdb/Makefile             |   21 
 arch/ia64/kdb/cpu-ia64-opc.c       |  598 ++
 arch/ia64/kdb/ia64-asmtab.c        | 8585 +++++++++++++++++++++++++++++++++++++
 arch/ia64/kdb/ia64-asmtab.h        |  158 
 arch/ia64/kdb/ia64-dis.c           |  312 +
 arch/ia64/kdb/ia64-opc.c           |  749 +++
 arch/ia64/kdb/ia64-opc.h           |  141 
 arch/ia64/kdb/ia64.h               |  402 +
 arch/ia64/kdb/kdb_cmds             |   17 
 arch/ia64/kdb/kdba_bp.c            |  841 +++
 arch/ia64/kdb/kdba_bt.c            |  285 +
 arch/ia64/kdb/kdba_fru.c           |   65 
 arch/ia64/kdb/kdba_id.c            |  529 ++
 arch/ia64/kdb/kdba_io.c            |  661 ++
 arch/ia64/kdb/kdba_jmp.S           |  394 +
 arch/ia64/kdb/kdba_pod.c           |   64 
 arch/ia64/kdb/kdba_support.c       | 1720 +++++++
 arch/ia64/kernel/head.S            |    7 
 arch/ia64/kernel/mca.c             |   72 
 arch/ia64/kernel/smp.c             |   23 
 arch/ia64/kernel/traps.c           |   22 
 arch/ia64/kernel/unwind.c          |   33 
 32 files changed, 22539 insertions(+), 13 deletions(-)

--- a/arch/ia64/Kconfig.debug
+++ b/arch/ia64/Kconfig.debug
@@ -56,9 +56,106 @@ config IA64_DEBUG_IRQ
 	  and restore instructions.  It's useful for tracking down spinlock
 	  problems, but slow!  If you're unsure, select N.
 
+config KDB
+	bool "Built-in Kernel Debugger support"
+	depends on DEBUG_KERNEL
+	select KALLSYMS
+	select KALLSYMS_ALL
+	help
+	  This option provides a built-in kernel debugger.  The built-in
+	  kernel debugger contains commands which allow memory to be examined,
+	  instructions to be disassembled and breakpoints to be set.  For details,
+	  see Documentation/kdb/kdb.mm and the manual pages kdb_bt, kdb_ss, etc.
+	  Kdb can also be used via the serial port.  Set up the system to
+	  have a serial console (see Documentation/serial-console.txt).
+	  The key sequence <escape>KDB on the serial port will cause the
+	  kernel debugger to be entered with input from the serial port and
+	  output to the serial console.  If unsure, say N.
+
+config KDB_MODULES
+	tristate "KDB modules"
+	depends on KDB
+	help
+	  KDB can be extended by adding your own modules, in directory
+	  kdb/modules.  This option selects the way that these modules should
+	  be compiled, as free standing modules (select M) or built into the
+	  kernel (select Y).  If unsure say M.
+
+config KDB_OFF
+	bool "KDB off by default"
+	depends on KDB
+	help
+	  Normally kdb is activated by default, as long as CONFIG_KDB is set.
+	  If you want to ship a kernel with kdb support but only have kdb
+	  turned on when the user requests it then select this option.  When
+	  compiled with CONFIG_KDB_OFF, kdb ignores all events unless you boot
+	  with kdb=on or you echo "1" > /proc/sys/kernel/kdb.  This option also
+	  works in reverse, if kdb is normally activated, you can boot with
+	  kdb=off or echo "0" > /proc/sys/kernel/kdb to deactivate kdb. If
+	  unsure, say N.
+
+config KDB_CONTINUE_CATASTROPHIC
+	int "KDB continues after catastrophic errors"
+	depends on KDB
+	default "0"
+	help
+	  This integer controls the behaviour of kdb when the kernel gets a
+	  catastrophic error, i.e. for a panic, oops, NMI or other watchdog
+	  tripping.  CONFIG_KDB_CONTINUE_CATASTROPHIC interacts with
+	  /proc/sys/kernel/kdb and CONFIG_LKCD_DUMP (if your kernel has the
+	  LKCD patch).
+	  When KDB is active (/proc/sys/kernel/kdb == 1) and a catastrophic
+	  error occurs, nothing extra happens until you type 'go'.
+	  CONFIG_KDB_CONTINUE_CATASTROPHIC == 0 (default).  The first time
+	  you type 'go', kdb warns you.  The second time you type 'go', KDB
+	  tries to continue - no guarantees that the kernel is still usable.
+	  CONFIG_KDB_CONTINUE_CATASTROPHIC == 1.  KDB tries to continue - no
+	  guarantees that the kernel is still usable.
+	  CONFIG_KDB_CONTINUE_CATASTROPHIC == 2.  If your kernel has the LKCD
+	  patch and LKCD is configured to take a dump then KDB forces a dump.
+	  Whether or not a dump is taken, KDB forces a reboot.
+	  When KDB is not active (/proc/sys/kernel/kdb == 0) and a catastrophic
+	  error occurs, the following steps are automatic, no human
+	  intervention is required.
+	  CONFIG_KDB_CONTINUE_CATASTROPHIC == 0 (default) or 1.  KDB attempts
+	  to continue - no guarantees that the kernel is still usable.
+	  CONFIG_KDB_CONTINUE_CATASTROPHIC == 2.  If your kernel has the LKCD
+	  patch and LKCD is configured to take a dump then KDB automatically
+	  forces a dump.  Whether or not a dump is taken, KDB forces a
+	  reboot.
+	  If you are not sure, say 0.  Read Documentation/kdb/dump.txt before
+	  setting to 2.
+
+config KDB_USB
+	bool "Support for USB Keyboard in KDB (OHCI and/or EHCI only)"
+	depends on KDB && (USB_OHCI_HCD || USB_UHCI_HCD)
+	help
+	  If you want to use kdb from USB keyboards then say Y here.  If you
+	  say N then kdb can only be used from a PC (AT) keyboard or a serial
+	  console.
+
+config KDB_HARDWARE_BREAKPOINTS
+	bool "Enable hardware breakpoints in KDB"
+	depends on KDB
+	default y
+	help
+	  If you say Y here, KDB will allow you to use the IA64
+	  hardware watchpoint feature (via the bph and bpha
+	  commands).  Currently, only data breakpoints are
+	  implemented.
+
 config SYSVIPC_COMPAT
 	bool
 	depends on COMPAT && SYSVIPC
 	default y
 
+config KDB_KDUMP
+	bool "Support for Kdump in KDB"
+	depends on KDB
+	select KEXEC
+	default N
+	help
+	  If you want to take Kdump kernel vmcore from KDB then say Y here.
+	  Of imsire. say N.
+
 endmenu
--- a/arch/ia64/Makefile
+++ b/arch/ia64/Makefile
@@ -60,6 +60,7 @@ core-$(CONFIG_IA64_SGI_SN2)	+= arch/ia64
 core-$(CONFIG_IA64_SGI_UV)	+= arch/ia64/uv/
 core-$(CONFIG_KVM) 		+= arch/ia64/kvm/
 
+drivers-$(CONFIG_KDB)		+= arch/$(ARCH)/kdb/
 drivers-$(CONFIG_PCI)		+= arch/ia64/pci/
 drivers-$(CONFIG_IA64_HP_SIM)	+= arch/ia64/hp/sim/
 drivers-$(CONFIG_IA64_HP_ZX1)	+= arch/ia64/hp/common/ arch/ia64/hp/zx1/
--- /dev/null
+++ b/arch/ia64/include/asm/ansidecl.h
@@ -0,0 +1,383 @@
+/* ANSI and traditional C compatability macros
+   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* Extracted from binutils 2.16.91.0.2 (OpenSUSE 10.0) and modified for kdb use.
+ * Any trailing whitespace was removed and #ifdef/ifndef __KERNEL__ added as
+ * required.
+ * Keith Owens <kaos@sgi.com> 15 May 2006
+ */
+
+/* ANSI and traditional C compatibility macros
+
+   ANSI C is assumed if __STDC__ is #defined.
+
+   Macro		ANSI C definition	Traditional C definition
+   -----		---- - ----------	----------- - ----------
+   ANSI_PROTOTYPES	1			not defined
+   PTR			`void *'		`char *'
+   PTRCONST		`void *const'		`char *'
+   LONG_DOUBLE		`long double'		`double'
+   const		not defined		`'
+   volatile		not defined		`'
+   signed		not defined		`'
+   VA_START(ap, var)	va_start(ap, var)	va_start(ap)
+
+   Note that it is safe to write "void foo();" indicating a function
+   with no return value, in all K+R compilers we have been able to test.
+
+   For declaring functions with prototypes, we also provide these:
+
+   PARAMS ((prototype))
+   -- for functions which take a fixed number of arguments.  Use this
+   when declaring the function.  When defining the function, write a
+   K+R style argument list.  For example:
+
+	char *strcpy PARAMS ((char *dest, char *source));
+	...
+	char *
+	strcpy (dest, source)
+	     char *dest;
+	     char *source;
+	{ ... }
+
+
+   VPARAMS ((prototype, ...))
+   -- for functions which take a variable number of arguments.  Use
+   PARAMS to declare the function, VPARAMS to define it.  For example:
+
+	int printf PARAMS ((const char *format, ...));
+	...
+	int
+	printf VPARAMS ((const char *format, ...))
+	{
+	   ...
+	}
+
+   For writing functions which take variable numbers of arguments, we
+   also provide the VA_OPEN, VA_CLOSE, and VA_FIXEDARG macros.  These
+   hide the differences between K+R <varargs.h> and C89 <stdarg.h> more
+   thoroughly than the simple VA_START() macro mentioned above.
+
+   VA_OPEN and VA_CLOSE are used *instead of* va_start and va_end.
+   Immediately after VA_OPEN, put a sequence of VA_FIXEDARG calls
+   corresponding to the list of fixed arguments.  Then use va_arg
+   normally to get the variable arguments, or pass your va_list object
+   around.  You do not declare the va_list yourself; VA_OPEN does it
+   for you.
+
+   Here is a complete example:
+
+	int
+	printf VPARAMS ((const char *format, ...))
+	{
+	   int result;
+
+	   VA_OPEN (ap, format);
+	   VA_FIXEDARG (ap, const char *, format);
+
+	   result = vfprintf (stdout, format, ap);
+	   VA_CLOSE (ap);
+
+	   return result;
+	}
+
+
+   You can declare variables either before or after the VA_OPEN,
+   VA_FIXEDARG sequence.  Also, VA_OPEN and VA_CLOSE are the beginning
+   and end of a block.  They must appear at the same nesting level,
+   and any variables declared after VA_OPEN go out of scope at
+   VA_CLOSE.  Unfortunately, with a K+R compiler, that includes the
+   argument list.  You can have multiple instances of VA_OPEN/VA_CLOSE
+   pairs in a single function in case you need to traverse the
+   argument list more than once.
+
+   For ease of writing code which uses GCC extensions but needs to be
+   portable to other compilers, we provide the GCC_VERSION macro that
+   simplifies testing __GNUC__ and __GNUC_MINOR__ together, and various
+   wrappers around __attribute__.  Also, __extension__ will be #defined
+   to nothing if it doesn't work.  See below.
+
+   This header also defines a lot of obsolete macros:
+   CONST, VOLATILE, SIGNED, PROTO, EXFUN, DEFUN, DEFUN_VOID,
+   AND, DOTS, NOARGS.  Don't use them.  */
+
+#ifndef	_ANSIDECL_H
+#define _ANSIDECL_H	1
+
+/* Every source file includes this file,
+   so they will all get the switch for lint.  */
+/* LINTLIBRARY */
+
+/* Using MACRO(x,y) in cpp #if conditionals does not work with some
+   older preprocessors.  Thus we can't define something like this:
+
+#define HAVE_GCC_VERSION(MAJOR, MINOR) \
+  (__GNUC__ > (MAJOR) || (__GNUC__ == (MAJOR) && __GNUC_MINOR__ >= (MINOR)))
+
+and then test "#if HAVE_GCC_VERSION(2,7)".
+
+So instead we use the macro below and test it against specific values.  */
+
+/* This macro simplifies testing whether we are using gcc, and if it
+   is of a particular minimum version. (Both major & minor numbers are
+   significant.)  This macro will evaluate to 0 if we are not using
+   gcc at all.  */
+#ifndef GCC_VERSION
+#define GCC_VERSION (__GNUC__ * 1000 + __GNUC_MINOR__)
+#endif /* GCC_VERSION */
+
+#if defined (__STDC__) || defined (_AIX) || (defined (__mips) && defined (_SYSTYPE_SVR4)) || defined(_WIN32) || (defined(__alpha) && defined(__cplusplus))
+/* All known AIX compilers implement these things (but don't always
+   define __STDC__).  The RISC/OS MIPS compiler defines these things
+   in SVR4 mode, but does not define __STDC__.  */
+/* eraxxon@alumni.rice.edu: The Compaq C++ compiler, unlike many other
+   C++ compilers, does not define __STDC__, though it acts as if this
+   was so. (Verified versions: 5.7, 6.2, 6.3, 6.5) */
+
+#define ANSI_PROTOTYPES	1
+#define PTR		void *
+#define PTRCONST	void *const
+#define LONG_DOUBLE	long double
+
+/* PARAMS is often defined elsewhere (e.g. by libintl.h), so wrap it in
+   a #ifndef.  */
+#ifndef PARAMS
+#define PARAMS(ARGS)		ARGS
+#endif
+
+#define VPARAMS(ARGS)		ARGS
+#define VA_START(VA_LIST, VAR)	va_start(VA_LIST, VAR)
+
+/* variadic function helper macros */
+/* "struct Qdmy" swallows the semicolon after VA_OPEN/VA_FIXEDARG's
+   use without inhibiting further decls and without declaring an
+   actual variable.  */
+#define VA_OPEN(AP, VAR)	{ va_list AP; va_start(AP, VAR); { struct Qdmy
+#define VA_CLOSE(AP)		} va_end(AP); }
+#define VA_FIXEDARG(AP, T, N)	struct Qdmy
+
+#undef const
+#undef volatile
+#undef signed
+
+#ifdef	__KERNEL__
+#ifndef	__STDC_VERSION__
+#define	__STDC_VERSION__ 0
+#endif
+#endif	/* __KERNEL__ */
+
+/* inline requires special treatment; it's in C99, and GCC >=2.7 supports
+   it too, but it's not in C89.  */
+#undef inline
+#if __STDC_VERSION__ > 199901L
+/* it's a keyword */
+#else
+# if GCC_VERSION >= 2007
+#  define inline __inline__   /* __inline__ prevents -pedantic warnings */
+# else
+#  define inline  /* nothing */
+# endif
+#endif
+
+/* These are obsolete.  Do not use.  */
+#ifndef IN_GCC
+#define CONST		const
+#define VOLATILE	volatile
+#define SIGNED		signed
+
+#define PROTO(type, name, arglist)	type name arglist
+#define EXFUN(name, proto)		name proto
+#define DEFUN(name, arglist, args)	name(args)
+#define DEFUN_VOID(name)		name(void)
+#define AND		,
+#define DOTS		, ...
+#define NOARGS		void
+#endif /* ! IN_GCC */
+
+#else	/* Not ANSI C.  */
+
+#undef  ANSI_PROTOTYPES
+#define PTR		char *
+#define PTRCONST	PTR
+#define LONG_DOUBLE	double
+
+#define PARAMS(args)		()
+#define VPARAMS(args)		(va_alist) va_dcl
+#define VA_START(va_list, var)	va_start(va_list)
+
+#define VA_OPEN(AP, VAR)		{ va_list AP; va_start(AP); { struct Qdmy
+#define VA_CLOSE(AP)			} va_end(AP); }
+#define VA_FIXEDARG(AP, TYPE, NAME)	TYPE NAME = va_arg(AP, TYPE)
+
+/* some systems define these in header files for non-ansi mode */
+#undef const
+#undef volatile
+#undef signed
+#undef inline
+#define const
+#define volatile
+#define signed
+#define inline
+
+#ifndef IN_GCC
+#define CONST
+#define VOLATILE
+#define SIGNED
+
+#define PROTO(type, name, arglist)	type name ()
+#define EXFUN(name, proto)		name()
+#define DEFUN(name, arglist, args)	name arglist args;
+#define DEFUN_VOID(name)		name()
+#define AND		;
+#define DOTS
+#define NOARGS
+#endif /* ! IN_GCC */
+
+#endif	/* ANSI C.  */
+
+/* Define macros for some gcc attributes.  This permits us to use the
+   macros freely, and know that they will come into play for the
+   version of gcc in which they are supported.  */
+
+#if (GCC_VERSION < 2007)
+# define __attribute__(x)
+#endif
+
+/* Attribute __malloc__ on functions was valid as of gcc 2.96. */
+#ifndef ATTRIBUTE_MALLOC
+# if (GCC_VERSION >= 2096)
+#  define ATTRIBUTE_MALLOC __attribute__ ((__malloc__))
+# else
+#  define ATTRIBUTE_MALLOC
+# endif /* GNUC >= 2.96 */
+#endif /* ATTRIBUTE_MALLOC */
+
+/* Attributes on labels were valid as of gcc 2.93. */
+#ifndef ATTRIBUTE_UNUSED_LABEL
+# if (!defined (__cplusplus) && GCC_VERSION >= 2093)
+#  define ATTRIBUTE_UNUSED_LABEL ATTRIBUTE_UNUSED
+# else
+#  define ATTRIBUTE_UNUSED_LABEL
+# endif /* !__cplusplus && GNUC >= 2.93 */
+#endif /* ATTRIBUTE_UNUSED_LABEL */
+
+#ifndef ATTRIBUTE_UNUSED
+#define ATTRIBUTE_UNUSED __attribute__ ((__unused__))
+#endif /* ATTRIBUTE_UNUSED */
+
+/* Before GCC 3.4, the C++ frontend couldn't parse attributes placed after the
+   identifier name.  */
+#if ! defined(__cplusplus) || (GCC_VERSION >= 3004)
+# define ARG_UNUSED(NAME) NAME ATTRIBUTE_UNUSED
+#else /* !__cplusplus || GNUC >= 3.4 */
+# define ARG_UNUSED(NAME) NAME
+#endif /* !__cplusplus || GNUC >= 3.4 */
+
+#ifndef ATTRIBUTE_NORETURN
+#define ATTRIBUTE_NORETURN __attribute__ ((__noreturn__))
+#endif /* ATTRIBUTE_NORETURN */
+
+/* Attribute `nonnull' was valid as of gcc 3.3.  */
+#ifndef ATTRIBUTE_NONNULL
+# if (GCC_VERSION >= 3003)
+#  define ATTRIBUTE_NONNULL(m) __attribute__ ((__nonnull__ (m)))
+# else
+#  define ATTRIBUTE_NONNULL(m)
+# endif /* GNUC >= 3.3 */
+#endif /* ATTRIBUTE_NONNULL */
+
+/* Attribute `pure' was valid as of gcc 3.0.  */
+#ifndef ATTRIBUTE_PURE
+# if (GCC_VERSION >= 3000)
+#  define ATTRIBUTE_PURE __attribute__ ((__pure__))
+# else
+#  define ATTRIBUTE_PURE
+# endif /* GNUC >= 3.0 */
+#endif /* ATTRIBUTE_PURE */
+
+/* Use ATTRIBUTE_PRINTF when the format specifier must not be NULL.
+   This was the case for the `printf' format attribute by itself
+   before GCC 3.3, but as of 3.3 we need to add the `nonnull'
+   attribute to retain this behavior.  */
+#ifndef ATTRIBUTE_PRINTF
+#define ATTRIBUTE_PRINTF(m, n) __attribute__ ((__format__ (__printf__, m, n))) ATTRIBUTE_NONNULL(m)
+#define ATTRIBUTE_PRINTF_1 ATTRIBUTE_PRINTF(1, 2)
+#define ATTRIBUTE_PRINTF_2 ATTRIBUTE_PRINTF(2, 3)
+#define ATTRIBUTE_PRINTF_3 ATTRIBUTE_PRINTF(3, 4)
+#define ATTRIBUTE_PRINTF_4 ATTRIBUTE_PRINTF(4, 5)
+#define ATTRIBUTE_PRINTF_5 ATTRIBUTE_PRINTF(5, 6)
+#endif /* ATTRIBUTE_PRINTF */
+
+/* Use ATTRIBUTE_FPTR_PRINTF when the format attribute is to be set on
+   a function pointer.  Format attributes were allowed on function
+   pointers as of gcc 3.1.  */
+#ifndef ATTRIBUTE_FPTR_PRINTF
+# if (GCC_VERSION >= 3001)
+#  define ATTRIBUTE_FPTR_PRINTF(m, n) ATTRIBUTE_PRINTF(m, n)
+# else
+#  define ATTRIBUTE_FPTR_PRINTF(m, n)
+# endif /* GNUC >= 3.1 */
+# define ATTRIBUTE_FPTR_PRINTF_1 ATTRIBUTE_FPTR_PRINTF(1, 2)
+# define ATTRIBUTE_FPTR_PRINTF_2 ATTRIBUTE_FPTR_PRINTF(2, 3)
+# define ATTRIBUTE_FPTR_PRINTF_3 ATTRIBUTE_FPTR_PRINTF(3, 4)
+# define ATTRIBUTE_FPTR_PRINTF_4 ATTRIBUTE_FPTR_PRINTF(4, 5)
+# define ATTRIBUTE_FPTR_PRINTF_5 ATTRIBUTE_FPTR_PRINTF(5, 6)
+#endif /* ATTRIBUTE_FPTR_PRINTF */
+
+/* Use ATTRIBUTE_NULL_PRINTF when the format specifier may be NULL.  A
+   NULL format specifier was allowed as of gcc 3.3.  */
+#ifndef ATTRIBUTE_NULL_PRINTF
+# if (GCC_VERSION >= 3003)
+#  define ATTRIBUTE_NULL_PRINTF(m, n) __attribute__ ((__format__ (__printf__, m, n)))
+# else
+#  define ATTRIBUTE_NULL_PRINTF(m, n)
+# endif /* GNUC >= 3.3 */
+# define ATTRIBUTE_NULL_PRINTF_1 ATTRIBUTE_NULL_PRINTF(1, 2)
+# define ATTRIBUTE_NULL_PRINTF_2 ATTRIBUTE_NULL_PRINTF(2, 3)
+# define ATTRIBUTE_NULL_PRINTF_3 ATTRIBUTE_NULL_PRINTF(3, 4)
+# define ATTRIBUTE_NULL_PRINTF_4 ATTRIBUTE_NULL_PRINTF(4, 5)
+# define ATTRIBUTE_NULL_PRINTF_5 ATTRIBUTE_NULL_PRINTF(5, 6)
+#endif /* ATTRIBUTE_NULL_PRINTF */
+
+/* Attribute `sentinel' was valid as of gcc 3.5.  */
+#ifndef ATTRIBUTE_SENTINEL
+# if (GCC_VERSION >= 3005)
+#  define ATTRIBUTE_SENTINEL __attribute__ ((__sentinel__))
+# else
+#  define ATTRIBUTE_SENTINEL
+# endif /* GNUC >= 3.5 */
+#endif /* ATTRIBUTE_SENTINEL */
+
+
+#ifndef ATTRIBUTE_ALIGNED_ALIGNOF
+# if (GCC_VERSION >= 3000)
+#  define ATTRIBUTE_ALIGNED_ALIGNOF(m) __attribute__ ((__aligned__ (__alignof__ (m))))
+# else
+#  define ATTRIBUTE_ALIGNED_ALIGNOF(m)
+# endif /* GNUC >= 3.0 */
+#endif /* ATTRIBUTE_ALIGNED_ALIGNOF */
+
+/* We use __extension__ in some places to suppress -pedantic warnings
+   about GCC extensions.  This feature didn't work properly before
+   gcc 2.8.  */
+#if GCC_VERSION < 2008
+#define __extension__
+#endif
+
+#endif	/* ansidecl.h	*/
--- /dev/null
+++ b/arch/ia64/include/asm/bfd.h
@@ -0,0 +1,5089 @@
+/* DO NOT EDIT!  -*- buffer-read-only: t -*-  This file is automatically
+   generated from "bfd-in.h", "init.c", "opncls.c", "libbfd.c",
+   "bfdio.c", "bfdwin.c", "section.c", "archures.c", "reloc.c",
+   "syms.c", "bfd.c", "archive.c", "corefile.c", "targets.c", "format.c",
+   "linker.c" and "simple.c".
+   Run "make headers" in your build bfd/ to regenerate.  */
+
+/* Main header file for the bfd library -- portable access to object files.
+
+   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
+   1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+
+   Contributed by Cygnus Support.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* Extracted from binutils 2.16.91.0.2 (OpenSUSE 10.0) and modified for kdb use.
+ * Any trailing whitespace was removed and #ifdef/ifndef __KERNEL__ added as
+ * required.
+ * Keith Owens <kaos@sgi.com> 15 May 2006
+ */
+
+#ifndef __BFD_H_SEEN__
+#define __BFD_H_SEEN__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef __KERNEL__
+#include <asm/ansidecl.h>
+#else	/* __KERNEL__ */
+#include "ansidecl.h"
+#include "symcat.h"
+#endif	/* __KERNEL__ */
+#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
+#ifndef SABER
+/* This hack is to avoid a problem with some strict ANSI C preprocessors.
+   The problem is, "32_" is not a valid preprocessing token, and we don't
+   want extra underscores (e.g., "nlm_32_").  The XCONCAT2 macro will
+   cause the inner CONCAT2 macros to be evaluated first, producing
+   still-valid pp-tokens.  Then the final concatenation can be done.  */
+#undef CONCAT4
+#define CONCAT4(a,b,c,d) XCONCAT2(CONCAT2(a,b),CONCAT2(c,d))
+#endif
+#endif
+
+/* The word size used by BFD on the host.  This may be 64 with a 32
+   bit target if the host is 64 bit, or if other 64 bit targets have
+   been selected with --enable-targets, or if --enable-64-bit-bfd.  */
+#define BFD_ARCH_SIZE 64
+
+/* The word size of the default bfd target.  */
+#define BFD_DEFAULT_TARGET_SIZE 64
+
+#define BFD_HOST_64BIT_LONG 1
+#define BFD_HOST_LONG_LONG 1
+#if 1
+#define BFD_HOST_64_BIT long
+#define BFD_HOST_U_64_BIT unsigned long
+typedef BFD_HOST_64_BIT bfd_int64_t;
+typedef BFD_HOST_U_64_BIT bfd_uint64_t;
+#endif
+
+#if BFD_ARCH_SIZE >= 64
+#define BFD64
+#endif
+
+#ifndef INLINE
+#if __GNUC__ >= 2
+#define INLINE __inline__
+#else
+#define INLINE
+#endif
+#endif
+
+/* Forward declaration.  */
+typedef struct bfd bfd;
+
+/* Boolean type used in bfd.  Too many systems define their own
+   versions of "boolean" for us to safely typedef a "boolean" of
+   our own.  Using an enum for "bfd_boolean" has its own set of
+   problems, with strange looking casts required to avoid warnings
+   on some older compilers.  Thus we just use an int.
+
+   General rule: Functions which are bfd_boolean return TRUE on
+   success and FALSE on failure (unless they're a predicate).  */
+
+typedef int bfd_boolean;
+#undef FALSE
+#undef TRUE
+#define FALSE 0
+#define TRUE 1
+
+#ifdef BFD64
+
+#ifndef BFD_HOST_64_BIT
+ #error No 64 bit integer type available
+#endif /* ! defined (BFD_HOST_64_BIT) */
+
+typedef BFD_HOST_U_64_BIT bfd_vma;
+typedef BFD_HOST_64_BIT bfd_signed_vma;
+typedef BFD_HOST_U_64_BIT bfd_size_type;
+typedef BFD_HOST_U_64_BIT symvalue;
+
+#ifndef fprintf_vma
+#if BFD_HOST_64BIT_LONG
+#define sprintf_vma(s,x) sprintf (s, "%016lx", x)
+#define fprintf_vma(f,x) fprintf (f, "%016lx", x)
+#else
+#define _bfd_int64_low(x) ((unsigned long) (((x) & 0xffffffff)))
+#define _bfd_int64_high(x) ((unsigned long) (((x) >> 32) & 0xffffffff))
+#define fprintf_vma(s,x) \
+  fprintf ((s), "%08lx%08lx", _bfd_int64_high (x), _bfd_int64_low (x))
+#define sprintf_vma(s,x) \
+  sprintf ((s), "%08lx%08lx", _bfd_int64_high (x), _bfd_int64_low (x))
+#endif
+#endif
+
+#else /* not BFD64  */
+
+/* Represent a target address.  Also used as a generic unsigned type
+   which is guaranteed to be big enough to hold any arithmetic types
+   we need to deal with.  */
+typedef unsigned long bfd_vma;
+
+/* A generic signed type which is guaranteed to be big enough to hold any
+   arithmetic types we need to deal with.  Can be assumed to be compatible
+   with bfd_vma in the same way that signed and unsigned ints are compatible
+   (as parameters, in assignment, etc).  */
+typedef long bfd_signed_vma;
+
+typedef unsigned long symvalue;
+typedef unsigned long bfd_size_type;
+
+/* Print a bfd_vma x on stream s.  */
+#define fprintf_vma(s,x) fprintf (s, "%08lx", x)
+#define sprintf_vma(s,x) sprintf (s, "%08lx", x)
+
+#endif /* not BFD64  */
+
+#define HALF_BFD_SIZE_TYPE \
+  (((bfd_size_type) 1) << (8 * sizeof (bfd_size_type) / 2))
+
+#ifndef BFD_HOST_64_BIT
+/* Fall back on a 32 bit type.  The idea is to make these types always
+   available for function return types, but in the case that
+   BFD_HOST_64_BIT is undefined such a function should abort or
+   otherwise signal an error.  */
+typedef bfd_signed_vma bfd_int64_t;
+typedef bfd_vma bfd_uint64_t;
+#endif
+
+/* An offset into a file.  BFD always uses the largest possible offset
+   based on the build time availability of fseek, fseeko, or fseeko64.  */
+typedef BFD_HOST_64_BIT file_ptr;
+typedef unsigned BFD_HOST_64_BIT ufile_ptr;
+
+extern void bfd_sprintf_vma (bfd *, char *, bfd_vma);
+extern void bfd_fprintf_vma (bfd *, void *, bfd_vma);
+
+#define printf_vma(x) fprintf_vma(stdout,x)
+#define bfd_printf_vma(abfd,x) bfd_fprintf_vma (abfd,stdout,x)
+
+typedef unsigned int flagword;	/* 32 bits of flags */
+typedef unsigned char bfd_byte;
+
+typedef int (*bfd_qsort_closure_func) (const void *, const void *, const void *);
+extern void bfd_qsort (void *base, bfd_size_type nmemb, bfd_size_type size,
+		       bfd_qsort_closure_func cmp, void *closure);
+
+/* File formats.  */
+
+typedef enum bfd_format
+{
+  bfd_unknown = 0,	/* File format is unknown.  */
+  bfd_object,		/* Linker/assembler/compiler output.  */
+  bfd_archive,		/* Object archive file.  */
+  bfd_core,		/* Core dump.  */
+  bfd_type_end		/* Marks the end; don't use it!  */
+}
+bfd_format;
+
+/* Values that may appear in the flags field of a BFD.  These also
+   appear in the object_flags field of the bfd_target structure, where
+   they indicate the set of flags used by that backend (not all flags
+   are meaningful for all object file formats) (FIXME: at the moment,
+   the object_flags values have mostly just been copied from backend
+   to another, and are not necessarily correct).  */
+
+/* No flags.  */
+#define BFD_NO_FLAGS   	0x00
+
+/* BFD contains relocation entries.  */
+#define HAS_RELOC   	0x01
+
+/* BFD is directly executable.  */
+#define EXEC_P      	0x02
+
+/* BFD has line number information (basically used for F_LNNO in a
+   COFF header).  */
+#define HAS_LINENO  	0x04
+
+/* BFD has debugging information.  */
+#define HAS_DEBUG   	0x08
+
+/* BFD has symbols.  */
+#define HAS_SYMS    	0x10
+
+/* BFD has local symbols (basically used for F_LSYMS in a COFF
+   header).  */
+#define HAS_LOCALS  	0x20
+
+/* BFD is a dynamic object.  */
+#define DYNAMIC     	0x40
+
+/* Text section is write protected (if D_PAGED is not set, this is
+   like an a.out NMAGIC file) (the linker sets this by default, but
+   clears it for -r or -N).  */
+#define WP_TEXT     	0x80
+
+/* BFD is dynamically paged (this is like an a.out ZMAGIC file) (the
+   linker sets this by default, but clears it for -r or -n or -N).  */
+#define D_PAGED     	0x100
+
+/* BFD is relaxable (this means that bfd_relax_section may be able to
+   do something) (sometimes bfd_relax_section can do something even if
+   this is not set).  */
+#define BFD_IS_RELAXABLE 0x200
+
+/* This may be set before writing out a BFD to request using a
+   traditional format.  For example, this is used to request that when
+   writing out an a.out object the symbols not be hashed to eliminate
+   duplicates.  */
+#define BFD_TRADITIONAL_FORMAT 0x400
+
+/* This flag indicates that the BFD contents are actually cached in
+   memory.  If this is set, iostream points to a bfd_in_memory struct.  */
+#define BFD_IN_MEMORY 0x800
+
+/* The sections in this BFD specify a memory page.  */
+#define HAS_LOAD_PAGE 0x1000
+
+/* This BFD has been created by the linker and doesn't correspond
+   to any input file.  */
+#define BFD_LINKER_CREATED 0x2000
+
+/* Symbols and relocation.  */
+
+/* A count of carsyms (canonical archive symbols).  */
+typedef unsigned long symindex;
+
+/* How to perform a relocation.  */
+typedef const struct reloc_howto_struct reloc_howto_type;
+
+#define BFD_NO_MORE_SYMBOLS ((symindex) ~0)
+
+/* General purpose part of a symbol X;
+   target specific parts are in libcoff.h, libaout.h, etc.  */
+
+#define bfd_get_section(x) ((x)->section)
+#define bfd_get_output_section(x) ((x)->section->output_section)
+#define bfd_set_section(x,y) ((x)->section) = (y)
+#define bfd_asymbol_base(x) ((x)->section->vma)
+#define bfd_asymbol_value(x) (bfd_asymbol_base(x) + (x)->value)
+#define bfd_asymbol_name(x) ((x)->name)
+/*Perhaps future: #define bfd_asymbol_bfd(x) ((x)->section->owner)*/
+#define bfd_asymbol_bfd(x) ((x)->the_bfd)
+#define bfd_asymbol_flavour(x) (bfd_asymbol_bfd(x)->xvec->flavour)
+
+/* A canonical archive symbol.  */
+/* This is a type pun with struct ranlib on purpose!  */
+typedef struct carsym
+{
+  char *name;
+  file_ptr file_offset;	/* Look here to find the file.  */
+}
+carsym;			/* To make these you call a carsymogen.  */
+
+/* Used in generating armaps (archive tables of contents).
+   Perhaps just a forward definition would do?  */
+struct orl 			/* Output ranlib.  */
+{
+  char **name;		/* Symbol name.  */
+  union
+  {
+    file_ptr pos;
+    bfd *abfd;
+  } u;			/* bfd* or file position.  */
+  int namidx;		/* Index into string table.  */
+};
+
+/* Linenumber stuff.  */
+typedef struct lineno_cache_entry
+{
+  unsigned int line_number;	/* Linenumber from start of function.  */
+  union
+  {
+    struct bfd_symbol *sym;	/* Function name.  */
+    bfd_vma offset;	    		/* Offset into section.  */
+  } u;
+}
+alent;
+
+/* Object and core file sections.  */
+
+#define	align_power(addr, align)	\
+  (((addr) + ((bfd_vma) 1 << (align)) - 1) & ((bfd_vma) -1 << (align)))
+
+typedef struct bfd_section *sec_ptr;
+
+#define bfd_get_section_name(bfd, ptr) ((ptr)->name + 0)
+#define bfd_get_section_vma(bfd, ptr) ((ptr)->vma + 0)
+#define bfd_get_section_lma(bfd, ptr) ((ptr)->lma + 0)
+#define bfd_get_section_alignment(bfd, ptr) ((ptr)->alignment_power + 0)
+#define bfd_section_name(bfd, ptr) ((ptr)->name)
+#define bfd_section_size(bfd, ptr) ((ptr)->size)
+#define bfd_get_section_size(ptr) ((ptr)->size)
+#define bfd_section_vma(bfd, ptr) ((ptr)->vma)
+#define bfd_section_lma(bfd, ptr) ((ptr)->lma)
+#define bfd_section_alignment(bfd, ptr) ((ptr)->alignment_power)
+#define bfd_get_section_flags(bfd, ptr) ((ptr)->flags + 0)
+#define bfd_get_section_userdata(bfd, ptr) ((ptr)->userdata)
+
+#define bfd_is_com_section(ptr) (((ptr)->flags & SEC_IS_COMMON) != 0)
+
+#define bfd_set_section_vma(bfd, ptr, val) (((ptr)->vma = (ptr)->lma = (val)), ((ptr)->user_set_vma = TRUE), TRUE)
+#define bfd_set_section_alignment(bfd, ptr, val) (((ptr)->alignment_power = (val)),TRUE)
+#define bfd_set_section_userdata(bfd, ptr, val) (((ptr)->userdata = (val)),TRUE)
+/* Find the address one past the end of SEC.  */
+#define bfd_get_section_limit(bfd, sec) \
+  (((sec)->rawsize ? (sec)->rawsize : (sec)->size) \
+   / bfd_octets_per_byte (bfd))
+
+typedef struct stat stat_type;
+
+typedef enum bfd_print_symbol
+{
+  bfd_print_symbol_name,
+  bfd_print_symbol_more,
+  bfd_print_symbol_all
+} bfd_print_symbol_type;
+
+/* Information about a symbol that nm needs.  */
+
+typedef struct _symbol_info
+{
+  symvalue value;
+  char type;
+  const char *name;            /* Symbol name.  */
+  unsigned char stab_type;     /* Stab type.  */
+  char stab_other;             /* Stab other.  */
+  short stab_desc;             /* Stab desc.  */
+  const char *stab_name;       /* String for stab type.  */
+} symbol_info;
+
+/* Get the name of a stabs type code.  */
+
+extern const char *bfd_get_stab_name (int);
+
+/* Hash table routines.  There is no way to free up a hash table.  */
+
+/* An element in the hash table.  Most uses will actually use a larger
+   structure, and an instance of this will be the first field.  */
+
+struct bfd_hash_entry
+{
+  /* Next entry for this hash code.  */
+  struct bfd_hash_entry *next;
+  /* String being hashed.  */
+  const char *string;
+  /* Hash code.  This is the full hash code, not the index into the
+     table.  */
+  unsigned long hash;
+};
+
+/* A hash table.  */
+
+struct bfd_hash_table
+{
+  /* The hash array.  */
+  struct bfd_hash_entry **table;
+  /* The number of slots in the hash table.  */
+  unsigned int size;
+  /* A function used to create new elements in the hash table.  The
+     first entry is itself a pointer to an element.  When this
+     function is first invoked, this pointer will be NULL.  However,
+     having the pointer permits a hierarchy of method functions to be
+     built each of which calls the function in the superclass.  Thus
+     each function should be written to allocate a new block of memory
+     only if the argument is NULL.  */
+  struct bfd_hash_entry *(*newfunc)
+    (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
+   /* An objalloc for this hash table.  This is a struct objalloc *,
+     but we use void * to avoid requiring the inclusion of objalloc.h.  */
+  void *memory;
+};
+
+/* Initialize a hash table.  */
+extern bfd_boolean bfd_hash_table_init
+  (struct bfd_hash_table *,
+   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
+			       struct bfd_hash_table *,
+			       const char *));
+
+/* Initialize a hash table specifying a size.  */
+extern bfd_boolean bfd_hash_table_init_n
+  (struct bfd_hash_table *,
+   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
+			       struct bfd_hash_table *,
+			       const char *),
+   unsigned int size);
+
+/* Free up a hash table.  */
+extern void bfd_hash_table_free
+  (struct bfd_hash_table *);
+
+/* Look up a string in a hash table.  If CREATE is TRUE, a new entry
+   will be created for this string if one does not already exist.  The
+   COPY argument must be TRUE if this routine should copy the string
+   into newly allocated memory when adding an entry.  */
+extern struct bfd_hash_entry *bfd_hash_lookup
+  (struct bfd_hash_table *, const char *, bfd_boolean create,
+   bfd_boolean copy);
+
+/* Replace an entry in a hash table.  */
+extern void bfd_hash_replace
+  (struct bfd_hash_table *, struct bfd_hash_entry *old,
+   struct bfd_hash_entry *nw);
+
+/* Base method for creating a hash table entry.  */
+extern struct bfd_hash_entry *bfd_hash_newfunc
+  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
+
+/* Grab some space for a hash table entry.  */
+extern void *bfd_hash_allocate
+  (struct bfd_hash_table *, unsigned int);
+
+/* Traverse a hash table in a random order, calling a function on each
+   element.  If the function returns FALSE, the traversal stops.  The
+   INFO argument is passed to the function.  */
+extern void bfd_hash_traverse
+  (struct bfd_hash_table *,
+   bfd_boolean (*) (struct bfd_hash_entry *, void *),
+   void *info);
+
+/* Allows the default size of a hash table to be configured. New hash
+   tables allocated using bfd_hash_table_init will be created with
+   this size.  */
+extern void bfd_hash_set_default_size (bfd_size_type);
+
+/* This structure is used to keep track of stabs in sections
+   information while linking.  */
+
+struct stab_info
+{
+  /* A hash table used to hold stabs strings.  */
+  struct bfd_strtab_hash *strings;
+  /* The header file hash table.  */
+  struct bfd_hash_table includes;
+  /* The first .stabstr section.  */
+  struct bfd_section *stabstr;
+};
+
+#define COFF_SWAP_TABLE (void *) &bfd_coff_std_swap_table
+
+/* User program access to BFD facilities.  */
+
+/* Direct I/O routines, for programs which know more about the object
+   file than BFD does.  Use higher level routines if possible.  */
+
+extern bfd_size_type bfd_bread (void *, bfd_size_type, bfd *);
+extern bfd_size_type bfd_bwrite (const void *, bfd_size_type, bfd *);
+extern int bfd_seek (bfd *, file_ptr, int);
+extern file_ptr bfd_tell (bfd *);
+extern int bfd_flush (bfd *);
+extern int bfd_stat (bfd *, struct stat *);
+
+/* Deprecated old routines.  */
+#if __GNUC__
+#define bfd_read(BUF, ELTSIZE, NITEMS, ABFD)				\
+  (warn_deprecated ("bfd_read", __FILE__, __LINE__, __FUNCTION__),	\
+   bfd_bread ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
+#define bfd_write(BUF, ELTSIZE, NITEMS, ABFD)				\
+  (warn_deprecated ("bfd_write", __FILE__, __LINE__, __FUNCTION__),	\
+   bfd_bwrite ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
+#else
+#define bfd_read(BUF, ELTSIZE, NITEMS, ABFD)				\
+  (warn_deprecated ("bfd_read", (const char *) 0, 0, (const char *) 0), \
+   bfd_bread ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
+#define bfd_write(BUF, ELTSIZE, NITEMS, ABFD)				\
+  (warn_deprecated ("bfd_write", (const char *) 0, 0, (const char *) 0),\
+   bfd_bwrite ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
+#endif
+extern void warn_deprecated (const char *, const char *, int, const char *);
+
+/* Cast from const char * to char * so that caller can assign to
+   a char * without a warning.  */
+#define bfd_get_filename(abfd) ((char *) (abfd)->filename)
+#define bfd_get_cacheable(abfd) ((abfd)->cacheable)
+#define bfd_get_format(abfd) ((abfd)->format)
+#define bfd_get_target(abfd) ((abfd)->xvec->name)
+#define bfd_get_flavour(abfd) ((abfd)->xvec->flavour)
+#define bfd_family_coff(abfd) \
+  (bfd_get_flavour (abfd) == bfd_target_coff_flavour || \
+   bfd_get_flavour (abfd) == bfd_target_xcoff_flavour)
+#define bfd_big_endian(abfd) ((abfd)->xvec->byteorder == BFD_ENDIAN_BIG)
+#define bfd_little_endian(abfd) ((abfd)->xvec->byteorder == BFD_ENDIAN_LITTLE)
+#define bfd_header_big_endian(abfd) \
+  ((abfd)->xvec->header_byteorder == BFD_ENDIAN_BIG)
+#define bfd_header_little_endian(abfd) \
+  ((abfd)->xvec->header_byteorder == BFD_ENDIAN_LITTLE)
+#define bfd_get_file_flags(abfd) ((abfd)->flags)
+#define bfd_applicable_file_flags(abfd) ((abfd)->xvec->object_flags)
+#define bfd_applicable_section_flags(abfd) ((abfd)->xvec->section_flags)
+#define bfd_my_archive(abfd) ((abfd)->my_archive)
+#define bfd_has_map(abfd) ((abfd)->has_armap)
+
+#define bfd_valid_reloc_types(abfd) ((abfd)->xvec->valid_reloc_types)
+#define bfd_usrdata(abfd) ((abfd)->usrdata)
+
+#define bfd_get_start_address(abfd) ((abfd)->start_address)
+#define bfd_get_symcount(abfd) ((abfd)->symcount)
+#define bfd_get_outsymbols(abfd) ((abfd)->outsymbols)
+#define bfd_count_sections(abfd) ((abfd)->section_count)
+
+#define bfd_get_dynamic_symcount(abfd) ((abfd)->dynsymcount)
+
+#define bfd_get_symbol_leading_char(abfd) ((abfd)->xvec->symbol_leading_char)
+
+#define bfd_set_cacheable(abfd,bool) (((abfd)->cacheable = bool), TRUE)
+
+extern bfd_boolean bfd_cache_close
+  (bfd *abfd);
+/* NB: This declaration should match the autogenerated one in libbfd.h.  */
+
+extern bfd_boolean bfd_cache_close_all (void);
+
+extern bfd_boolean bfd_record_phdr
+  (bfd *, unsigned long, bfd_boolean, flagword, bfd_boolean, bfd_vma,
+   bfd_boolean, bfd_boolean, unsigned int, struct bfd_section **);
+
+/* Byte swapping routines.  */
+
+bfd_uint64_t bfd_getb64 (const void *);
+bfd_uint64_t bfd_getl64 (const void *);
+bfd_int64_t bfd_getb_signed_64 (const void *);
+bfd_int64_t bfd_getl_signed_64 (const void *);
+bfd_vma bfd_getb32 (const void *);
+bfd_vma bfd_getl32 (const void *);
+bfd_signed_vma bfd_getb_signed_32 (const void *);
+bfd_signed_vma bfd_getl_signed_32 (const void *);
+bfd_vma bfd_getb16 (const void *);
+bfd_vma bfd_getl16 (const void *);
+bfd_signed_vma bfd_getb_signed_16 (const void *);
+bfd_signed_vma bfd_getl_signed_16 (const void *);
+void bfd_putb64 (bfd_uint64_t, void *);
+void bfd_putl64 (bfd_uint64_t, void *);
+void bfd_putb32 (bfd_vma, void *);
+void bfd_putl32 (bfd_vma, void *);
+void bfd_putb16 (bfd_vma, void *);
+void bfd_putl16 (bfd_vma, void *);
+
+/* Byte swapping routines which take size and endiannes as arguments.  */
+
+bfd_uint64_t bfd_get_bits (const void *, int, bfd_boolean);
+void bfd_put_bits (bfd_uint64_t, void *, int, bfd_boolean);
+
+extern bfd_boolean bfd_section_already_linked_table_init (void);
+extern void bfd_section_already_linked_table_free (void);
+
+/* Externally visible ECOFF routines.  */
+
+#if defined(__STDC__) || defined(ALMOST_STDC)
+struct ecoff_debug_info;
+struct ecoff_debug_swap;
+struct ecoff_extr;
+struct bfd_symbol;
+struct bfd_link_info;
+struct bfd_link_hash_entry;
+struct bfd_elf_version_tree;
+#endif
+extern bfd_vma bfd_ecoff_get_gp_value
+  (bfd * abfd);
+extern bfd_boolean bfd_ecoff_set_gp_value
+  (bfd *abfd, bfd_vma gp_value);
+extern bfd_boolean bfd_ecoff_set_regmasks
+  (bfd *abfd, unsigned long gprmask, unsigned long fprmask,
+   unsigned long *cprmask);
+extern void *bfd_ecoff_debug_init
+  (bfd *output_bfd, struct ecoff_debug_info *output_debug,
+   const struct ecoff_debug_swap *output_swap, struct bfd_link_info *);
+extern void bfd_ecoff_debug_free
+  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
+   const struct ecoff_debug_swap *output_swap, struct bfd_link_info *);
+extern bfd_boolean bfd_ecoff_debug_accumulate
+  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
+   const struct ecoff_debug_swap *output_swap, bfd *input_bfd,
+   struct ecoff_debug_info *input_debug,
+   const struct ecoff_debug_swap *input_swap, struct bfd_link_info *);
+extern bfd_boolean bfd_ecoff_debug_accumulate_other
+  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
+   const struct ecoff_debug_swap *output_swap, bfd *input_bfd,
+   struct bfd_link_info *);
+extern bfd_boolean bfd_ecoff_debug_externals
+  (bfd *abfd, struct ecoff_debug_info *debug,
+   const struct ecoff_debug_swap *swap, bfd_boolean relocatable,
+   bfd_boolean (*get_extr) (struct bfd_symbol *, struct ecoff_extr *),
+   void (*set_index) (struct bfd_symbol *, bfd_size_type));
+extern bfd_boolean bfd_ecoff_debug_one_external
+  (bfd *abfd, struct ecoff_debug_info *debug,
+   const struct ecoff_debug_swap *swap, const char *name,
+   struct ecoff_extr *esym);
+extern bfd_size_type bfd_ecoff_debug_size
+  (bfd *abfd, struct ecoff_debug_info *debug,
+   const struct ecoff_debug_swap *swap);
+extern bfd_boolean bfd_ecoff_write_debug
+  (bfd *abfd, struct ecoff_debug_info *debug,
+   const struct ecoff_debug_swap *swap, file_ptr where);
+extern bfd_boolean bfd_ecoff_write_accumulated_debug
+  (void *handle, bfd *abfd, struct ecoff_debug_info *debug,
+   const struct ecoff_debug_swap *swap,
+   struct bfd_link_info *info, file_ptr where);
+
+/* Externally visible ELF routines.  */
+
+struct bfd_link_needed_list
+{
+  struct bfd_link_needed_list *next;
+  bfd *by;
+  const char *name;
+};
+
+enum dynamic_lib_link_class {
+  DYN_NORMAL = 0,
+  DYN_AS_NEEDED = 1,
+  DYN_DT_NEEDED = 2,
+  DYN_NO_ADD_NEEDED = 4,
+  DYN_NO_NEEDED = 8
+};
+
+extern bfd_boolean bfd_elf_record_link_assignment
+  (bfd *, struct bfd_link_info *, const char *, bfd_boolean,
+   bfd_boolean);
+extern struct bfd_link_needed_list *bfd_elf_get_needed_list
+  (bfd *, struct bfd_link_info *);
+extern bfd_boolean bfd_elf_get_bfd_needed_list
+  (bfd *, struct bfd_link_needed_list **);
+extern bfd_boolean bfd_elf_size_dynamic_sections
+  (bfd *, const char *, const char *, const char *, const char * const *,
+   struct bfd_link_info *, struct bfd_section **,
+   struct bfd_elf_version_tree *);
+extern bfd_boolean bfd_elf_size_dynsym_hash_dynstr
+  (bfd *, struct bfd_link_info *);
+extern void bfd_elf_set_dt_needed_name
+  (bfd *, const char *);
+extern const char *bfd_elf_get_dt_soname
+  (bfd *);
+extern void bfd_elf_set_dyn_lib_class
+  (bfd *, int);
+extern int bfd_elf_get_dyn_lib_class
+  (bfd *);
+extern struct bfd_link_needed_list *bfd_elf_get_runpath_list
+  (bfd *, struct bfd_link_info *);
+extern bfd_boolean bfd_elf_discard_info
+  (bfd *, struct bfd_link_info *);
+extern unsigned int _bfd_elf_default_action_discarded
+  (struct bfd_section *);
+
+/* Return an upper bound on the number of bytes required to store a
+   copy of ABFD's program header table entries.  Return -1 if an error
+   occurs; bfd_get_error will return an appropriate code.  */
+extern long bfd_get_elf_phdr_upper_bound
+  (bfd *abfd);
+
+/* Copy ABFD's program header table entries to *PHDRS.  The entries
+   will be stored as an array of Elf_Internal_Phdr structures, as
+   defined in include/elf/internal.h.  To find out how large the
+   buffer needs to be, call bfd_get_elf_phdr_upper_bound.
+
+   Return the number of program header table entries read, or -1 if an
+   error occurs; bfd_get_error will return an appropriate code.  */
+extern int bfd_get_elf_phdrs
+  (bfd *abfd, void *phdrs);
+
+/* Create a new BFD as if by bfd_openr.  Rather than opening a file,
+   reconstruct an ELF file by reading the segments out of remote memory
+   based on the ELF file header at EHDR_VMA and the ELF program headers it
+   points to.  If not null, *LOADBASEP is filled in with the difference
+   between the VMAs from which the segments were read, and the VMAs the
+   file headers (and hence BFD's idea of each section's VMA) put them at.
+
+   The function TARGET_READ_MEMORY is called to copy LEN bytes from the
+   remote memory at target address VMA into the local buffer at MYADDR; it
+   should return zero on success or an `errno' code on failure.  TEMPL must
+   be a BFD for an ELF target with the word size and byte order found in
+   the remote memory.  */
+extern bfd *bfd_elf_bfd_from_remote_memory
+  (bfd *templ, bfd_vma ehdr_vma, bfd_vma *loadbasep,
+   int (*target_read_memory) (bfd_vma vma, bfd_byte *myaddr, int len));
+
+/* Return the arch_size field of an elf bfd, or -1 if not elf.  */
+extern int bfd_get_arch_size
+  (bfd *);
+
+/* Return TRUE if address "naturally" sign extends, or -1 if not elf.  */
+extern int bfd_get_sign_extend_vma
+  (bfd *);
+
+extern struct bfd_section *_bfd_elf_tls_setup
+  (bfd *, struct bfd_link_info *);
+
+extern void _bfd_fix_excluded_sec_syms
+  (bfd *, struct bfd_link_info *);
+
+extern bfd_boolean bfd_m68k_elf32_create_embedded_relocs
+  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *,
+   char **);
+
+extern bfd_boolean bfd_bfin_elf32_create_embedded_relocs
+  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *,
+   char **);
+
+/* SunOS shared library support routines for the linker.  */
+
+extern struct bfd_link_needed_list *bfd_sunos_get_needed_list
+  (bfd *, struct bfd_link_info *);
+extern bfd_boolean bfd_sunos_record_link_assignment
+  (bfd *, struct bfd_link_info *, const char *);
+extern bfd_boolean bfd_sunos_size_dynamic_sections
+  (bfd *, struct bfd_link_info *, struct bfd_section **,
+   struct bfd_section **, struct bfd_section **);
+
+/* Linux shared library support routines for the linker.  */
+
+extern bfd_boolean bfd_i386linux_size_dynamic_sections
+  (bfd *, struct bfd_link_info *);
+extern bfd_boolean bfd_m68klinux_size_dynamic_sections
+  (bfd *, struct bfd_link_info *);
+extern bfd_boolean bfd_sparclinux_size_dynamic_sections
+  (bfd *, struct bfd_link_info *);
+
+/* mmap hacks */
+
+struct _bfd_window_internal;
+typedef struct _bfd_window_internal bfd_window_internal;
+
+typedef struct _bfd_window
+{
+  /* What the user asked for.  */
+  void *data;
+  bfd_size_type size;
+  /* The actual window used by BFD.  Small user-requested read-only
+     regions sharing a page may share a single window into the object
+     file.  Read-write versions shouldn't until I've fixed things to
+     keep track of which portions have been claimed by the
+     application; don't want to give the same region back when the
+     application wants two writable copies!  */
+  struct _bfd_window_internal *i;
+}
+bfd_window;
+
+extern void bfd_init_window
+  (bfd_window *);
+extern void bfd_free_window
+  (bfd_window *);
+extern bfd_boolean bfd_get_file_window
+  (bfd *, file_ptr, bfd_size_type, bfd_window *, bfd_boolean);
+
+/* XCOFF support routines for the linker.  */
+
+extern bfd_boolean bfd_xcoff_link_record_set
+  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *, bfd_size_type);
+extern bfd_boolean bfd_xcoff_import_symbol
+  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *, bfd_vma,
+   const char *, const char *, const char *, unsigned int);
+extern bfd_boolean bfd_xcoff_export_symbol
+  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *);
+extern bfd_boolean bfd_xcoff_link_count_reloc
+  (bfd *, struct bfd_link_info *, const char *);
+extern bfd_boolean bfd_xcoff_record_link_assignment
+  (bfd *, struct bfd_link_info *, const char *);
+extern bfd_boolean bfd_xcoff_size_dynamic_sections
+  (bfd *, struct bfd_link_info *, const char *, const char *,
+   unsigned long, unsigned long, unsigned long, bfd_boolean,
+   int, bfd_boolean, bfd_boolean, struct bfd_section **, bfd_boolean);
+extern bfd_boolean bfd_xcoff_link_generate_rtinit
+  (bfd *, const char *, const char *, bfd_boolean);
+
+/* XCOFF support routines for ar.  */
+extern bfd_boolean bfd_xcoff_ar_archive_set_magic
+  (bfd *, char *);
+
+/* Externally visible COFF routines.  */
+
+#if defined(__STDC__) || defined(ALMOST_STDC)
+struct internal_syment;
+union internal_auxent;
+#endif
+
+extern bfd_boolean bfd_coff_get_syment
+  (bfd *, struct bfd_symbol *, struct internal_syment *);
+
+extern bfd_boolean bfd_coff_get_auxent
+  (bfd *, struct bfd_symbol *, int, union internal_auxent *);
+
+extern bfd_boolean bfd_coff_set_symbol_class
+  (bfd *, struct bfd_symbol *, unsigned int);
+
+extern bfd_boolean bfd_m68k_coff_create_embedded_relocs
+  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *, char **);
+
+/* ARM Interworking support.  Called from linker.  */
+extern bfd_boolean bfd_arm_allocate_interworking_sections
+  (struct bfd_link_info *);
+
+extern bfd_boolean bfd_arm_process_before_allocation
+  (bfd *, struct bfd_link_info *, int);
+
+extern bfd_boolean bfd_arm_get_bfd_for_interworking
+  (bfd *, struct bfd_link_info *);
+
+/* PE ARM Interworking support.  Called from linker.  */
+extern bfd_boolean bfd_arm_pe_allocate_interworking_sections
+  (struct bfd_link_info *);
+
+extern bfd_boolean bfd_arm_pe_process_before_allocation
+  (bfd *, struct bfd_link_info *, int);
+
+extern bfd_boolean bfd_arm_pe_get_bfd_for_interworking
+  (bfd *, struct bfd_link_info *);
+
+/* ELF ARM Interworking support.  Called from linker.  */
+extern bfd_boolean bfd_elf32_arm_allocate_interworking_sections
+  (struct bfd_link_info *);
+
+extern bfd_boolean bfd_elf32_arm_process_before_allocation
+  (bfd *, struct bfd_link_info *, int);
+
+void bfd_elf32_arm_set_target_relocs
+  (struct bfd_link_info *, int, char *, int, int);
+
+extern bfd_boolean bfd_elf32_arm_get_bfd_for_interworking
+  (bfd *, struct bfd_link_info *);
+
+extern bfd_boolean bfd_elf32_arm_add_glue_sections_to_bfd
+  (bfd *, struct bfd_link_info *);
+
+/* ELF ARM mapping symbol support */
+extern bfd_boolean bfd_is_arm_mapping_symbol_name
+  (const char * name);
+
+/* ARM Note section processing.  */
+extern bfd_boolean bfd_arm_merge_machines
+  (bfd *, bfd *);
+
+extern bfd_boolean bfd_arm_update_notes
+  (bfd *, const char *);
+
+extern unsigned int bfd_arm_get_mach_from_notes
+  (bfd *, const char *);
+
+/* TI COFF load page support.  */
+extern void bfd_ticoff_set_section_load_page
+  (struct bfd_section *, int);
+
+extern int bfd_ticoff_get_section_load_page
+  (struct bfd_section *);
+
+/* H8/300 functions.  */
+extern bfd_vma bfd_h8300_pad_address
+  (bfd *, bfd_vma);
+
+/* IA64 Itanium code generation.  Called from linker.  */
+extern void bfd_elf32_ia64_after_parse
+  (int);
+
+extern void bfd_elf64_ia64_after_parse
+  (int);
+
+/* This structure is used for a comdat section, as in PE.  A comdat
+   section is associated with a particular symbol.  When the linker
+   sees a comdat section, it keeps only one of the sections with a
+   given name and associated with a given symbol.  */
+
+struct coff_comdat_info
+{
+  /* The name of the symbol associated with a comdat section.  */
+  const char *name;
+
+  /* The local symbol table index of the symbol associated with a
+     comdat section.  This is only meaningful to the object file format
+     specific code; it is not an index into the list returned by
+     bfd_canonicalize_symtab.  */
+  long symbol;
+};
+
+extern struct coff_comdat_info *bfd_coff_get_comdat_section
+  (bfd *, struct bfd_section *);
+
+/* Extracted from init.c.  */
+void bfd_init (void);
+
+/* Extracted from opncls.c.  */
+bfd *bfd_fopen (const char *filename, const char *target,
+    const char *mode, int fd);
+
+bfd *bfd_openr (const char *filename, const char *target);
+
+bfd *bfd_fdopenr (const char *filename, const char *target, int fd);
+
+bfd *bfd_openstreamr (const char *, const char *, void *);
+
+bfd *bfd_openr_iovec (const char *filename, const char *target,
+    void *(*open) (struct bfd *nbfd,
+    void *open_closure),
+    void *open_closure,
+    file_ptr (*pread) (struct bfd *nbfd,
+    void *stream,
+    void *buf,
+    file_ptr nbytes,
+    file_ptr offset),
+    int (*close) (struct bfd *nbfd,
+    void *stream));
+
+bfd *bfd_openw (const char *filename, const char *target);
+
+bfd_boolean bfd_close (bfd *abfd);
+
+bfd_boolean bfd_close_all_done (bfd *);
+
+bfd *bfd_create (const char *filename, bfd *templ);
+
+bfd_boolean bfd_make_writable (bfd *abfd);
+
+bfd_boolean bfd_make_readable (bfd *abfd);
+
+unsigned long bfd_calc_gnu_debuglink_crc32
+   (unsigned long crc, const unsigned char *buf, bfd_size_type len);
+
+char *bfd_follow_gnu_debuglink (bfd *abfd, const char *dir);
+
+struct bfd_section *bfd_create_gnu_debuglink_section
+   (bfd *abfd, const char *filename);
+
+bfd_boolean bfd_fill_in_gnu_debuglink_section
+   (bfd *abfd, struct bfd_section *sect, const char *filename);
+
+/* Extracted from libbfd.c.  */
+
+/* Byte swapping macros for user section data.  */
+
+#define bfd_put_8(abfd, val, ptr) \
+  ((void) (*((unsigned char *) (ptr)) = (val) & 0xff))
+#define bfd_put_signed_8 \
+  bfd_put_8
+#define bfd_get_8(abfd, ptr) \
+  (*(unsigned char *) (ptr) & 0xff)
+#define bfd_get_signed_8(abfd, ptr) \
+  (((*(unsigned char *) (ptr) & 0xff) ^ 0x80) - 0x80)
+
+#define bfd_put_16(abfd, val, ptr) \
+  BFD_SEND (abfd, bfd_putx16, ((val),(ptr)))
+#define bfd_put_signed_16 \
+  bfd_put_16
+#define bfd_get_16(abfd, ptr) \
+  BFD_SEND (abfd, bfd_getx16, (ptr))
+#define bfd_get_signed_16(abfd, ptr) \
+  BFD_SEND (abfd, bfd_getx_signed_16, (ptr))
+
+#define bfd_put_32(abfd, val, ptr) \
+  BFD_SEND (abfd, bfd_putx32, ((val),(ptr)))
+#define bfd_put_signed_32 \
+  bfd_put_32
+#define bfd_get_32(abfd, ptr) \
+  BFD_SEND (abfd, bfd_getx32, (ptr))
+#define bfd_get_signed_32(abfd, ptr) \
+  BFD_SEND (abfd, bfd_getx_signed_32, (ptr))
+
+#define bfd_put_64(abfd, val, ptr) \
+  BFD_SEND (abfd, bfd_putx64, ((val), (ptr)))
+#define bfd_put_signed_64 \
+  bfd_put_64
+#define bfd_get_64(abfd, ptr) \
+  BFD_SEND (abfd, bfd_getx64, (ptr))
+#define bfd_get_signed_64(abfd, ptr) \
+  BFD_SEND (abfd, bfd_getx_signed_64, (ptr))
+
+#define bfd_get(bits, abfd, ptr)                       \
+  ((bits) == 8 ? (bfd_vma) bfd_get_8 (abfd, ptr)       \
+   : (bits) == 16 ? bfd_get_16 (abfd, ptr)             \
+   : (bits) == 32 ? bfd_get_32 (abfd, ptr)             \
+   : (bits) == 64 ? bfd_get_64 (abfd, ptr)             \
+   : (abort (), (bfd_vma) - 1))
+
+#define bfd_put(bits, abfd, val, ptr)                  \
+  ((bits) == 8 ? bfd_put_8  (abfd, val, ptr)           \
+   : (bits) == 16 ? bfd_put_16 (abfd, val, ptr)                \
+   : (bits) == 32 ? bfd_put_32 (abfd, val, ptr)                \
+   : (bits) == 64 ? bfd_put_64 (abfd, val, ptr)                \
+   : (abort (), (void) 0))
+
+
+/* Byte swapping macros for file header data.  */
+
+#define bfd_h_put_8(abfd, val, ptr) \
+  bfd_put_8 (abfd, val, ptr)
+#define bfd_h_put_signed_8(abfd, val, ptr) \
+  bfd_put_8 (abfd, val, ptr)
+#define bfd_h_get_8(abfd, ptr) \
+  bfd_get_8 (abfd, ptr)
+#define bfd_h_get_signed_8(abfd, ptr) \
+  bfd_get_signed_8 (abfd, ptr)
+
+#define bfd_h_put_16(abfd, val, ptr) \
+  BFD_SEND (abfd, bfd_h_putx16, (val, ptr))
+#define bfd_h_put_signed_16 \
+  bfd_h_put_16
+#define bfd_h_get_16(abfd, ptr) \
+  BFD_SEND (abfd, bfd_h_getx16, (ptr))
+#define bfd_h_get_signed_16(abfd, ptr) \
+  BFD_SEND (abfd, bfd_h_getx_signed_16, (ptr))
+
+#define bfd_h_put_32(abfd, val, ptr) \
+  BFD_SEND (abfd, bfd_h_putx32, (val, ptr))
+#define bfd_h_put_signed_32 \
+  bfd_h_put_32
+#define bfd_h_get_32(abfd, ptr) \
+  BFD_SEND (abfd, bfd_h_getx32, (ptr))
+#define bfd_h_get_signed_32(abfd, ptr) \
+  BFD_SEND (abfd, bfd_h_getx_signed_32, (ptr))
+
+#define bfd_h_put_64(abfd, val, ptr) \
+  BFD_SEND (abfd, bfd_h_putx64, (val, ptr))
+#define bfd_h_put_signed_64 \
+  bfd_h_put_64
+#define bfd_h_get_64(abfd, ptr) \
+  BFD_SEND (abfd, bfd_h_getx64, (ptr))
+#define bfd_h_get_signed_64(abfd, ptr) \
+  BFD_SEND (abfd, bfd_h_getx_signed_64, (ptr))
+
+/* Aliases for the above, which should eventually go away.  */
+
+#define H_PUT_64  bfd_h_put_64
+#define H_PUT_32  bfd_h_put_32
+#define H_PUT_16  bfd_h_put_16
+#define H_PUT_8   bfd_h_put_8
+#define H_PUT_S64 bfd_h_put_signed_64
+#define H_PUT_S32 bfd_h_put_signed_32
+#define H_PUT_S16 bfd_h_put_signed_16
+#define H_PUT_S8  bfd_h_put_signed_8
+#define H_GET_64  bfd_h_get_64
+#define H_GET_32  bfd_h_get_32
+#define H_GET_16  bfd_h_get_16
+#define H_GET_8   bfd_h_get_8
+#define H_GET_S64 bfd_h_get_signed_64
+#define H_GET_S32 bfd_h_get_signed_32
+#define H_GET_S16 bfd_h_get_signed_16
+#define H_GET_S8  bfd_h_get_signed_8
+
+
+/* Extracted from bfdio.c.  */
+long bfd_get_mtime (bfd *abfd);
+
+long bfd_get_size (bfd *abfd);
+
+/* Extracted from bfdwin.c.  */
+/* Extracted from section.c.  */
+typedef struct bfd_section
+{
+  /* The name of the section; the name isn't a copy, the pointer is
+     the same as that passed to bfd_make_section.  */
+  const char *name;
+
+  /* A unique sequence number.  */
+  int id;
+
+  /* Which section in the bfd; 0..n-1 as sections are created in a bfd.  */
+  int index;
+
+  /* The next section in the list belonging to the BFD, or NULL.  */
+  struct bfd_section *next;
+
+  /* The previous section in the list belonging to the BFD, or NULL.  */
+  struct bfd_section *prev;
+
+  /* The field flags contains attributes of the section. Some
+     flags are read in from the object file, and some are
+     synthesized from other information.  */
+  flagword flags;
+
+#define SEC_NO_FLAGS   0x000
+
+  /* Tells the OS to allocate space for this section when loading.
+     This is clear for a section containing debug information only.  */
+#define SEC_ALLOC      0x001
+
+  /* Tells the OS to load the section from the file when loading.
+     This is clear for a .bss section.  */
+#define SEC_LOAD       0x002
+
+  /* The section contains data still to be relocated, so there is
+     some relocation information too.  */
+#define SEC_RELOC      0x004
+
+  /* A signal to the OS that the section contains read only data.  */
+#define SEC_READONLY   0x008
+
+  /* The section contains code only.  */
+#define SEC_CODE       0x010
+
+  /* The section contains data only.  */
+#define SEC_DATA       0x020
+
+  /* The section will reside in ROM.  */
+#define SEC_ROM        0x040
+
+  /* The section contains constructor information. This section
+     type is used by the linker to create lists of constructors and
+     destructors used by <<g++>>. When a back end sees a symbol
+     which should be used in a constructor list, it creates a new
+     section for the type of name (e.g., <<__CTOR_LIST__>>), attaches
+     the symbol to it, and builds a relocation. To build the lists
+     of constructors, all the linker has to do is catenate all the
+     sections called <<__CTOR_LIST__>> and relocate the data
+     contained within - exactly the operations it would peform on
+     standard data.  */
+#define SEC_CONSTRUCTOR 0x080
+
+  /* The section has contents - a data section could be
+     <<SEC_ALLOC>> | <<SEC_HAS_CONTENTS>>; a debug section could be
+     <<SEC_HAS_CONTENTS>>  */
+#define SEC_HAS_CONTENTS 0x100
+
+  /* An instruction to the linker to not output the section
+     even if it has information which would normally be written.  */
+#define SEC_NEVER_LOAD 0x200
+
+  /* The section contains thread local data.  */
+#define SEC_THREAD_LOCAL 0x400
+
+  /* The section has GOT references.  This flag is only for the
+     linker, and is currently only used by the elf32-hppa back end.
+     It will be set if global offset table references were detected
+     in this section, which indicate to the linker that the section
+     contains PIC code, and must be handled specially when doing a
+     static link.  */
+#define SEC_HAS_GOT_REF 0x800
+
+  /* The section contains common symbols (symbols may be defined
+     multiple times, the value of a symbol is the amount of
+     space it requires, and the largest symbol value is the one
+     used).  Most targets have exactly one of these (which we
+     translate to bfd_com_section_ptr), but ECOFF has two.  */
+#define SEC_IS_COMMON 0x1000
+
+  /* The section contains only debugging information.  For
+     example, this is set for ELF .debug and .stab sections.
+     strip tests this flag to see if a section can be
+     discarded.  */
+#define SEC_DEBUGGING 0x2000
+
+  /* The contents of this section are held in memory pointed to
+     by the contents field.  This is checked by bfd_get_section_contents,
+     and the data is retrieved from memory if appropriate.  */
+#define SEC_IN_MEMORY 0x4000
+
+  /* The contents of this section are to be excluded by the
+     linker for executable and shared objects unless those
+     objects are to be further relocated.  */
+#define SEC_EXCLUDE 0x8000
+
+  /* The contents of this section are to be sorted based on the sum of
+     the symbol and addend values specified by the associated relocation
+     entries.  Entries without associated relocation entries will be
+     appended to the end of the section in an unspecified order.  */
+#define SEC_SORT_ENTRIES 0x10000
+
+  /* When linking, duplicate sections of the same name should be
+     discarded, rather than being combined into a single section as
+     is usually done.  This is similar to how common symbols are
+     handled.  See SEC_LINK_DUPLICATES below.  */
+#define SEC_LINK_ONCE 0x20000
+
+  /* If SEC_LINK_ONCE is set, this bitfield describes how the linker
+     should handle duplicate sections.  */
+#define SEC_LINK_DUPLICATES 0x40000
+
+  /* This value for SEC_LINK_DUPLICATES means that duplicate
+     sections with the same name should simply be discarded.  */
+#define SEC_LINK_DUPLICATES_DISCARD 0x0
+
+  /* This value for SEC_LINK_DUPLICATES means that the linker
+     should warn if there are any duplicate sections, although
+     it should still only link one copy.  */
+#define SEC_LINK_DUPLICATES_ONE_ONLY 0x80000
+
+  /* This value for SEC_LINK_DUPLICATES means that the linker
+     should warn if any duplicate sections are a different size.  */
+#define SEC_LINK_DUPLICATES_SAME_SIZE 0x100000
+
+  /* This value for SEC_LINK_DUPLICATES means that the linker
+     should warn if any duplicate sections contain different
+     contents.  */
+#define SEC_LINK_DUPLICATES_SAME_CONTENTS \
+  (SEC_LINK_DUPLICATES_ONE_ONLY | SEC_LINK_DUPLICATES_SAME_SIZE)
+
+  /* This section was created by the linker as part of dynamic
+     relocation or other arcane processing.  It is skipped when
+     going through the first-pass output, trusting that someone
+     else up the line will take care of it later.  */
+#define SEC_LINKER_CREATED 0x200000
+
+  /* This section should not be subject to garbage collection.  */
+#define SEC_KEEP 0x400000
+
+  /* This section contains "short" data, and should be placed
+     "near" the GP.  */
+#define SEC_SMALL_DATA 0x800000
+
+  /* Attempt to merge identical entities in the section.
+     Entity size is given in the entsize field.  */
+#define SEC_MERGE 0x1000000
+
+  /* If given with SEC_MERGE, entities to merge are zero terminated
+     strings where entsize specifies character size instead of fixed
+     size entries.  */
+#define SEC_STRINGS 0x2000000
+
+  /* This section contains data about section groups.  */
+#define SEC_GROUP 0x4000000
+
+  /* The section is a COFF shared library section.  This flag is
+     only for the linker.  If this type of section appears in
+     the input file, the linker must copy it to the output file
+     without changing the vma or size.  FIXME: Although this
+     was originally intended to be general, it really is COFF
+     specific (and the flag was renamed to indicate this).  It
+     might be cleaner to have some more general mechanism to
+     allow the back end to control what the linker does with
+     sections.  */
+#define SEC_COFF_SHARED_LIBRARY 0x10000000
+
+  /* This section contains data which may be shared with other
+     executables or shared objects. This is for COFF only.  */
+#define SEC_COFF_SHARED 0x20000000
+
+  /* When a section with this flag is being linked, then if the size of
+     the input section is less than a page, it should not cross a page
+     boundary.  If the size of the input section is one page or more,
+     it should be aligned on a page boundary.  This is for TI
+     TMS320C54X only.  */
+#define SEC_TIC54X_BLOCK 0x40000000
+
+  /* Conditionally link this section; do not link if there are no
+     references found to any symbol in the section.  This is for TI
+     TMS320C54X only.  */
+#define SEC_TIC54X_CLINK 0x80000000
+
+  /*  End of section flags.  */
+
+  /* Some internal packed boolean fields.  */
+
+  /* See the vma field.  */
+  unsigned int user_set_vma : 1;
+
+  /* A mark flag used by some of the linker backends.  */
+  unsigned int linker_mark : 1;
+
+  /* Another mark flag used by some of the linker backends.  Set for
+     output sections that have an input section.  */
+  unsigned int linker_has_input : 1;
+
+  /* Mark flags used by some linker backends for garbage collection.  */
+  unsigned int gc_mark : 1;
+  unsigned int gc_mark_from_eh : 1;
+
+  /* The following flags are used by the ELF linker. */
+
+  /* Mark sections which have been allocated to segments.  */
+  unsigned int segment_mark : 1;
+
+  /* Type of sec_info information.  */
+  unsigned int sec_info_type:3;
+#define ELF_INFO_TYPE_NONE      0
+#define ELF_INFO_TYPE_STABS     1
+#define ELF_INFO_TYPE_MERGE     2
+#define ELF_INFO_TYPE_EH_FRAME  3
+#define ELF_INFO_TYPE_JUST_SYMS 4
+
+  /* Nonzero if this section uses RELA relocations, rather than REL.  */
+  unsigned int use_rela_p:1;
+
+  /* Bits used by various backends.  The generic code doesn't touch
+     these fields.  */
+
+  /* Nonzero if this section has TLS related relocations.  */
+  unsigned int has_tls_reloc:1;
+
+  /* Nonzero if this section has a gp reloc.  */
+  unsigned int has_gp_reloc:1;
+
+  /* Nonzero if this section needs the relax finalize pass.  */
+  unsigned int need_finalize_relax:1;
+
+  /* Whether relocations have been processed.  */
+  unsigned int reloc_done : 1;
+
+  /* End of internal packed boolean fields.  */
+
+  /*  The virtual memory address of the section - where it will be
+      at run time.  The symbols are relocated against this.  The
+      user_set_vma flag is maintained by bfd; if it's not set, the
+      backend can assign addresses (for example, in <<a.out>>, where
+      the default address for <<.data>> is dependent on the specific
+      target and various flags).  */
+  bfd_vma vma;
+
+  /*  The load address of the section - where it would be in a
+      rom image; really only used for writing section header
+      information.  */
+  bfd_vma lma;
+
+  /* The size of the section in octets, as it will be output.
+     Contains a value even if the section has no contents (e.g., the
+     size of <<.bss>>).  */
+  bfd_size_type size;
+
+  /* For input sections, the original size on disk of the section, in
+     octets.  This field is used by the linker relaxation code.  It is
+     currently only set for sections where the linker relaxation scheme
+     doesn't cache altered section and reloc contents (stabs, eh_frame,
+     SEC_MERGE, some coff relaxing targets), and thus the original size
+     needs to be kept to read the section multiple times.
+     For output sections, rawsize holds the section size calculated on
+     a previous linker relaxation pass.  */
+  bfd_size_type rawsize;
+
+  /* If this section is going to be output, then this value is the
+     offset in *bytes* into the output section of the first byte in the
+     input section (byte ==> smallest addressable unit on the
+     target).  In most cases, if this was going to start at the
+     100th octet (8-bit quantity) in the output section, this value
+     would be 100.  However, if the target byte size is 16 bits
+     (bfd_octets_per_byte is "2"), this value would be 50.  */
+  bfd_vma output_offset;
+
+  /* The output section through which to map on output.  */
+  struct bfd_section *output_section;
+
+  /* The alignment requirement of the section, as an exponent of 2 -
+     e.g., 3 aligns to 2^3 (or 8).  */
+  unsigned int alignment_power;
+
+  /* If an input section, a pointer to a vector of relocation
+     records for the data in this section.  */
+  struct reloc_cache_entry *relocation;
+
+  /* If an output section, a pointer to a vector of pointers to
+     relocation records for the data in this section.  */
+  struct reloc_cache_entry **orelocation;
+
+  /* The number of relocation records in one of the above.  */
+  unsigned reloc_count;
+
+  /* Information below is back end specific - and not always used
+     or updated.  */
+
+  /* File position of section data.  */
+  file_ptr filepos;
+
+  /* File position of relocation info.  */
+  file_ptr rel_filepos;
+
+  /* File position of line data.  */
+  file_ptr line_filepos;
+
+  /* Pointer to data for applications.  */
+  void *userdata;
+
+  /* If the SEC_IN_MEMORY flag is set, this points to the actual
+     contents.  */
+  unsigned char *contents;
+
+  /* Attached line number information.  */
+  alent *lineno;
+
+  /* Number of line number records.  */
+  unsigned int lineno_count;
+
+  /* Entity size for merging purposes.  */
+  unsigned int entsize;
+
+  /* Points to the kept section if this section is a link-once section,
+     and is discarded.  */
+  struct bfd_section *kept_section;
+
+  /* When a section is being output, this value changes as more
+     linenumbers are written out.  */
+  file_ptr moving_line_filepos;
+
+  /* What the section number is in the target world.  */
+  int target_index;
+
+  void *used_by_bfd;
+
+  /* If this is a constructor section then here is a list of the
+     relocations created to relocate items within it.  */
+  struct relent_chain *constructor_chain;
+
+  /* The BFD which owns the section.  */
+  bfd *owner;
+
+  /* A symbol which points at this section only.  */
+  struct bfd_symbol *symbol;
+  struct bfd_symbol **symbol_ptr_ptr;
+
+  /* Early in the link process, map_head and map_tail are used to build
+     a list of input sections attached to an output section.  Later,
+     output sections use these fields for a list of bfd_link_order
+     structs.  */
+  union {
+    struct bfd_link_order *link_order;
+    struct bfd_section *s;
+  } map_head, map_tail;
+} asection;
+
+/* These sections are global, and are managed by BFD.  The application
+   and target back end are not permitted to change the values in
+   these sections.  New code should use the section_ptr macros rather
+   than referring directly to the const sections.  The const sections
+   may eventually vanish.  */
+#define BFD_ABS_SECTION_NAME "*ABS*"
+#define BFD_UND_SECTION_NAME "*UND*"
+#define BFD_COM_SECTION_NAME "*COM*"
+#define BFD_IND_SECTION_NAME "*IND*"
+
+/* The absolute section.  */
+extern asection bfd_abs_section;
+#define bfd_abs_section_ptr ((asection *) &bfd_abs_section)
+#define bfd_is_abs_section(sec) ((sec) == bfd_abs_section_ptr)
+/* Pointer to the undefined section.  */
+extern asection bfd_und_section;
+#define bfd_und_section_ptr ((asection *) &bfd_und_section)
+#define bfd_is_und_section(sec) ((sec) == bfd_und_section_ptr)
+/* Pointer to the common section.  */
+extern asection bfd_com_section;
+#define bfd_com_section_ptr ((asection *) &bfd_com_section)
+/* Pointer to the indirect section.  */
+extern asection bfd_ind_section;
+#define bfd_ind_section_ptr ((asection *) &bfd_ind_section)
+#define bfd_is_ind_section(sec) ((sec) == bfd_ind_section_ptr)
+
+#define bfd_is_const_section(SEC)              \
+ (   ((SEC) == bfd_abs_section_ptr)            \
+  || ((SEC) == bfd_und_section_ptr)            \
+  || ((SEC) == bfd_com_section_ptr)            \
+  || ((SEC) == bfd_ind_section_ptr))
+
+extern const struct bfd_symbol * const bfd_abs_symbol;
+extern const struct bfd_symbol * const bfd_com_symbol;
+extern const struct bfd_symbol * const bfd_und_symbol;
+extern const struct bfd_symbol * const bfd_ind_symbol;
+
+/* Macros to handle insertion and deletion of a bfd's sections.  These
+   only handle the list pointers, ie. do not adjust section_count,
+   target_index etc.  */
+#define bfd_section_list_remove(ABFD, S) \
+  do                                                   \
+    {                                                  \
+      asection *_s = S;                                \
+      asection *_next = _s->next;                      \
+      asection *_prev = _s->prev;                      \
+      if (_prev)                                       \
+        _prev->next = _next;                           \
+      else                                             \
+        (ABFD)->sections = _next;                      \
+      if (_next)                                       \
+        _next->prev = _prev;                           \
+      else                                             \
+        (ABFD)->section_last = _prev;                  \
+    }                                                  \
+  while (0)
+#define bfd_section_list_append(ABFD, S) \
+  do                                                   \
+    {                                                  \
+      asection *_s = S;                                \
+      bfd *_abfd = ABFD;                               \
+      _s->next = NULL;                                 \
+      if (_abfd->section_last)                         \
+        {                                              \
+          _s->prev = _abfd->section_last;              \
+          _abfd->section_last->next = _s;              \
+        }                                              \
+      else                                             \
+        {                                              \
+          _s->prev = NULL;                             \
+          _abfd->sections = _s;                        \
+        }                                              \
+      _abfd->section_last = _s;                        \
+    }                                                  \
+  while (0)
+#define bfd_section_list_prepend(ABFD, S) \
+  do                                                   \
+    {                                                  \
+      asection *_s = S;                                \
+      bfd *_abfd = ABFD;                               \
+      _s->prev = NULL;                                 \
+      if (_abfd->sections)                             \
+        {                                              \
+          _s->next = _abfd->sections;                  \
+          _abfd->sections->prev = _s;                  \
+        }                                              \
+      else                                             \
+        {                                              \
+          _s->next = NULL;                             \
+          _abfd->section_last = _s;                    \
+        }                                              \
+      _abfd->sections = _s;                            \
+    }                                                  \
+  while (0)
+#define bfd_section_list_insert_after(ABFD, A, S) \
+  do                                                   \
+    {                                                  \
+      asection *_a = A;                                \
+      asection *_s = S;                                \
+      asection *_next = _a->next;                      \
+      _s->next = _next;                                \
+      _s->prev = _a;                                   \
+      _a->next = _s;                                   \
+      if (_next)                                       \
+        _next->prev = _s;                              \
+      else                                             \
+        (ABFD)->section_last = _s;                     \
+    }                                                  \
+  while (0)
+#define bfd_section_list_insert_before(ABFD, B, S) \
+  do                                                   \
+    {                                                  \
+      asection *_b = B;                                \
+      asection *_s = S;                                \
+      asection *_prev = _b->prev;                      \
+      _s->prev = _prev;                                \
+      _s->next = _b;                                   \
+      _b->prev = _s;                                   \
+      if (_prev)                                       \
+        _prev->next = _s;                              \
+      else                                             \
+        (ABFD)->sections = _s;                         \
+    }                                                  \
+  while (0)
+#define bfd_section_removed_from_list(ABFD, S) \
+  ((S)->next == NULL ? (ABFD)->section_last != (S) : (S)->next->prev != (S))
+
+#define BFD_FAKE_SECTION(SEC, FLAGS, SYM, SYM_PTR, NAME, IDX)          \
+  /* name, id,  index, next, prev, flags, user_set_vma,            */  \
+  { NAME,  IDX, 0,     NULL, NULL, FLAGS, 0,                           \
+                                                                       \
+  /* linker_mark, linker_has_input, gc_mark, gc_mark_from_eh,      */  \
+     0,           0,                1,       0,                        \
+                                                                       \
+  /* segment_mark, sec_info_type, use_rela_p, has_tls_reloc,       */  \
+     0,            0,             0,          0,                       \
+                                                                       \
+  /* has_gp_reloc, need_finalize_relax, reloc_done,                */  \
+     0,            0,                   0,                             \
+                                                                       \
+  /* vma, lma, size, rawsize                                       */  \
+     0,   0,   0,    0,                                                \
+                                                                       \
+  /* output_offset, output_section,              alignment_power,  */  \
+     0,             (struct bfd_section *) &SEC, 0,                    \
+                                                                       \
+  /* relocation, orelocation, reloc_count, filepos, rel_filepos,   */  \
+     NULL,       NULL,        0,           0,       0,                 \
+                                                                       \
+  /* line_filepos, userdata, contents, lineno, lineno_count,       */  \
+     0,            NULL,     NULL,     NULL,   0,                      \
+                                                                       \
+  /* entsize, kept_section, moving_line_filepos,                    */ \
+     0,       NULL,          0,                                        \
+                                                                       \
+  /* target_index, used_by_bfd, constructor_chain, owner,          */  \
+     0,            NULL,        NULL,              NULL,               \
+                                                                       \
+  /* symbol,                                                       */  \
+     (struct bfd_symbol *) SYM,                                        \
+                                                                       \
+  /* symbol_ptr_ptr,                                               */  \
+     (struct bfd_symbol **) SYM_PTR,                                   \
+                                                                       \
+  /* map_head, map_tail                                            */  \
+     { NULL }, { NULL }                                                \
+    }
+
+void bfd_section_list_clear (bfd *);
+
+asection *bfd_get_section_by_name (bfd *abfd, const char *name);
+
+asection *bfd_get_section_by_name_if
+   (bfd *abfd,
+    const char *name,
+    bfd_boolean (*func) (bfd *abfd, asection *sect, void *obj),
+    void *obj);
+
+char *bfd_get_unique_section_name
+   (bfd *abfd, const char *templat, int *count);
+
+asection *bfd_make_section_old_way (bfd *abfd, const char *name);
+
+asection *bfd_make_section_anyway_with_flags
+   (bfd *abfd, const char *name, flagword flags);
+
+asection *bfd_make_section_anyway (bfd *abfd, const char *name);
+
+asection *bfd_make_section_with_flags
+   (bfd *, const char *name, flagword flags);
+
+asection *bfd_make_section (bfd *, const char *name);
+
+bfd_boolean bfd_set_section_flags
+   (bfd *abfd, asection *sec, flagword flags);
+
+void bfd_map_over_sections
+   (bfd *abfd,
+    void (*func) (bfd *abfd, asection *sect, void *obj),
+    void *obj);
+
+asection *bfd_sections_find_if
+   (bfd *abfd,
+    bfd_boolean (*operation) (bfd *abfd, asection *sect, void *obj),
+    void *obj);
+
+bfd_boolean bfd_set_section_size
+   (bfd *abfd, asection *sec, bfd_size_type val);
+
+bfd_boolean bfd_set_section_contents
+   (bfd *abfd, asection *section, const void *data,
+    file_ptr offset, bfd_size_type count);
+
+bfd_boolean bfd_get_section_contents
+   (bfd *abfd, asection *section, void *location, file_ptr offset,
+    bfd_size_type count);
+
+bfd_boolean bfd_malloc_and_get_section
+   (bfd *abfd, asection *section, bfd_byte **buf);
+
+bfd_boolean bfd_copy_private_section_data
+   (bfd *ibfd, asection *isec, bfd *obfd, asection *osec);
+
+#define bfd_copy_private_section_data(ibfd, isection, obfd, osection) \
+     BFD_SEND (obfd, _bfd_copy_private_section_data, \
+               (ibfd, isection, obfd, osection))
+bfd_boolean bfd_generic_is_group_section (bfd *, const asection *sec);
+
+bfd_boolean bfd_generic_discard_group (bfd *abfd, asection *group);
+
+/* Extracted from archures.c.  */
+enum bfd_architecture
+{
+  bfd_arch_unknown,   /* File arch not known.  */
+  bfd_arch_obscure,   /* Arch known, not one of these.  */
+  bfd_arch_m68k,      /* Motorola 68xxx */
+#define bfd_mach_m68000 1
+#define bfd_mach_m68008 2
+#define bfd_mach_m68010 3
+#define bfd_mach_m68020 4
+#define bfd_mach_m68030 5
+#define bfd_mach_m68040 6
+#define bfd_mach_m68060 7
+#define bfd_mach_cpu32  8
+#define bfd_mach_mcf5200  9
+#define bfd_mach_mcf5206e 10
+#define bfd_mach_mcf5307  11
+#define bfd_mach_mcf5407  12
+#define bfd_mach_mcf528x  13
+#define bfd_mach_mcfv4e   14
+#define bfd_mach_mcf521x   15
+#define bfd_mach_mcf5249   16
+#define bfd_mach_mcf547x   17
+#define bfd_mach_mcf548x   18
+  bfd_arch_vax,       /* DEC Vax */
+  bfd_arch_i960,      /* Intel 960 */
+    /* The order of the following is important.
+       lower number indicates a machine type that
+       only accepts a subset of the instructions
+       available to machines with higher numbers.
+       The exception is the "ca", which is
+       incompatible with all other machines except
+       "core".  */
+
+#define bfd_mach_i960_core      1
+#define bfd_mach_i960_ka_sa     2
+#define bfd_mach_i960_kb_sb     3
+#define bfd_mach_i960_mc        4
+#define bfd_mach_i960_xa        5
+#define bfd_mach_i960_ca        6
+#define bfd_mach_i960_jx        7
+#define bfd_mach_i960_hx        8
+
+  bfd_arch_or32,      /* OpenRISC 32 */
+
+  bfd_arch_sparc,     /* SPARC */
+#define bfd_mach_sparc                 1
+/* The difference between v8plus and v9 is that v9 is a true 64 bit env.  */
+#define bfd_mach_sparc_sparclet        2
+#define bfd_mach_sparc_sparclite       3
+#define bfd_mach_sparc_v8plus          4
+#define bfd_mach_sparc_v8plusa         5 /* with ultrasparc add'ns.  */
+#define bfd_mach_sparc_sparclite_le    6
+#define bfd_mach_sparc_v9              7
+#define bfd_mach_sparc_v9a             8 /* with ultrasparc add'ns.  */
+#define bfd_mach_sparc_v8plusb         9 /* with cheetah add'ns.  */
+#define bfd_mach_sparc_v9b             10 /* with cheetah add'ns.  */
+/* Nonzero if MACH has the v9 instruction set.  */
+#define bfd_mach_sparc_v9_p(mach) \
+  ((mach) >= bfd_mach_sparc_v8plus && (mach) <= bfd_mach_sparc_v9b \
+   && (mach) != bfd_mach_sparc_sparclite_le)
+/* Nonzero if MACH is a 64 bit sparc architecture.  */
+#define bfd_mach_sparc_64bit_p(mach) \
+  ((mach) >= bfd_mach_sparc_v9 && (mach) != bfd_mach_sparc_v8plusb)
+  bfd_arch_mips,      /* MIPS Rxxxx */
+#define bfd_mach_mips3000              3000
+#define bfd_mach_mips3900              3900
+#define bfd_mach_mips4000              4000
+#define bfd_mach_mips4010              4010
+#define bfd_mach_mips4100              4100
+#define bfd_mach_mips4111              4111
+#define bfd_mach_mips4120              4120
+#define bfd_mach_mips4300              4300
+#define bfd_mach_mips4400              4400
+#define bfd_mach_mips4600              4600
+#define bfd_mach_mips4650              4650
+#define bfd_mach_mips5000              5000
+#define bfd_mach_mips5400              5400
+#define bfd_mach_mips5500              5500
+#define bfd_mach_mips6000              6000
+#define bfd_mach_mips7000              7000
+#define bfd_mach_mips8000              8000
+#define bfd_mach_mips9000              9000
+#define bfd_mach_mips10000             10000
+#define bfd_mach_mips12000             12000
+#define bfd_mach_mips16                16
+#define bfd_mach_mips5                 5
+#define bfd_mach_mips_sb1              12310201 /* octal 'SB', 01 */
+#define bfd_mach_mipsisa32             32
+#define bfd_mach_mipsisa32r2           33
+#define bfd_mach_mipsisa64             64
+#define bfd_mach_mipsisa64r2           65
+  bfd_arch_i386,      /* Intel 386 */
+#define bfd_mach_i386_i386 1
+#define bfd_mach_i386_i8086 2
+#define bfd_mach_i386_i386_intel_syntax 3
+#define bfd_mach_x86_64 64
+#define bfd_mach_x86_64_intel_syntax 65
+  bfd_arch_we32k,     /* AT&T WE32xxx */
+  bfd_arch_tahoe,     /* CCI/Harris Tahoe */
+  bfd_arch_i860,      /* Intel 860 */
+  bfd_arch_i370,      /* IBM 360/370 Mainframes */
+  bfd_arch_romp,      /* IBM ROMP PC/RT */
+  bfd_arch_convex,    /* Convex */
+  bfd_arch_m88k,      /* Motorola 88xxx */
+  bfd_arch_m98k,      /* Motorola 98xxx */
+  bfd_arch_pyramid,   /* Pyramid Technology */
+  bfd_arch_h8300,     /* Renesas H8/300 (formerly Hitachi H8/300) */
+#define bfd_mach_h8300    1
+#define bfd_mach_h8300h   2
+#define bfd_mach_h8300s   3
+#define bfd_mach_h8300hn  4
+#define bfd_mach_h8300sn  5
+#define bfd_mach_h8300sx  6
+#define bfd_mach_h8300sxn 7
+  bfd_arch_pdp11,     /* DEC PDP-11 */
+  bfd_arch_powerpc,   /* PowerPC */
+#define bfd_mach_ppc           32
+#define bfd_mach_ppc64         64
+#define bfd_mach_ppc_403       403
+#define bfd_mach_ppc_403gc     4030
+#define bfd_mach_ppc_505       505
+#define bfd_mach_ppc_601       601
+#define bfd_mach_ppc_602       602
+#define bfd_mach_ppc_603       603
+#define bfd_mach_ppc_ec603e    6031
+#define bfd_mach_ppc_604       604
+#define bfd_mach_ppc_620       620
+#define bfd_mach_ppc_630       630
+#define bfd_mach_ppc_750       750
+#define bfd_mach_ppc_860       860
+#define bfd_mach_ppc_a35       35
+#define bfd_mach_ppc_rs64ii    642
+#define bfd_mach_ppc_rs64iii   643
+#define bfd_mach_ppc_7400      7400
+#define bfd_mach_ppc_e500      500
+  bfd_arch_rs6000,    /* IBM RS/6000 */
+#define bfd_mach_rs6k          6000
+#define bfd_mach_rs6k_rs1      6001
+#define bfd_mach_rs6k_rsc      6003
+#define bfd_mach_rs6k_rs2      6002
+  bfd_arch_hppa,      /* HP PA RISC */
+#define bfd_mach_hppa10        10
+#define bfd_mach_hppa11        11
+#define bfd_mach_hppa20        20
+#define bfd_mach_hppa20w       25
+  bfd_arch_d10v,      /* Mitsubishi D10V */
+#define bfd_mach_d10v          1
+#define bfd_mach_d10v_ts2      2
+#define bfd_mach_d10v_ts3      3
+  bfd_arch_d30v,      /* Mitsubishi D30V */
+  bfd_arch_dlx,       /* DLX */
+  bfd_arch_m68hc11,   /* Motorola 68HC11 */
+  bfd_arch_m68hc12,   /* Motorola 68HC12 */
+#define bfd_mach_m6812_default 0
+#define bfd_mach_m6812         1
+#define bfd_mach_m6812s        2
+  bfd_arch_z8k,       /* Zilog Z8000 */
+#define bfd_mach_z8001         1
+#define bfd_mach_z8002         2
+  bfd_arch_h8500,     /* Renesas H8/500 (formerly Hitachi H8/500) */
+  bfd_arch_sh,        /* Renesas / SuperH SH (formerly Hitachi SH) */
+#define bfd_mach_sh            1
+#define bfd_mach_sh2        0x20
+#define bfd_mach_sh_dsp     0x2d
+#define bfd_mach_sh2a       0x2a
+#define bfd_mach_sh2a_nofpu 0x2b
+#define bfd_mach_sh2a_nofpu_or_sh4_nommu_nofpu 0x2a1
+#define bfd_mach_sh2a_nofpu_or_sh3_nommu 0x2a2
+#define bfd_mach_sh2a_or_sh4  0x2a3
+#define bfd_mach_sh2a_or_sh3e 0x2a4
+#define bfd_mach_sh2e       0x2e
+#define bfd_mach_sh3        0x30
+#define bfd_mach_sh3_nommu  0x31
+#define bfd_mach_sh3_dsp    0x3d
+#define bfd_mach_sh3e       0x3e
+#define bfd_mach_sh4        0x40
+#define bfd_mach_sh4_nofpu  0x41
+#define bfd_mach_sh4_nommu_nofpu  0x42
+#define bfd_mach_sh4a       0x4a
+#define bfd_mach_sh4a_nofpu 0x4b
+#define bfd_mach_sh4al_dsp  0x4d
+#define bfd_mach_sh5        0x50
+  bfd_arch_alpha,     /* Dec Alpha */
+#define bfd_mach_alpha_ev4  0x10
+#define bfd_mach_alpha_ev5  0x20
+#define bfd_mach_alpha_ev6  0x30
+  bfd_arch_arm,       /* Advanced Risc Machines ARM.  */
+#define bfd_mach_arm_unknown   0
+#define bfd_mach_arm_2         1
+#define bfd_mach_arm_2a        2
+#define bfd_mach_arm_3         3
+#define bfd_mach_arm_3M        4
+#define bfd_mach_arm_4         5
+#define bfd_mach_arm_4T        6
+#define bfd_mach_arm_5         7
+#define bfd_mach_arm_5T        8
+#define bfd_mach_arm_5TE       9
+#define bfd_mach_arm_XScale    10
+#define bfd_mach_arm_ep9312    11
+#define bfd_mach_arm_iWMMXt    12
+  bfd_arch_ns32k,     /* National Semiconductors ns32000 */
+  bfd_arch_w65,       /* WDC 65816 */
+  bfd_arch_tic30,     /* Texas Instruments TMS320C30 */
+  bfd_arch_tic4x,     /* Texas Instruments TMS320C3X/4X */
+#define bfd_mach_tic3x         30
+#define bfd_mach_tic4x         40
+  bfd_arch_tic54x,    /* Texas Instruments TMS320C54X */
+  bfd_arch_tic80,     /* TI TMS320c80 (MVP) */
+  bfd_arch_v850,      /* NEC V850 */
+#define bfd_mach_v850          1
+#define bfd_mach_v850e         'E'
+#define bfd_mach_v850e1        '1'
+  bfd_arch_arc,       /* ARC Cores */
+#define bfd_mach_arc_5         5
+#define bfd_mach_arc_6         6
+#define bfd_mach_arc_7         7
+#define bfd_mach_arc_8         8
+ bfd_arch_m32c,     /* Renesas M16C/M32C.  */
+#define bfd_mach_m16c        0x75
+#define bfd_mach_m32c        0x78
+  bfd_arch_m32r,      /* Renesas M32R (formerly Mitsubishi M32R/D) */
+#define bfd_mach_m32r          1 /* For backwards compatibility.  */
+#define bfd_mach_m32rx         'x'
+#define bfd_mach_m32r2         '2'
+  bfd_arch_mn10200,   /* Matsushita MN10200 */
+  bfd_arch_mn10300,   /* Matsushita MN10300 */
+#define bfd_mach_mn10300               300
+#define bfd_mach_am33          330
+#define bfd_mach_am33_2        332
+  bfd_arch_fr30,
+#define bfd_mach_fr30          0x46523330
+  bfd_arch_frv,
+#define bfd_mach_frv           1
+#define bfd_mach_frvsimple     2
+#define bfd_mach_fr300         300
+#define bfd_mach_fr400         400
+#define bfd_mach_fr450         450
+#define bfd_mach_frvtomcat     499     /* fr500 prototype */
+#define bfd_mach_fr500         500
+#define bfd_mach_fr550         550
+  bfd_arch_mcore,
+  bfd_arch_ia64,      /* HP/Intel ia64 */
+#define bfd_mach_ia64_elf64    64
+#define bfd_mach_ia64_elf32    32
+  bfd_arch_ip2k,      /* Ubicom IP2K microcontrollers. */
+#define bfd_mach_ip2022        1
+#define bfd_mach_ip2022ext     2
+ bfd_arch_iq2000,     /* Vitesse IQ2000.  */
+#define bfd_mach_iq2000        1
+#define bfd_mach_iq10          2
+  bfd_arch_mt,
+#define bfd_mach_ms1           1
+#define bfd_mach_mrisc2        2
+#define bfd_mach_ms2           3
+  bfd_arch_pj,
+  bfd_arch_avr,       /* Atmel AVR microcontrollers.  */
+#define bfd_mach_avr1          1
+#define bfd_mach_avr2          2
+#define bfd_mach_avr3          3
+#define bfd_mach_avr4          4
+#define bfd_mach_avr5          5
+  bfd_arch_bfin,        /* ADI Blackfin */
+#define bfd_mach_bfin          1
+  bfd_arch_cr16c,       /* National Semiconductor CompactRISC. */
+#define bfd_mach_cr16c         1
+  bfd_arch_crx,       /*  National Semiconductor CRX.  */
+#define bfd_mach_crx           1
+  bfd_arch_cris,      /* Axis CRIS */
+#define bfd_mach_cris_v0_v10   255
+#define bfd_mach_cris_v32      32
+#define bfd_mach_cris_v10_v32  1032
+  bfd_arch_s390,      /* IBM s390 */
+#define bfd_mach_s390_31       31
+#define bfd_mach_s390_64       64
+  bfd_arch_openrisc,  /* OpenRISC */
+  bfd_arch_mmix,      /* Donald Knuth's educational processor.  */
+  bfd_arch_xstormy16,
+#define bfd_mach_xstormy16     1
+  bfd_arch_msp430,    /* Texas Instruments MSP430 architecture.  */
+#define bfd_mach_msp11          11
+#define bfd_mach_msp110         110
+#define bfd_mach_msp12          12
+#define bfd_mach_msp13          13
+#define bfd_mach_msp14          14
+#define bfd_mach_msp15          15
+#define bfd_mach_msp16          16
+#define bfd_mach_msp21          21
+#define bfd_mach_msp31          31
+#define bfd_mach_msp32          32
+#define bfd_mach_msp33          33
+#define bfd_mach_msp41          41
+#define bfd_mach_msp42          42
+#define bfd_mach_msp43          43
+#define bfd_mach_msp44          44
+  bfd_arch_xtensa,    /* Tensilica's Xtensa cores.  */
+#define bfd_mach_xtensa        1
+   bfd_arch_maxq,     /* Dallas MAXQ 10/20 */
+#define bfd_mach_maxq10    10
+#define bfd_mach_maxq20    20
+  bfd_arch_z80,
+#define bfd_mach_z80strict      1 /* No undocumented opcodes.  */
+#define bfd_mach_z80            3 /* With ixl, ixh, iyl, and iyh.  */
+#define bfd_mach_z80full        7 /* All undocumented instructions.  */
+#define bfd_mach_r800           11 /* R800: successor with multiplication.  */
+  bfd_arch_last
+  };
+
+typedef struct bfd_arch_info
+{
+  int bits_per_word;
+  int bits_per_address;
+  int bits_per_byte;
+  enum bfd_architecture arch;
+  unsigned long mach;
+  const char *arch_name;
+  const char *printable_name;
+  unsigned int section_align_power;
+  /* TRUE if this is the default machine for the architecture.
+     The default arch should be the first entry for an arch so that
+     all the entries for that arch can be accessed via <<next>>.  */
+  bfd_boolean the_default;
+  const struct bfd_arch_info * (*compatible)
+    (const struct bfd_arch_info *a, const struct bfd_arch_info *b);
+
+  bfd_boolean (*scan) (const struct bfd_arch_info *, const char *);
+
+  const struct bfd_arch_info *next;
+}
+bfd_arch_info_type;
+
+const char *bfd_printable_name (bfd *abfd);
+
+const bfd_arch_info_type *bfd_scan_arch (const char *string);
+
+const char **bfd_arch_list (void);
+
+const bfd_arch_info_type *bfd_arch_get_compatible
+   (const bfd *abfd, const bfd *bbfd, bfd_boolean accept_unknowns);
+
+void bfd_set_arch_info (bfd *abfd, const bfd_arch_info_type *arg);
+
+enum bfd_architecture bfd_get_arch (bfd *abfd);
+
+unsigned long bfd_get_mach (bfd *abfd);
+
+unsigned int bfd_arch_bits_per_byte (bfd *abfd);
+
+unsigned int bfd_arch_bits_per_address (bfd *abfd);
+
+const bfd_arch_info_type *bfd_get_arch_info (bfd *abfd);
+
+const bfd_arch_info_type *bfd_lookup_arch
+   (enum bfd_architecture arch, unsigned long machine);
+
+const char *bfd_printable_arch_mach
+   (enum bfd_architecture arch, unsigned long machine);
+
+unsigned int bfd_octets_per_byte (bfd *abfd);
+
+unsigned int bfd_arch_mach_octets_per_byte
+   (enum bfd_architecture arch, unsigned long machine);
+
+/* Extracted from reloc.c.  */
+typedef enum bfd_reloc_status
+{
+  /* No errors detected.  */
+  bfd_reloc_ok,
+
+  /* The relocation was performed, but there was an overflow.  */
+  bfd_reloc_overflow,
+
+  /* The address to relocate was not within the section supplied.  */
+  bfd_reloc_outofrange,
+
+  /* Used by special functions.  */
+  bfd_reloc_continue,
+
+  /* Unsupported relocation size requested.  */
+  bfd_reloc_notsupported,
+
+  /* Unused.  */
+  bfd_reloc_other,
+
+  /* The symbol to relocate against was undefined.  */
+  bfd_reloc_undefined,
+
+  /* The relocation was performed, but may not be ok - presently
+     generated only when linking i960 coff files with i960 b.out
+     symbols.  If this type is returned, the error_message argument
+     to bfd_perform_relocation will be set.  */
+  bfd_reloc_dangerous
+ }
+ bfd_reloc_status_type;
+
+
+typedef struct reloc_cache_entry
+{
+  /* A pointer into the canonical table of pointers.  */
+  struct bfd_symbol **sym_ptr_ptr;
+
+  /* offset in section.  */
+  bfd_size_type address;
+
+  /* addend for relocation value.  */
+  bfd_vma addend;
+
+  /* Pointer to how to perform the required relocation.  */
+  reloc_howto_type *howto;
+
+}
+arelent;
+
+enum complain_overflow
+{
+  /* Do not complain on overflow.  */
+  complain_overflow_dont,
+
+  /* Complain if the value overflows when considered as a signed
+     number one bit larger than the field.  ie. A bitfield of N bits
+     is allowed to represent -2**n to 2**n-1.  */
+  complain_overflow_bitfield,
+
+  /* Complain if the value overflows when considered as a signed
+     number.  */
+  complain_overflow_signed,
+
+  /* Complain if the value overflows when considered as an
+     unsigned number.  */
+  complain_overflow_unsigned
+};
+
+struct reloc_howto_struct
+{
+  /*  The type field has mainly a documentary use - the back end can
+      do what it wants with it, though normally the back end's
+      external idea of what a reloc number is stored
+      in this field.  For example, a PC relative word relocation
+      in a coff environment has the type 023 - because that's
+      what the outside world calls a R_PCRWORD reloc.  */
+  unsigned int type;
+
+  /*  The value the final relocation is shifted right by.  This drops
+      unwanted data from the relocation.  */
+  unsigned int rightshift;
+
+  /*  The size of the item to be relocated.  This is *not* a
+      power-of-two measure.  To get the number of bytes operated
+      on by a type of relocation, use bfd_get_reloc_size.  */
+  int size;
+
+  /*  The number of bits in the item to be relocated.  This is used
+      when doing overflow checking.  */
+  unsigned int bitsize;
+
+  /*  Notes that the relocation is relative to the location in the
+      data section of the addend.  The relocation function will
+      subtract from the relocation value the address of the location
+      being relocated.  */
+  bfd_boolean pc_relative;
+
+  /*  The bit position of the reloc value in the destination.
+      The relocated value is left shifted by this amount.  */
+  unsigned int bitpos;
+
+  /* What type of overflow error should be checked for when
+     relocating.  */
+  enum complain_overflow complain_on_overflow;
+
+  /* If this field is non null, then the supplied function is
+     called rather than the normal function.  This allows really
+     strange relocation methods to be accommodated (e.g., i960 callj
+     instructions).  */
+  bfd_reloc_status_type (*special_function)
+    (bfd *, arelent *, struct bfd_symbol *, void *, asection *,
+     bfd *, char **);
+
+  /* The textual name of the relocation type.  */
+  char *name;
+
+  /* Some formats record a relocation addend in the section contents
+     rather than with the relocation.  For ELF formats this is the
+     distinction between USE_REL and USE_RELA (though the code checks
+     for USE_REL == 1/0).  The value of this field is TRUE if the
+     addend is recorded with the section contents; when performing a
+     partial link (ld -r) the section contents (the data) will be
+     modified.  The value of this field is FALSE if addends are
+     recorded with the relocation (in arelent.addend); when performing
+     a partial link the relocation will be modified.
+     All relocations for all ELF USE_RELA targets should set this field
+     to FALSE (values of TRUE should be looked on with suspicion).
+     However, the converse is not true: not all relocations of all ELF
+     USE_REL targets set this field to TRUE.  Why this is so is peculiar
+     to each particular target.  For relocs that aren't used in partial
+     links (e.g. GOT stuff) it doesn't matter what this is set to.  */
+  bfd_boolean partial_inplace;
+
+  /* src_mask selects the part of the instruction (or data) to be used
+     in the relocation sum.  If the target relocations don't have an
+     addend in the reloc, eg. ELF USE_REL, src_mask will normally equal
+     dst_mask to extract the addend from the section contents.  If
+     relocations do have an addend in the reloc, eg. ELF USE_RELA, this
+     field should be zero.  Non-zero values for ELF USE_RELA targets are
+     bogus as in those cases the value in the dst_mask part of the
+     section contents should be treated as garbage.  */
+  bfd_vma src_mask;
+
+  /* dst_mask selects which parts of the instruction (or data) are
+     replaced with a relocated value.  */
+  bfd_vma dst_mask;
+
+  /* When some formats create PC relative instructions, they leave
+     the value of the pc of the place being relocated in the offset
+     slot of the instruction, so that a PC relative relocation can
+     be made just by adding in an ordinary offset (e.g., sun3 a.out).
+     Some formats leave the displacement part of an instruction
+     empty (e.g., m88k bcs); this flag signals the fact.  */
+  bfd_boolean pcrel_offset;
+};
+
+#define HOWTO(C, R, S, B, P, BI, O, SF, NAME, INPLACE, MASKSRC, MASKDST, PC) \
+  { (unsigned) C, R, S, B, P, BI, O, SF, NAME, INPLACE, MASKSRC, MASKDST, PC }
+#define NEWHOWTO(FUNCTION, NAME, SIZE, REL, IN) \
+  HOWTO (0, 0, SIZE, 0, REL, 0, complain_overflow_dont, FUNCTION, \
+         NAME, FALSE, 0, 0, IN)
+
+#define EMPTY_HOWTO(C) \
+  HOWTO ((C), 0, 0, 0, FALSE, 0, complain_overflow_dont, NULL, \
+         NULL, FALSE, 0, 0, FALSE)
+
+#define HOWTO_PREPARE(relocation, symbol)               \
+  {                                                     \
+    if (symbol != NULL)                                 \
+      {                                                 \
+        if (bfd_is_com_section (symbol->section))       \
+          {                                             \
+            relocation = 0;                             \
+          }                                             \
+        else                                            \
+          {                                             \
+            relocation = symbol->value;                 \
+          }                                             \
+      }                                                 \
+  }
+
+unsigned int bfd_get_reloc_size (reloc_howto_type *);
+
+typedef struct relent_chain
+{
+  arelent relent;
+  struct relent_chain *next;
+}
+arelent_chain;
+
+bfd_reloc_status_type bfd_check_overflow
+   (enum complain_overflow how,
+    unsigned int bitsize,
+    unsigned int rightshift,
+    unsigned int addrsize,
+    bfd_vma relocation);
+
+bfd_reloc_status_type bfd_perform_relocation
+   (bfd *abfd,
+    arelent *reloc_entry,
+    void *data,
+    asection *input_section,
+    bfd *output_bfd,
+    char **error_message);
+
+bfd_reloc_status_type bfd_install_relocation
+   (bfd *abfd,
+    arelent *reloc_entry,
+    void *data, bfd_vma data_start,
+    asection *input_section,
+    char **error_message);
+
+enum bfd_reloc_code_real {
+  _dummy_first_bfd_reloc_code_real,
+
+
+/* Basic absolute relocations of N bits.  */
+  BFD_RELOC_64,
+  BFD_RELOC_32,
+  BFD_RELOC_26,
+  BFD_RELOC_24,
+  BFD_RELOC_16,
+  BFD_RELOC_14,
+  BFD_RELOC_8,
+
+/* PC-relative relocations.  Sometimes these are relative to the address
+of the relocation itself; sometimes they are relative to the start of
+the section containing the relocation.  It depends on the specific target.
+
+The 24-bit relocation is used in some Intel 960 configurations.  */
+  BFD_RELOC_64_PCREL,
+  BFD_RELOC_32_PCREL,
+  BFD_RELOC_24_PCREL,
+  BFD_RELOC_16_PCREL,
+  BFD_RELOC_12_PCREL,
+  BFD_RELOC_8_PCREL,
+
+/* Section relative relocations.  Some targets need this for DWARF2.  */
+  BFD_RELOC_32_SECREL,
+
+/* For ELF.  */
+  BFD_RELOC_32_GOT_PCREL,
+  BFD_RELOC_16_GOT_PCREL,
+  BFD_RELOC_8_GOT_PCREL,
+  BFD_RELOC_32_GOTOFF,
+  BFD_RELOC_16_GOTOFF,
+  BFD_RELOC_LO16_GOTOFF,
+  BFD_RELOC_HI16_GOTOFF,
+  BFD_RELOC_HI16_S_GOTOFF,
+  BFD_RELOC_8_GOTOFF,
+  BFD_RELOC_64_PLT_PCREL,
+  BFD_RELOC_32_PLT_PCREL,
+  BFD_RELOC_24_PLT_PCREL,
+  BFD_RELOC_16_PLT_PCREL,
+  BFD_RELOC_8_PLT_PCREL,
+  BFD_RELOC_64_PLTOFF,
+  BFD_RELOC_32_PLTOFF,
+  BFD_RELOC_16_PLTOFF,
+  BFD_RELOC_LO16_PLTOFF,
+  BFD_RELOC_HI16_PLTOFF,
+  BFD_RELOC_HI16_S_PLTOFF,
+  BFD_RELOC_8_PLTOFF,
+
+/* Relocations used by 68K ELF.  */
+  BFD_RELOC_68K_GLOB_DAT,
+  BFD_RELOC_68K_JMP_SLOT,
+  BFD_RELOC_68K_RELATIVE,
+
+/* Linkage-table relative.  */
+  BFD_RELOC_32_BASEREL,
+  BFD_RELOC_16_BASEREL,
+  BFD_RELOC_LO16_BASEREL,
+  BFD_RELOC_HI16_BASEREL,
+  BFD_RELOC_HI16_S_BASEREL,
+  BFD_RELOC_8_BASEREL,
+  BFD_RELOC_RVA,
+
+/* Absolute 8-bit relocation, but used to form an address like 0xFFnn.  */
+  BFD_RELOC_8_FFnn,
+
+/* These PC-relative relocations are stored as word displacements --
+i.e., byte displacements shifted right two bits.  The 30-bit word
+displacement (<<32_PCREL_S2>> -- 32 bits, shifted 2) is used on the
+SPARC.  (SPARC tools generally refer to this as <<WDISP30>>.)  The
+signed 16-bit displacement is used on the MIPS, and the 23-bit
+displacement is used on the Alpha.  */
+  BFD_RELOC_32_PCREL_S2,
+  BFD_RELOC_16_PCREL_S2,
+  BFD_RELOC_23_PCREL_S2,
+
+/* High 22 bits and low 10 bits of 32-bit value, placed into lower bits of
+the target word.  These are used on the SPARC.  */
+  BFD_RELOC_HI22,
+  BFD_RELOC_LO10,
+
+/* For systems that allocate a Global Pointer register, these are
+displacements off that register.  These relocation types are
+handled specially, because the value the register will have is
+decided relatively late.  */
+  BFD_RELOC_GPREL16,
+  BFD_RELOC_GPREL32,
+
+/* Reloc types used for i960/b.out.  */
+  BFD_RELOC_I960_CALLJ,
+
+/* SPARC ELF relocations.  There is probably some overlap with other
+relocation types already defined.  */
+  BFD_RELOC_NONE,
+  BFD_RELOC_SPARC_WDISP22,
+  BFD_RELOC_SPARC22,
+  BFD_RELOC_SPARC13,
+  BFD_RELOC_SPARC_GOT10,
+  BFD_RELOC_SPARC_GOT13,
+  BFD_RELOC_SPARC_GOT22,
+  BFD_RELOC_SPARC_PC10,
+  BFD_RELOC_SPARC_PC22,
+  BFD_RELOC_SPARC_WPLT30,
+  BFD_RELOC_SPARC_COPY,
+  BFD_RELOC_SPARC_GLOB_DAT,
+  BFD_RELOC_SPARC_JMP_SLOT,
+  BFD_RELOC_SPARC_RELATIVE,
+  BFD_RELOC_SPARC_UA16,
+  BFD_RELOC_SPARC_UA32,
+  BFD_RELOC_SPARC_UA64,
+
+/* I think these are specific to SPARC a.out (e.g., Sun 4).  */
+  BFD_RELOC_SPARC_BASE13,
+  BFD_RELOC_SPARC_BASE22,
+
+/* SPARC64 relocations  */
+#define BFD_RELOC_SPARC_64 BFD_RELOC_64
+  BFD_RELOC_SPARC_10,
+  BFD_RELOC_SPARC_11,
+  BFD_RELOC_SPARC_OLO10,
+  BFD_RELOC_SPARC_HH22,
+  BFD_RELOC_SPARC_HM10,
+  BFD_RELOC_SPARC_LM22,
+  BFD_RELOC_SPARC_PC_HH22,
+  BFD_RELOC_SPARC_PC_HM10,
+  BFD_RELOC_SPARC_PC_LM22,
+  BFD_RELOC_SPARC_WDISP16,
+  BFD_RELOC_SPARC_WDISP19,
+  BFD_RELOC_SPARC_7,
+  BFD_RELOC_SPARC_6,
+  BFD_RELOC_SPARC_5,
+#define BFD_RELOC_SPARC_DISP64 BFD_RELOC_64_PCREL
+  BFD_RELOC_SPARC_PLT32,
+  BFD_RELOC_SPARC_PLT64,
+  BFD_RELOC_SPARC_HIX22,
+  BFD_RELOC_SPARC_LOX10,
+  BFD_RELOC_SPARC_H44,
+  BFD_RELOC_SPARC_M44,
+  BFD_RELOC_SPARC_L44,
+  BFD_RELOC_SPARC_REGISTER,
+
+/* SPARC little endian relocation  */
+  BFD_RELOC_SPARC_REV32,
+
+/* SPARC TLS relocations  */
+  BFD_RELOC_SPARC_TLS_GD_HI22,
+  BFD_RELOC_SPARC_TLS_GD_LO10,
+  BFD_RELOC_SPARC_TLS_GD_ADD,
+  BFD_RELOC_SPARC_TLS_GD_CALL,
+  BFD_RELOC_SPARC_TLS_LDM_HI22,
+  BFD_RELOC_SPARC_TLS_LDM_LO10,
+  BFD_RELOC_SPARC_TLS_LDM_ADD,
+  BFD_RELOC_SPARC_TLS_LDM_CALL,
+  BFD_RELOC_SPARC_TLS_LDO_HIX22,
+  BFD_RELOC_SPARC_TLS_LDO_LOX10,
+  BFD_RELOC_SPARC_TLS_LDO_ADD,
+  BFD_RELOC_SPARC_TLS_IE_HI22,
+  BFD_RELOC_SPARC_TLS_IE_LO10,
+  BFD_RELOC_SPARC_TLS_IE_LD,
+  BFD_RELOC_SPARC_TLS_IE_LDX,
+  BFD_RELOC_SPARC_TLS_IE_ADD,
+  BFD_RELOC_SPARC_TLS_LE_HIX22,
+  BFD_RELOC_SPARC_TLS_LE_LOX10,
+  BFD_RELOC_SPARC_TLS_DTPMOD32,
+  BFD_RELOC_SPARC_TLS_DTPMOD64,
+  BFD_RELOC_SPARC_TLS_DTPOFF32,
+  BFD_RELOC_SPARC_TLS_DTPOFF64,
+  BFD_RELOC_SPARC_TLS_TPOFF32,
+  BFD_RELOC_SPARC_TLS_TPOFF64,
+
+/* Alpha ECOFF and ELF relocations.  Some of these treat the symbol or
+"addend" in some special way.
+For GPDISP_HI16 ("gpdisp") relocations, the symbol is ignored when
+writing; when reading, it will be the absolute section symbol.  The
+addend is the displacement in bytes of the "lda" instruction from
+the "ldah" instruction (which is at the address of this reloc).  */
+  BFD_RELOC_ALPHA_GPDISP_HI16,
+
+/* For GPDISP_LO16 ("ignore") relocations, the symbol is handled as
+with GPDISP_HI16 relocs.  The addend is ignored when writing the
+relocations out, and is filled in with the file's GP value on
+reading, for convenience.  */
+  BFD_RELOC_ALPHA_GPDISP_LO16,
+
+/* The ELF GPDISP relocation is exactly the same as the GPDISP_HI16
+relocation except that there is no accompanying GPDISP_LO16
+relocation.  */
+  BFD_RELOC_ALPHA_GPDISP,
+
+/* The Alpha LITERAL/LITUSE relocs are produced by a symbol reference;
+the assembler turns it into a LDQ instruction to load the address of
+the symbol, and then fills in a register in the real instruction.
+
+The LITERAL reloc, at the LDQ instruction, refers to the .lita
+section symbol.  The addend is ignored when writing, but is filled
+in with the file's GP value on reading, for convenience, as with the
+GPDISP_LO16 reloc.
+
+The ELF_LITERAL reloc is somewhere between 16_GOTOFF and GPDISP_LO16.
+It should refer to the symbol to be referenced, as with 16_GOTOFF,
+but it generates output not based on the position within the .got
+section, but relative to the GP value chosen for the file during the
+final link stage.
+
+The LITUSE reloc, on the instruction using the loaded address, gives
+information to the linker that it might be able to use to optimize
+away some literal section references.  The symbol is ignored (read
+as the absolute section symbol), and the "addend" indicates the type
+of instruction using the register:
+1 - "memory" fmt insn
+2 - byte-manipulation (byte offset reg)
+3 - jsr (target of branch)  */
+  BFD_RELOC_ALPHA_LITERAL,
+  BFD_RELOC_ALPHA_ELF_LITERAL,
+  BFD_RELOC_ALPHA_LITUSE,
+
+/* The HINT relocation indicates a value that should be filled into the
+"hint" field of a jmp/jsr/ret instruction, for possible branch-
+prediction logic which may be provided on some processors.  */
+  BFD_RELOC_ALPHA_HINT,
+
+/* The LINKAGE relocation outputs a linkage pair in the object file,
+which is filled by the linker.  */
+  BFD_RELOC_ALPHA_LINKAGE,
+
+/* The CODEADDR relocation outputs a STO_CA in the object file,
+which is filled by the linker.  */
+  BFD_RELOC_ALPHA_CODEADDR,
+
+/* The GPREL_HI/LO relocations together form a 32-bit offset from the
+GP register.  */
+  BFD_RELOC_ALPHA_GPREL_HI16,
+  BFD_RELOC_ALPHA_GPREL_LO16,
+
+/* Like BFD_RELOC_23_PCREL_S2, except that the source and target must
+share a common GP, and the target address is adjusted for
+STO_ALPHA_STD_GPLOAD.  */
+  BFD_RELOC_ALPHA_BRSGP,
+
+/* Alpha thread-local storage relocations.  */
+  BFD_RELOC_ALPHA_TLSGD,
+  BFD_RELOC_ALPHA_TLSLDM,
+  BFD_RELOC_ALPHA_DTPMOD64,
+  BFD_RELOC_ALPHA_GOTDTPREL16,
+  BFD_RELOC_ALPHA_DTPREL64,
+  BFD_RELOC_ALPHA_DTPREL_HI16,
+  BFD_RELOC_ALPHA_DTPREL_LO16,
+  BFD_RELOC_ALPHA_DTPREL16,
+  BFD_RELOC_ALPHA_GOTTPREL16,
+  BFD_RELOC_ALPHA_TPREL64,
+  BFD_RELOC_ALPHA_TPREL_HI16,
+  BFD_RELOC_ALPHA_TPREL_LO16,
+  BFD_RELOC_ALPHA_TPREL16,
+
+/* Bits 27..2 of the relocation address shifted right 2 bits;
+simple reloc otherwise.  */
+  BFD_RELOC_MIPS_JMP,
+
+/* The MIPS16 jump instruction.  */
+  BFD_RELOC_MIPS16_JMP,
+
+/* MIPS16 GP relative reloc.  */
+  BFD_RELOC_MIPS16_GPREL,
+
+/* High 16 bits of 32-bit value; simple reloc.  */
+  BFD_RELOC_HI16,
+
+/* High 16 bits of 32-bit value but the low 16 bits will be sign
+extended and added to form the final result.  If the low 16
+bits form a negative number, we need to add one to the high value
+to compensate for the borrow when the low bits are added.  */
+  BFD_RELOC_HI16_S,
+
+/* Low 16 bits.  */
+  BFD_RELOC_LO16,
+
+/* High 16 bits of 32-bit pc-relative value  */
+  BFD_RELOC_HI16_PCREL,
+
+/* High 16 bits of 32-bit pc-relative value, adjusted  */
+  BFD_RELOC_HI16_S_PCREL,
+
+/* Low 16 bits of pc-relative value  */
+  BFD_RELOC_LO16_PCREL,
+
+/* MIPS16 high 16 bits of 32-bit value.  */
+  BFD_RELOC_MIPS16_HI16,
+
+/* MIPS16 high 16 bits of 32-bit value but the low 16 bits will be sign
+extended and added to form the final result.  If the low 16
+bits form a negative number, we need to add one to the high value
+to compensate for the borrow when the low bits are added.  */
+  BFD_RELOC_MIPS16_HI16_S,
+
+/* MIPS16 low 16 bits.  */
+  BFD_RELOC_MIPS16_LO16,
+
+/* Relocation against a MIPS literal section.  */
+  BFD_RELOC_MIPS_LITERAL,
+
+/* MIPS ELF relocations.  */
+  BFD_RELOC_MIPS_GOT16,
+  BFD_RELOC_MIPS_CALL16,
+  BFD_RELOC_MIPS_GOT_HI16,
+  BFD_RELOC_MIPS_GOT_LO16,
+  BFD_RELOC_MIPS_CALL_HI16,
+  BFD_RELOC_MIPS_CALL_LO16,
+  BFD_RELOC_MIPS_SUB,
+  BFD_RELOC_MIPS_GOT_PAGE,
+  BFD_RELOC_MIPS_GOT_OFST,
+  BFD_RELOC_MIPS_GOT_DISP,
+  BFD_RELOC_MIPS_SHIFT5,
+  BFD_RELOC_MIPS_SHIFT6,
+  BFD_RELOC_MIPS_INSERT_A,
+  BFD_RELOC_MIPS_INSERT_B,
+  BFD_RELOC_MIPS_DELETE,
+  BFD_RELOC_MIPS_HIGHEST,
+  BFD_RELOC_MIPS_HIGHER,
+  BFD_RELOC_MIPS_SCN_DISP,
+  BFD_RELOC_MIPS_REL16,
+  BFD_RELOC_MIPS_RELGOT,
+  BFD_RELOC_MIPS_JALR,
+  BFD_RELOC_MIPS_TLS_DTPMOD32,
+  BFD_RELOC_MIPS_TLS_DTPREL32,
+  BFD_RELOC_MIPS_TLS_DTPMOD64,
+  BFD_RELOC_MIPS_TLS_DTPREL64,
+  BFD_RELOC_MIPS_TLS_GD,
+  BFD_RELOC_MIPS_TLS_LDM,
+  BFD_RELOC_MIPS_TLS_DTPREL_HI16,
+  BFD_RELOC_MIPS_TLS_DTPREL_LO16,
+  BFD_RELOC_MIPS_TLS_GOTTPREL,
+  BFD_RELOC_MIPS_TLS_TPREL32,
+  BFD_RELOC_MIPS_TLS_TPREL64,
+  BFD_RELOC_MIPS_TLS_TPREL_HI16,
+  BFD_RELOC_MIPS_TLS_TPREL_LO16,
+
+
+/* Fujitsu Frv Relocations.  */
+  BFD_RELOC_FRV_LABEL16,
+  BFD_RELOC_FRV_LABEL24,
+  BFD_RELOC_FRV_LO16,
+  BFD_RELOC_FRV_HI16,
+  BFD_RELOC_FRV_GPREL12,
+  BFD_RELOC_FRV_GPRELU12,
+  BFD_RELOC_FRV_GPREL32,
+  BFD_RELOC_FRV_GPRELHI,
+  BFD_RELOC_FRV_GPRELLO,
+  BFD_RELOC_FRV_GOT12,
+  BFD_RELOC_FRV_GOTHI,
+  BFD_RELOC_FRV_GOTLO,
+  BFD_RELOC_FRV_FUNCDESC,
+  BFD_RELOC_FRV_FUNCDESC_GOT12,
+  BFD_RELOC_FRV_FUNCDESC_GOTHI,
+  BFD_RELOC_FRV_FUNCDESC_GOTLO,
+  BFD_RELOC_FRV_FUNCDESC_VALUE,
+  BFD_RELOC_FRV_FUNCDESC_GOTOFF12,
+  BFD_RELOC_FRV_FUNCDESC_GOTOFFHI,
+  BFD_RELOC_FRV_FUNCDESC_GOTOFFLO,
+  BFD_RELOC_FRV_GOTOFF12,
+  BFD_RELOC_FRV_GOTOFFHI,
+  BFD_RELOC_FRV_GOTOFFLO,
+  BFD_RELOC_FRV_GETTLSOFF,
+  BFD_RELOC_FRV_TLSDESC_VALUE,
+  BFD_RELOC_FRV_GOTTLSDESC12,
+  BFD_RELOC_FRV_GOTTLSDESCHI,
+  BFD_RELOC_FRV_GOTTLSDESCLO,
+  BFD_RELOC_FRV_TLSMOFF12,
+  BFD_RELOC_FRV_TLSMOFFHI,
+  BFD_RELOC_FRV_TLSMOFFLO,
+  BFD_RELOC_FRV_GOTTLSOFF12,
+  BFD_RELOC_FRV_GOTTLSOFFHI,
+  BFD_RELOC_FRV_GOTTLSOFFLO,
+  BFD_RELOC_FRV_TLSOFF,
+  BFD_RELOC_FRV_TLSDESC_RELAX,
+  BFD_RELOC_FRV_GETTLSOFF_RELAX,
+  BFD_RELOC_FRV_TLSOFF_RELAX,
+  BFD_RELOC_FRV_TLSMOFF,
+
+
+/* This is a 24bit GOT-relative reloc for the mn10300.  */
+  BFD_RELOC_MN10300_GOTOFF24,
+
+/* This is a 32bit GOT-relative reloc for the mn10300, offset by two bytes
+in the instruction.  */
+  BFD_RELOC_MN10300_GOT32,
+
+/* This is a 24bit GOT-relative reloc for the mn10300, offset by two bytes
+in the instruction.  */
+  BFD_RELOC_MN10300_GOT24,
+
+/* This is a 16bit GOT-relative reloc for the mn10300, offset by two bytes
+in the instruction.  */
+  BFD_RELOC_MN10300_GOT16,
+
+/* Copy symbol at runtime.  */
+  BFD_RELOC_MN10300_COPY,
+
+/* Create GOT entry.  */
+  BFD_RELOC_MN10300_GLOB_DAT,
+
+/* Create PLT entry.  */
+  BFD_RELOC_MN10300_JMP_SLOT,
+
+/* Adjust by program base.  */
+  BFD_RELOC_MN10300_RELATIVE,
+
+
+/* i386/elf relocations  */
+  BFD_RELOC_386_GOT32,
+  BFD_RELOC_386_PLT32,
+  BFD_RELOC_386_COPY,
+  BFD_RELOC_386_GLOB_DAT,
+  BFD_RELOC_386_JUMP_SLOT,
+  BFD_RELOC_386_RELATIVE,
+  BFD_RELOC_386_GOTOFF,
+  BFD_RELOC_386_GOTPC,
+  BFD_RELOC_386_TLS_TPOFF,
+  BFD_RELOC_386_TLS_IE,
+  BFD_RELOC_386_TLS_GOTIE,
+  BFD_RELOC_386_TLS_LE,
+  BFD_RELOC_386_TLS_GD,
+  BFD_RELOC_386_TLS_LDM,
+  BFD_RELOC_386_TLS_LDO_32,
+  BFD_RELOC_386_TLS_IE_32,
+  BFD_RELOC_386_TLS_LE_32,
+  BFD_RELOC_386_TLS_DTPMOD32,
+  BFD_RELOC_386_TLS_DTPOFF32,
+  BFD_RELOC_386_TLS_TPOFF32,
+
+/* x86-64/elf relocations  */
+  BFD_RELOC_X86_64_GOT32,
+  BFD_RELOC_X86_64_PLT32,
+  BFD_RELOC_X86_64_COPY,
+  BFD_RELOC_X86_64_GLOB_DAT,
+  BFD_RELOC_X86_64_JUMP_SLOT,
+  BFD_RELOC_X86_64_RELATIVE,
+  BFD_RELOC_X86_64_GOTPCREL,
+  BFD_RELOC_X86_64_32S,
+  BFD_RELOC_X86_64_DTPMOD64,
+  BFD_RELOC_X86_64_DTPOFF64,
+  BFD_RELOC_X86_64_TPOFF64,
+  BFD_RELOC_X86_64_TLSGD,
+  BFD_RELOC_X86_64_TLSLD,
+  BFD_RELOC_X86_64_DTPOFF32,
+  BFD_RELOC_X86_64_GOTTPOFF,
+  BFD_RELOC_X86_64_TPOFF32,
+  BFD_RELOC_X86_64_GOTOFF64,
+  BFD_RELOC_X86_64_GOTPC32,
+  BFD_RELOC_X86_64_GOT64,
+  BFD_RELOC_X86_64_GOTPCREL64,
+  BFD_RELOC_X86_64_GOTPC64,
+  BFD_RELOC_X86_64_GOTPLT64,
+  BFD_RELOC_X86_64_PLTOFF64,
+
+/* ns32k relocations  */
+  BFD_RELOC_NS32K_IMM_8,
+  BFD_RELOC_NS32K_IMM_16,
+  BFD_RELOC_NS32K_IMM_32,
+  BFD_RELOC_NS32K_IMM_8_PCREL,
+  BFD_RELOC_NS32K_IMM_16_PCREL,
+  BFD_RELOC_NS32K_IMM_32_PCREL,
+  BFD_RELOC_NS32K_DISP_8,
+  BFD_RELOC_NS32K_DISP_16,
+  BFD_RELOC_NS32K_DISP_32,
+  BFD_RELOC_NS32K_DISP_8_PCREL,
+  BFD_RELOC_NS32K_DISP_16_PCREL,
+  BFD_RELOC_NS32K_DISP_32_PCREL,
+
+/* PDP11 relocations  */
+  BFD_RELOC_PDP11_DISP_8_PCREL,
+  BFD_RELOC_PDP11_DISP_6_PCREL,
+
+/* Picojava relocs.  Not all of these appear in object files.  */
+  BFD_RELOC_PJ_CODE_HI16,
+  BFD_RELOC_PJ_CODE_LO16,
+  BFD_RELOC_PJ_CODE_DIR16,
+  BFD_RELOC_PJ_CODE_DIR32,
+  BFD_RELOC_PJ_CODE_REL16,
+  BFD_RELOC_PJ_CODE_REL32,
+
+/* Power(rs6000) and PowerPC relocations.  */
+  BFD_RELOC_PPC_B26,
+  BFD_RELOC_PPC_BA26,
+  BFD_RELOC_PPC_TOC16,
+  BFD_RELOC_PPC_B16,
+  BFD_RELOC_PPC_B16_BRTAKEN,
+  BFD_RELOC_PPC_B16_BRNTAKEN,
+  BFD_RELOC_PPC_BA16,
+  BFD_RELOC_PPC_BA16_BRTAKEN,
+  BFD_RELOC_PPC_BA16_BRNTAKEN,
+  BFD_RELOC_PPC_COPY,
+  BFD_RELOC_PPC_GLOB_DAT,
+  BFD_RELOC_PPC_JMP_SLOT,
+  BFD_RELOC_PPC_RELATIVE,
+  BFD_RELOC_PPC_LOCAL24PC,
+  BFD_RELOC_PPC_EMB_NADDR32,
+  BFD_RELOC_PPC_EMB_NADDR16,
+  BFD_RELOC_PPC_EMB_NADDR16_LO,
+  BFD_RELOC_PPC_EMB_NADDR16_HI,
+  BFD_RELOC_PPC_EMB_NADDR16_HA,
+  BFD_RELOC_PPC_EMB_SDAI16,
+  BFD_RELOC_PPC_EMB_SDA2I16,
+  BFD_RELOC_PPC_EMB_SDA2REL,
+  BFD_RELOC_PPC_EMB_SDA21,
+  BFD_RELOC_PPC_EMB_MRKREF,
+  BFD_RELOC_PPC_EMB_RELSEC16,
+  BFD_RELOC_PPC_EMB_RELST_LO,
+  BFD_RELOC_PPC_EMB_RELST_HI,
+  BFD_RELOC_PPC_EMB_RELST_HA,
+  BFD_RELOC_PPC_EMB_BIT_FLD,
+  BFD_RELOC_PPC_EMB_RELSDA,
+  BFD_RELOC_PPC64_HIGHER,
+  BFD_RELOC_PPC64_HIGHER_S,
+  BFD_RELOC_PPC64_HIGHEST,
+  BFD_RELOC_PPC64_HIGHEST_S,
+  BFD_RELOC_PPC64_TOC16_LO,
+  BFD_RELOC_PPC64_TOC16_HI,
+  BFD_RELOC_PPC64_TOC16_HA,
+  BFD_RELOC_PPC64_TOC,
+  BFD_RELOC_PPC64_PLTGOT16,
+  BFD_RELOC_PPC64_PLTGOT16_LO,
+  BFD_RELOC_PPC64_PLTGOT16_HI,
+  BFD_RELOC_PPC64_PLTGOT16_HA,
+  BFD_RELOC_PPC64_ADDR16_DS,
+  BFD_RELOC_PPC64_ADDR16_LO_DS,
+  BFD_RELOC_PPC64_GOT16_DS,
+  BFD_RELOC_PPC64_GOT16_LO_DS,
+  BFD_RELOC_PPC64_PLT16_LO_DS,
+  BFD_RELOC_PPC64_SECTOFF_DS,
+  BFD_RELOC_PPC64_SECTOFF_LO_DS,
+  BFD_RELOC_PPC64_TOC16_DS,
+  BFD_RELOC_PPC64_TOC16_LO_DS,
+  BFD_RELOC_PPC64_PLTGOT16_DS,
+  BFD_RELOC_PPC64_PLTGOT16_LO_DS,
+
+/* PowerPC and PowerPC64 thread-local storage relocations.  */
+  BFD_RELOC_PPC_TLS,
+  BFD_RELOC_PPC_DTPMOD,
+  BFD_RELOC_PPC_TPREL16,
+  BFD_RELOC_PPC_TPREL16_LO,
+  BFD_RELOC_PPC_TPREL16_HI,
+  BFD_RELOC_PPC_TPREL16_HA,
+  BFD_RELOC_PPC_TPREL,
+  BFD_RELOC_PPC_DTPREL16,
+  BFD_RELOC_PPC_DTPREL16_LO,
+  BFD_RELOC_PPC_DTPREL16_HI,
+  BFD_RELOC_PPC_DTPREL16_HA,
+  BFD_RELOC_PPC_DTPREL,
+  BFD_RELOC_PPC_GOT_TLSGD16,
+  BFD_RELOC_PPC_GOT_TLSGD16_LO,
+  BFD_RELOC_PPC_GOT_TLSGD16_HI,
+  BFD_RELOC_PPC_GOT_TLSGD16_HA,
+  BFD_RELOC_PPC_GOT_TLSLD16,
+  BFD_RELOC_PPC_GOT_TLSLD16_LO,
+  BFD_RELOC_PPC_GOT_TLSLD16_HI,
+  BFD_RELOC_PPC_GOT_TLSLD16_HA,
+  BFD_RELOC_PPC_GOT_TPREL16,
+  BFD_RELOC_PPC_GOT_TPREL16_LO,
+  BFD_RELOC_PPC_GOT_TPREL16_HI,
+  BFD_RELOC_PPC_GOT_TPREL16_HA,
+  BFD_RELOC_PPC_GOT_DTPREL16,
+  BFD_RELOC_PPC_GOT_DTPREL16_LO,
+  BFD_RELOC_PPC_GOT_DTPREL16_HI,
+  BFD_RELOC_PPC_GOT_DTPREL16_HA,
+  BFD_RELOC_PPC64_TPREL16_DS,
+  BFD_RELOC_PPC64_TPREL16_LO_DS,
+  BFD_RELOC_PPC64_TPREL16_HIGHER,
+  BFD_RELOC_PPC64_TPREL16_HIGHERA,
+  BFD_RELOC_PPC64_TPREL16_HIGHEST,
+  BFD_RELOC_PPC64_TPREL16_HIGHESTA,
+  BFD_RELOC_PPC64_DTPREL16_DS,
+  BFD_RELOC_PPC64_DTPREL16_LO_DS,
+  BFD_RELOC_PPC64_DTPREL16_HIGHER,
+  BFD_RELOC_PPC64_DTPREL16_HIGHERA,
+  BFD_RELOC_PPC64_DTPREL16_HIGHEST,
+  BFD_RELOC_PPC64_DTPREL16_HIGHESTA,
+
+/* IBM 370/390 relocations  */
+  BFD_RELOC_I370_D12,
+
+/* The type of reloc used to build a constructor table - at the moment
+probably a 32 bit wide absolute relocation, but the target can choose.
+It generally does map to one of the other relocation types.  */
+  BFD_RELOC_CTOR,
+
+/* ARM 26 bit pc-relative branch.  The lowest two bits must be zero and are
+not stored in the instruction.  */
+  BFD_RELOC_ARM_PCREL_BRANCH,
+
+/* ARM 26 bit pc-relative branch.  The lowest bit must be zero and is
+not stored in the instruction.  The 2nd lowest bit comes from a 1 bit
+field in the instruction.  */
+  BFD_RELOC_ARM_PCREL_BLX,
+
+/* Thumb 22 bit pc-relative branch.  The lowest bit must be zero and is
+not stored in the instruction.  The 2nd lowest bit comes from a 1 bit
+field in the instruction.  */
+  BFD_RELOC_THUMB_PCREL_BLX,
+
+/* ARM 26-bit pc-relative branch for an unconditional BL or BLX instruction.  */
+  BFD_RELOC_ARM_PCREL_CALL,
+
+/* ARM 26-bit pc-relative branch for B or conditional BL instruction.  */
+  BFD_RELOC_ARM_PCREL_JUMP,
+
+/* Thumb 7-, 9-, 12-, 20-, 23-, and 25-bit pc-relative branches.
+The lowest bit must be zero and is not stored in the instruction.
+Note that the corresponding ELF R_ARM_THM_JUMPnn constant has an
+"nn" one smaller in all cases.  Note further that BRANCH23
+corresponds to R_ARM_THM_CALL.  */
+  BFD_RELOC_THUMB_PCREL_BRANCH7,
+  BFD_RELOC_THUMB_PCREL_BRANCH9,
+  BFD_RELOC_THUMB_PCREL_BRANCH12,
+  BFD_RELOC_THUMB_PCREL_BRANCH20,
+  BFD_RELOC_THUMB_PCREL_BRANCH23,
+  BFD_RELOC_THUMB_PCREL_BRANCH25,
+
+/* 12-bit immediate offset, used in ARM-format ldr and str instructions.  */
+  BFD_RELOC_ARM_OFFSET_IMM,
+
+/* 5-bit immediate offset, used in Thumb-format ldr and str instructions.  */
+  BFD_RELOC_ARM_THUMB_OFFSET,
+
+/* Pc-relative or absolute relocation depending on target.  Used for
+entries in .init_array sections.  */
+  BFD_RELOC_ARM_TARGET1,
+
+/* Read-only segment base relative address.  */
+  BFD_RELOC_ARM_ROSEGREL32,
+
+/* Data segment base relative address.  */
+  BFD_RELOC_ARM_SBREL32,
+
+/* This reloc is used for references to RTTI data from exception handling
+tables.  The actual definition depends on the target.  It may be a
+pc-relative or some form of GOT-indirect relocation.  */
+  BFD_RELOC_ARM_TARGET2,
+
+/* 31-bit PC relative address.  */
+  BFD_RELOC_ARM_PREL31,
+
+/* Relocations for setting up GOTs and PLTs for shared libraries.  */
+  BFD_RELOC_ARM_JUMP_SLOT,
+  BFD_RELOC_ARM_GLOB_DAT,
+  BFD_RELOC_ARM_GOT32,
+  BFD_RELOC_ARM_PLT32,
+  BFD_RELOC_ARM_RELATIVE,
+  BFD_RELOC_ARM_GOTOFF,
+  BFD_RELOC_ARM_GOTPC,
+
+/* ARM thread-local storage relocations.  */
+  BFD_RELOC_ARM_TLS_GD32,
+  BFD_RELOC_ARM_TLS_LDO32,
+  BFD_RELOC_ARM_TLS_LDM32,
+  BFD_RELOC_ARM_TLS_DTPOFF32,
+  BFD_RELOC_ARM_TLS_DTPMOD32,
+  BFD_RELOC_ARM_TLS_TPOFF32,
+  BFD_RELOC_ARM_TLS_IE32,
+  BFD_RELOC_ARM_TLS_LE32,
+
+/* These relocs are only used within the ARM assembler.  They are not
+(at present) written to any object files.  */
+  BFD_RELOC_ARM_IMMEDIATE,
+  BFD_RELOC_ARM_ADRL_IMMEDIATE,
+  BFD_RELOC_ARM_T32_IMMEDIATE,
+  BFD_RELOC_ARM_T32_IMM12,
+  BFD_RELOC_ARM_T32_ADD_PC12,
+  BFD_RELOC_ARM_SHIFT_IMM,
+  BFD_RELOC_ARM_SMC,
+  BFD_RELOC_ARM_SWI,
+  BFD_RELOC_ARM_MULTI,
+  BFD_RELOC_ARM_CP_OFF_IMM,
+  BFD_RELOC_ARM_CP_OFF_IMM_S2,
+  BFD_RELOC_ARM_T32_CP_OFF_IMM,
+  BFD_RELOC_ARM_T32_CP_OFF_IMM_S2,
+  BFD_RELOC_ARM_ADR_IMM,
+  BFD_RELOC_ARM_LDR_IMM,
+  BFD_RELOC_ARM_LITERAL,
+  BFD_RELOC_ARM_IN_POOL,
+  BFD_RELOC_ARM_OFFSET_IMM8,
+  BFD_RELOC_ARM_T32_OFFSET_U8,
+  BFD_RELOC_ARM_T32_OFFSET_IMM,
+  BFD_RELOC_ARM_HWLITERAL,
+  BFD_RELOC_ARM_THUMB_ADD,
+  BFD_RELOC_ARM_THUMB_IMM,
+  BFD_RELOC_ARM_THUMB_SHIFT,
+
+/* Renesas / SuperH SH relocs.  Not all of these appear in object files.  */
+  BFD_RELOC_SH_PCDISP8BY2,
+  BFD_RELOC_SH_PCDISP12BY2,
+  BFD_RELOC_SH_IMM3,
+  BFD_RELOC_SH_IMM3U,
+  BFD_RELOC_SH_DISP12,
+  BFD_RELOC_SH_DISP12BY2,
+  BFD_RELOC_SH_DISP12BY4,
+  BFD_RELOC_SH_DISP12BY8,
+  BFD_RELOC_SH_DISP20,
+  BFD_RELOC_SH_DISP20BY8,
+  BFD_RELOC_SH_IMM4,
+  BFD_RELOC_SH_IMM4BY2,
+  BFD_RELOC_SH_IMM4BY4,
+  BFD_RELOC_SH_IMM8,
+  BFD_RELOC_SH_IMM8BY2,
+  BFD_RELOC_SH_IMM8BY4,
+  BFD_RELOC_SH_PCRELIMM8BY2,
+  BFD_RELOC_SH_PCRELIMM8BY4,
+  BFD_RELOC_SH_SWITCH16,
+  BFD_RELOC_SH_SWITCH32,
+  BFD_RELOC_SH_USES,
+  BFD_RELOC_SH_COUNT,
+  BFD_RELOC_SH_ALIGN,
+  BFD_RELOC_SH_CODE,
+  BFD_RELOC_SH_DATA,
+  BFD_RELOC_SH_LABEL,
+  BFD_RELOC_SH_LOOP_START,
+  BFD_RELOC_SH_LOOP_END,
+  BFD_RELOC_SH_COPY,
+  BFD_RELOC_SH_GLOB_DAT,
+  BFD_RELOC_SH_JMP_SLOT,
+  BFD_RELOC_SH_RELATIVE,
+  BFD_RELOC_SH_GOTPC,
+  BFD_RELOC_SH_GOT_LOW16,
+  BFD_RELOC_SH_GOT_MEDLOW16,
+  BFD_RELOC_SH_GOT_MEDHI16,
+  BFD_RELOC_SH_GOT_HI16,
+  BFD_RELOC_SH_GOTPLT_LOW16,
+  BFD_RELOC_SH_GOTPLT_MEDLOW16,
+  BFD_RELOC_SH_GOTPLT_MEDHI16,
+  BFD_RELOC_SH_GOTPLT_HI16,
+  BFD_RELOC_SH_PLT_LOW16,
+  BFD_RELOC_SH_PLT_MEDLOW16,
+  BFD_RELOC_SH_PLT_MEDHI16,
+  BFD_RELOC_SH_PLT_HI16,
+  BFD_RELOC_SH_GOTOFF_LOW16,
+  BFD_RELOC_SH_GOTOFF_MEDLOW16,
+  BFD_RELOC_SH_GOTOFF_MEDHI16,
+  BFD_RELOC_SH_GOTOFF_HI16,
+  BFD_RELOC_SH_GOTPC_LOW16,
+  BFD_RELOC_SH_GOTPC_MEDLOW16,
+  BFD_RELOC_SH_GOTPC_MEDHI16,
+  BFD_RELOC_SH_GOTPC_HI16,
+  BFD_RELOC_SH_COPY64,
+  BFD_RELOC_SH_GLOB_DAT64,
+  BFD_RELOC_SH_JMP_SLOT64,
+  BFD_RELOC_SH_RELATIVE64,
+  BFD_RELOC_SH_GOT10BY4,
+  BFD_RELOC_SH_GOT10BY8,
+  BFD_RELOC_SH_GOTPLT10BY4,
+  BFD_RELOC_SH_GOTPLT10BY8,
+  BFD_RELOC_SH_GOTPLT32,
+  BFD_RELOC_SH_SHMEDIA_CODE,
+  BFD_RELOC_SH_IMMU5,
+  BFD_RELOC_SH_IMMS6,
+  BFD_RELOC_SH_IMMS6BY32,
+  BFD_RELOC_SH_IMMU6,
+  BFD_RELOC_SH_IMMS10,
+  BFD_RELOC_SH_IMMS10BY2,
+  BFD_RELOC_SH_IMMS10BY4,
+  BFD_RELOC_SH_IMMS10BY8,
+  BFD_RELOC_SH_IMMS16,
+  BFD_RELOC_SH_IMMU16,
+  BFD_RELOC_SH_IMM_LOW16,
+  BFD_RELOC_SH_IMM_LOW16_PCREL,
+  BFD_RELOC_SH_IMM_MEDLOW16,
+  BFD_RELOC_SH_IMM_MEDLOW16_PCREL,
+  BFD_RELOC_SH_IMM_MEDHI16,
+  BFD_RELOC_SH_IMM_MEDHI16_PCREL,
+  BFD_RELOC_SH_IMM_HI16,
+  BFD_RELOC_SH_IMM_HI16_PCREL,
+  BFD_RELOC_SH_PT_16,
+  BFD_RELOC_SH_TLS_GD_32,
+  BFD_RELOC_SH_TLS_LD_32,
+  BFD_RELOC_SH_TLS_LDO_32,
+  BFD_RELOC_SH_TLS_IE_32,
+  BFD_RELOC_SH_TLS_LE_32,
+  BFD_RELOC_SH_TLS_DTPMOD32,
+  BFD_RELOC_SH_TLS_DTPOFF32,
+  BFD_RELOC_SH_TLS_TPOFF32,
+
+/* ARC Cores relocs.
+ARC 22 bit pc-relative branch.  The lowest two bits must be zero and are
+not stored in the instruction.  The high 20 bits are installed in bits 26
+through 7 of the instruction.  */
+  BFD_RELOC_ARC_B22_PCREL,
+
+/* ARC 26 bit absolute branch.  The lowest two bits must be zero and are not
+stored in the instruction.  The high 24 bits are installed in bits 23
+through 0.  */
+  BFD_RELOC_ARC_B26,
+
+/* ADI Blackfin 16 bit immediate absolute reloc.  */
+  BFD_RELOC_BFIN_16_IMM,
+
+/* ADI Blackfin 16 bit immediate absolute reloc higher 16 bits.  */
+  BFD_RELOC_BFIN_16_HIGH,
+
+/* ADI Blackfin 'a' part of LSETUP.  */
+  BFD_RELOC_BFIN_4_PCREL,
+
+/* ADI Blackfin.  */
+  BFD_RELOC_BFIN_5_PCREL,
+
+/* ADI Blackfin 16 bit immediate absolute reloc lower 16 bits.  */
+  BFD_RELOC_BFIN_16_LOW,
+
+/* ADI Blackfin.  */
+  BFD_RELOC_BFIN_10_PCREL,
+
+/* ADI Blackfin 'b' part of LSETUP.  */
+  BFD_RELOC_BFIN_11_PCREL,
+
+/* ADI Blackfin.  */
+  BFD_RELOC_BFIN_12_PCREL_JUMP,
+
+/* ADI Blackfin Short jump, pcrel.  */
+  BFD_RELOC_BFIN_12_PCREL_JUMP_S,
+
+/* ADI Blackfin Call.x not implemented.  */
+  BFD_RELOC_BFIN_24_PCREL_CALL_X,
+
+/* ADI Blackfin Long Jump pcrel.  */
+  BFD_RELOC_BFIN_24_PCREL_JUMP_L,
+
+/* ADI Blackfin GOT relocation.  */
+  BFD_RELOC_BFIN_GOT,
+
+/* ADI Blackfin PLTPC relocation.  */
+  BFD_RELOC_BFIN_PLTPC,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_PUSH,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_CONST,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_ADD,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_SUB,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_MULT,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_DIV,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_MOD,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_LSHIFT,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_RSHIFT,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_AND,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_OR,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_XOR,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_LAND,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_LOR,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_LEN,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_NEG,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_COMP,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_PAGE,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_HWPAGE,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_ADDR,
+
+/* Mitsubishi D10V relocs.
+This is a 10-bit reloc with the right 2 bits
+assumed to be 0.  */
+  BFD_RELOC_D10V_10_PCREL_R,
+
+/* Mitsubishi D10V relocs.
+This is a 10-bit reloc with the right 2 bits
+assumed to be 0.  This is the same as the previous reloc
+except it is in the left container, i.e.,
+shifted left 15 bits.  */
+  BFD_RELOC_D10V_10_PCREL_L,
+
+/* This is an 18-bit reloc with the right 2 bits
+assumed to be 0.  */
+  BFD_RELOC_D10V_18,
+
+/* This is an 18-bit reloc with the right 2 bits
+assumed to be 0.  */
+  BFD_RELOC_D10V_18_PCREL,
+
+/* Mitsubishi D30V relocs.
+This is a 6-bit absolute reloc.  */
+  BFD_RELOC_D30V_6,
+
+/* This is a 6-bit pc-relative reloc with
+the right 3 bits assumed to be 0.  */
+  BFD_RELOC_D30V_9_PCREL,
+
+/* This is a 6-bit pc-relative reloc with
+the right 3 bits assumed to be 0. Same
+as the previous reloc but on the right side
+of the container.  */
+  BFD_RELOC_D30V_9_PCREL_R,
+
+/* This is a 12-bit absolute reloc with the
+right 3 bitsassumed to be 0.  */
+  BFD_RELOC_D30V_15,
+
+/* This is a 12-bit pc-relative reloc with
+the right 3 bits assumed to be 0.  */
+  BFD_RELOC_D30V_15_PCREL,
+
+/* This is a 12-bit pc-relative reloc with
+the right 3 bits assumed to be 0. Same
+as the previous reloc but on the right side
+of the container.  */
+  BFD_RELOC_D30V_15_PCREL_R,
+
+/* This is an 18-bit absolute reloc with
+the right 3 bits assumed to be 0.  */
+  BFD_RELOC_D30V_21,
+
+/* This is an 18-bit pc-relative reloc with
+the right 3 bits assumed to be 0.  */
+  BFD_RELOC_D30V_21_PCREL,
+
+/* This is an 18-bit pc-relative reloc with
+the right 3 bits assumed to be 0. Same
+as the previous reloc but on the right side
+of the container.  */
+  BFD_RELOC_D30V_21_PCREL_R,
+
+/* This is a 32-bit absolute reloc.  */
+  BFD_RELOC_D30V_32,
+
+/* This is a 32-bit pc-relative reloc.  */
+  BFD_RELOC_D30V_32_PCREL,
+
+/* DLX relocs  */
+  BFD_RELOC_DLX_HI16_S,
+
+/* DLX relocs  */
+  BFD_RELOC_DLX_LO16,
+
+/* DLX relocs  */
+  BFD_RELOC_DLX_JMP26,
+
+/* Renesas M16C/M32C Relocations.  */
+  BFD_RELOC_M32C_HI8,
+
+/* Renesas M32R (formerly Mitsubishi M32R) relocs.
+This is a 24 bit absolute address.  */
+  BFD_RELOC_M32R_24,
+
+/* This is a 10-bit pc-relative reloc with the right 2 bits assumed to be 0.  */
+  BFD_RELOC_M32R_10_PCREL,
+
+/* This is an 18-bit reloc with the right 2 bits assumed to be 0.  */
+  BFD_RELOC_M32R_18_PCREL,
+
+/* This is a 26-bit reloc with the right 2 bits assumed to be 0.  */
+  BFD_RELOC_M32R_26_PCREL,
+
+/* This is a 16-bit reloc containing the high 16 bits of an address
+used when the lower 16 bits are treated as unsigned.  */
+  BFD_RELOC_M32R_HI16_ULO,
+
+/* This is a 16-bit reloc containing the high 16 bits of an address
+used when the lower 16 bits are treated as signed.  */
+  BFD_RELOC_M32R_HI16_SLO,
+
+/* This is a 16-bit reloc containing the lower 16 bits of an address.  */
+  BFD_RELOC_M32R_LO16,
+
+/* This is a 16-bit reloc containing the small data area offset for use in
+add3, load, and store instructions.  */
+  BFD_RELOC_M32R_SDA16,
+
+/* For PIC.  */
+  BFD_RELOC_M32R_GOT24,
+  BFD_RELOC_M32R_26_PLTREL,
+  BFD_RELOC_M32R_COPY,
+  BFD_RELOC_M32R_GLOB_DAT,
+  BFD_RELOC_M32R_JMP_SLOT,
+  BFD_RELOC_M32R_RELATIVE,
+  BFD_RELOC_M32R_GOTOFF,
+  BFD_RELOC_M32R_GOTOFF_HI_ULO,
+  BFD_RELOC_M32R_GOTOFF_HI_SLO,
+  BFD_RELOC_M32R_GOTOFF_LO,
+  BFD_RELOC_M32R_GOTPC24,
+  BFD_RELOC_M32R_GOT16_HI_ULO,
+  BFD_RELOC_M32R_GOT16_HI_SLO,
+  BFD_RELOC_M32R_GOT16_LO,
+  BFD_RELOC_M32R_GOTPC_HI_ULO,
+  BFD_RELOC_M32R_GOTPC_HI_SLO,
+  BFD_RELOC_M32R_GOTPC_LO,
+
+/* This is a 9-bit reloc  */
+  BFD_RELOC_V850_9_PCREL,
+
+/* This is a 22-bit reloc  */
+  BFD_RELOC_V850_22_PCREL,
+
+/* This is a 16 bit offset from the short data area pointer.  */
+  BFD_RELOC_V850_SDA_16_16_OFFSET,
+
+/* This is a 16 bit offset (of which only 15 bits are used) from the
+short data area pointer.  */
+  BFD_RELOC_V850_SDA_15_16_OFFSET,
+
+/* This is a 16 bit offset from the zero data area pointer.  */
+  BFD_RELOC_V850_ZDA_16_16_OFFSET,
+
+/* This is a 16 bit offset (of which only 15 bits are used) from the
+zero data area pointer.  */
+  BFD_RELOC_V850_ZDA_15_16_OFFSET,
+
+/* This is an 8 bit offset (of which only 6 bits are used) from the
+tiny data area pointer.  */
+  BFD_RELOC_V850_TDA_6_8_OFFSET,
+
+/* This is an 8bit offset (of which only 7 bits are used) from the tiny
+data area pointer.  */
+  BFD_RELOC_V850_TDA_7_8_OFFSET,
+
+/* This is a 7 bit offset from the tiny data area pointer.  */
+  BFD_RELOC_V850_TDA_7_7_OFFSET,
+
+/* This is a 16 bit offset from the tiny data area pointer.  */
+  BFD_RELOC_V850_TDA_16_16_OFFSET,
+
+/* This is a 5 bit offset (of which only 4 bits are used) from the tiny
+data area pointer.  */
+  BFD_RELOC_V850_TDA_4_5_OFFSET,
+
+/* This is a 4 bit offset from the tiny data area pointer.  */
+  BFD_RELOC_V850_TDA_4_4_OFFSET,
+
+/* This is a 16 bit offset from the short data area pointer, with the
+bits placed non-contiguously in the instruction.  */
+  BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET,
+
+/* This is a 16 bit offset from the zero data area pointer, with the
+bits placed non-contiguously in the instruction.  */
+  BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET,
+
+/* This is a 6 bit offset from the call table base pointer.  */
+  BFD_RELOC_V850_CALLT_6_7_OFFSET,
+
+/* This is a 16 bit offset from the call table base pointer.  */
+  BFD_RELOC_V850_CALLT_16_16_OFFSET,
+
+/* Used for relaxing indirect function calls.  */
+  BFD_RELOC_V850_LONGCALL,
+
+/* Used for relaxing indirect jumps.  */
+  BFD_RELOC_V850_LONGJUMP,
+
+/* Used to maintain alignment whilst relaxing.  */
+  BFD_RELOC_V850_ALIGN,
+
+/* This is a variation of BFD_RELOC_LO16 that can be used in v850e ld.bu
+instructions.  */
+  BFD_RELOC_V850_LO16_SPLIT_OFFSET,
+
+/* This is a 32bit pcrel reloc for the mn10300, offset by two bytes in the
+instruction.  */
+  BFD_RELOC_MN10300_32_PCREL,
+
+/* This is a 16bit pcrel reloc for the mn10300, offset by two bytes in the
+instruction.  */
+  BFD_RELOC_MN10300_16_PCREL,
+
+/* This is a 8bit DP reloc for the tms320c30, where the most
+significant 8 bits of a 24 bit word are placed into the least
+significant 8 bits of the opcode.  */
+  BFD_RELOC_TIC30_LDP,
+
+/* This is a 7bit reloc for the tms320c54x, where the least
+significant 7 bits of a 16 bit word are placed into the least
+significant 7 bits of the opcode.  */
+  BFD_RELOC_TIC54X_PARTLS7,
+
+/* This is a 9bit DP reloc for the tms320c54x, where the most
+significant 9 bits of a 16 bit word are placed into the least
+significant 9 bits of the opcode.  */
+  BFD_RELOC_TIC54X_PARTMS9,
+
+/* This is an extended address 23-bit reloc for the tms320c54x.  */
+  BFD_RELOC_TIC54X_23,
+
+/* This is a 16-bit reloc for the tms320c54x, where the least
+significant 16 bits of a 23-bit extended address are placed into
+the opcode.  */
+  BFD_RELOC_TIC54X_16_OF_23,
+
+/* This is a reloc for the tms320c54x, where the most
+significant 7 bits of a 23-bit extended address are placed into
+the opcode.  */
+  BFD_RELOC_TIC54X_MS7_OF_23,
+
+/* This is a 48 bit reloc for the FR30 that stores 32 bits.  */
+  BFD_RELOC_FR30_48,
+
+/* This is a 32 bit reloc for the FR30 that stores 20 bits split up into
+two sections.  */
+  BFD_RELOC_FR30_20,
+
+/* This is a 16 bit reloc for the FR30 that stores a 6 bit word offset in
+4 bits.  */
+  BFD_RELOC_FR30_6_IN_4,
+
+/* This is a 16 bit reloc for the FR30 that stores an 8 bit byte offset
+into 8 bits.  */
+  BFD_RELOC_FR30_8_IN_8,
+
+/* This is a 16 bit reloc for the FR30 that stores a 9 bit short offset
+into 8 bits.  */
+  BFD_RELOC_FR30_9_IN_8,
+
+/* This is a 16 bit reloc for the FR30 that stores a 10 bit word offset
+into 8 bits.  */
+  BFD_RELOC_FR30_10_IN_8,
+
+/* This is a 16 bit reloc for the FR30 that stores a 9 bit pc relative
+short offset into 8 bits.  */
+  BFD_RELOC_FR30_9_PCREL,
+
+/* This is a 16 bit reloc for the FR30 that stores a 12 bit pc relative
+short offset into 11 bits.  */
+  BFD_RELOC_FR30_12_PCREL,
+
+/* Motorola Mcore relocations.  */
+  BFD_RELOC_MCORE_PCREL_IMM8BY4,
+  BFD_RELOC_MCORE_PCREL_IMM11BY2,
+  BFD_RELOC_MCORE_PCREL_IMM4BY2,
+  BFD_RELOC_MCORE_PCREL_32,
+  BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2,
+  BFD_RELOC_MCORE_RVA,
+
+/* These are relocations for the GETA instruction.  */
+  BFD_RELOC_MMIX_GETA,
+  BFD_RELOC_MMIX_GETA_1,
+  BFD_RELOC_MMIX_GETA_2,
+  BFD_RELOC_MMIX_GETA_3,
+
+/* These are relocations for a conditional branch instruction.  */
+  BFD_RELOC_MMIX_CBRANCH,
+  BFD_RELOC_MMIX_CBRANCH_J,
+  BFD_RELOC_MMIX_CBRANCH_1,
+  BFD_RELOC_MMIX_CBRANCH_2,
+  BFD_RELOC_MMIX_CBRANCH_3,
+
+/* These are relocations for the PUSHJ instruction.  */
+  BFD_RELOC_MMIX_PUSHJ,
+  BFD_RELOC_MMIX_PUSHJ_1,
+  BFD_RELOC_MMIX_PUSHJ_2,
+  BFD_RELOC_MMIX_PUSHJ_3,
+  BFD_RELOC_MMIX_PUSHJ_STUBBABLE,
+
+/* These are relocations for the JMP instruction.  */
+  BFD_RELOC_MMIX_JMP,
+  BFD_RELOC_MMIX_JMP_1,
+  BFD_RELOC_MMIX_JMP_2,
+  BFD_RELOC_MMIX_JMP_3,
+
+/* This is a relocation for a relative address as in a GETA instruction or
+a branch.  */
+  BFD_RELOC_MMIX_ADDR19,
+
+/* This is a relocation for a relative address as in a JMP instruction.  */
+  BFD_RELOC_MMIX_ADDR27,
+
+/* This is a relocation for an instruction field that may be a general
+register or a value 0..255.  */
+  BFD_RELOC_MMIX_REG_OR_BYTE,
+
+/* This is a relocation for an instruction field that may be a general
+register.  */
+  BFD_RELOC_MMIX_REG,
+
+/* This is a relocation for two instruction fields holding a register and
+an offset, the equivalent of the relocation.  */
+  BFD_RELOC_MMIX_BASE_PLUS_OFFSET,
+
+/* This relocation is an assertion that the expression is not allocated as
+a global register.  It does not modify contents.  */
+  BFD_RELOC_MMIX_LOCAL,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit pc relative
+short offset into 7 bits.  */
+  BFD_RELOC_AVR_7_PCREL,
+
+/* This is a 16 bit reloc for the AVR that stores 13 bit pc relative
+short offset into 12 bits.  */
+  BFD_RELOC_AVR_13_PCREL,
+
+/* This is a 16 bit reloc for the AVR that stores 17 bit value (usually
+program memory address) into 16 bits.  */
+  BFD_RELOC_AVR_16_PM,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (usually
+data memory address) into 8 bit immediate value of LDI insn.  */
+  BFD_RELOC_AVR_LO8_LDI,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (high 8 bit
+of data memory address) into 8 bit immediate value of LDI insn.  */
+  BFD_RELOC_AVR_HI8_LDI,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (most high 8 bit
+of program memory address) into 8 bit immediate value of LDI insn.  */
+  BFD_RELOC_AVR_HH8_LDI,
+
+/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
+(usually data memory address) into 8 bit immediate value of SUBI insn.  */
+  BFD_RELOC_AVR_LO8_LDI_NEG,
+
+/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
+(high 8 bit of data memory address) into 8 bit immediate value of
+SUBI insn.  */
+  BFD_RELOC_AVR_HI8_LDI_NEG,
+
+/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
+(most high 8 bit of program memory address) into 8 bit immediate value
+of LDI or SUBI insn.  */
+  BFD_RELOC_AVR_HH8_LDI_NEG,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (usually
+command address) into 8 bit immediate value of LDI insn.  */
+  BFD_RELOC_AVR_LO8_LDI_PM,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (high 8 bit
+of command address) into 8 bit immediate value of LDI insn.  */
+  BFD_RELOC_AVR_HI8_LDI_PM,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (most high 8 bit
+of command address) into 8 bit immediate value of LDI insn.  */
+  BFD_RELOC_AVR_HH8_LDI_PM,
+
+/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
+(usually command address) into 8 bit immediate value of SUBI insn.  */
+  BFD_RELOC_AVR_LO8_LDI_PM_NEG,
+
+/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
+(high 8 bit of 16 bit command address) into 8 bit immediate value
+of SUBI insn.  */
+  BFD_RELOC_AVR_HI8_LDI_PM_NEG,
+
+/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
+(high 6 bit of 22 bit command address) into 8 bit immediate
+value of SUBI insn.  */
+  BFD_RELOC_AVR_HH8_LDI_PM_NEG,
+
+/* This is a 32 bit reloc for the AVR that stores 23 bit value
+into 22 bits.  */
+  BFD_RELOC_AVR_CALL,
+
+/* This is a 16 bit reloc for the AVR that stores all needed bits
+for absolute addressing with ldi with overflow check to linktime  */
+  BFD_RELOC_AVR_LDI,
+
+/* This is a 6 bit reloc for the AVR that stores offset for ldd/std
+instructions  */
+  BFD_RELOC_AVR_6,
+
+/* This is a 6 bit reloc for the AVR that stores offset for adiw/sbiw
+instructions  */
+  BFD_RELOC_AVR_6_ADIW,
+
+/* Direct 12 bit.  */
+  BFD_RELOC_390_12,
+
+/* 12 bit GOT offset.  */
+  BFD_RELOC_390_GOT12,
+
+/* 32 bit PC relative PLT address.  */
+  BFD_RELOC_390_PLT32,
+
+/* Copy symbol at runtime.  */
+  BFD_RELOC_390_COPY,
+
+/* Create GOT entry.  */
+  BFD_RELOC_390_GLOB_DAT,
+
+/* Create PLT entry.  */
+  BFD_RELOC_390_JMP_SLOT,
+
+/* Adjust by program base.  */
+  BFD_RELOC_390_RELATIVE,
+
+/* 32 bit PC relative offset to GOT.  */
+  BFD_RELOC_390_GOTPC,
+
+/* 16 bit GOT offset.  */
+  BFD_RELOC_390_GOT16,
+
+/* PC relative 16 bit shifted by 1.  */
+  BFD_RELOC_390_PC16DBL,
+
+/* 16 bit PC rel. PLT shifted by 1.  */
+  BFD_RELOC_390_PLT16DBL,
+
+/* PC relative 32 bit shifted by 1.  */
+  BFD_RELOC_390_PC32DBL,
+
+/* 32 bit PC rel. PLT shifted by 1.  */
+  BFD_RELOC_390_PLT32DBL,
+
+/* 32 bit PC rel. GOT shifted by 1.  */
+  BFD_RELOC_390_GOTPCDBL,
+
+/* 64 bit GOT offset.  */
+  BFD_RELOC_390_GOT64,
+
+/* 64 bit PC relative PLT address.  */
+  BFD_RELOC_390_PLT64,
+
+/* 32 bit rel. offset to GOT entry.  */
+  BFD_RELOC_390_GOTENT,
+
+/* 64 bit offset to GOT.  */
+  BFD_RELOC_390_GOTOFF64,
+
+/* 12-bit offset to symbol-entry within GOT, with PLT handling.  */
+  BFD_RELOC_390_GOTPLT12,
+
+/* 16-bit offset to symbol-entry within GOT, with PLT handling.  */
+  BFD_RELOC_390_GOTPLT16,
+
+/* 32-bit offset to symbol-entry within GOT, with PLT handling.  */
+  BFD_RELOC_390_GOTPLT32,
+
+/* 64-bit offset to symbol-entry within GOT, with PLT handling.  */
+  BFD_RELOC_390_GOTPLT64,
+
+/* 32-bit rel. offset to symbol-entry within GOT, with PLT handling.  */
+  BFD_RELOC_390_GOTPLTENT,
+
+/* 16-bit rel. offset from the GOT to a PLT entry.  */
+  BFD_RELOC_390_PLTOFF16,
+
+/* 32-bit rel. offset from the GOT to a PLT entry.  */
+  BFD_RELOC_390_PLTOFF32,
+
+/* 64-bit rel. offset from the GOT to a PLT entry.  */
+  BFD_RELOC_390_PLTOFF64,
+
+/* s390 tls relocations.  */
+  BFD_RELOC_390_TLS_LOAD,
+  BFD_RELOC_390_TLS_GDCALL,
+  BFD_RELOC_390_TLS_LDCALL,
+  BFD_RELOC_390_TLS_GD32,
+  BFD_RELOC_390_TLS_GD64,
+  BFD_RELOC_390_TLS_GOTIE12,
+  BFD_RELOC_390_TLS_GOTIE32,
+  BFD_RELOC_390_TLS_GOTIE64,
+  BFD_RELOC_390_TLS_LDM32,
+  BFD_RELOC_390_TLS_LDM64,
+  BFD_RELOC_390_TLS_IE32,
+  BFD_RELOC_390_TLS_IE64,
+  BFD_RELOC_390_TLS_IEENT,
+  BFD_RELOC_390_TLS_LE32,
+  BFD_RELOC_390_TLS_LE64,
+  BFD_RELOC_390_TLS_LDO32,
+  BFD_RELOC_390_TLS_LDO64,
+  BFD_RELOC_390_TLS_DTPMOD,
+  BFD_RELOC_390_TLS_DTPOFF,
+  BFD_RELOC_390_TLS_TPOFF,
+
+/* Long displacement extension.  */
+  BFD_RELOC_390_20,
+  BFD_RELOC_390_GOT20,
+  BFD_RELOC_390_GOTPLT20,
+  BFD_RELOC_390_TLS_GOTIE20,
+
+/* Scenix IP2K - 9-bit register number / data address  */
+  BFD_RELOC_IP2K_FR9,
+
+/* Scenix IP2K - 4-bit register/data bank number  */
+  BFD_RELOC_IP2K_BANK,
+
+/* Scenix IP2K - low 13 bits of instruction word address  */
+  BFD_RELOC_IP2K_ADDR16CJP,
+
+/* Scenix IP2K - high 3 bits of instruction word address  */
+  BFD_RELOC_IP2K_PAGE3,
+
+/* Scenix IP2K - ext/low/high 8 bits of data address  */
+  BFD_RELOC_IP2K_LO8DATA,
+  BFD_RELOC_IP2K_HI8DATA,
+  BFD_RELOC_IP2K_EX8DATA,
+
+/* Scenix IP2K - low/high 8 bits of instruction word address  */
+  BFD_RELOC_IP2K_LO8INSN,
+  BFD_RELOC_IP2K_HI8INSN,
+
+/* Scenix IP2K - even/odd PC modifier to modify snb pcl.0  */
+  BFD_RELOC_IP2K_PC_SKIP,
+
+/* Scenix IP2K - 16 bit word address in text section.  */
+  BFD_RELOC_IP2K_TEXT,
+
+/* Scenix IP2K - 7-bit sp or dp offset  */
+  BFD_RELOC_IP2K_FR_OFFSET,
+
+/* Scenix VPE4K coprocessor - data/insn-space addressing  */
+  BFD_RELOC_VPE4KMATH_DATA,
+  BFD_RELOC_VPE4KMATH_INSN,
+
+/* These two relocations are used by the linker to determine which of
+the entries in a C++ virtual function table are actually used.  When
+the --gc-sections option is given, the linker will zero out the entries
+that are not used, so that the code for those functions need not be
+included in the output.
+
+VTABLE_INHERIT is a zero-space relocation used to describe to the
+linker the inheritance tree of a C++ virtual function table.  The
+relocation's symbol should be the parent class' vtable, and the
+relocation should be located at the child vtable.
+
+VTABLE_ENTRY is a zero-space relocation that describes the use of a
+virtual function table entry.  The reloc's symbol should refer to the
+table of the class mentioned in the code.  Off of that base, an offset
+describes the entry that is being used.  For Rela hosts, this offset
+is stored in the reloc's addend.  For Rel hosts, we are forced to put
+this offset in the reloc's section offset.  */
+  BFD_RELOC_VTABLE_INHERIT,
+  BFD_RELOC_VTABLE_ENTRY,
+
+/* Intel IA64 Relocations.  */
+  BFD_RELOC_IA64_IMM14,
+  BFD_RELOC_IA64_IMM22,
+  BFD_RELOC_IA64_IMM64,
+  BFD_RELOC_IA64_DIR32MSB,
+  BFD_RELOC_IA64_DIR32LSB,
+  BFD_RELOC_IA64_DIR64MSB,
+  BFD_RELOC_IA64_DIR64LSB,
+  BFD_RELOC_IA64_GPREL22,
+  BFD_RELOC_IA64_GPREL64I,
+  BFD_RELOC_IA64_GPREL32MSB,
+  BFD_RELOC_IA64_GPREL32LSB,
+  BFD_RELOC_IA64_GPREL64MSB,
+  BFD_RELOC_IA64_GPREL64LSB,
+  BFD_RELOC_IA64_LTOFF22,
+  BFD_RELOC_IA64_LTOFF64I,
+  BFD_RELOC_IA64_PLTOFF22,
+  BFD_RELOC_IA64_PLTOFF64I,
+  BFD_RELOC_IA64_PLTOFF64MSB,
+  BFD_RELOC_IA64_PLTOFF64LSB,
+  BFD_RELOC_IA64_FPTR64I,
+  BFD_RELOC_IA64_FPTR32MSB,
+  BFD_RELOC_IA64_FPTR32LSB,
+  BFD_RELOC_IA64_FPTR64MSB,
+  BFD_RELOC_IA64_FPTR64LSB,
+  BFD_RELOC_IA64_PCREL21B,
+  BFD_RELOC_IA64_PCREL21BI,
+  BFD_RELOC_IA64_PCREL21M,
+  BFD_RELOC_IA64_PCREL21F,
+  BFD_RELOC_IA64_PCREL22,
+  BFD_RELOC_IA64_PCREL60B,
+  BFD_RELOC_IA64_PCREL64I,
+  BFD_RELOC_IA64_PCREL32MSB,
+  BFD_RELOC_IA64_PCREL32LSB,
+  BFD_RELOC_IA64_PCREL64MSB,
+  BFD_RELOC_IA64_PCREL64LSB,
+  BFD_RELOC_IA64_LTOFF_FPTR22,
+  BFD_RELOC_IA64_LTOFF_FPTR64I,
+  BFD_RELOC_IA64_LTOFF_FPTR32MSB,
+  BFD_RELOC_IA64_LTOFF_FPTR32LSB,
+  BFD_RELOC_IA64_LTOFF_FPTR64MSB,
+  BFD_RELOC_IA64_LTOFF_FPTR64LSB,
+  BFD_RELOC_IA64_SEGREL32MSB,
+  BFD_RELOC_IA64_SEGREL32LSB,
+  BFD_RELOC_IA64_SEGREL64MSB,
+  BFD_RELOC_IA64_SEGREL64LSB,
+  BFD_RELOC_IA64_SECREL32MSB,
+  BFD_RELOC_IA64_SECREL32LSB,
+  BFD_RELOC_IA64_SECREL64MSB,
+  BFD_RELOC_IA64_SECREL64LSB,
+  BFD_RELOC_IA64_REL32MSB,
+  BFD_RELOC_IA64_REL32LSB,
+  BFD_RELOC_IA64_REL64MSB,
+  BFD_RELOC_IA64_REL64LSB,
+  BFD_RELOC_IA64_LTV32MSB,
+  BFD_RELOC_IA64_LTV32LSB,
+  BFD_RELOC_IA64_LTV64MSB,
+  BFD_RELOC_IA64_LTV64LSB,
+  BFD_RELOC_IA64_IPLTMSB,
+  BFD_RELOC_IA64_IPLTLSB,
+  BFD_RELOC_IA64_COPY,
+  BFD_RELOC_IA64_LTOFF22X,
+  BFD_RELOC_IA64_LDXMOV,
+  BFD_RELOC_IA64_TPREL14,
+  BFD_RELOC_IA64_TPREL22,
+  BFD_RELOC_IA64_TPREL64I,
+  BFD_RELOC_IA64_TPREL64MSB,
+  BFD_RELOC_IA64_TPREL64LSB,
+  BFD_RELOC_IA64_LTOFF_TPREL22,
+  BFD_RELOC_IA64_DTPMOD64MSB,
+  BFD_RELOC_IA64_DTPMOD64LSB,
+  BFD_RELOC_IA64_LTOFF_DTPMOD22,
+  BFD_RELOC_IA64_DTPREL14,
+  BFD_RELOC_IA64_DTPREL22,
+  BFD_RELOC_IA64_DTPREL64I,
+  BFD_RELOC_IA64_DTPREL32MSB,
+  BFD_RELOC_IA64_DTPREL32LSB,
+  BFD_RELOC_IA64_DTPREL64MSB,
+  BFD_RELOC_IA64_DTPREL64LSB,
+  BFD_RELOC_IA64_LTOFF_DTPREL22,
+
+/* Motorola 68HC11 reloc.
+This is the 8 bit high part of an absolute address.  */
+  BFD_RELOC_M68HC11_HI8,
+
+/* Motorola 68HC11 reloc.
+This is the 8 bit low part of an absolute address.  */
+  BFD_RELOC_M68HC11_LO8,
+
+/* Motorola 68HC11 reloc.
+This is the 3 bit of a value.  */
+  BFD_RELOC_M68HC11_3B,
+
+/* Motorola 68HC11 reloc.
+This reloc marks the beginning of a jump/call instruction.
+It is used for linker relaxation to correctly identify beginning
+of instruction and change some branches to use PC-relative
+addressing mode.  */
+  BFD_RELOC_M68HC11_RL_JUMP,
+
+/* Motorola 68HC11 reloc.
+This reloc marks a group of several instructions that gcc generates
+and for which the linker relaxation pass can modify and/or remove
+some of them.  */
+  BFD_RELOC_M68HC11_RL_GROUP,
+
+/* Motorola 68HC11 reloc.
+This is the 16-bit lower part of an address.  It is used for 'call'
+instruction to specify the symbol address without any special
+transformation (due to memory bank window).  */
+  BFD_RELOC_M68HC11_LO16,
+
+/* Motorola 68HC11 reloc.
+This is a 8-bit reloc that specifies the page number of an address.
+It is used by 'call' instruction to specify the page number of
+the symbol.  */
+  BFD_RELOC_M68HC11_PAGE,
+
+/* Motorola 68HC11 reloc.
+This is a 24-bit reloc that represents the address with a 16-bit
+value and a 8-bit page number.  The symbol address is transformed
+to follow the 16K memory bank of 68HC12 (seen as mapped in the window).  */
+  BFD_RELOC_M68HC11_24,
+
+/* Motorola 68HC12 reloc.
+This is the 5 bits of a value.  */
+  BFD_RELOC_M68HC12_5B,
+
+/* NS CR16C Relocations.  */
+  BFD_RELOC_16C_NUM08,
+  BFD_RELOC_16C_NUM08_C,
+  BFD_RELOC_16C_NUM16,
+  BFD_RELOC_16C_NUM16_C,
+  BFD_RELOC_16C_NUM32,
+  BFD_RELOC_16C_NUM32_C,
+  BFD_RELOC_16C_DISP04,
+  BFD_RELOC_16C_DISP04_C,
+  BFD_RELOC_16C_DISP08,
+  BFD_RELOC_16C_DISP08_C,
+  BFD_RELOC_16C_DISP16,
+  BFD_RELOC_16C_DISP16_C,
+  BFD_RELOC_16C_DISP24,
+  BFD_RELOC_16C_DISP24_C,
+  BFD_RELOC_16C_DISP24a,
+  BFD_RELOC_16C_DISP24a_C,
+  BFD_RELOC_16C_REG04,
+  BFD_RELOC_16C_REG04_C,
+  BFD_RELOC_16C_REG04a,
+  BFD_RELOC_16C_REG04a_C,
+  BFD_RELOC_16C_REG14,
+  BFD_RELOC_16C_REG14_C,
+  BFD_RELOC_16C_REG16,
+  BFD_RELOC_16C_REG16_C,
+  BFD_RELOC_16C_REG20,
+  BFD_RELOC_16C_REG20_C,
+  BFD_RELOC_16C_ABS20,
+  BFD_RELOC_16C_ABS20_C,
+  BFD_RELOC_16C_ABS24,
+  BFD_RELOC_16C_ABS24_C,
+  BFD_RELOC_16C_IMM04,
+  BFD_RELOC_16C_IMM04_C,
+  BFD_RELOC_16C_IMM16,
+  BFD_RELOC_16C_IMM16_C,
+  BFD_RELOC_16C_IMM20,
+  BFD_RELOC_16C_IMM20_C,
+  BFD_RELOC_16C_IMM24,
+  BFD_RELOC_16C_IMM24_C,
+  BFD_RELOC_16C_IMM32,
+  BFD_RELOC_16C_IMM32_C,
+
+/* NS CRX Relocations.  */
+  BFD_RELOC_CRX_REL4,
+  BFD_RELOC_CRX_REL8,
+  BFD_RELOC_CRX_REL8_CMP,
+  BFD_RELOC_CRX_REL16,
+  BFD_RELOC_CRX_REL24,
+  BFD_RELOC_CRX_REL32,
+  BFD_RELOC_CRX_REGREL12,
+  BFD_RELOC_CRX_REGREL22,
+  BFD_RELOC_CRX_REGREL28,
+  BFD_RELOC_CRX_REGREL32,
+  BFD_RELOC_CRX_ABS16,
+  BFD_RELOC_CRX_ABS32,
+  BFD_RELOC_CRX_NUM8,
+  BFD_RELOC_CRX_NUM16,
+  BFD_RELOC_CRX_NUM32,
+  BFD_RELOC_CRX_IMM16,
+  BFD_RELOC_CRX_IMM32,
+  BFD_RELOC_CRX_SWITCH8,
+  BFD_RELOC_CRX_SWITCH16,
+  BFD_RELOC_CRX_SWITCH32,
+
+/* These relocs are only used within the CRIS assembler.  They are not
+(at present) written to any object files.  */
+  BFD_RELOC_CRIS_BDISP8,
+  BFD_RELOC_CRIS_UNSIGNED_5,
+  BFD_RELOC_CRIS_SIGNED_6,
+  BFD_RELOC_CRIS_UNSIGNED_6,
+  BFD_RELOC_CRIS_SIGNED_8,
+  BFD_RELOC_CRIS_UNSIGNED_8,
+  BFD_RELOC_CRIS_SIGNED_16,
+  BFD_RELOC_CRIS_UNSIGNED_16,
+  BFD_RELOC_CRIS_LAPCQ_OFFSET,
+  BFD_RELOC_CRIS_UNSIGNED_4,
+
+/* Relocs used in ELF shared libraries for CRIS.  */
+  BFD_RELOC_CRIS_COPY,
+  BFD_RELOC_CRIS_GLOB_DAT,
+  BFD_RELOC_CRIS_JUMP_SLOT,
+  BFD_RELOC_CRIS_RELATIVE,
+
+/* 32-bit offset to symbol-entry within GOT.  */
+  BFD_RELOC_CRIS_32_GOT,
+
+/* 16-bit offset to symbol-entry within GOT.  */
+  BFD_RELOC_CRIS_16_GOT,
+
+/* 32-bit offset to symbol-entry within GOT, with PLT handling.  */
+  BFD_RELOC_CRIS_32_GOTPLT,
+
+/* 16-bit offset to symbol-entry within GOT, with PLT handling.  */
+  BFD_RELOC_CRIS_16_GOTPLT,
+
+/* 32-bit offset to symbol, relative to GOT.  */
+  BFD_RELOC_CRIS_32_GOTREL,
+
+/* 32-bit offset to symbol with PLT entry, relative to GOT.  */
+  BFD_RELOC_CRIS_32_PLT_GOTREL,
+
+/* 32-bit offset to symbol with PLT entry, relative to this relocation.  */
+  BFD_RELOC_CRIS_32_PLT_PCREL,
+
+/* Intel i860 Relocations.  */
+  BFD_RELOC_860_COPY,
+  BFD_RELOC_860_GLOB_DAT,
+  BFD_RELOC_860_JUMP_SLOT,
+  BFD_RELOC_860_RELATIVE,
+  BFD_RELOC_860_PC26,
+  BFD_RELOC_860_PLT26,
+  BFD_RELOC_860_PC16,
+  BFD_RELOC_860_LOW0,
+  BFD_RELOC_860_SPLIT0,
+  BFD_RELOC_860_LOW1,
+  BFD_RELOC_860_SPLIT1,
+  BFD_RELOC_860_LOW2,
+  BFD_RELOC_860_SPLIT2,
+  BFD_RELOC_860_LOW3,
+  BFD_RELOC_860_LOGOT0,
+  BFD_RELOC_860_SPGOT0,
+  BFD_RELOC_860_LOGOT1,
+  BFD_RELOC_860_SPGOT1,
+  BFD_RELOC_860_LOGOTOFF0,
+  BFD_RELOC_860_SPGOTOFF0,
+  BFD_RELOC_860_LOGOTOFF1,
+  BFD_RELOC_860_SPGOTOFF1,
+  BFD_RELOC_860_LOGOTOFF2,
+  BFD_RELOC_860_LOGOTOFF3,
+  BFD_RELOC_860_LOPC,
+  BFD_RELOC_860_HIGHADJ,
+  BFD_RELOC_860_HAGOT,
+  BFD_RELOC_860_HAGOTOFF,
+  BFD_RELOC_860_HAPC,
+  BFD_RELOC_860_HIGH,
+  BFD_RELOC_860_HIGOT,
+  BFD_RELOC_860_HIGOTOFF,
+
+/* OpenRISC Relocations.  */
+  BFD_RELOC_OPENRISC_ABS_26,
+  BFD_RELOC_OPENRISC_REL_26,
+
+/* H8 elf Relocations.  */
+  BFD_RELOC_H8_DIR16A8,
+  BFD_RELOC_H8_DIR16R8,
+  BFD_RELOC_H8_DIR24A8,
+  BFD_RELOC_H8_DIR24R8,
+  BFD_RELOC_H8_DIR32A16,
+
+/* Sony Xstormy16 Relocations.  */
+  BFD_RELOC_XSTORMY16_REL_12,
+  BFD_RELOC_XSTORMY16_12,
+  BFD_RELOC_XSTORMY16_24,
+  BFD_RELOC_XSTORMY16_FPTR16,
+
+/* Relocations used by VAX ELF.  */
+  BFD_RELOC_VAX_GLOB_DAT,
+  BFD_RELOC_VAX_JMP_SLOT,
+  BFD_RELOC_VAX_RELATIVE,
+
+/* Morpho MT - 16 bit immediate relocation.  */
+  BFD_RELOC_MT_PC16,
+
+/* Morpho MT - Hi 16 bits of an address.  */
+  BFD_RELOC_MT_HI16,
+
+/* Morpho MT - Low 16 bits of an address.  */
+  BFD_RELOC_MT_LO16,
+
+/* Morpho MT - Used to tell the linker which vtable entries are used.  */
+  BFD_RELOC_MT_GNU_VTINHERIT,
+
+/* Morpho MT - Used to tell the linker which vtable entries are used.  */
+  BFD_RELOC_MT_GNU_VTENTRY,
+
+/* Morpho MT - 8 bit immediate relocation.  */
+  BFD_RELOC_MT_PCINSN8,
+
+/* msp430 specific relocation codes  */
+  BFD_RELOC_MSP430_10_PCREL,
+  BFD_RELOC_MSP430_16_PCREL,
+  BFD_RELOC_MSP430_16,
+  BFD_RELOC_MSP430_16_PCREL_BYTE,
+  BFD_RELOC_MSP430_16_BYTE,
+  BFD_RELOC_MSP430_2X_PCREL,
+  BFD_RELOC_MSP430_RL_PCREL,
+
+/* IQ2000 Relocations.  */
+  BFD_RELOC_IQ2000_OFFSET_16,
+  BFD_RELOC_IQ2000_OFFSET_21,
+  BFD_RELOC_IQ2000_UHI16,
+
+/* Special Xtensa relocation used only by PLT entries in ELF shared
+objects to indicate that the runtime linker should set the value
+to one of its own internal functions or data structures.  */
+  BFD_RELOC_XTENSA_RTLD,
+
+/* Xtensa relocations for ELF shared objects.  */
+  BFD_RELOC_XTENSA_GLOB_DAT,
+  BFD_RELOC_XTENSA_JMP_SLOT,
+  BFD_RELOC_XTENSA_RELATIVE,
+
+/* Xtensa relocation used in ELF object files for symbols that may require
+PLT entries.  Otherwise, this is just a generic 32-bit relocation.  */
+  BFD_RELOC_XTENSA_PLT,
+
+/* Xtensa relocations to mark the difference of two local symbols.
+These are only needed to support linker relaxation and can be ignored
+when not relaxing.  The field is set to the value of the difference
+assuming no relaxation.  The relocation encodes the position of the
+first symbol so the linker can determine whether to adjust the field
+value.  */
+  BFD_RELOC_XTENSA_DIFF8,
+  BFD_RELOC_XTENSA_DIFF16,
+  BFD_RELOC_XTENSA_DIFF32,
+
+/* Generic Xtensa relocations for instruction operands.  Only the slot
+number is encoded in the relocation.  The relocation applies to the
+last PC-relative immediate operand, or if there are no PC-relative
+immediates, to the last immediate operand.  */
+  BFD_RELOC_XTENSA_SLOT0_OP,
+  BFD_RELOC_XTENSA_SLOT1_OP,
+  BFD_RELOC_XTENSA_SLOT2_OP,
+  BFD_RELOC_XTENSA_SLOT3_OP,
+  BFD_RELOC_XTENSA_SLOT4_OP,
+  BFD_RELOC_XTENSA_SLOT5_OP,
+  BFD_RELOC_XTENSA_SLOT6_OP,
+  BFD_RELOC_XTENSA_SLOT7_OP,
+  BFD_RELOC_XTENSA_SLOT8_OP,
+  BFD_RELOC_XTENSA_SLOT9_OP,
+  BFD_RELOC_XTENSA_SLOT10_OP,
+  BFD_RELOC_XTENSA_SLOT11_OP,
+  BFD_RELOC_XTENSA_SLOT12_OP,
+  BFD_RELOC_XTENSA_SLOT13_OP,
+  BFD_RELOC_XTENSA_SLOT14_OP,
+
+/* Alternate Xtensa relocations.  Only the slot is encoded in the
+relocation.  The meaning of these relocations is opcode-specific.  */
+  BFD_RELOC_XTENSA_SLOT0_ALT,
+  BFD_RELOC_XTENSA_SLOT1_ALT,
+  BFD_RELOC_XTENSA_SLOT2_ALT,
+  BFD_RELOC_XTENSA_SLOT3_ALT,
+  BFD_RELOC_XTENSA_SLOT4_ALT,
+  BFD_RELOC_XTENSA_SLOT5_ALT,
+  BFD_RELOC_XTENSA_SLOT6_ALT,
+  BFD_RELOC_XTENSA_SLOT7_ALT,
+  BFD_RELOC_XTENSA_SLOT8_ALT,
+  BFD_RELOC_XTENSA_SLOT9_ALT,
+  BFD_RELOC_XTENSA_SLOT10_ALT,
+  BFD_RELOC_XTENSA_SLOT11_ALT,
+  BFD_RELOC_XTENSA_SLOT12_ALT,
+  BFD_RELOC_XTENSA_SLOT13_ALT,
+  BFD_RELOC_XTENSA_SLOT14_ALT,
+
+/* Xtensa relocations for backward compatibility.  These have all been
+replaced by BFD_RELOC_XTENSA_SLOT0_OP.  */
+  BFD_RELOC_XTENSA_OP0,
+  BFD_RELOC_XTENSA_OP1,
+  BFD_RELOC_XTENSA_OP2,
+
+/* Xtensa relocation to mark that the assembler expanded the
+instructions from an original target.  The expansion size is
+encoded in the reloc size.  */
+  BFD_RELOC_XTENSA_ASM_EXPAND,
+
+/* Xtensa relocation to mark that the linker should simplify
+assembler-expanded instructions.  This is commonly used
+internally by the linker after analysis of a
+BFD_RELOC_XTENSA_ASM_EXPAND.  */
+  BFD_RELOC_XTENSA_ASM_SIMPLIFY,
+
+/* 8 bit signed offset in (ix+d) or (iy+d).  */
+  BFD_RELOC_Z80_DISP8,
+
+/* DJNZ offset.  */
+  BFD_RELOC_Z8K_DISP7,
+
+/* CALR offset.  */
+  BFD_RELOC_Z8K_CALLR,
+
+/* 4 bit value.  */
+  BFD_RELOC_Z8K_IMM4L,
+  BFD_RELOC_UNUSED };
+typedef enum bfd_reloc_code_real bfd_reloc_code_real_type;
+reloc_howto_type *bfd_reloc_type_lookup
+   (bfd *abfd, bfd_reloc_code_real_type code);
+
+const char *bfd_get_reloc_code_name (bfd_reloc_code_real_type code);
+
+/* Extracted from syms.c.  */
+
+typedef struct bfd_symbol
+{
+  /* A pointer to the BFD which owns the symbol. This information
+     is necessary so that a back end can work out what additional
+     information (invisible to the application writer) is carried
+     with the symbol.
+
+     This field is *almost* redundant, since you can use section->owner
+     instead, except that some symbols point to the global sections
+     bfd_{abs,com,und}_section.  This could be fixed by making
+     these globals be per-bfd (or per-target-flavor).  FIXME.  */
+  struct bfd *the_bfd; /* Use bfd_asymbol_bfd(sym) to access this field.  */
+
+  /* The text of the symbol. The name is left alone, and not copied; the
+     application may not alter it.  */
+  const char *name;
+
+  /* The value of the symbol.  This really should be a union of a
+     numeric value with a pointer, since some flags indicate that
+     a pointer to another symbol is stored here.  */
+  symvalue value;
+
+  /* Attributes of a symbol.  */
+#define BSF_NO_FLAGS    0x00
+
+  /* The symbol has local scope; <<static>> in <<C>>. The value
+     is the offset into the section of the data.  */
+#define BSF_LOCAL      0x01
+
+  /* The symbol has global scope; initialized data in <<C>>. The
+     value is the offset into the section of the data.  */
+#define BSF_GLOBAL     0x02
+
+  /* The symbol has global scope and is exported. The value is
+     the offset into the section of the data.  */
+#define BSF_EXPORT     BSF_GLOBAL /* No real difference.  */
+
+  /* A normal C symbol would be one of:
+     <<BSF_LOCAL>>, <<BSF_FORT_COMM>>,  <<BSF_UNDEFINED>> or
+     <<BSF_GLOBAL>>.  */
+
+  /* The symbol is a debugging record. The value has an arbitrary
+     meaning, unless BSF_DEBUGGING_RELOC is also set.  */
+#define BSF_DEBUGGING  0x08
+
+  /* The symbol denotes a function entry point.  Used in ELF,
+     perhaps others someday.  */
+#define BSF_FUNCTION    0x10
+
+  /* Used by the linker.  */
+#define BSF_KEEP        0x20
+#define BSF_KEEP_G      0x40
+
+  /* A weak global symbol, overridable without warnings by
+     a regular global symbol of the same name.  */
+#define BSF_WEAK        0x80
+
+  /* This symbol was created to point to a section, e.g. ELF's
+     STT_SECTION symbols.  */
+#define BSF_SECTION_SYM 0x100
+
+  /* The symbol used to be a common symbol, but now it is
+     allocated.  */
+#define BSF_OLD_COMMON  0x200
+
+  /* The default value for common data.  */
+#define BFD_FORT_COMM_DEFAULT_VALUE 0
+
+  /* In some files the type of a symbol sometimes alters its
+     location in an output file - ie in coff a <<ISFCN>> symbol
+     which is also <<C_EXT>> symbol appears where it was
+     declared and not at the end of a section.  This bit is set
+     by the target BFD part to convey this information.  */
+#define BSF_NOT_AT_END    0x400
+
+  /* Signal that the symbol is the label of constructor section.  */
+#define BSF_CONSTRUCTOR   0x800
+
+  /* Signal that the symbol is a warning symbol.  The name is a
+     warning.  The name of the next symbol is the one to warn about;
+     if a reference is made to a symbol with the same name as the next
+     symbol, a warning is issued by the linker.  */
+#define BSF_WARNING       0x1000
+
+  /* Signal that the symbol is indirect.  This symbol is an indirect
+     pointer to the symbol with the same name as the next symbol.  */
+#define BSF_INDIRECT      0x2000
+
+  /* BSF_FILE marks symbols that contain a file name.  This is used
+     for ELF STT_FILE symbols.  */
+#define BSF_FILE          0x4000
+
+  /* Symbol is from dynamic linking information.  */
+#define BSF_DYNAMIC       0x8000
+
+  /* The symbol denotes a data object.  Used in ELF, and perhaps
+     others someday.  */
+#define BSF_OBJECT        0x10000
+
+  /* This symbol is a debugging symbol.  The value is the offset
+     into the section of the data.  BSF_DEBUGGING should be set
+     as well.  */
+#define BSF_DEBUGGING_RELOC 0x20000
+
+  /* This symbol is thread local.  Used in ELF.  */
+#define BSF_THREAD_LOCAL  0x40000
+
+  flagword flags;
+
+  /* A pointer to the section to which this symbol is
+     relative.  This will always be non NULL, there are special
+     sections for undefined and absolute symbols.  */
+  struct bfd_section *section;
+
+  /* Back end special data.  */
+  union
+    {
+      void *p;
+      bfd_vma i;
+    }
+  udata;
+}
+asymbol;
+
+#define bfd_get_symtab_upper_bound(abfd) \
+     BFD_SEND (abfd, _bfd_get_symtab_upper_bound, (abfd))
+
+bfd_boolean bfd_is_local_label (bfd *abfd, asymbol *sym);
+
+bfd_boolean bfd_is_local_label_name (bfd *abfd, const char *name);
+
+#define bfd_is_local_label_name(abfd, name) \
+  BFD_SEND (abfd, _bfd_is_local_label_name, (abfd, name))
+
+bfd_boolean bfd_is_target_special_symbol (bfd *abfd, asymbol *sym);
+
+#define bfd_is_target_special_symbol(abfd, sym) \
+  BFD_SEND (abfd, _bfd_is_target_special_symbol, (abfd, sym))
+
+#define bfd_canonicalize_symtab(abfd, location) \
+  BFD_SEND (abfd, _bfd_canonicalize_symtab, (abfd, location))
+
+bfd_boolean bfd_set_symtab
+   (bfd *abfd, asymbol **location, unsigned int count);
+
+void bfd_print_symbol_vandf (bfd *abfd, void *file, asymbol *symbol);
+
+#define bfd_make_empty_symbol(abfd) \
+  BFD_SEND (abfd, _bfd_make_empty_symbol, (abfd))
+
+asymbol *_bfd_generic_make_empty_symbol (bfd *);
+
+#define bfd_make_debug_symbol(abfd,ptr,size) \
+  BFD_SEND (abfd, _bfd_make_debug_symbol, (abfd, ptr, size))
+
+int bfd_decode_symclass (asymbol *symbol);
+
+bfd_boolean bfd_is_undefined_symclass (int symclass);
+
+void bfd_symbol_info (asymbol *symbol, symbol_info *ret);
+
+bfd_boolean bfd_copy_private_symbol_data
+   (bfd *ibfd, asymbol *isym, bfd *obfd, asymbol *osym);
+
+#define bfd_copy_private_symbol_data(ibfd, isymbol, obfd, osymbol) \
+  BFD_SEND (obfd, _bfd_copy_private_symbol_data, \
+            (ibfd, isymbol, obfd, osymbol))
+
+/* Extracted from bfd.c.  */
+struct bfd
+{
+  /* A unique identifier of the BFD  */
+  unsigned int id;
+
+  /* The filename the application opened the BFD with.  */
+  const char *filename;
+
+  /* A pointer to the target jump table.  */
+  const struct bfd_target *xvec;
+
+  /* The IOSTREAM, and corresponding IO vector that provide access
+     to the file backing the BFD.  */
+  void *iostream;
+  const struct bfd_iovec *iovec;
+
+  /* Is the file descriptor being cached?  That is, can it be closed as
+     needed, and re-opened when accessed later?  */
+  bfd_boolean cacheable;
+
+  /* Marks whether there was a default target specified when the
+     BFD was opened. This is used to select which matching algorithm
+     to use to choose the back end.  */
+  bfd_boolean target_defaulted;
+
+  /* The caching routines use these to maintain a
+     least-recently-used list of BFDs.  */
+  struct bfd *lru_prev, *lru_next;
+
+  /* When a file is closed by the caching routines, BFD retains
+     state information on the file here...  */
+  ufile_ptr where;
+
+  /* ... and here: (``once'' means at least once).  */
+  bfd_boolean opened_once;
+
+  /* Set if we have a locally maintained mtime value, rather than
+     getting it from the file each time.  */
+  bfd_boolean mtime_set;
+
+  /* File modified time, if mtime_set is TRUE.  */
+  long mtime;
+
+  /* Reserved for an unimplemented file locking extension.  */
+  int ifd;
+
+  /* The format which belongs to the BFD. (object, core, etc.)  */
+  bfd_format format;
+
+  /* The direction with which the BFD was opened.  */
+  enum bfd_direction
+    {
+      no_direction = 0,
+      read_direction = 1,
+      write_direction = 2,
+      both_direction = 3
+    }
+  direction;
+
+  /* Format_specific flags.  */
+  flagword flags;
+
+  /* Currently my_archive is tested before adding origin to
+     anything. I believe that this can become always an add of
+     origin, with origin set to 0 for non archive files.  */
+  ufile_ptr origin;
+
+  /* Remember when output has begun, to stop strange things
+     from happening.  */
+  bfd_boolean output_has_begun;
+
+  /* A hash table for section names.  */
+  struct bfd_hash_table section_htab;
+
+  /* Pointer to linked list of sections.  */
+  struct bfd_section *sections;
+
+  /* The last section on the section list.  */
+  struct bfd_section *section_last;
+
+  /* The number of sections.  */
+  unsigned int section_count;
+
+  /* Stuff only useful for object files:
+     The start address.  */
+  bfd_vma start_address;
+
+  /* Used for input and output.  */
+  unsigned int symcount;
+
+  /* Symbol table for output BFD (with symcount entries).  */
+  struct bfd_symbol  **outsymbols;
+
+  /* Used for slurped dynamic symbol tables.  */
+  unsigned int dynsymcount;
+
+  /* Pointer to structure which contains architecture information.  */
+  const struct bfd_arch_info *arch_info;
+
+  /* Flag set if symbols from this BFD should not be exported.  */
+  bfd_boolean no_export;
+
+  /* Stuff only useful for archives.  */
+  void *arelt_data;
+  struct bfd *my_archive;      /* The containing archive BFD.  */
+  struct bfd *next;            /* The next BFD in the archive.  */
+  struct bfd *archive_head;    /* The first BFD in the archive.  */
+  bfd_boolean has_armap;
+
+  /* A chain of BFD structures involved in a link.  */
+  struct bfd *link_next;
+
+  /* A field used by _bfd_generic_link_add_archive_symbols.  This will
+     be used only for archive elements.  */
+  int archive_pass;
+
+  /* Used by the back end to hold private data.  */
+  union
+    {
+      struct aout_data_struct *aout_data;
+      struct artdata *aout_ar_data;
+      struct _oasys_data *oasys_obj_data;
+      struct _oasys_ar_data *oasys_ar_data;
+      struct coff_tdata *coff_obj_data;
+      struct pe_tdata *pe_obj_data;
+      struct xcoff_tdata *xcoff_obj_data;
+      struct ecoff_tdata *ecoff_obj_data;
+      struct ieee_data_struct *ieee_data;
+      struct ieee_ar_data_struct *ieee_ar_data;
+      struct srec_data_struct *srec_data;
+      struct ihex_data_struct *ihex_data;
+      struct tekhex_data_struct *tekhex_data;
+      struct elf_obj_tdata *elf_obj_data;
+      struct nlm_obj_tdata *nlm_obj_data;
+      struct bout_data_struct *bout_data;
+      struct mmo_data_struct *mmo_data;
+      struct sun_core_struct *sun_core_data;
+      struct sco5_core_struct *sco5_core_data;
+      struct trad_core_struct *trad_core_data;
+      struct som_data_struct *som_data;
+      struct hpux_core_struct *hpux_core_data;
+      struct hppabsd_core_struct *hppabsd_core_data;
+      struct sgi_core_struct *sgi_core_data;
+      struct lynx_core_struct *lynx_core_data;
+      struct osf_core_struct *osf_core_data;
+      struct cisco_core_struct *cisco_core_data;
+      struct versados_data_struct *versados_data;
+      struct netbsd_core_struct *netbsd_core_data;
+      struct mach_o_data_struct *mach_o_data;
+      struct mach_o_fat_data_struct *mach_o_fat_data;
+      struct bfd_pef_data_struct *pef_data;
+      struct bfd_pef_xlib_data_struct *pef_xlib_data;
+      struct bfd_sym_data_struct *sym_data;
+      void *any;
+    }
+  tdata;
+
+  /* Used by the application to hold private data.  */
+  void *usrdata;
+
+  /* Where all the allocated stuff under this BFD goes.  This is a
+     struct objalloc *, but we use void * to avoid requiring the inclusion
+     of objalloc.h.  */
+  void *memory;
+};
+
+typedef enum bfd_error
+{
+  bfd_error_no_error = 0,
+  bfd_error_system_call,
+  bfd_error_invalid_target,
+  bfd_error_wrong_format,
+  bfd_error_wrong_object_format,
+  bfd_error_invalid_operation,
+  bfd_error_no_memory,
+  bfd_error_no_symbols,
+  bfd_error_no_armap,
+  bfd_error_no_more_archived_files,
+  bfd_error_malformed_archive,
+  bfd_error_file_not_recognized,
+  bfd_error_file_ambiguously_recognized,
+  bfd_error_no_contents,
+  bfd_error_nonrepresentable_section,
+  bfd_error_no_debug_section,
+  bfd_error_bad_value,
+  bfd_error_file_truncated,
+  bfd_error_file_too_big,
+  bfd_error_invalid_error_code
+}
+bfd_error_type;
+
+bfd_error_type bfd_get_error (void);
+
+void bfd_set_error (bfd_error_type error_tag);
+
+const char *bfd_errmsg (bfd_error_type error_tag);
+
+void bfd_perror (const char *message);
+
+typedef void (*bfd_error_handler_type) (const char *, ...);
+
+bfd_error_handler_type bfd_set_error_handler (bfd_error_handler_type);
+
+void bfd_set_error_program_name (const char *);
+
+bfd_error_handler_type bfd_get_error_handler (void);
+
+long bfd_get_reloc_upper_bound (bfd *abfd, asection *sect);
+
+long bfd_canonicalize_reloc
+   (bfd *abfd, asection *sec, arelent **loc, asymbol **syms);
+
+void bfd_set_reloc
+   (bfd *abfd, asection *sec, arelent **rel, unsigned int count);
+
+bfd_boolean bfd_set_file_flags (bfd *abfd, flagword flags);
+
+int bfd_get_arch_size (bfd *abfd);
+
+int bfd_get_sign_extend_vma (bfd *abfd);
+
+bfd_boolean bfd_set_start_address (bfd *abfd, bfd_vma vma);
+
+unsigned int bfd_get_gp_size (bfd *abfd);
+
+void bfd_set_gp_size (bfd *abfd, unsigned int i);
+
+bfd_vma bfd_scan_vma (const char *string, const char **end, int base);
+
+bfd_boolean bfd_copy_private_header_data (bfd *ibfd, bfd *obfd);
+
+#define bfd_copy_private_header_data(ibfd, obfd) \
+     BFD_SEND (obfd, _bfd_copy_private_header_data, \
+               (ibfd, obfd))
+bfd_boolean bfd_copy_private_bfd_data (bfd *ibfd, bfd *obfd);
+
+#define bfd_copy_private_bfd_data(ibfd, obfd) \
+     BFD_SEND (obfd, _bfd_copy_private_bfd_data, \
+               (ibfd, obfd))
+bfd_boolean bfd_merge_private_bfd_data (bfd *ibfd, bfd *obfd);
+
+#define bfd_merge_private_bfd_data(ibfd, obfd) \
+     BFD_SEND (obfd, _bfd_merge_private_bfd_data, \
+               (ibfd, obfd))
+bfd_boolean bfd_set_private_flags (bfd *abfd, flagword flags);
+
+#define bfd_set_private_flags(abfd, flags) \
+     BFD_SEND (abfd, _bfd_set_private_flags, (abfd, flags))
+#define bfd_sizeof_headers(abfd, reloc) \
+       BFD_SEND (abfd, _bfd_sizeof_headers, (abfd, reloc))
+
+#define bfd_find_nearest_line(abfd, sec, syms, off, file, func, line) \
+       BFD_SEND (abfd, _bfd_find_nearest_line, \
+                 (abfd, sec, syms, off, file, func, line))
+
+#define bfd_find_line(abfd, syms, sym, file, line) \
+       BFD_SEND (abfd, _bfd_find_line, \
+                 (abfd, syms, sym, file, line))
+
+#define bfd_find_inliner_info(abfd, file, func, line) \
+       BFD_SEND (abfd, _bfd_find_inliner_info, \
+                 (abfd, file, func, line))
+
+#define bfd_debug_info_start(abfd) \
+       BFD_SEND (abfd, _bfd_debug_info_start, (abfd))
+
+#define bfd_debug_info_end(abfd) \
+       BFD_SEND (abfd, _bfd_debug_info_end, (abfd))
+
+#define bfd_debug_info_accumulate(abfd, section) \
+       BFD_SEND (abfd, _bfd_debug_info_accumulate, (abfd, section))
+
+#define bfd_stat_arch_elt(abfd, stat) \
+       BFD_SEND (abfd, _bfd_stat_arch_elt,(abfd, stat))
+
+#define bfd_update_armap_timestamp(abfd) \
+       BFD_SEND (abfd, _bfd_update_armap_timestamp, (abfd))
+
+#define bfd_set_arch_mach(abfd, arch, mach)\
+       BFD_SEND ( abfd, _bfd_set_arch_mach, (abfd, arch, mach))
+
+#define bfd_relax_section(abfd, section, link_info, again) \
+       BFD_SEND (abfd, _bfd_relax_section, (abfd, section, link_info, again))
+
+#define bfd_gc_sections(abfd, link_info) \
+       BFD_SEND (abfd, _bfd_gc_sections, (abfd, link_info))
+
+#define bfd_merge_sections(abfd, link_info) \
+       BFD_SEND (abfd, _bfd_merge_sections, (abfd, link_info))
+
+#define bfd_is_group_section(abfd, sec) \
+       BFD_SEND (abfd, _bfd_is_group_section, (abfd, sec))
+
+#define bfd_discard_group(abfd, sec) \
+       BFD_SEND (abfd, _bfd_discard_group, (abfd, sec))
+
+#define bfd_link_hash_table_create(abfd) \
+       BFD_SEND (abfd, _bfd_link_hash_table_create, (abfd))
+
+#define bfd_link_hash_table_free(abfd, hash) \
+       BFD_SEND (abfd, _bfd_link_hash_table_free, (hash))
+
+#define bfd_link_add_symbols(abfd, info) \
+       BFD_SEND (abfd, _bfd_link_add_symbols, (abfd, info))
+
+#define bfd_link_just_syms(abfd, sec, info) \
+       BFD_SEND (abfd, _bfd_link_just_syms, (sec, info))
+
+#define bfd_final_link(abfd, info) \
+       BFD_SEND (abfd, _bfd_final_link, (abfd, info))
+
+#define bfd_free_cached_info(abfd) \
+       BFD_SEND (abfd, _bfd_free_cached_info, (abfd))
+
+#define bfd_get_dynamic_symtab_upper_bound(abfd) \
+       BFD_SEND (abfd, _bfd_get_dynamic_symtab_upper_bound, (abfd))
+
+#define bfd_print_private_bfd_data(abfd, file)\
+       BFD_SEND (abfd, _bfd_print_private_bfd_data, (abfd, file))
+
+#define bfd_canonicalize_dynamic_symtab(abfd, asymbols) \
+       BFD_SEND (abfd, _bfd_canonicalize_dynamic_symtab, (abfd, asymbols))
+
+#define bfd_get_synthetic_symtab(abfd, count, syms, dyncount, dynsyms, ret) \
+       BFD_SEND (abfd, _bfd_get_synthetic_symtab, (abfd, count, syms, \
+                                                   dyncount, dynsyms, ret))
+
+#define bfd_get_dynamic_reloc_upper_bound(abfd) \
+       BFD_SEND (abfd, _bfd_get_dynamic_reloc_upper_bound, (abfd))
+
+#define bfd_canonicalize_dynamic_reloc(abfd, arels, asyms) \
+       BFD_SEND (abfd, _bfd_canonicalize_dynamic_reloc, (abfd, arels, asyms))
+
+extern bfd_byte *bfd_get_relocated_section_contents
+  (bfd *, struct bfd_link_info *, struct bfd_link_order *, bfd_byte *,
+   bfd_boolean, asymbol **);
+
+bfd_boolean bfd_alt_mach_code (bfd *abfd, int alternative);
+
+struct bfd_preserve
+{
+  void *marker;
+  void *tdata;
+  flagword flags;
+  const struct bfd_arch_info *arch_info;
+  struct bfd_section *sections;
+  struct bfd_section *section_last;
+  unsigned int section_count;
+  struct bfd_hash_table section_htab;
+};
+
+bfd_boolean bfd_preserve_save (bfd *, struct bfd_preserve *);
+
+void bfd_preserve_restore (bfd *, struct bfd_preserve *);
+
+void bfd_preserve_finish (bfd *, struct bfd_preserve *);
+
+/* Extracted from archive.c.  */
+symindex bfd_get_next_mapent
+   (bfd *abfd, symindex previous, carsym **sym);
+
+bfd_boolean bfd_set_archive_head (bfd *output, bfd *new_head);
+
+bfd *bfd_openr_next_archived_file (bfd *archive, bfd *previous);
+
+/* Extracted from corefile.c.  */
+const char *bfd_core_file_failing_command (bfd *abfd);
+
+int bfd_core_file_failing_signal (bfd *abfd);
+
+bfd_boolean core_file_matches_executable_p
+   (bfd *core_bfd, bfd *exec_bfd);
+
+/* Extracted from targets.c.  */
+#define BFD_SEND(bfd, message, arglist) \
+  ((*((bfd)->xvec->message)) arglist)
+
+#ifdef DEBUG_BFD_SEND
+#undef BFD_SEND
+#define BFD_SEND(bfd, message, arglist) \
+  (((bfd) && (bfd)->xvec && (bfd)->xvec->message) ? \
+    ((*((bfd)->xvec->message)) arglist) : \
+    (bfd_assert (__FILE__,__LINE__), NULL))
+#endif
+#define BFD_SEND_FMT(bfd, message, arglist) \
+  (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist)
+
+#ifdef DEBUG_BFD_SEND
+#undef BFD_SEND_FMT
+#define BFD_SEND_FMT(bfd, message, arglist) \
+  (((bfd) && (bfd)->xvec && (bfd)->xvec->message) ? \
+   (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist) : \
+   (bfd_assert (__FILE__,__LINE__), NULL))
+#endif
+
+enum bfd_flavour
+{
+  bfd_target_unknown_flavour,
+  bfd_target_aout_flavour,
+  bfd_target_coff_flavour,
+  bfd_target_ecoff_flavour,
+  bfd_target_xcoff_flavour,
+  bfd_target_elf_flavour,
+  bfd_target_ieee_flavour,
+  bfd_target_nlm_flavour,
+  bfd_target_oasys_flavour,
+  bfd_target_tekhex_flavour,
+  bfd_target_srec_flavour,
+  bfd_target_ihex_flavour,
+  bfd_target_som_flavour,
+  bfd_target_os9k_flavour,
+  bfd_target_versados_flavour,
+  bfd_target_msdos_flavour,
+  bfd_target_ovax_flavour,
+  bfd_target_evax_flavour,
+  bfd_target_mmo_flavour,
+  bfd_target_mach_o_flavour,
+  bfd_target_pef_flavour,
+  bfd_target_pef_xlib_flavour,
+  bfd_target_sym_flavour
+};
+
+enum bfd_endian { BFD_ENDIAN_BIG, BFD_ENDIAN_LITTLE, BFD_ENDIAN_UNKNOWN };
+
+/* Forward declaration.  */
+typedef struct bfd_link_info _bfd_link_info;
+
+typedef struct bfd_target
+{
+  /* Identifies the kind of target, e.g., SunOS4, Ultrix, etc.  */
+  char *name;
+
+ /* The "flavour" of a back end is a general indication about
+    the contents of a file.  */
+  enum bfd_flavour flavour;
+
+  /* The order of bytes within the data area of a file.  */
+  enum bfd_endian byteorder;
+
+ /* The order of bytes within the header parts of a file.  */
+  enum bfd_endian header_byteorder;
+
+  /* A mask of all the flags which an executable may have set -
+     from the set <<BFD_NO_FLAGS>>, <<HAS_RELOC>>, ...<<D_PAGED>>.  */
+  flagword object_flags;
+
+ /* A mask of all the flags which a section may have set - from
+    the set <<SEC_NO_FLAGS>>, <<SEC_ALLOC>>, ...<<SET_NEVER_LOAD>>.  */
+  flagword section_flags;
+
+ /* The character normally found at the front of a symbol.
+    (if any), perhaps `_'.  */
+  char symbol_leading_char;
+
+ /* The pad character for file names within an archive header.  */
+  char ar_pad_char;
+
+  /* The maximum number of characters in an archive header.  */
+  unsigned short ar_max_namelen;
+
+  /* Entries for byte swapping for data. These are different from the
+     other entry points, since they don't take a BFD as the first argument.
+     Certain other handlers could do the same.  */
+  bfd_uint64_t   (*bfd_getx64) (const void *);
+  bfd_int64_t    (*bfd_getx_signed_64) (const void *);
+  void           (*bfd_putx64) (bfd_uint64_t, void *);
+  bfd_vma        (*bfd_getx32) (const void *);
+  bfd_signed_vma (*bfd_getx_signed_32) (const void *);
+  void           (*bfd_putx32) (bfd_vma, void *);
+  bfd_vma        (*bfd_getx16) (const void *);
+  bfd_signed_vma (*bfd_getx_signed_16) (const void *);
+  void           (*bfd_putx16) (bfd_vma, void *);
+
+  /* Byte swapping for the headers.  */
+  bfd_uint64_t   (*bfd_h_getx64) (const void *);
+  bfd_int64_t    (*bfd_h_getx_signed_64) (const void *);
+  void           (*bfd_h_putx64) (bfd_uint64_t, void *);
+  bfd_vma        (*bfd_h_getx32) (const void *);
+  bfd_signed_vma (*bfd_h_getx_signed_32) (const void *);
+  void           (*bfd_h_putx32) (bfd_vma, void *);
+  bfd_vma        (*bfd_h_getx16) (const void *);
+  bfd_signed_vma (*bfd_h_getx_signed_16) (const void *);
+  void           (*bfd_h_putx16) (bfd_vma, void *);
+
+  /* Format dependent routines: these are vectors of entry points
+     within the target vector structure, one for each format to check.  */
+
+  /* Check the format of a file being read.  Return a <<bfd_target *>> or zero.  */
+  const struct bfd_target *(*_bfd_check_format[bfd_type_end]) (bfd *);
+
+  /* Set the format of a file being written.  */
+  bfd_boolean (*_bfd_set_format[bfd_type_end]) (bfd *);
+
+  /* Write cached information into a file being written, at <<bfd_close>>.  */
+  bfd_boolean (*_bfd_write_contents[bfd_type_end]) (bfd *);
+
+
+  /* Generic entry points.  */
+#define BFD_JUMP_TABLE_GENERIC(NAME) \
+  NAME##_close_and_cleanup, \
+  NAME##_bfd_free_cached_info, \
+  NAME##_new_section_hook, \
+  NAME##_get_section_contents, \
+  NAME##_get_section_contents_in_window
+
+  /* Called when the BFD is being closed to do any necessary cleanup.  */
+  bfd_boolean (*_close_and_cleanup) (bfd *);
+  /* Ask the BFD to free all cached information.  */
+  bfd_boolean (*_bfd_free_cached_info) (bfd *);
+  /* Called when a new section is created.  */
+  bfd_boolean (*_new_section_hook) (bfd *, sec_ptr);
+  /* Read the contents of a section.  */
+  bfd_boolean (*_bfd_get_section_contents)
+    (bfd *, sec_ptr, void *, file_ptr, bfd_size_type);
+  bfd_boolean (*_bfd_get_section_contents_in_window)
+    (bfd *, sec_ptr, bfd_window *, file_ptr, bfd_size_type);
+
+  /* Entry points to copy private data.  */
+#define BFD_JUMP_TABLE_COPY(NAME) \
+  NAME##_bfd_copy_private_bfd_data, \
+  NAME##_bfd_merge_private_bfd_data, \
+  _bfd_generic_init_private_section_data, \
+  NAME##_bfd_copy_private_section_data, \
+  NAME##_bfd_copy_private_symbol_data, \
+  NAME##_bfd_copy_private_header_data, \
+  NAME##_bfd_set_private_flags, \
+  NAME##_bfd_print_private_bfd_data
+
+  /* Called to copy BFD general private data from one object file
+     to another.  */
+  bfd_boolean (*_bfd_copy_private_bfd_data) (bfd *, bfd *);
+  /* Called to merge BFD general private data from one object file
+     to a common output file when linking.  */
+  bfd_boolean (*_bfd_merge_private_bfd_data) (bfd *, bfd *);
+  /* Called to initialize BFD private section data from one object file
+     to another.  */
+#define bfd_init_private_section_data(ibfd, isec, obfd, osec, link_info) \
+  BFD_SEND (obfd, _bfd_init_private_section_data, (ibfd, isec, obfd, osec, link_info))
+  bfd_boolean (*_bfd_init_private_section_data)
+    (bfd *, sec_ptr, bfd *, sec_ptr, struct bfd_link_info *);
+  /* Called to copy BFD private section data from one object file
+     to another.  */
+  bfd_boolean (*_bfd_copy_private_section_data)
+    (bfd *, sec_ptr, bfd *, sec_ptr);
+  /* Called to copy BFD private symbol data from one symbol
+     to another.  */
+  bfd_boolean (*_bfd_copy_private_symbol_data)
+    (bfd *, asymbol *, bfd *, asymbol *);
+  /* Called to copy BFD private header data from one object file
+     to another.  */
+  bfd_boolean (*_bfd_copy_private_header_data)
+    (bfd *, bfd *);
+  /* Called to set private backend flags.  */
+  bfd_boolean (*_bfd_set_private_flags) (bfd *, flagword);
+
+  /* Called to print private BFD data.  */
+  bfd_boolean (*_bfd_print_private_bfd_data) (bfd *, void *);
+
+  /* Core file entry points.  */
+#define BFD_JUMP_TABLE_CORE(NAME) \
+  NAME##_core_file_failing_command, \
+  NAME##_core_file_failing_signal, \
+  NAME##_core_file_matches_executable_p
+
+  char *      (*_core_file_failing_command) (bfd *);
+  int         (*_core_file_failing_signal) (bfd *);
+  bfd_boolean (*_core_file_matches_executable_p) (bfd *, bfd *);
+
+  /* Archive entry points.  */
+#define BFD_JUMP_TABLE_ARCHIVE(NAME) \
+  NAME##_slurp_armap, \
+  NAME##_slurp_extended_name_table, \
+  NAME##_construct_extended_name_table, \
+  NAME##_truncate_arname, \
+  NAME##_write_armap, \
+  NAME##_read_ar_hdr, \
+  NAME##_openr_next_archived_file, \
+  NAME##_get_elt_at_index, \
+  NAME##_generic_stat_arch_elt, \
+  NAME##_update_armap_timestamp
+
+  bfd_boolean (*_bfd_slurp_armap) (bfd *);
+  bfd_boolean (*_bfd_slurp_extended_name_table) (bfd *);
+  bfd_boolean (*_bfd_construct_extended_name_table)
+    (bfd *, char **, bfd_size_type *, const char **);
+  void        (*_bfd_truncate_arname) (bfd *, const char *, char *);
+  bfd_boolean (*write_armap)
+    (bfd *, unsigned int, struct orl *, unsigned int, int);
+  void *      (*_bfd_read_ar_hdr_fn) (bfd *);
+  bfd *       (*openr_next_archived_file) (bfd *, bfd *);
+#define bfd_get_elt_at_index(b,i) BFD_SEND (b, _bfd_get_elt_at_index, (b,i))
+  bfd *       (*_bfd_get_elt_at_index) (bfd *, symindex);
+  int         (*_bfd_stat_arch_elt) (bfd *, struct stat *);
+  bfd_boolean (*_bfd_update_armap_timestamp) (bfd *);
+
+  /* Entry points used for symbols.  */
+#define BFD_JUMP_TABLE_SYMBOLS(NAME) \
+  NAME##_get_symtab_upper_bound, \
+  NAME##_canonicalize_symtab, \
+  NAME##_make_empty_symbol, \
+  NAME##_print_symbol, \
+  NAME##_get_symbol_info, \
+  NAME##_bfd_is_local_label_name, \
+  NAME##_bfd_is_target_special_symbol, \
+  NAME##_get_lineno, \
+  NAME##_find_nearest_line, \
+  _bfd_generic_find_line, \
+  NAME##_find_inliner_info, \
+  NAME##_bfd_make_debug_symbol, \
+  NAME##_read_minisymbols, \
+  NAME##_minisymbol_to_symbol
+
+  long        (*_bfd_get_symtab_upper_bound) (bfd *);
+  long        (*_bfd_canonicalize_symtab)
+    (bfd *, struct bfd_symbol **);
+  struct bfd_symbol *
+              (*_bfd_make_empty_symbol) (bfd *);
+  void        (*_bfd_print_symbol)
+    (bfd *, void *, struct bfd_symbol *, bfd_print_symbol_type);
+#define bfd_print_symbol(b,p,s,e) BFD_SEND (b, _bfd_print_symbol, (b,p,s,e))
+  void        (*_bfd_get_symbol_info)
+    (bfd *, struct bfd_symbol *, symbol_info *);
+#define bfd_get_symbol_info(b,p,e) BFD_SEND (b, _bfd_get_symbol_info, (b,p,e))
+  bfd_boolean (*_bfd_is_local_label_name) (bfd *, const char *);
+  bfd_boolean (*_bfd_is_target_special_symbol) (bfd *, asymbol *);
+  alent *     (*_get_lineno) (bfd *, struct bfd_symbol *);
+  bfd_boolean (*_bfd_find_nearest_line)
+    (bfd *, struct bfd_section *, struct bfd_symbol **, bfd_vma,
+     const char **, const char **, unsigned int *);
+  bfd_boolean (*_bfd_find_line)
+    (bfd *, struct bfd_symbol **, struct bfd_symbol *,
+     const char **, unsigned int *);
+  bfd_boolean (*_bfd_find_inliner_info)
+    (bfd *, const char **, const char **, unsigned int *);
+ /* Back-door to allow format-aware applications to create debug symbols
+    while using BFD for everything else.  Currently used by the assembler
+    when creating COFF files.  */
+  asymbol *   (*_bfd_make_debug_symbol)
+    (bfd *, void *, unsigned long size);
+#define bfd_read_minisymbols(b, d, m, s) \
+  BFD_SEND (b, _read_minisymbols, (b, d, m, s))
+  long        (*_read_minisymbols)
+    (bfd *, bfd_boolean, void **, unsigned int *);
+#define bfd_minisymbol_to_symbol(b, d, m, f) \
+  BFD_SEND (b, _minisymbol_to_symbol, (b, d, m, f))
+  asymbol *   (*_minisymbol_to_symbol)
+    (bfd *, bfd_boolean, const void *, asymbol *);
+
+  /* Routines for relocs.  */
+#define BFD_JUMP_TABLE_RELOCS(NAME) \
+  NAME##_get_reloc_upper_bound, \
+  NAME##_canonicalize_reloc, \
+  NAME##_bfd_reloc_type_lookup
+
+  long        (*_get_reloc_upper_bound) (bfd *, sec_ptr);
+  long        (*_bfd_canonicalize_reloc)
+    (bfd *, sec_ptr, arelent **, struct bfd_symbol **);
+  /* See documentation on reloc types.  */
+  reloc_howto_type *
+              (*reloc_type_lookup) (bfd *, bfd_reloc_code_real_type);
+
+  /* Routines used when writing an object file.  */
+#define BFD_JUMP_TABLE_WRITE(NAME) \
+  NAME##_set_arch_mach, \
+  NAME##_set_section_contents
+
+  bfd_boolean (*_bfd_set_arch_mach)
+    (bfd *, enum bfd_architecture, unsigned long);
+  bfd_boolean (*_bfd_set_section_contents)
+    (bfd *, sec_ptr, const void *, file_ptr, bfd_size_type);
+
+  /* Routines used by the linker.  */
+#define BFD_JUMP_TABLE_LINK(NAME) \
+  NAME##_sizeof_headers, \
+  NAME##_bfd_get_relocated_section_contents, \
+  NAME##_bfd_relax_section, \
+  NAME##_bfd_link_hash_table_create, \
+  NAME##_bfd_link_hash_table_free, \
+  NAME##_bfd_link_add_symbols, \
+  NAME##_bfd_link_just_syms, \
+  NAME##_bfd_final_link, \
+  NAME##_bfd_link_split_section, \
+  NAME##_bfd_gc_sections, \
+  NAME##_bfd_merge_sections, \
+  NAME##_bfd_is_group_section, \
+  NAME##_bfd_discard_group, \
+  NAME##_section_already_linked \
+
+  int         (*_bfd_sizeof_headers) (bfd *, bfd_boolean);
+  bfd_byte *  (*_bfd_get_relocated_section_contents)
+    (bfd *, struct bfd_link_info *, struct bfd_link_order *,
+     bfd_byte *, bfd_boolean, struct bfd_symbol **);
+
+  bfd_boolean (*_bfd_relax_section)
+    (bfd *, struct bfd_section *, struct bfd_link_info *, bfd_boolean *);
+
+  /* Create a hash table for the linker.  Different backends store
+     different information in this table.  */
+  struct bfd_link_hash_table *
+              (*_bfd_link_hash_table_create) (bfd *);
+
+  /* Release the memory associated with the linker hash table.  */
+  void        (*_bfd_link_hash_table_free) (struct bfd_link_hash_table *);
+
+  /* Add symbols from this object file into the hash table.  */
+  bfd_boolean (*_bfd_link_add_symbols) (bfd *, struct bfd_link_info *);
+
+  /* Indicate that we are only retrieving symbol values from this section.  */
+  void        (*_bfd_link_just_syms) (asection *, struct bfd_link_info *);
+
+  /* Do a link based on the link_order structures attached to each
+     section of the BFD.  */
+  bfd_boolean (*_bfd_final_link) (bfd *, struct bfd_link_info *);
+
+  /* Should this section be split up into smaller pieces during linking.  */
+  bfd_boolean (*_bfd_link_split_section) (bfd *, struct bfd_section *);
+
+  /* Remove sections that are not referenced from the output.  */
+  bfd_boolean (*_bfd_gc_sections) (bfd *, struct bfd_link_info *);
+
+  /* Attempt to merge SEC_MERGE sections.  */
+  bfd_boolean (*_bfd_merge_sections) (bfd *, struct bfd_link_info *);
+
+  /* Is this section a member of a group?  */
+  bfd_boolean (*_bfd_is_group_section) (bfd *, const struct bfd_section *);
+
+  /* Discard members of a group.  */
+  bfd_boolean (*_bfd_discard_group) (bfd *, struct bfd_section *);
+
+  /* Check if SEC has been already linked during a reloceatable or
+     final link.  */
+  void (*_section_already_linked) (bfd *, struct bfd_section *);
+
+  /* Routines to handle dynamic symbols and relocs.  */
+#define BFD_JUMP_TABLE_DYNAMIC(NAME) \
+  NAME##_get_dynamic_symtab_upper_bound, \
+  NAME##_canonicalize_dynamic_symtab, \
+  NAME##_get_synthetic_symtab, \
+  NAME##_get_dynamic_reloc_upper_bound, \
+  NAME##_canonicalize_dynamic_reloc
+
+  /* Get the amount of memory required to hold the dynamic symbols.  */
+  long        (*_bfd_get_dynamic_symtab_upper_bound) (bfd *);
+  /* Read in the dynamic symbols.  */
+  long        (*_bfd_canonicalize_dynamic_symtab)
+    (bfd *, struct bfd_symbol **);
+  /* Create synthetized symbols.  */
+  long        (*_bfd_get_synthetic_symtab)
+    (bfd *, long, struct bfd_symbol **, long, struct bfd_symbol **,
+     struct bfd_symbol **);
+  /* Get the amount of memory required to hold the dynamic relocs.  */
+  long        (*_bfd_get_dynamic_reloc_upper_bound) (bfd *);
+  /* Read in the dynamic relocs.  */
+  long        (*_bfd_canonicalize_dynamic_reloc)
+    (bfd *, arelent **, struct bfd_symbol **);
+
+  /* Opposite endian version of this target.  */
+  const struct bfd_target * alternative_target;
+
+  /* Data for use by back-end routines, which isn't
+     generic enough to belong in this structure.  */
+  const void *backend_data;
+
+} bfd_target;
+
+bfd_boolean bfd_set_default_target (const char *name);
+
+const bfd_target *bfd_find_target (const char *target_name, bfd *abfd);
+
+const char ** bfd_target_list (void);
+
+const bfd_target *bfd_search_for_target
+   (int (*search_func) (const bfd_target *, void *),
+    void *);
+
+/* Extracted from format.c.  */
+bfd_boolean bfd_check_format (bfd *abfd, bfd_format format);
+
+bfd_boolean bfd_check_format_matches
+   (bfd *abfd, bfd_format format, char ***matching);
+
+bfd_boolean bfd_set_format (bfd *abfd, bfd_format format);
+
+const char *bfd_format_string (bfd_format format);
+
+/* Extracted from linker.c.  */
+bfd_boolean bfd_link_split_section (bfd *abfd, asection *sec);
+
+#define bfd_link_split_section(abfd, sec) \
+       BFD_SEND (abfd, _bfd_link_split_section, (abfd, sec))
+
+void bfd_section_already_linked (bfd *abfd, asection *sec);
+
+#define bfd_section_already_linked(abfd, sec) \
+       BFD_SEND (abfd, _section_already_linked, (abfd, sec))
+
+/* Extracted from simple.c.  */
+bfd_byte *bfd_simple_get_relocated_section_contents
+   (bfd *abfd, asection *sec, bfd_byte *outbuf, asymbol **symbol_table);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
--- /dev/null
+++ b/arch/ia64/include/asm/kdb.h
@@ -0,0 +1,45 @@
+#ifndef _ASM_KDB_H
+#define _ASM_KDB_H
+
+/*
+ * Kernel Debugger Architecture Dependent Global Headers
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (c) 1999-2004 Silicon Graphics, Inc.  All Rights Reserved.
+ */
+
+/*
+ * KDB_ENTER() is a macro which causes entry into the kernel
+ * debugger from any point in the kernel code stream.  If it
+ * is intended to be used from interrupt level, it must use
+ * a non-maskable entry method.
+ */
+#include <asm/kdb_break.h>		/* break numbers are separated for CONFIG_KDB_LOCK */
+#define __KDB_ENTER2(b)	asm("\tbreak.m "#b"\n")
+#define __KDB_ENTER1(b)	__KDB_ENTER2(b)
+#define KDB_ENTER()		do {if (kdb_on && !KDB_IS_RUNNING()) { __KDB_ENTER1(KDB_BREAK_ENTER); }} while(0)
+#define KDB_ENTER_SLAVE()	do {if (kdb_on) { __KDB_ENTER1(KDB_BREAK_ENTER_SLAVE); }} while(0)
+
+	/*
+	 * Needed for exported symbols.
+	 */
+typedef unsigned long kdb_machreg_t;
+
+#define kdb_machreg_fmt		"0x%lx"
+#define kdb_machreg_fmt0	"0x%016lx"
+#define kdb_bfd_vma_fmt		"0x%lx"
+#define kdb_bfd_vma_fmt0	"0x%016lx"
+#define kdb_elfw_addr_fmt	"0x%lx"
+#define kdb_elfw_addr_fmt0	"0x%016lx"
+
+static inline unsigned long
+kdba_funcptr_value(void *fp)
+{
+	/* ia64 function descriptor, first word is address of code */
+	return *(unsigned long *)fp;
+}
+
+#endif	/* !_ASM_KDB_H */
--- /dev/null
+++ b/arch/ia64/include/asm/kdb_break.h
@@ -0,0 +1,24 @@
+#ifndef _ASM_KDB_BREAK_H
+#define _ASM_KDB_BREAK_H
+
+/*
+ * Kernel Debugger Architecture Dependent Global Headers
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (c) 1999-2004 Silicon Graphics, Inc.  All Rights Reserved.
+ */
+
+/*
+ * Break numbers are used by CONFIG_KDB_LOCK code.  They need to be seperated
+ * from asm/kdb.h to let spinlock code build without pulling in all of the kdb
+ * headers.
+ */
+
+#define KDB_BREAK_BREAK		0x80100		/* kdb breakpoint in kernel */
+#define KDB_BREAK_ENTER		0x80101		/* KDB_ENTER(), single event or monarch */
+#define KDB_BREAK_ENTER_SLAVE	0x80102		/* KDB_ENTER_SLAVE(), concurrent slave events */
+
+#endif	/* !_ASM_KDB_BREAK_H */
--- /dev/null
+++ b/arch/ia64/include/asm/kdbprivate.h
@@ -0,0 +1,124 @@
+#ifndef _ASM_KDBPRIVATE_H
+#define _ASM_KDBPRIVATE_H
+
+/*
+ * Kernel Debugger Architecture Dependent Private Headers
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (c) 1999-2004 Silicon Graphics, Inc.  All Rights Reserved.
+ */
+
+/* Definition of an machine instruction.
+ * Takes care of VLIW processors like Itanium
+ */
+
+typedef struct {
+	unsigned long inst[2];
+} kdb_machinst_t;
+
+/*
+ * KDB_MAXBPT describes the total number of breakpoints
+ * supported by this architecure.
+ */
+#define KDB_MAXBPT	16
+
+/*
+ * KDB_MAXHARDBPT describes the total number of hardware
+ * breakpoint registers that exist.
+ */
+#define KDB_MAXHARDBPT	 4
+
+/*
+ * Platform specific environment entries
+ */
+#define KDB_PLATFORM_ENV	"IDMODE=ia64", "BYTESPERWORD=4", "IDCOUNT=8"
+
+/*
+ * Support for IA64 debug registers
+ */
+typedef struct _kdbhard_bp {
+	kdb_machreg_t	bph_reg;	/* Register this breakpoint uses */
+
+	unsigned int	bph_free:1;	/* Register available for use */
+	unsigned int	bph_data:1;	/* Data Access breakpoint */
+
+	unsigned int	bph_write:1;	/* Write Data breakpoint */
+	unsigned int	bph_mode:2;	/* 0=inst, 1=write, 2=io, 3=read */
+	unsigned int	bph_length:2;	/* 0=1, 1=2, 2=BAD, 3=4 (bytes) */
+} kdbhard_bp_t;
+
+#define getprsregs(regs)        ((struct switch_stack *)regs -1)
+
+/* bkpt support using break inst instead of IBP reg */
+
+/*
+ * Define certain specific instructions
+ */
+#define BREAK_INSTR             (long)(KDB_BREAK_BREAK << (5+6))
+#define INST_SLOT0_MASK         (0x1ffffffffffL << 5)
+
+#define BKPTMODE_DATAR  3
+#define BKPTMODE_IO     2
+#define BKPTMODE_DATAW  1
+#define BKPTMODE_INST   0
+
+/* Some of the fault registers needed by kdb but not passed with
+ * regs or switch stack.
+ */
+typedef struct fault_regs {
+	unsigned long   isr ;
+	unsigned long   ifa ;
+	unsigned long   iim ;
+	unsigned long   itir ;
+} fault_regs_t ;
+
+/*
+ * Support for setjmp/longjmp
+ */
+
+/* __jmp_buf definition copied from libc/sysdeps/unix/sysv/linux/ia64/bits/setjmp.h */
+
+#define _JBLEN  70
+
+typedef struct __kdb_jmp_buf {
+	unsigned long   __jmp_buf[_JBLEN];
+} kdb_jmp_buf __attribute__ ((aligned (16)));
+
+extern int kdba_setjmp(kdb_jmp_buf *);
+extern void kdba_longjmp(kdb_jmp_buf *, int);
+#define kdba_setjmp kdba_setjmp
+
+extern kdb_jmp_buf *kdbjmpbuf;
+
+/* Arch specific data saved for running processes */
+
+struct kdba_running_process {
+	struct switch_stack *sw;
+};
+
+extern void kdba_save_running(struct kdba_running_process *, struct pt_regs *);
+extern void kdba_unsave_running(struct kdba_running_process *, struct pt_regs *);
+
+/* kdba wrappers which want to save switch stack will call unw_init_running().
+ * That routine only takes a void* so pack the interrupt data into a structure.
+ */
+
+#include <linux/interrupt.h>	/* for irqreturn_t */
+
+enum kdba_serial_console {
+	KDBA_SC_NONE = 0,
+	KDBA_SC_STANDARD,
+	KDBA_SC_SGI_L1,
+};
+
+extern enum kdba_serial_console kdba_serial_console;
+
+#define KDB_RUNNING_PROCESS_ORIGINAL kdb_running_process_save
+extern struct kdb_running_process *kdb_running_process_save; /* [NR_CPUS] */
+
+extern void kdba_wait_for_cpus(void);
+
+#endif	/* !_ASM_KDBPRIVATE_H */
--- a/arch/ia64/include/asm/kmap_types.h
+++ b/arch/ia64/include/asm/kmap_types.h
@@ -22,7 +22,8 @@ D(9)	KM_IRQ0,
 D(10)	KM_IRQ1,
 D(11)	KM_SOFTIRQ0,
 D(12)	KM_SOFTIRQ1,
-D(13)	KM_TYPE_NR
+D(13)	KM_KDB,
+D(14)	KM_TYPE_NR
 };
 
 #undef D
--- a/arch/ia64/include/asm/kregs.h
+++ b/arch/ia64/include/asm/kregs.h
@@ -72,7 +72,7 @@
 /* A mask of PSR bits that we generally don't want to inherit across a clone2() or an
    execve().  Only list flags here that need to be cleared/set for BOTH clone2() and
    execve().  */
-#define IA64_PSR_BITS_TO_CLEAR	(IA64_PSR_MFL | IA64_PSR_MFH | IA64_PSR_DB | IA64_PSR_LP | \
+#define IA64_PSR_BITS_TO_CLEAR	(IA64_PSR_MFL | IA64_PSR_MFH | IA64_PSR_LP | \
 				 IA64_PSR_TB  | IA64_PSR_ID  | IA64_PSR_DA | IA64_PSR_DD | \
 				 IA64_PSR_SS  | IA64_PSR_ED  | IA64_PSR_IA)
 #define IA64_PSR_BITS_TO_SET	(IA64_PSR_DFH | IA64_PSR_SP)
--- /dev/null
+++ b/arch/ia64/kdb/ChangeLog
@@ -0,0 +1,1085 @@
+2008-09-30 Jay Lan  <jlan@sgi.com>
+
+	* kdb-v4.4-2.6.27-rc8-ia64-1.
+
+2008-09-22 Jay Lan  <jlan@sgi.com>
+
+	* kdb-v4.4-2.6.27-rc7-ia64-1.
+
+2008-09-03 Jay Lan  <jlan@sgi.com>
+
+	* kdb-v4.4-2.6.27-rc5-ia64-1.
+
+2008-08-19 Jay Lan  <jlan@sgi.com>
+
+	* kdb-v4.4-2.6.27-rc3-ia64-1.
+
+2008-08-15 Jay Lan  <jlan@sgi.com>
+
+	* Fix a problem that slave cpus panic'ed during NMI.
+	  Jay Lan <jlan@sgi.com>
+	* kdb-v4.4-2.6.27-rc2-ia64-2.1.
+
+2008-08-14 Jay Lan  <jlan@sgi.com>
+
+	* Support 'kdump' command to take a kdump vmcore from KDB,
+	    Dan Aloni (da-x@monatomic.org),
+	    Jason Xiao (jidong.xiao@gmail.com),
+	    Jay Lan (jlan@sgi.com)
+	* kdb-v4.4-2.6.27-rc2-ia64-2.
+
+2008-08-06 Jay Lan  <jlan@sgi.com>
+
+	* Fix up the NULL pointer deference issue in ohci_kdb_poll_char,
+	  Jason Xiao <jidong.xiao@gmail.com>
+	* kdb-v4.4-2.6.27-rc2-ia64-1.
+
+2008-07-18 Jay Lan  <jlan@sgi.com>
+
+	* support Hardware Breakpoint (bph/bpha) commands
+	  IA64: Greg Banks <gnb@sgi.com>
+	  X86:  Konstantin Baydarov <kbaidarov@ru.mvista.com>
+	* kdb-v4.4-2.6.26-ia64-2.
+
+2008-07-14 Jay Lan  <jlan@sgi.com>
+
+        * kdb-v4.4-2.6.26-ia64-1.
+
+2008-07-11 Jay Lan  <jlan@sgi.com>
+
+        * New commands and some fixups and enhancements,
+          Joe Korty <joe.korty@ccur.com>
+          John Blackwood <john.blackwood@ccur.com>
+          Jim Houston <jim.houston@ccur.com>
+          - Use the non-sleeping copy_from_user_atomic.
+          - Enhance kdb_cmderror diagnostic output.
+          - Expand the KDB 'duplicate command' error message.
+          - Touch NMI watchdog in various KDB busy-loops.
+          - Support IMB HS20 Blade 8843 platform.
+          - Display exactly which cpus needed an NMI to get them into kdb.
+          - Better document that kdb's 'ps A' command can be used to show
+            _all_ processes and threads
+          - Suppress KDB boottime INFO messages if quiet boot.
+          - Add a KDB breakpoint to the OOPs path.
+          - Add CONFIG_DISCONTIGMEM support to kdbm_memmap.
+          - Extend the KDB task command to handle CONFIG_NUMA fields.
+          - Extend the KDB vm command to support NUMA stuff.
+          - Create the KDB mempolicy command.
+          - Create a pgdat command for KDB.
+          - Fix a hang on boot on some i386 systems.
+        * kdb-v4.4-2.6.26-rc9-ia64-1.
+
+2008-06-30 Jay Lan  <jlan@sgi.com>
+
+	* kdb-v4.4-2.6.26-rc8-ia64-1.
+
+2008-06-25 Jay Lan  <jlan@sgi.com>
+
+	* kdb-v4.4-2.6.26-rc7-ia64-1.
+
+2008-06-06 Jay Lan  <jlan@sgi.com>
+
+	* kdb-v4.4-2.6.26-rc5-ia64-1.
+
+2008-05-30 Jay Lan  <jlan@sgi.com>
+
+	* kdb-v4.4-2.6.26-rc4-ia64-1.
+
+2008-05-20 Jay Lan  <jlan@sgi.com>
+
+	* kdb-v4.4-2.6.26-rc3-ia64-1.
+
+2008-05-13 Jay Lan  <jlan@sgi.com>
+
+	* XPC support removed from KDB due to XPC changes to 2.6.26-rc1.
+        * kdb-v4.4-2.6.26-rc1-ia64-1.
+
+2008-04-17 Jay Lan  <jlan@sgi.com>
+
+	* kdb-v4.4-2.6.25-ia64-1.
+
+2008-03-16 Jay Lan  <jlan@sgi.com>
+
+	* kdb-v4.4-2.6.25-rc6-ia64-1.
+
+2008-03-03 Jay Lan  <jlan@sgi.com>
+
+	* kdb-v4.4-2.6.25-rc3-ia64-1.
+
+2008-02-26 Jay Lan  <jlan@sgi.com>
+
+	* kdb-v4.4-2.6.25-rc2-ia64-1.
+
+2008-02-19 Jay Lan  <jlan@sgi.com>
+
+	* kdb-v4.4-2.6.25-rc1-ia64-1.
+
+2008-02-01 Jay Lan  <jlan@sgi.com>
+
+	* Backed out USB UHCI support since it caused dropped characters and
+          broke OHCI.
+	* Restored "archkdbcommon" commands for x86. It was lost at the x86
+	  merge.
+	* Detecting if the HC was "busy", Aaron Young <ayoung@sgi.com>
+	* kdb-v4.4-2.6.24-ia64-2.
+
+2008-01-29 Jay Lan  <jlan@sgi.com>
+
+	* kdb-v4.4-2.6.24-ia64-1.
+
+2008-01-22 Jay Lan  <jlan@sgi.com>
+
+	* USB UHCI kdb support, Konstantin Baydarov <kbaidarov@ru.mvista.com>
+	* kdb-v4.4-2.6.24-rc8-ia64-3.
+
+2008-01-18 Jay Lan  <jlan@sgi.com>
+
+	* USB EHCI kdb support,  Aaron Young <ayoung@sgi.com>
+	* kdb-v4.4-2.6.24-rc8-ia64-2.
+
+2008-01-18 Jay Lan  <jlan@sgi.com>
+
+	* kdb-v4.4-2.6.24-rc8-ia64-1.
+
+2008-01-07 Jay Lan  <jlan@sgi.com>
+
+	* kdb-v4.4-2.6.24-rc7-ia64-1.
+
+2007-12-21 Jay Lan  <jlan@sgi.com>
+
+	* kdb v4.4-2.6.24-rc6-ia64-1.
+
+2007-12-12 Jay Lan  <jlan@sgi.com>
+
+	* kdb v4.4-2.6.24-rc5-ia64-1.
+
+2007-12-05 Jay Lan  <jlan@sgi.com>
+
+	* Fixed a 'sysctl table check failed' problem.
+	* kdb v4.4-2.6.24-rc4-ia64-1.
+
+2007-11-26 Jay Lan  <jlan@sgi.com>
+
+	* kdb v4.4-2.6.24-rc3-ia64-1.
+
+2007-11-13 Jay Lan  <jlan@sgi.com>
+
+	* Back ported "New KDB USB interface" from Aaron Young in
+	  v4.4-2.6.23-ia64-2 to 2.6.24 kdb patchset.
+	* kdb v4.4-2.6.24-rc2-ia64-2.
+
+2007-11-12 Jay Lan  <jlan@sgi.com>
+
+	* kdb v4.4-2.6.24-rc2-ia64-1.
+
+2007-11-09 Jay Lan  <jlan@sgi.com>
+
+	* Rebase to 2.6.24-rc1 kernel
+	*   - merged kdb-v4.4-2.6.23-i386-1 and kdb-v4.4-2.6.23-x86_64-1
+	*     into kdb-v4.4-2.6.24-rc1-x86-1
+	*   - Fields "done", "sglist_len", and "pid" are removed from
+	*     struct scsi_cmnd. Thus, these fields are no longer displayed
+	*     on "sc" command.
+	* kdb v4.4-2.6.24-rc1-ia64-1.
+
+2007-11-08 Jay Lan  <jlan@sgi.com>
+
+	* New KDB USB interface,  Aaron Young <ayoung@sgi.com>
+	*  1. This patch allows KDB to work with any Host Contoller driver
+	*     and call the correct HC driver poll routine (as long as the
+	*     HC driver provides a .kdb_poll_char routine via it's
+	*     associated hc_driver struct).
+	*  2. Hotplugged keyboards are now recognized by KDB.
+	*  3. Currently KDB can only make use of 1 USB type keyboard.
+	*     New code can handle up to 8 attached keyboards - input is
+	*     multiplexed from all of them while in kdb.
+	* kdb v4.4-2.6.23-ia64-2.
+
+2007-10-24 Jay Lan  <jlan@sgi.com>
+
+	* kdb v4.4-2.6.23-ia64-1.
+
+2007-09-26 Jay Lan  <jlan@sgi.com>
+
+	* kdb v4.4-2.6.23-rc8-ia64-1.
+
+2007-09-21 Jay Lan  <jlan@sgi.com>
+
+	* kdb v4.4-2.6.23-rc7-ia64-1.
+
+2007-09-19 Jay Lan  <jlan@sgi.com>
+
+	* Get into KDB successfully if multiple cpus are in MCA. <rja@sgi.com>
+	* kdb v4.4-2.6.23-rc6-ia64-2.
+
+2007-09-12 Jay Lan  <jlan@sgi.com>
+
+	* kdb v4.4-2.6.23-rc6-ia64-1.
+
+2007-09-06 Jay Lan  <jlan@sgi.com>
+
+	* kdb v4.4-2.6.23-rc5-ia64-1.
+
+2007-08-30 Keith Owens  <kaos@sgi.com>
+
+	* New i386/x86_64 backtrace requires that kdb_save_running() does not
+	  exit until after kdb_main_loop() has completed.
+	* kdb v4.4-2.6.23-rc4-ia64-2.
+
+2007-08-30 Jay Lan  <jlan@sgi.com>
+
+	* kdb v4.4-2.6.23-rc4-ia64-1.
+
+2007-08-24 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.23-rc3-ia64-1.
+
+2007-08-07 Jay Lan  <jlan@sgi.com>
+
+	* kdb v4.4-2.6.23-rc2-ia64-1.
+
+2007-07-30 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.23-rc1-ia64-1.
+
+2007-07-09 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.22-ia64-1.
+
+2007-07-02 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.22-rc7-ia64-1.
+
+2007-06-20 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.22-rc5-ia64-1.
+
+2007-06-08 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.22-rc4-ia64-1.
+
+2007-05-28 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.22-rc3-ia64-1.
+
+2007-05-22 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.22-rc2-ia64-1.
+
+2007-05-22 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.22-rc1-ia64-1.
+
+2007-04-29 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.21-ia64-1.
+
+2007-04-16 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.21-rc7-ia64-1.
+
+2007-04-10 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.21-rc6-ia64-1.
+
+2007-04-02 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.21-rc5-ia64-1.
+
+2007-03-19 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.21-rc4-ia64-1.
+
+2007-03-14 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.21-rc3-ia64-1.
+
+2007-03-14 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.21-rc2-ia64-1.
+
+2007-03-01 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.21-rc1-ia64-1.
+
+2007-03-01 Keith Owens  <kaos@sgi.com>
+
+	* Remove sparse warnings.
+	* kdb v4.4-2.6.20-ia64-3.
+
+2007-02-16 Keith Owens  <kaos@sgi.com>
+
+	* Initialise variable bits of struct disassemble_info each time.
+	* kdb v4.4-2.6.20-ia64-2.
+
+2007-02-06 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.20-ia64-1.
+
+2007-02-01 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.20-rc7-ia64-1.
+
+2007-01-08 Keith Owens  <kaos@sgi.com>
+
+	* Detect calls via PLT and decode the target address.
+	* kdb v4.4-2.6.20-rc4-ia64-2.
+
+2007-01-08 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.20-rc4-ia64-1.
+
+2007-01-02 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.20-rc3-ia64-1.
+
+2006-12-20 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.20-rc1-ia64-1.
+
+2006-12-07 Keith Owens  <kaos@sgi.com>
+
+	* Export kdba_dumpregs.
+	* kdb v4.4-2.6.19-ia64-2.
+
+2006-11-30 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.19-ia64-1.
+
+2006-11-27 Keith Owens  <kaos@sgi.com>
+
+	* Only use VT keyboard if the command line allows it and ACPI indicates
+	  that there is an i8042.
+	* kdb v4.4-2.6.19-rc6-ia64-2.
+
+2006-11-20 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.19-rc6-ia64-1.
+
+2006-11-09 Keith Owens  <kaos@sgi.com>
+
+	* Only use VT console if the command line allows it.
+	* kdb v4.4-2.6.19-rc5-ia64-2.
+
+2006-11-08 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.19-rc5-ia64-1.
+
+2006-11-01 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.19-rc4-ia64-1.
+
+2006-10-24 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.19-rc3-ia64-1.
+
+2006-10-24 Keith Owens  <kaos@sgi.com>
+
+	* Remove redundant regs and envp parameters.
+	* kdb v4.4-2.6.19-rc2-ia64-2.
+
+2006-10-18 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.19-rc2-ia64-1.
+
+2006-10-09 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.19-rc1-ia64-1.
+
+2006-10-06 Keith Owens  <kaos@sgi.com>
+
+	* Remove #include <linux/config.h>
+	* kdb v4.4-2.6.18-ia64-2.
+
+2006-09-20 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.18-ia64-1.
+
+2006-09-15 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.18-rc7-ia64-1.
+
+2006-08-29 Keith Owens  <kaos@sgi.com>
+
+	* Rewrite all backtrace code.
+	* kdb v4.4-2.6.18-rc5-ia64-2.
+
+2006-08-28 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.18-rc5-ia64-1.
+
+2006-08-08 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.18-rc4-ia64-1.
+
+2006-08-04 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.18-rc3-ia64-1.
+
+2006-07-18 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.18-rc2-ia64-1.
+
+2006-07-12 Keith Owens  <kaos@sgi.com>
+
+	* Remove dead KDB_REASON codes.
+	* sparse cleanups.
+	* kdb v4.4-2.6.18-rc1-ia64-2.
+
+2006-07-07 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.18-rc1-ia64-1.
+
+2006-07-04 Keith Owens  <kaos@sgi.com>
+
+	* Delete kdba_enable_lbr, kdba_disable_lbr, kdba_print_lbr,
+	  page_fault_mca.  Only ever implemented on x86, difficult to maintain
+	  and rarely used in the field.
+	* Replace #ifdef KDB_HAVE_LONGJMP with #ifdef kdba_setjmp.
+	* kdb v4.4-2.6.17-ia64-2.
+
+2006-06-19 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.17-ia64-1.
+
+2006-05-25 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.17-rc5-ia64-1.
+
+2006-05-15 Keith Owens  <kaos@sgi.com>
+
+	* Refresh bfd related files from binutils 2.16.91.0.2.
+	* kdb v4.4-2.6.17-rc4-ia64-2.
+
+2006-05-12 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.17-rc4-ia64-1.
+
+2006-04-28 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.17-rc3-ia64-1.
+
+2006-04-22 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.17-rc2-ia64-1.
+
+2006-04-11 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.17-rc1-ia64-1.
+
+2006-03-30 Keith Owens  <kaos@sgi.com>
+
+	* Change CONFIG_LKCD to CONFIG_LKCD_DUMP.
+	* kdb v4.4-2.6.16-ia64-3.
+
+2006-03-24 Keith Owens  <kaos@sgi.com>
+
+	* Use INIT to interrupt cpus that do not respond to a normal kdb IPI.
+	* Remove KDBA_MCA_TRACE from arch/ia64/kernel/mca.c.
+	* kdb v4.4-2.6.16-ia64-2.
+
+2006-03-21 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.16-ia64-1.
+
+2006-03-14 Nathan Scott  <nathans@sgi.com>
+
+	* kdb v4.4-2.6.16-rc6-ia64-1.
+
+2006-02-28 Nathan Scott  <nathans@sgi.com>
+
+	* kdb v4.4-2.6.16-rc5-ia64-1.
+
+2006-02-20 Nathan Scott  <nathans@sgi.com>
+
+	* kdb v4.4-2.6.16-rc4-ia64-1.
+
+2006-02-07 Keith Owens  <kaos@sgi.com>
+
+	* Change kdb_running_process_save from a static array to a pointer.
+	  gcc 4.0 objects to forward declarations for arrays with an incomplete
+	  type.
+	* kdb v4.4-2.6.16-rc2-ia64-3.
+
+2006-02-06 Keith Owens  <kaos@sgi.com>
+
+	* Change CONFIG_CRASH_DUMP to CONFIG_LKCD.
+	* kdb v4.4-2.6.16-rc2-ia64-2.
+
+2006-02-06 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.16-rc2-ia64-1.
+
+2006-02-01 Keith Owens  <kaos@sgi.com>
+
+	* Handlers: check that the task is in kernel space before looking at
+	  the thread_info bits.
+	* Expose kdb_running_process_save[] so 'pid R' can get the original
+	  process, even when the MCA/INIT handlers are being used.
+	* kdb v4.4-2.6.16-rc1-ia64-3.
+
+2006-01-19 Keith Owens  <kaos@sgi.com>
+
+	* Add back some kdb changes to xpc_main that were lost due to a patch
+	  conflict.
+	* kdb v4.4-2.6.16-rc1-ia64-2.
+
+2006-01-18 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.16-rc1-ia64-1.
+
+2006-01-10 Keith Owens  <kaos@sgi.com>
+
+	* Build kdba_pod for generic as well as sn2 kernels and test at run
+	  time if the platform is sn2.
+	* kdb v4.4-2.6.15-ia64-3.
+
+2006-01-08 Keith Owens  <kaos@sgi.com>
+
+	* Convert xpc to use DIE_KDEBUG_ENTER and DIE_KDEBUG_LEAVE.
+	* Add debug option for xpc.
+	* break.b always sets a debug trap number of 0 , so pass that to kdb as
+	  well as the normal kdb traaps.
+	* kdb v4.4-2.6.15-ia64-2.
+
+2006-01-04 Keith Owens  <kaos@sgi.com>
+
+	* Remove some inlines and the last vestige of CONFIG_NUMA_REPLICATE.
+	* Read the keyboard acknowledgment after sending a character.  SuSE
+	  Bugzilla 60240.
+	* kdb v4.4-2.6.15-ia64-1.
+
+2005-12-25 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.15-rc7-ia64-1.
+
+2005-12-20 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.15-rc6-ia64-1.
+
+2005-12-06 Keith Owens  <kaos@sgi.com>
+
+	* Use RECOVERY flag in MCA handler.
+	* kdb v4.4-2.6.15-rc5-ia64-2.
+
+2005-12-05 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.15-rc5-ia64-1.
+
+2005-12-02 Keith Owens  <kaos@sgi.com>
+
+	* Reinstate hook for debug trap, the patch chunk was accidentally
+	  dropped in 2.6.15-rc1.
+	* kdb v4.4-2.6.15-rc4-ia64-1.
+
+2005-11-30 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.15-rc3-ia64-1.
+
+2005-11-21 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.15-rc2-ia64-1.
+
+2005-11-15 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.15-rc1-ia64-1.
+
+2005-10-28 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.14-ia64-1.
+
+2005-10-21 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.14-rc5-ia64-1.
+
+2005-10-11 Keith Owens  <kaos@sgi.com>
+
+	* Handle removal of USB keyboard.  Aaron Young, SGI
+	* kdb v4.4-2.6.14-rc4-ia64-1.
+
+2005-10-04 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.14-rc3-ia64-1.
+
+2005-09-21 Keith Owens  <kaos@sgi.com>
+
+	* Support kdb_current_task in register display and modify commands.
+	* kdb v4.4-2.6.14-rc2-ia64-1.
+
+2005-09-20 Keith Owens  <kaos@sgi.com>
+
+	* Coexist with kprobes.
+	* Coexist with MCA/INIT rewrite.
+	* Add KDB_ENTER_SLAVE to handle concurrent entry to kdb from multiple
+	  cpus.
+	* Add handlers command to control whether the MCA/INIT task or the
+	  original task is displayed.
+	* Namespace clean up, remove unused kdba_sw_interrupt.
+	* kdb v4.4-2.6.14-rc1-ia64-1.
+
+2005-08-29 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.13-ia64-1.
+
+2005-08-24 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.13-rc7-ia64-1.
+
+2005-08-08 Keith Owens  <kaos@sgi.com>
+
+	* Add minstate command.
+	* kdb v4.4-2.6.13-rc6-ia64-1.
+
+2005-08-02 Keith Owens  <kaos@sgi.com>
+
+	* Replace hard coded kdb declarations with #include <asm/sections>.
+	* kdb v4.4-2.6.13-rc5-ia64-1.
+
+2005-07-30 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.13-rc4-ia64-1.
+
+2005-07-22 Keith Owens  <kaos@sgi.com>
+
+	* Handle INIT delivered while in physical mode.
+	* kdb v4.4-2.6.13-rc3-ia64-2.
+
+2005-07-19 Keith Owens  <kaos@sgi.com>
+
+	* Add support for USB keyboard (OHCI only).  Aaron Young, SGI.
+	* kdb v4.4-2.6.13-rc3-ia64-1.
+
+2005-07-08 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.13-rc2-ia64-1.
+
+2005-07-01 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.13-rc1-ia64-1.
+
+2005-06-18 Keith Owens  <kaos@sgi.com>
+
+	* Standard IA64 code now works around break.b setting cr.iim to 0
+	  instead of the break number.  Remove the kdb workaround.
+	* kdb v4.4-2.6.12-ia64-1.
+
+2005-06-08 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.12-rc6-ia64-1.
+
+2005-05-25 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.12-rc5-ia64-1.
+
+2005-05-24 Keith Owens  <kaos@sgi.com>
+
+	* break.b sets cr.iim to 0 instead of the break number.  Deal with it.
+	* kdb v4.4-2.6.12-rc4-ia64-3.
+
+2005-05-14 Keith Owens  <kaos@sgi.com>
+
+	* Correct MCA path after calling kdba_mca_bspstore_fixup().
+	  Mark Larson, SGI.
+	* Tell the user that MCA/INIT is recoverable so kdb is not entered.
+	* kdb v4.4-2.6.12-rc4-ia64-2.
+
+2005-05-08 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.12-rc4-ia64-1.
+
+2005-04-21 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.12-rc3-ia64-1.
+
+2005-04-06 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.12-rc2-ia64-1.
+
+2005-04-04 Keith Owens  <kaos@sgi.com>
+
+	* More tweaks to cope with invalid old bspstore in MCA handler.
+	* kdb v4.4-2.6.12-rc1-ia64-2.
+
+2005-03-29 Keith Owens  <kaos@sgi.com>
+
+	* Replace __copy_to_user with __copy_to_user_inatomic.
+	* MCA handler, do not use old_bspstore if it is in region 4 or below.
+	* kdb v4.4-2.6.12-rc1-ia64-1.
+
+2005-03-08 Keith Owens  <kaos@sgi.com>
+
+	* Coexistence patches for lkcd.  Jason Uhlenkott, SGI.
+	* kdb v4.4-2.6.11-ia64-2.
+
+2005-03-03 Keith Owens  <kaos@sgi.com>
+
+	* kdb-v4.4-2.6.11-ia64-1.
+
+2005-02-14 Keith Owens  <kaos@sgi.com>
+
+	* kdb-v4.4-2.6.11-rc4-ia64-1.
+
+2005-02-08 Keith Owens  <kaos@sgi.com>
+
+	* kdb-v4.4-2.6.11-rc3-bk4-ia64-1.
+
+2005-02-03 Keith Owens  <kaos@sgi.com>
+
+	* kdb-v4.4-2.6.11-rc3-ia64-1.
+
+2005-01-27 Keith Owens  <kaos@sgi.com>
+
+	* kdb-v4.4-2.6.11-rc2-ia64-1.
+
+2005-01-20 Keith Owens  <kaos@sgi.com>
+
+	* MCA and INIT stacks moved to per-cpu area.
+	* kdb-v4.4-2.6.11-rc1-bk7-ia64-1.
+
+2005-01-12 Keith Owens  <kaos@sgi.com>
+
+	* ia64_spinlock_contention_pre3_4_end is in base kernel, remove from kdb.
+	* Use last ditch allocator if unwind cannot allocate memory.
+	* kdb-v4.4-2.6.11-rc1-ia64-1.
+
+2004-12-25 Keith Owens  <kaos@sgi.com>
+
+	* Add cpuinfo command.
+	* kdb-v4.4-2.6.10-ia64-1.
+
+2004-12-07 Keith Owens  <kaos@sgi.com>
+
+	* Clean up error path in kdba_mca_init.
+	* kdb-v4.4-2.6.10-rc3-ia64-1.
+
+2004-11-15 Keith Owens  <kaos@sgi.com>
+
+	* kdb-v4.4-2.6.10-rc2-ia64-1.
+
+2004-10-29 Keith Owens  <kaos@sgi.com>
+
+	* kdb-v4.4-2.6.10-rc1-ia64-1.
+
+2004-10-19 Keith Owens  <kaos@sgi.com>
+
+	* kdb-v4.4-2.6.9-ia64-1.
+
+2004-10-12 Keith Owens  <kaos@sgi.com>
+
+	* kdb-v4.4-2.6.9-rc4-ia64-1.
+
+2004-10-01 Keith Owens  <kaos@sgi.com>
+
+	* kdb-v4.4-2.6.9-rc3-ia64-1.
+
+2004-09-30 Keith Owens  <kaos@sgi.com>
+
+	* Add stackdepth command.
+	* kdb-v4.4-2.6.9-rc2-ia64-3.
+
+2004-09-16 Keith Owens  <kaos@sgi.com>
+
+	* Fixes for current in region 5 instead of 7 (idle task on cpu 0).
+	* kdb-v4.4-2.6.9-rc2-ia64-2.
+
+2004-09-14 Keith Owens  <kaos@sgi.com>
+
+	* kdb-v4.4-2.6.9-rc2-ia64-1.
+
+2004-08-27 Keith Owens  <kaos@sgi.com>
+
+	* kdb-v4.4-2.6.9-rc1-ia64-1.
+
+2004-08-14 Keith Owens  <kaos@sgi.com>
+
+	* kdb-v4.4-2.6.8-ia64-1.
+
+2004-08-12 Keith Owens  <kaos@sgi.com>
+
+	* kdb-v4.4-2.6.8-rc4-ia64-1.
+
+2004-08-04 Keith Owens  <kaos@sgi.com>
+
+	* kdb-v4.4-2.6.8-rc3-ia64-1.
+
+2004-07-18 Keith Owens  <kaos@sgi.com>
+
+	* New config name for SN serial console.
+	* kdb-v4.4-2.6.8-rc2-ia64-1.
+
+2004-07-12 Keith Owens  <kaos@sgi.com>
+
+	* kdb-v4.4-2.6.8-rc1-ia64-1.
+
+2004-06-30 Keith Owens  <kaos@sgi.com>
+
+	* kdb-v4.4-2.6.7-ia64-040629-1.
+
+2004-06-16 Keith Owens  <kaos@sgi.com>
+
+	* Coexist with 2.6.7-ia64-040619.
+	* kdb-v4.4-2.6.7-ia64-040619-1.
+
+2004-06-16 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.7-ia64-1.
+
+2004-06-10 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.7-rc3-ia64-1.
+
+2004-06-09 Keith Owens  <kaos@sgi.com>
+
+	* Namespace clean up.  Mark code/variables as static when it is only
+	  used in one file, delete dead code/variables.
+	* Saved interrupt state requires long, not int.
+	* kdb v4.4-2.6.7-rc2-ia64-3.
+
+2004-06-08 Keith Owens  <kaos@sgi.com>
+
+	* Whitespace clean up, no code changes.
+	* kdb v4.4-2.6.7-rc2-2.
+
+2004-06-07 Keith Owens  <kaos@sgi.com>
+
+	* Force KALLSYMS and KALLSYMS_ALL for CONFIG_KDB.
+	* kdb v4.4-2.6.7-rc2-1.
+
+2004-06-06 Keith Owens  <kaos@sgi.com>
+
+	* Add standard archkdb commands.
+	* Move kdb_{get,put}userarea_size definitions to linux/kdb.h.
+	* kdb v4.4-2.6.6-ia64-040521-2.
+
+2004-05-25 Keith Owens  <kaos@sgi.com>
+
+	* Update Kconfig text.
+	* kdb v4.4-2.6.6-ia64-040521-1.
+
+2004-05-23 Keith Owens  <kaos@sgi.com>
+
+	* Move bfd.h and ansidecl.h from arch/$(ARCH)/kdb to include/asm-$(ARCH).
+	* ia64-opc.c needs kdbprivate.h after common reorganisation.
+	* Update copyright notices.
+	* kdb v4.4-2.6.6-ia64-1.
+
+2004-05-60 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.3-2.6.6-rc3-ia64-1.
+
+2004-05-60 Keith Owens  <kaos@sgi.com>
+
+	* Tweak WAR for backtrace through contended spinlocks.
+	* kdb v4.3-2.6.6-rc2-ia64-1.
+
+2004-04-30 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.3-2.6.6-rc1-ia64-1.
+
+2004-04-15 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.3-2.6.5-ia64-040413-1.
+
+2004-03-06 Keith Owens  <kaos@sgi.com>
+
+	* Use kdb_print for unwind debugging.
+	* kdb v4.3-2.6.4-rc2-ia64-1.
+
+2004-02-29 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.3-2.6.4-rc1-ia64-1.
+
+2004-02-18 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.3-2.6.3-ia64-1.
+
+2004-02-17 Keith Owens  <kaos@sgi.com>
+
+	* Reconcile 2.6-test versions from Xavier Bru (Bull), Greg Banks (SGI),
+	  Jim Houston (Concurrent Computer Corp).
+	* Reconcile with kdb v4.3-2.4.23-ia64-0312??-1.
+	* Reconcile with salinfo changes.
+	* Port WAR for backtrace from spinlock contention from 2.4 to 2.6.
+	* Merge PGS FIFO tweak with SERIAL_IO_MEM and concurrent support for
+	  multiple consoles (no USB consoles yet).
+	* Update pt_regs output to match the order of struct pt_regs.
+	* KDB wrappers for interrupts handlers now return the handler's return code.
+	* tpa and tpav commands from Anonymous.
+	* Reconcile with mca changes.
+	* Upgrade to 2.6.3-rc3.
+	* kdb v4.3-2.6.3-rc3-ia64-1.
+
+2003-10-22 Xavier Bru   <xavier.bru@bull.net>
+	* Merge to 2.6.0-test7
+2003-10-20 Philippe Garrigues <Philippe.Garrigues@bull.net>
+	* Enable FIFO in UART
+2003-09-08 Xavier Bru   <xavier.bru@bull.net>
+	* Merge to 2.6.0-test4
+2003-03-21 Xavier Bru <xavier.bru@bull.net>
+	* Merge kdb v4.0 on 2.5.64 ia64
+	* new kernel parameters support
+	* new kallsyms support
+
+2003-10-24 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.3-2.4.23-pre8-cset-1.1069.1.143-to-1.1108-ia64-1.
+
+2003-10-03 Keith Owens  <kaos@sgi.com>
+
+	* After MCA, copy the saved RSE registers from ia64_mca_bspstore to the
+	  stack of the failing process.
+	* Abort backtrace when we hit IVT, no unwind data which confuses
+	  unw_unwind().
+	* Workaround for backtrace through spinlock contention called from leaf
+	  functions.
+	* kdb v4.3-2.4.22-ia64-030909-1.
+
+2003-07-20 Keith Owens  <kaos@sgi.com>
+
+	* MCA rendezvous timeout affects kdb_wait_for_cpus_secs.
+	* Support SGI L1 console.
+	* kdb v4.3-2.4.21-ia64-030702-2.
+
+2003-07-08 Keith Owens  <kaos@sgi.com>
+
+	* print_symbol() in mca.c does something useful when kdb is installed.
+	* Unwind and SAL changes removed from kdb, they are in the base kernel.
+	* kdb v4.3-2.4.21-ia64-030702-1.
+
+2003-06-20 Keith Owens  <kaos@sgi.com>
+
+	* Add CONFIG_KDB_CONTINUE_CATASTROPHIC.
+	* Do not send IPI if the machine state does not require them.
+	* Correct definition of KDB_ENTER().
+	* Workaround for broken init monarch handler.
+	* Monarch cpu must get to kdb, even if it was interrupted in user space.
+	* Unwind fixes.
+	* Generalize ia64_spinlock_contention name.
+	* Add kdba_fru for SN machines.
+	* Correct test for cpu number.
+	* kdb v4.3-2.4.20-ia64-020821-1.
+
+2003-05-02 Keith Owens  <kaos@sgi.com>
+
+	* Add kdba_fp_value().
+	* Limit backtrace size to catch loops.
+	* Print spinlock name in ia64_spinlock_contention.
+	* Tweak INIT slave stack lock and handler.
+	* Add read/write access to user pages.  Vamsi Krishna S., IBM
+	* Rename cpu_is_online to cpu_online, as in 2.5.
+	* Clean up USB keyboard support.
+	* Clean up serial console support.
+	* kdb v4.2-2.4.20-ia64-020821-1.
+
+2003-04-04 Keith Owens  <kaos@sgi.com>
+
+	* Add support for INIT slave interrupts.
+	* Tell SAL to always rendezvous on MCA.
+	* No lock on SAL rendezvous call.
+	* Include unwind.c from 2.4.21-pre5.
+	* Rename cpu_online to cpu_is_online.
+	* Workarounds for scheduler bugs.
+	* kdb v4.1-2.4.20-ia64-020821-1.
+
+2003-03-16 Keith Owens  <kaos@sgi.com>
+
+	* Each cpu saves its state as it enters kdb or before it enters code
+	  which cannot call kdb, converting kdb from a pull to a push model.
+	* Clean up kdb interaction with CONFIG_SERIAL_CONSOLE.
+	* Removal of special cases for i386 backtrace from common code
+	  simplifies the architecture code.
+	* Add support for MCA events (both main and rendezvous) plus INIT
+	  monarch event.
+	* Correct decode of brl.
+	* Move kdba_print_nameval to common code.
+	* Generalize kdba unwind handlers.
+	* Fix decode of sal records (fix included in later ia64 kernels).
+	* Handle multiple pt_regs in stack (fix included in later ia64 kernels).
+	* Clean up debug code in unwind (fix included in later ia64 kernels).
+	* Move kdb break numbers to their own file so it can be used in asm.
+	* kdb v4.0-2.4.20-ia64-021210-1.
+
+2003-02-03 Keith Owens  <kaos@sgi.com>
+
+	* Register kdb commands early.
+	* Handle KDB_ENTER() when kdb=off.
+	* Optimize __kdba_getarea_size when width is a constant.
+	* Decode oops via kallsyms if it is available.
+	* Update copyright notices to 2003.
+	* Add commands to dump struct pt_regs and switch_stack.
+	* Handle padding from unw_init_running for switch_stack.
+	* Add dummy kdba_local_arch_setup/kdba_local_arch_cleanup.
+	* Warning for pod mode.
+	* Add command history and editing.  Sonic Zhang.
+	* kdb_toggleled is conditional on KDB_BLINK_LED.  Bernhard Fischer.
+	* Allow tab on serial line for symbol completion.
+	* Ignore KDB_ENTER() when kdb is already running.
+	* kdb v3.0-2.4.20-ia64-021210-1.
+
+2003-01-23 Keith Owens  <kaos@sgi.com>
+
+	* Upgrade to 2.4.20-ia64-021210.
+	* kdb v2.5-2.4.20-ia64-021210-1.
+
+2002-11-14 Keith Owens  <kaos@sgi.com>
+
+	* General clean up of handling for breakpoints and single stepping over
+	  software breakpoints.
+	* kdb v2.5-2.4.19-ia64-020821-1.
+
+2002-10-31 Keith Owens  <kaos@sgi.com>
+
+	* Remove kdb_eframe_t.
+	* Sanity check if we have pt_regs.
+	* Remove kdba_getcurrentframe().
+	* Comments for coexistence with O(1) scheduler.
+	* kdb v2.4-2.4.19-ia64-020821-1.
+
+2002-10-15 Keith Owens  <kaos@sgi.com>
+
+	* Minimize differences between patches for 2.4 and 2.5 kernels.
+	* kdb v2.3-2.4.19-ia64-020821-2.
+
+2002-08-10 Keith Owens  <kaos@sgi.com>
+
+	* Verify rw address for instruction breakpoint.
+	* Replace kdb_port with kdb_serial to support memory mapped I/O.
+	  David Mosberger.
+	  Note: This needs kdb v2.3-2.4.18-common-2 or later.
+	* kdb v2.3-2.4.18-ia64-020722-2.
+
+2002-08-07 Keith Owens  <kaos@sgi.com>
+
+	* Upgrade to 2.4.18-ia64-020722.
+	* Remove individual SGI copyrights, the general SGI copyright applies.
+	* Clean up disassembly layout.  Hugh Dickins, Keith Owens.
+	* Remove fixed KDB_MAX_COMMANDS size.
+	* Add set_fs() around __copy_to_user on kernel addresses.
+	  Randolph Chung.
+	* Position ia64 for CONFIG_NUMA_REPLICATE.
+	* Stacked registers modification support.  Sebastien Lelarge.
+	* USB keyboard support.  Sebastien Lelarge.
+	* kdb v2.3-2.4.18-ia64-020722-1.
+
+2002-03-20 Keith Owens  <kaos@sgi.com>
+
+	* Sync with 2.4.17-sn2.
+	* Add pod command.
+
+2002-02-20 Keith Owens  <kaos@sgi.com>
+
+	* Call kdb from mca handler.  Jenna S. Hall, Intel.
+	* kdb v2.1-2.4.17-ia64-011226-2.
+
+2002-01-18 Keith Owens  <kaos@sgi.com>
+
+	* Replace kdb_get/putword with kdb_get/putarea functions.
+	* Wrap kdb references in #ifdef CONFIG_KDB.
+	* Delete sample i386 code.
+	* Refuse to update kernel text on NUMA systems.
+	* Reject hardware breakpoints, not supported yet.
+	* kdb v2.1-2.4.17-ia64-011226-1.
+
+2002-01-07 Keith Owens  <kaos@sgi.com>
+
+	* Split kdb for ia64 as kdb v2.0-2.4.17-ia64-011226-1.
--- /dev/null
+++ b/arch/ia64/kdb/Makefile
@@ -0,0 +1,21 @@
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License.  See the file "COPYING" in the main directory of this archive
+# for more details.
+#
+# Copyright (c) 1999-2004 Silicon Graphics, Inc.  All Rights Reserved.
+#
+
+obj-y	 := kdba_bt.o kdba_bp.o kdba_io.o kdba_support.o \
+	    cpu-ia64-opc.o ia64-dis.o ia64-opc.o kdba_id.o kdba_jmp.o
+
+# fru does not compile on 2.6.
+# obj-$(CONFIG_IA64_SGI_SN2) += kdba_fru.o
+obj-$(CONFIG_IA64_SGI_SN2) += kdba_pod.o
+obj-$(CONFIG_IA64_GENERIC) += kdba_pod.o
+
+override CFLAGS := $(CFLAGS:%-pg=% )
+
+AFLAGS_kdba_jmp.o += $(AFLAGS_KERNEL)
+
+USE_STANDARD_AS_RULE	:= true
--- /dev/null
+++ b/arch/ia64/kdb/cpu-ia64-opc.c
@@ -0,0 +1,598 @@
+/* Copyright 1998, 1999, 2000, 2001, 2002, 2003
+   Free Software Foundation, Inc.
+   Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* Extracted from binutils 2.16.91.0.2 (OpenSUSE 10.0) and modified for kdb use.
+ * Any trailing whitespace was removed and #ifdef/ifndef __KERNEL__ added as
+ * required.
+ * Keith Owens <kaos@sgi.com> 15 May 2006
+ */
+
+/* Logically, this code should be part of libopcode but since some of
+   the operand insertion/extraction functions help bfd to implement
+   relocations, this code is included as part of cpu-ia64.c.  This
+   avoids circular dependencies between libopcode and libbfd and also
+   obviates the need for applications to link in libopcode when all
+   they really want is libbfd.
+
+   --davidm Mon Apr 13 22:14:02 1998 */
+
+#ifdef __KERNEL__
+#include "ia64-opc.h"
+#else	/* __KERNEL__ */
+#include "../opcodes/ia64-opc.h"
+#endif	/* __KERNEL__ */
+
+#define NELEMS(a)  ((int) (sizeof (a) / sizeof ((a)[0])))
+
+static const char*
+ins_rsvd (const struct ia64_operand *self ATTRIBUTE_UNUSED,
+	  ia64_insn value ATTRIBUTE_UNUSED, ia64_insn *code ATTRIBUTE_UNUSED)
+{
+  return "internal error---this shouldn't happen";
+}
+
+static const char*
+ext_rsvd (const struct ia64_operand *self ATTRIBUTE_UNUSED,
+	  ia64_insn code ATTRIBUTE_UNUSED, ia64_insn *valuep ATTRIBUTE_UNUSED)
+{
+  return "internal error---this shouldn't happen";
+}
+
+static const char*
+ins_const (const struct ia64_operand *self ATTRIBUTE_UNUSED,
+	   ia64_insn value ATTRIBUTE_UNUSED, ia64_insn *code ATTRIBUTE_UNUSED)
+{
+  return 0;
+}
+
+static const char*
+ext_const (const struct ia64_operand *self ATTRIBUTE_UNUSED,
+	   ia64_insn code ATTRIBUTE_UNUSED, ia64_insn *valuep ATTRIBUTE_UNUSED)
+{
+  return 0;
+}
+
+static const char*
+ins_reg (const struct ia64_operand *self, ia64_insn value, ia64_insn *code)
+{
+  if (value >= 1u << self->field[0].bits)
+    return "register number out of range";
+
+  *code |= value << self->field[0].shift;
+  return 0;
+}
+
+static const char*
+ext_reg (const struct ia64_operand *self, ia64_insn code, ia64_insn *valuep)
+{
+  *valuep = ((code >> self->field[0].shift)
+	     & ((1u << self->field[0].bits) - 1));
+  return 0;
+}
+
+static const char*
+ins_immu (const struct ia64_operand *self, ia64_insn value, ia64_insn *code)
+{
+  ia64_insn new = 0;
+  int i;
+
+  for (i = 0; i < NELEMS (self->field) && self->field[i].bits; ++i)
+    {
+      new |= ((value & ((((ia64_insn) 1) << self->field[i].bits) - 1))
+	      << self->field[i].shift);
+      value >>= self->field[i].bits;
+    }
+  if (value)
+    return "integer operand out of range";
+
+  *code |= new;
+  return 0;
+}
+
+static const char*
+ext_immu (const struct ia64_operand *self, ia64_insn code, ia64_insn *valuep)
+{
+  BFD_HOST_U_64_BIT value = 0;
+  int i, bits = 0, total = 0;
+
+  for (i = 0; i < NELEMS (self->field) && self->field[i].bits; ++i)
+    {
+      bits = self->field[i].bits;
+      value |= ((code >> self->field[i].shift)
+		& ((((BFD_HOST_U_64_BIT) 1) << bits) - 1)) << total;
+      total += bits;
+    }
+  *valuep = value;
+  return 0;
+}
+
+static const char*
+ins_immus8 (const struct ia64_operand *self, ia64_insn value, ia64_insn *code)
+{
+  if (value & 0x7)
+    return "value not an integer multiple of 8";
+  return ins_immu (self, value >> 3, code);
+}
+
+static const char*
+ext_immus8 (const struct ia64_operand *self, ia64_insn code, ia64_insn *valuep)
+{
+  const char *result;
+
+  result = ext_immu (self, code, valuep);
+  if (result)
+    return result;
+
+  *valuep = *valuep << 3;
+  return 0;
+}
+
+static const char*
+ins_imms_scaled (const struct ia64_operand *self, ia64_insn value,
+		 ia64_insn *code, int scale)
+{
+  BFD_HOST_64_BIT svalue = value, sign_bit = 0;
+  ia64_insn new = 0;
+  int i;
+
+  svalue >>= scale;
+
+  for (i = 0; i < NELEMS (self->field) && self->field[i].bits; ++i)
+    {
+      new |= ((svalue & ((((ia64_insn) 1) << self->field[i].bits) - 1))
+	      << self->field[i].shift);
+      sign_bit = (svalue >> (self->field[i].bits - 1)) & 1;
+      svalue >>= self->field[i].bits;
+    }
+  if ((!sign_bit && svalue != 0) || (sign_bit && svalue != -1))
+    return "integer operand out of range";
+
+  *code |= new;
+  return 0;
+}
+
+static const char*
+ext_imms_scaled (const struct ia64_operand *self, ia64_insn code,
+		 ia64_insn *valuep, int scale)
+{
+  int i, bits = 0, total = 0;
+  BFD_HOST_64_BIT val = 0, sign;
+
+  for (i = 0; i < NELEMS (self->field) && self->field[i].bits; ++i)
+    {
+      bits = self->field[i].bits;
+      val |= ((code >> self->field[i].shift)
+	      & ((((BFD_HOST_U_64_BIT) 1) << bits) - 1)) << total;
+      total += bits;
+    }
+  /* sign extend: */
+  sign = (BFD_HOST_64_BIT) 1 << (total - 1);
+  val = (val ^ sign) - sign;
+
+  *valuep = (val << scale);
+  return 0;
+}
+
+static const char*
+ins_imms (const struct ia64_operand *self, ia64_insn value, ia64_insn *code)
+{
+  return ins_imms_scaled (self, value, code, 0);
+}
+
+static const char*
+ins_immsu4 (const struct ia64_operand *self, ia64_insn value, ia64_insn *code)
+{
+  value = ((value & 0xffffffff) ^ 0x80000000) - 0x80000000;
+
+  return ins_imms_scaled (self, value, code, 0);
+}
+
+static const char*
+ext_imms (const struct ia64_operand *self, ia64_insn code, ia64_insn *valuep)
+{
+  return ext_imms_scaled (self, code, valuep, 0);
+}
+
+static const char*
+ins_immsm1 (const struct ia64_operand *self, ia64_insn value, ia64_insn *code)
+{
+  --value;
+  return ins_imms_scaled (self, value, code, 0);
+}
+
+static const char*
+ins_immsm1u4 (const struct ia64_operand *self, ia64_insn value,
+	      ia64_insn *code)
+{
+  value = ((value & 0xffffffff) ^ 0x80000000) - 0x80000000;
+
+  --value;
+  return ins_imms_scaled (self, value, code, 0);
+}
+
+static const char*
+ext_immsm1 (const struct ia64_operand *self, ia64_insn code, ia64_insn *valuep)
+{
+  const char *res = ext_imms_scaled (self, code, valuep, 0);
+
+  ++*valuep;
+  return res;
+}
+
+static const char*
+ins_imms1 (const struct ia64_operand *self, ia64_insn value, ia64_insn *code)
+{
+  return ins_imms_scaled (self, value, code, 1);
+}
+
+static const char*
+ext_imms1 (const struct ia64_operand *self, ia64_insn code, ia64_insn *valuep)
+{
+  return ext_imms_scaled (self, code, valuep, 1);
+}
+
+static const char*
+ins_imms4 (const struct ia64_operand *self, ia64_insn value, ia64_insn *code)
+{
+  return ins_imms_scaled (self, value, code, 4);
+}
+
+static const char*
+ext_imms4 (const struct ia64_operand *self, ia64_insn code, ia64_insn *valuep)
+{
+  return ext_imms_scaled (self, code, valuep, 4);
+}
+
+static const char*
+ins_imms16 (const struct ia64_operand *self, ia64_insn value, ia64_insn *code)
+{
+  return ins_imms_scaled (self, value, code, 16);
+}
+
+static const char*
+ext_imms16 (const struct ia64_operand *self, ia64_insn code, ia64_insn *valuep)
+{
+  return ext_imms_scaled (self, code, valuep, 16);
+}
+
+static const char*
+ins_cimmu (const struct ia64_operand *self, ia64_insn value, ia64_insn *code)
+{
+  ia64_insn mask = (((ia64_insn) 1) << self->field[0].bits) - 1;
+  return ins_immu (self, value ^ mask, code);
+}
+
+static const char*
+ext_cimmu (const struct ia64_operand *self, ia64_insn code, ia64_insn *valuep)
+{
+  const char *result;
+  ia64_insn mask;
+
+  mask = (((ia64_insn) 1) << self->field[0].bits) - 1;
+  result = ext_immu (self, code, valuep);
+  if (!result)
+    {
+      mask = (((ia64_insn) 1) << self->field[0].bits) - 1;
+      *valuep ^= mask;
+    }
+  return result;
+}
+
+static const char*
+ins_cnt (const struct ia64_operand *self, ia64_insn value, ia64_insn *code)
+{
+  --value;
+  if (value >= ((BFD_HOST_U_64_BIT) 1) << self->field[0].bits)
+    return "count out of range";
+
+  *code |= value << self->field[0].shift;
+  return 0;
+}
+
+static const char*
+ext_cnt (const struct ia64_operand *self, ia64_insn code, ia64_insn *valuep)
+{
+  *valuep = ((code >> self->field[0].shift)
+	     & ((((BFD_HOST_U_64_BIT) 1) << self->field[0].bits) - 1)) + 1;
+  return 0;
+}
+
+static const char*
+ins_cnt2b (const struct ia64_operand *self, ia64_insn value, ia64_insn *code)
+{
+  --value;
+
+  if (value > 2)
+    return "count must be in range 1..3";
+
+  *code |= value << self->field[0].shift;
+  return 0;
+}
+
+static const char*
+ext_cnt2b (const struct ia64_operand *self, ia64_insn code, ia64_insn *valuep)
+{
+  *valuep = ((code >> self->field[0].shift) & 0x3) + 1;
+  return 0;
+}
+
+static const char*
+ins_cnt2c (const struct ia64_operand *self, ia64_insn value, ia64_insn *code)
+{
+  switch (value)
+    {
+    case 0:	value = 0; break;
+    case 7:	value = 1; break;
+    case 15:	value = 2; break;
+    case 16:	value = 3; break;
+    default:	return "count must be 0, 7, 15, or 16";
+    }
+  *code |= value << self->field[0].shift;
+  return 0;
+}
+
+static const char*
+ext_cnt2c (const struct ia64_operand *self, ia64_insn code, ia64_insn *valuep)
+{
+  ia64_insn value;
+
+  value = (code >> self->field[0].shift) & 0x3;
+  switch (value)
+    {
+    case 0: value =  0; break;
+    case 1: value =  7; break;
+    case 2: value = 15; break;
+    case 3: value = 16; break;
+    }
+  *valuep = value;
+  return 0;
+}
+
+static const char*
+ins_inc3 (const struct ia64_operand *self, ia64_insn value, ia64_insn *code)
+{
+  BFD_HOST_64_BIT val = value;
+  BFD_HOST_U_64_BIT sign = 0;
+
+  if (val < 0)
+    {
+      sign = 0x4;
+      value = -value;
+    }
+  switch (value)
+    {
+    case  1:	value = 3; break;
+    case  4:	value = 2; break;
+    case  8:	value = 1; break;
+    case 16:	value = 0; break;
+    default:	return "count must be +/- 1, 4, 8, or 16";
+    }
+  *code |= (sign | value) << self->field[0].shift;
+  return 0;
+}
+
+static const char*
+ext_inc3 (const struct ia64_operand *self, ia64_insn code, ia64_insn *valuep)
+{
+  BFD_HOST_64_BIT val;
+  int negate;
+
+  val = (code >> self->field[0].shift) & 0x7;
+  negate = val & 0x4;
+  switch (val & 0x3)
+    {
+    case 0: val = 16; break;
+    case 1: val =  8; break;
+    case 2: val =  4; break;
+    case 3: val =  1; break;
+    }
+  if (negate)
+    val = -val;
+
+  *valuep = val;
+  return 0;
+}
+
+#define CST	IA64_OPND_CLASS_CST
+#define REG	IA64_OPND_CLASS_REG
+#define IND	IA64_OPND_CLASS_IND
+#define ABS	IA64_OPND_CLASS_ABS
+#define REL	IA64_OPND_CLASS_REL
+
+#define SDEC	IA64_OPND_FLAG_DECIMAL_SIGNED
+#define UDEC	IA64_OPND_FLAG_DECIMAL_UNSIGNED
+
+const struct ia64_operand elf64_ia64_operands[IA64_OPND_COUNT] =
+  {
+    /* constants: */
+    { CST, ins_const, ext_const, "NIL",		{{ 0, 0}}, 0, "<none>" },
+    { CST, ins_const, ext_const, "ar.csd",	{{ 0, 0}}, 0, "ar.csd" },
+    { CST, ins_const, ext_const, "ar.ccv",	{{ 0, 0}}, 0, "ar.ccv" },
+    { CST, ins_const, ext_const, "ar.pfs",	{{ 0, 0}}, 0, "ar.pfs" },
+    { CST, ins_const, ext_const, "1",		{{ 0, 0}}, 0, "1" },
+    { CST, ins_const, ext_const, "8",		{{ 0, 0}}, 0, "8" },
+    { CST, ins_const, ext_const, "16",		{{ 0, 0}}, 0, "16" },
+    { CST, ins_const, ext_const, "r0",		{{ 0, 0}}, 0, "r0" },
+    { CST, ins_const, ext_const, "ip",		{{ 0, 0}}, 0, "ip" },
+    { CST, ins_const, ext_const, "pr",		{{ 0, 0}}, 0, "pr" },
+    { CST, ins_const, ext_const, "pr.rot",	{{ 0, 0}}, 0, "pr.rot" },
+    { CST, ins_const, ext_const, "psr",		{{ 0, 0}}, 0, "psr" },
+    { CST, ins_const, ext_const, "psr.l",	{{ 0, 0}}, 0, "psr.l" },
+    { CST, ins_const, ext_const, "psr.um",	{{ 0, 0}}, 0, "psr.um" },
+
+    /* register operands: */
+    { REG, ins_reg,   ext_reg,	"ar", {{ 7, 20}}, 0,		/* AR3 */
+      "an application register" },
+    { REG, ins_reg,   ext_reg,	 "b", {{ 3,  6}}, 0,		/* B1 */
+      "a branch register" },
+    { REG, ins_reg,   ext_reg,	 "b", {{ 3, 13}}, 0,		/* B2 */
+      "a branch register"},
+    { REG, ins_reg,   ext_reg,	"cr", {{ 7, 20}}, 0,		/* CR */
+      "a control register"},
+    { REG, ins_reg,   ext_reg,	 "f", {{ 7,  6}}, 0,		/* F1 */
+      "a floating-point register" },
+    { REG, ins_reg,   ext_reg,	 "f", {{ 7, 13}}, 0,		/* F2 */
+      "a floating-point register" },
+    { REG, ins_reg,   ext_reg,	 "f", {{ 7, 20}}, 0,		/* F3 */
+      "a floating-point register" },
+    { REG, ins_reg,   ext_reg,	 "f", {{ 7, 27}}, 0,		/* F4 */
+      "a floating-point register" },
+    { REG, ins_reg,   ext_reg,	 "p", {{ 6,  6}}, 0,		/* P1 */
+      "a predicate register" },
+    { REG, ins_reg,   ext_reg,	 "p", {{ 6, 27}}, 0,		/* P2 */
+      "a predicate register" },
+    { REG, ins_reg,   ext_reg,	 "r", {{ 7,  6}}, 0,		/* R1 */
+      "a general register" },
+    { REG, ins_reg,   ext_reg,	 "r", {{ 7, 13}}, 0,		/* R2 */
+      "a general register" },
+    { REG, ins_reg,   ext_reg,	 "r", {{ 7, 20}}, 0,		/* R3 */
+      "a general register" },
+    { REG, ins_reg,   ext_reg,	 "r", {{ 2, 20}}, 0,		/* R3_2 */
+      "a general register r0-r3" },
+
+    /* indirect operands: */
+    { IND, ins_reg,   ext_reg,	"cpuid", {{7, 20}}, 0,		/* CPUID_R3 */
+      "a cpuid register" },
+    { IND, ins_reg,   ext_reg,	"dbr",   {{7, 20}}, 0,		/* DBR_R3 */
+      "a dbr register" },
+    { IND, ins_reg,   ext_reg,	"dtr",   {{7, 20}}, 0,		/* DTR_R3 */
+      "a dtr register" },
+    { IND, ins_reg,   ext_reg,	"itr",   {{7, 20}}, 0,		/* ITR_R3 */
+      "an itr register" },
+    { IND, ins_reg,   ext_reg,	"ibr",   {{7, 20}}, 0,		/* IBR_R3 */
+      "an ibr register" },
+    { IND, ins_reg,   ext_reg,	"",      {{7, 20}}, 0,		/* MR3 */
+      "an indirect memory address" },
+    { IND, ins_reg,   ext_reg,	"msr",   {{7, 20}}, 0,		/* MSR_R3 */
+      "an msr register" },
+    { IND, ins_reg,   ext_reg,	"pkr",   {{7, 20}}, 0,		/* PKR_R3 */
+      "a pkr register" },
+    { IND, ins_reg,   ext_reg,	"pmc",   {{7, 20}}, 0,		/* PMC_R3 */
+      "a pmc register" },
+    { IND, ins_reg,   ext_reg,	"pmd",   {{7, 20}}, 0,		/* PMD_R3 */
+      "a pmd register" },
+    { IND, ins_reg,   ext_reg,	"rr",    {{7, 20}}, 0,		/* RR_R3 */
+      "an rr register" },
+
+    /* immediate operands: */
+    { ABS, ins_cimmu, ext_cimmu, 0, {{ 5, 20 }}, UDEC,		/* CCNT5 */
+      "a 5-bit count (0-31)" },
+    { ABS, ins_cnt,   ext_cnt,   0, {{ 2, 27 }}, UDEC,		/* CNT2a */
+      "a 2-bit count (1-4)" },
+    { ABS, ins_cnt2b, ext_cnt2b, 0, {{ 2, 27 }}, UDEC,		/* CNT2b */
+      "a 2-bit count (1-3)" },
+    { ABS, ins_cnt2c, ext_cnt2c, 0, {{ 2, 30 }}, UDEC,		/* CNT2c */
+      "a count (0, 7, 15, or 16)" },
+    { ABS, ins_immu,  ext_immu,  0, {{ 5, 14}}, UDEC,		/* CNT5 */
+      "a 5-bit count (0-31)" },
+    { ABS, ins_immu,  ext_immu,  0, {{ 6, 27}}, UDEC,		/* CNT6 */
+      "a 6-bit count (0-63)" },
+    { ABS, ins_cimmu, ext_cimmu, 0, {{ 6, 20}}, UDEC,		/* CPOS6a */
+      "a 6-bit bit pos (0-63)" },
+    { ABS, ins_cimmu, ext_cimmu, 0, {{ 6, 14}}, UDEC,		/* CPOS6b */
+      "a 6-bit bit pos (0-63)" },
+    { ABS, ins_cimmu, ext_cimmu, 0, {{ 6, 31}}, UDEC,		/* CPOS6c */
+      "a 6-bit bit pos (0-63)" },
+    { ABS, ins_imms,  ext_imms,  0, {{ 1, 36}}, SDEC,		/* IMM1 */
+      "a 1-bit integer (-1, 0)" },
+    { ABS, ins_immu,  ext_immu,  0, {{ 2, 13}}, UDEC,		/* IMMU2 */
+      "a 2-bit unsigned (0-3)" },
+    { ABS, ins_immu,  ext_immu,  0, {{ 7, 13}}, 0,		/* IMMU7a */
+      "a 7-bit unsigned (0-127)" },
+    { ABS, ins_immu,  ext_immu,  0, {{ 7, 20}}, 0,		/* IMMU7b */
+      "a 7-bit unsigned (0-127)" },
+    { ABS, ins_immu,  ext_immu,  0, {{ 7, 13}}, UDEC,		/* SOF */
+      "a frame size (register count)" },
+    { ABS, ins_immu,  ext_immu,  0, {{ 7, 20}}, UDEC,		/* SOL */
+      "a local register count" },
+    { ABS, ins_immus8,ext_immus8,0, {{ 4, 27}}, UDEC,		/* SOR */
+      "a rotating register count (integer multiple of 8)" },
+    { ABS, ins_imms,  ext_imms,  0,				/* IMM8 */
+      {{ 7, 13}, { 1, 36}}, SDEC,
+      "an 8-bit integer (-128-127)" },
+    { ABS, ins_immsu4,  ext_imms,  0,				/* IMM8U4 */
+      {{ 7, 13}, { 1, 36}}, SDEC,
+      "an 8-bit signed integer for 32-bit unsigned compare (-128-127)" },
+    { ABS, ins_immsm1,  ext_immsm1,  0,				/* IMM8M1 */
+      {{ 7, 13}, { 1, 36}}, SDEC,
+      "an 8-bit integer (-127-128)" },
+    { ABS, ins_immsm1u4,  ext_immsm1,  0,			/* IMM8M1U4 */
+      {{ 7, 13}, { 1, 36}}, SDEC,
+      "an 8-bit integer for 32-bit unsigned compare (-127-(-1),1-128,0x100000000)" },
+    { ABS, ins_immsm1,  ext_immsm1,  0,				/* IMM8M1U8 */
+      {{ 7, 13}, { 1, 36}}, SDEC,
+      "an 8-bit integer for 64-bit unsigned compare (-127-(-1),1-128,0x10000000000000000)" },
+    { ABS, ins_immu,  ext_immu,  0, {{ 2, 33}, { 7, 20}}, 0,	/* IMMU9 */
+      "a 9-bit unsigned (0-511)" },
+    { ABS, ins_imms,  ext_imms,  0,				/* IMM9a */
+      {{ 7,  6}, { 1, 27}, { 1, 36}}, SDEC,
+      "a 9-bit integer (-256-255)" },
+    { ABS, ins_imms,  ext_imms, 0,				/* IMM9b */
+      {{ 7, 13}, { 1, 27}, { 1, 36}}, SDEC,
+      "a 9-bit integer (-256-255)" },
+    { ABS, ins_imms,  ext_imms, 0,				/* IMM14 */
+      {{ 7, 13}, { 6, 27}, { 1, 36}}, SDEC,
+      "a 14-bit integer (-8192-8191)" },
+    { ABS, ins_imms1, ext_imms1, 0,				/* IMM17 */
+      {{ 7,  6}, { 8, 24}, { 1, 36}}, 0,
+      "a 17-bit integer (-65536-65535)" },
+    { ABS, ins_immu,  ext_immu,  0, {{20,  6}, { 1, 36}}, 0,	/* IMMU21 */
+      "a 21-bit unsigned" },
+    { ABS, ins_imms,  ext_imms,  0,				/* IMM22 */
+      {{ 7, 13}, { 9, 27}, { 5, 22}, { 1, 36}}, SDEC,
+      "a 22-bit signed integer" },
+    { ABS, ins_immu,  ext_immu,  0,				/* IMMU24 */
+      {{21,  6}, { 2, 31}, { 1, 36}}, 0,
+      "a 24-bit unsigned" },
+    { ABS, ins_imms16,ext_imms16,0, {{27,  6}, { 1, 36}}, 0,	/* IMM44 */
+      "a 44-bit unsigned (least 16 bits ignored/zeroes)" },
+    { ABS, ins_rsvd,  ext_rsvd,	0, {{0,  0}}, 0,		/* IMMU62 */
+      "a 62-bit unsigned" },
+    { ABS, ins_rsvd,  ext_rsvd,	0, {{0,  0}}, 0,		/* IMMU64 */
+      "a 64-bit unsigned" },
+    { ABS, ins_inc3,  ext_inc3,  0, {{ 3, 13}}, SDEC,		/* INC3 */
+      "an increment (+/- 1, 4, 8, or 16)" },
+    { ABS, ins_cnt,   ext_cnt,   0, {{ 4, 27}}, UDEC,		/* LEN4 */
+      "a 4-bit length (1-16)" },
+    { ABS, ins_cnt,   ext_cnt,   0, {{ 6, 27}}, UDEC,		/* LEN6 */
+      "a 6-bit length (1-64)" },
+    { ABS, ins_immu,  ext_immu,  0, {{ 4, 20}},	0,		/* MBTYPE4 */
+      "a mix type (@rev, @mix, @shuf, @alt, or @brcst)" },
+    { ABS, ins_immu,  ext_immu,  0, {{ 8, 20}},	0,		/* MBTYPE8 */
+      "an 8-bit mix type" },
+    { ABS, ins_immu,  ext_immu,  0, {{ 6, 14}}, UDEC,		/* POS6 */
+      "a 6-bit bit pos (0-63)" },
+    { REL, ins_imms4, ext_imms4, 0, {{ 7,  6}, { 2, 33}}, 0,	/* TAG13 */
+      "a branch tag" },
+    { REL, ins_imms4, ext_imms4, 0, {{ 9, 24}}, 0,		/* TAG13b */
+      "a branch tag" },
+    { REL, ins_imms4, ext_imms4, 0, {{20,  6}, { 1, 36}}, 0,	/* TGT25 */
+      "a branch target" },
+    { REL, ins_imms4, ext_imms4, 0,				/* TGT25b */
+      {{ 7,  6}, {13, 20}, { 1, 36}}, 0,
+      "a branch target" },
+    { REL, ins_imms4, ext_imms4, 0, {{20, 13}, { 1, 36}}, 0,	/* TGT25c */
+      "a branch target" },
+    { REL, ins_rsvd, ext_rsvd, 0, {{0, 0}}, 0,                  /* TGT64  */
+      "a branch target" },
+
+    { ABS, ins_const, ext_const, 0, {{0, 0}}, 0,		/* LDXMOV */
+      "ldxmov target" },
+  };
--- /dev/null
+++ b/arch/ia64/kdb/ia64-asmtab.c
@@ -0,0 +1,8585 @@
+/* This file is automatically generated by ia64-gen.  Do not edit!  */
+
+/* Extracted from binutils 2.16.91.0.2 (OpenSUSE 10.0) and modified for kdb use.
+ * Any trailing whitespace was removed and #ifdef/ifndef __KERNEL__ added as
+ * required.
+ * Keith Owens <kaos@sgi.com> 15 May 2006
+ */
+
+static const char * const ia64_strings[] = {
+  "", "0", "1", "a", "acq", "add", "addl", "addp4", "adds", "alloc", "and",
+  "andcm", "b", "bias", "br", "break", "brl", "brp", "bsw", "c", "call",
+  "cexit", "chk", "cloop", "clr", "clrrrb", "cmp", "cmp4", "cmp8xchg16",
+  "cmpxchg1", "cmpxchg2", "cmpxchg4", "cmpxchg8", "cond", "cover", "ctop",
+  "czx1", "czx2", "d", "dep", "dpnt", "dptk", "e", "epc", "eq", "excl",
+  "exit", "exp", "extr", "f", "fabs", "fadd", "famax", "famin", "fand",
+  "fandcm", "fault", "fc", "fchkf", "fclass", "fclrf", "fcmp", "fcvt",
+  "fetchadd4", "fetchadd8", "few", "fill", "flushrs", "fma", "fmax",
+  "fmerge", "fmin", "fmix", "fmpy", "fms", "fneg", "fnegabs", "fnma",
+  "fnmpy", "fnorm", "for", "fpabs", "fpack", "fpamax", "fpamin", "fpcmp",
+  "fpcvt", "fpma", "fpmax", "fpmerge", "fpmin", "fpmpy", "fpms", "fpneg",
+  "fpnegabs", "fpnma", "fpnmpy", "fprcpa", "fprsqrta", "frcpa", "frsqrta",
+  "fselect", "fsetc", "fsub", "fswap", "fsxt", "fwb", "fx", "fxor", "fxu",
+  "g", "ga", "ge", "getf", "geu", "gt", "gtu", "h", "hint", "hu", "i", "ia",
+  "imp", "invala", "itc", "itr", "l", "ld1", "ld16", "ld2", "ld4", "ld8",
+  "ldf", "ldf8", "ldfd", "ldfe", "ldfp8", "ldfpd", "ldfps", "ldfs", "le",
+  "leu", "lfetch", "loadrs", "loop", "lr", "lt", "ltu", "lu", "m", "many",
+  "mf", "mix1", "mix2", "mix4", "mov", "movl", "mux1", "mux2", "nc", "ne",
+  "neq", "nge", "ngt", "nl", "nle", "nlt", "nm", "nop", "nr", "ns", "nt1",
+  "nt2", "nta", "nz", "or", "orcm", "ord", "pack2", "pack4", "padd1",
+  "padd2", "padd4", "pavg1", "pavg2", "pavgsub1", "pavgsub2", "pcmp1",
+  "pcmp2", "pcmp4", "pmax1", "pmax2", "pmin1", "pmin2", "pmpy2", "pmpyshr2",
+  "popcnt", "pr", "probe", "psad1", "pshl2", "pshl4", "pshladd2", "pshr2",
+  "pshr4", "pshradd2", "psub1", "psub2", "psub4", "ptc", "ptr", "r", "raz",
+  "rel", "ret", "rfi", "rsm", "rum", "rw", "s", "s0", "s1", "s2", "s3",
+  "sa", "se", "setf", "shl", "shladd", "shladdp4", "shr", "shrp", "sig",
+  "spill", "spnt", "sptk", "srlz", "ssm", "sss", "st1", "st16", "st2",
+  "st4", "st8", "stf", "stf8", "stfd", "stfe", "stfs", "sub", "sum", "sxt1",
+  "sxt2", "sxt4", "sync", "tak", "tbit", "thash", "tnat", "tpa", "trunc",
+  "ttag", "u", "unc", "unord", "unpack1", "unpack2", "unpack4", "uss",
+  "uus", "uuu", "w", "wexit", "wtop", "x", "xchg1", "xchg2", "xchg4",
+  "xchg8", "xf", "xma", "xmpy", "xor", "xuf", "z", "zxt1", "zxt2", "zxt4",
+};
+
+static const struct ia64_dependency
+dependencies[] = {
+  { "ALAT", 0, 0, 0, -1, NULL, },
+  { "AR[BSP]", 26, 0, 2, 17, NULL, },
+  { "AR[BSPSTORE]", 26, 0, 2, 18, NULL, },
+  { "AR[CFLG]", 26, 0, 2, 27, NULL, },
+  { "AR[CCV]", 26, 0, 2, 32, NULL, },
+  { "AR[CSD]", 26, 0, 2, 25, NULL, },
+  { "AR[EC]", 26, 0, 2, 66, NULL, },
+  { "AR[EFLAG]", 26, 0, 2, 24, NULL, },
+  { "AR[FCR]", 26, 0, 2, 21, NULL, },
+  { "AR[FDR]", 26, 0, 2, 30, NULL, },
+  { "AR[FIR]", 26, 0, 2, 29, NULL, },
+  { "AR[FPSR].sf0.controls", 30, 0, 2, -1, NULL, },
+  { "AR[FPSR].sf1.controls", 30, 0, 2, -1, NULL, },
+  { "AR[FPSR].sf2.controls", 30, 0, 2, -1, NULL, },
+  { "AR[FPSR].sf3.controls", 30, 0, 2, -1, NULL, },
+  { "AR[FPSR].sf0.flags", 30, 0, 2, -1, NULL, },
+  { "AR[FPSR].sf1.flags", 30, 0, 2, -1, NULL, },
+  { "AR[FPSR].sf2.flags", 30, 0, 2, -1, NULL, },
+  { "AR[FPSR].sf3.flags", 30, 0, 2, -1, NULL, },
+  { "AR[FPSR].traps", 30, 0, 2, -1, NULL, },
+  { "AR[FPSR].rv", 30, 0, 2, -1, NULL, },
+  { "AR[FSR]", 26, 0, 2, 28, NULL, },
+  { "AR[ITC]", 26, 0, 2, 44, NULL, },
+  { "AR[K%], % in 0 - 7", 1, 0, 2, -1, NULL, },
+  { "AR[LC]", 26, 0, 2, 65, NULL, },
+  { "AR[PFS]", 26, 0, 2, 64, NULL, },
+  { "AR[PFS]", 26, 0, 2, 64, NULL, },
+  { "AR[PFS]", 26, 0, 0, 64, NULL, },
+  { "AR[RNAT]", 26, 0, 2, 19, NULL, },
+  { "AR[RSC]", 26, 0, 2, 16, NULL, },
+  { "AR[SSD]", 26, 0, 2, 26, NULL, },
+  { "AR[UNAT]{%}, % in 0 - 63", 2, 0, 2, -1, NULL, },
+  { "AR%, % in 8-15, 20, 22-23, 31, 33-35, 37-39, 41-43, 45-47, 67-111", 3, 0, 0, -1, NULL, },
+  { "AR%, % in 48-63, 112-127", 4, 0, 2, -1, NULL, },
+  { "BR%, % in 0 - 7", 5, 0, 2, -1, NULL, },
+  { "BR%, % in 0 - 7", 5, 0, 0, -1, NULL, },
+  { "BR%, % in 0 - 7", 5, 0, 2, -1, NULL, },
+  { "CFM", 6, 0, 2, -1, NULL, },
+  { "CFM", 6, 0, 2, -1, NULL, },
+  { "CFM", 6, 0, 2, -1, NULL, },
+  { "CFM", 6, 0, 2, -1, NULL, },
+  { "CFM", 6, 0, 0, -1, NULL, },
+  { "CPUID#", 7, 0, 5, -1, NULL, },
+  { "CR[CMCV]", 27, 0, 3, 74, NULL, },
+  { "CR[DCR]", 27, 0, 3, 0, NULL, },
+  { "CR[EOI]", 27, 0, 7, 67, "SC Section 10.8.3.4", },
+  { "CR[GPTA]", 27, 0, 3, 9, NULL, },
+  { "CR[IFA]", 27, 0, 1, 20, NULL, },
+  { "CR[IFA]", 27, 0, 3, 20, NULL, },
+  { "CR[IFS]", 27, 0, 3, 23, NULL, },
+  { "CR[IFS]", 27, 0, 1, 23, NULL, },
+  { "CR[IFS]", 27, 0, 1, 23, NULL, },
+  { "CR[IHA]", 27, 0, 3, 25, NULL, },
+  { "CR[IIM]", 27, 0, 3, 24, NULL, },
+  { "CR[IIP]", 27, 0, 3, 19, NULL, },
+  { "CR[IIP]", 27, 0, 1, 19, NULL, },
+  { "CR[IIPA]", 27, 0, 3, 22, NULL, },
+  { "CR[IPSR]", 27, 0, 3, 16, NULL, },
+  { "CR[IPSR]", 27, 0, 1, 16, NULL, },
+  { "CR[IRR%], % in 0 - 3", 8, 0, 3, -1, NULL, },
+  { "CR[ISR]", 27, 0, 3, 17, NULL, },
+  { "CR[ITIR]", 27, 0, 3, 21, NULL, },
+  { "CR[ITIR]", 27, 0, 1, 21, NULL, },
+  { "CR[ITM]", 27, 0, 3, 1, NULL, },
+  { "CR[ITV]", 27, 0, 3, 72, NULL, },
+  { "CR[IVA]", 27, 0, 4, 2, NULL, },
+  { "CR[IVR]", 27, 0, 7, 65, "SC Section 10.8.3.2", },
+  { "CR[LID]", 27, 0, 7, 64, "SC Section 10.8.3.1", },
+  { "CR[LRR%], % in 0 - 1", 9, 0, 3, -1, NULL, },
+  { "CR[PMV]", 27, 0, 3, 73, NULL, },
+  { "CR[PTA]", 27, 0, 3, 8, NULL, },
+  { "CR[TPR]", 27, 0, 3, 66, NULL, },
+  { "CR[TPR]", 27, 0, 7, 66, "SC Section 10.8.3.3", },
+  { "CR%, % in 3-7, 10-15, 18, 26-63, 75-79, 82-127", 10, 0, 0, -1, NULL, },
+  { "DBR#", 11, 0, 2, -1, NULL, },
+  { "DBR#", 11, 0, 3, -1, NULL, },
+  { "DTC", 0, 0, 3, -1, NULL, },
+  { "DTC", 0, 0, 2, -1, NULL, },
+  { "DTC", 0, 0, 0, -1, NULL, },
+  { "DTC", 0, 0, 2, -1, NULL, },
+  { "DTC_LIMIT*", 0, 0, 2, -1, NULL, },
+  { "DTR", 0, 0, 3, -1, NULL, },
+  { "DTR", 0, 0, 2, -1, NULL, },
+  { "DTR", 0, 0, 3, -1, NULL, },
+  { "DTR", 0, 0, 0, -1, NULL, },
+  { "DTR", 0, 0, 2, -1, NULL, },
+  { "FR%, % in 0 - 1", 12, 0, 0, -1, NULL, },
+  { "FR%, % in 2 - 127", 13, 0, 2, -1, NULL, },
+  { "FR%, % in 2 - 127", 13, 0, 0, -1, NULL, },
+  { "GR0", 14, 0, 0, -1, NULL, },
+  { "GR%, % in 1 - 127", 15, 0, 0, -1, NULL, },
+  { "GR%, % in 1 - 127", 15, 0, 2, -1, NULL, },
+  { "IBR#", 16, 0, 2, -1, NULL, },
+  { "InService*", 17, 0, 3, -1, NULL, },
+  { "InService*", 17, 0, 2, -1, NULL, },
+  { "InService*", 17, 0, 2, -1, NULL, },
+  { "IP", 0, 0, 0, -1, NULL, },
+  { "ITC", 0, 0, 4, -1, NULL, },
+  { "ITC", 0, 0, 2, -1, NULL, },
+  { "ITC", 0, 0, 0, -1, NULL, },
+  { "ITC", 0, 0, 4, -1, NULL, },
+  { "ITC", 0, 0, 2, -1, NULL, },
+  { "ITC_LIMIT*", 0, 0, 2, -1, NULL, },
+  { "ITR", 0, 0, 2, -1, NULL, },
+  { "ITR", 0, 0, 4, -1, NULL, },
+  { "ITR", 0, 0, 2, -1, NULL, },
+  { "ITR", 0, 0, 0, -1, NULL, },
+  { "ITR", 0, 0, 4, -1, NULL, },
+  { "memory", 0, 0, 0, -1, NULL, },
+  { "MSR#", 18, 0, 5, -1, NULL, },
+  { "PKR#", 19, 0, 3, -1, NULL, },
+  { "PKR#", 19, 0, 0, -1, NULL, },
+  { "PKR#", 19, 0, 2, -1, NULL, },
+  { "PKR#", 19, 0, 2, -1, NULL, },
+  { "PMC#", 20, 0, 2, -1, NULL, },
+  { "PMC#", 20, 0, 7, -1, "SC+3 Section 12.1.1", },
+  { "PMD#", 21, 0, 2, -1, NULL, },
+  { "PR0", 0, 0, 0, -1, NULL, },
+  { "PR%, % in 1 - 15", 22, 0, 2, -1, NULL, },
+  { "PR%, % in 1 - 15", 22, 0, 2, -1, NULL, },
+  { "PR%, % in 1 - 15", 22, 0, 0, -1, NULL, },
+  { "PR%, % in 16 - 62", 23, 0, 2, -1, NULL, },
+  { "PR%, % in 16 - 62", 23, 0, 2, -1, NULL, },
+  { "PR%, % in 16 - 62", 23, 0, 0, -1, NULL, },
+  { "PR63", 24, 0, 2, -1, NULL, },
+  { "PR63", 24, 0, 2, -1, NULL, },
+  { "PR63", 24, 0, 0, -1, NULL, },
+  { "PSR.ac", 28, 0, 1, 3, NULL, },
+  { "PSR.ac", 28, 0, 3, 3, NULL, },
+  { "PSR.ac", 28, 0, 2, 3, NULL, },
+  { "PSR.be", 28, 0, 1, 1, NULL, },
+  { "PSR.be", 28, 0, 3, 1, NULL, },
+  { "PSR.be", 28, 0, 2, 1, NULL, },
+  { "PSR.bn", 28, 0, 2, 44, NULL, },
+  { "PSR.cpl", 28, 0, 1, 32, NULL, },
+  { "PSR.da", 28, 0, 3, 38, NULL, },
+  { "PSR.db", 28, 0, 3, 24, NULL, },
+  { "PSR.db", 28, 0, 2, 24, NULL, },
+  { "PSR.db", 28, 0, 3, 24, NULL, },
+  { "PSR.dd", 28, 0, 3, 39, NULL, },
+  { "PSR.dfh", 28, 0, 3, 19, NULL, },
+  { "PSR.dfh", 28, 0, 2, 19, NULL, },
+  { "PSR.dfl", 28, 0, 3, 18, NULL, },
+  { "PSR.dfl", 28, 0, 2, 18, NULL, },
+  { "PSR.di", 28, 0, 3, 22, NULL, },
+  { "PSR.di", 28, 0, 2, 22, NULL, },
+  { "PSR.dt", 28, 0, 3, 17, NULL, },
+  { "PSR.dt", 28, 0, 2, 17, NULL, },
+  { "PSR.ed", 28, 0, 3, 43, NULL, },
+  { "PSR.i", 28, 0, 2, 14, NULL, },
+  { "PSR.i", 28, 0, 3, 14, NULL, },
+  { "PSR.ia", 28, 0, 0, 14, NULL, },
+  { "PSR.ic", 28, 0, 2, 13, NULL, },
+  { "PSR.ic", 28, 0, 3, 13, NULL, },
+  { "PSR.id", 28, 0, 0, 14, NULL, },
+  { "PSR.is", 28, 0, 0, 14, NULL, },
+  { "PSR.it", 28, 0, 3, 14, NULL, },
+  { "PSR.lp", 28, 0, 2, 25, NULL, },
+  { "PSR.lp", 28, 0, 3, 25, NULL, },
+  { "PSR.lp", 28, 0, 3, 25, NULL, },
+  { "PSR.mc", 28, 0, 0, 35, NULL, },
+  { "PSR.mfh", 28, 0, 2, 5, NULL, },
+  { "PSR.mfl", 28, 0, 2, 4, NULL, },
+  { "PSR.pk", 28, 0, 3, 15, NULL, },
+  { "PSR.pk", 28, 0, 2, 15, NULL, },
+  { "PSR.pp", 28, 0, 2, 21, NULL, },
+  { "PSR.ri", 28, 0, 0, 41, NULL, },
+  { "PSR.rt", 28, 0, 2, 27, NULL, },
+  { "PSR.rt", 28, 0, 3, 27, NULL, },
+  { "PSR.rt", 28, 0, 3, 27, NULL, },
+  { "PSR.si", 28, 0, 2, 23, NULL, },
+  { "PSR.si", 28, 0, 3, 23, NULL, },
+  { "PSR.sp", 28, 0, 2, 20, NULL, },
+  { "PSR.sp", 28, 0, 3, 20, NULL, },
+  { "PSR.ss", 28, 0, 3, 40, NULL, },
+  { "PSR.tb", 28, 0, 3, 26, NULL, },
+  { "PSR.tb", 28, 0, 2, 26, NULL, },
+  { "PSR.up", 28, 0, 2, 2, NULL, },
+  { "RR#", 25, 0, 3, -1, NULL, },
+  { "RR#", 25, 0, 2, -1, NULL, },
+  { "RSE", 29, 0, 2, -1, NULL, },
+  { "ALAT", 0, 1, 0, -1, NULL, },
+  { "AR[BSP]", 26, 1, 2, 17, NULL, },
+  { "AR[BSPSTORE]", 26, 1, 2, 18, NULL, },
+  { "AR[CCV]", 26, 1, 2, 32, NULL, },
+  { "AR[CFLG]", 26, 1, 2, 27, NULL, },
+  { "AR[CSD]", 26, 1, 2, 25, NULL, },
+  { "AR[EC]", 26, 1, 2, 66, NULL, },
+  { "AR[EFLAG]", 26, 1, 2, 24, NULL, },
+  { "AR[FCR]", 26, 1, 2, 21, NULL, },
+  { "AR[FDR]", 26, 1, 2, 30, NULL, },
+  { "AR[FIR]", 26, 1, 2, 29, NULL, },
+  { "AR[FPSR].sf0.controls", 30, 1, 2, -1, NULL, },
+  { "AR[FPSR].sf1.controls", 30, 1, 2, -1, NULL, },
+  { "AR[FPSR].sf2.controls", 30, 1, 2, -1, NULL, },
+  { "AR[FPSR].sf3.controls", 30, 1, 2, -1, NULL, },
+  { "AR[FPSR].sf0.flags", 30, 1, 0, -1, NULL, },
+  { "AR[FPSR].sf0.flags", 30, 1, 2, -1, NULL, },
+  { "AR[FPSR].sf0.flags", 30, 1, 2, -1, NULL, },
+  { "AR[FPSR].sf1.flags", 30, 1, 0, -1, NULL, },
+  { "AR[FPSR].sf1.flags", 30, 1, 2, -1, NULL, },
+  { "AR[FPSR].sf1.flags", 30, 1, 2, -1, NULL, },
+  { "AR[FPSR].sf2.flags", 30, 1, 0, -1, NULL, },
+  { "AR[FPSR].sf2.flags", 30, 1, 2, -1, NULL, },
+  { "AR[FPSR].sf2.flags", 30, 1, 2, -1, NULL, },
+  { "AR[FPSR].sf3.flags", 30, 1, 0, -1, NULL, },
+  { "AR[FPSR].sf3.flags", 30, 1, 2, -1, NULL, },
+  { "AR[FPSR].sf3.flags", 30, 1, 2, -1, NULL, },
+  { "AR[FPSR].rv", 30, 1, 2, -1, NULL, },
+  { "AR[FPSR].traps", 30, 1, 2, -1, NULL, },
+  { "AR[FSR]", 26, 1, 2, 28, NULL, },
+  { "AR[ITC]", 26, 1, 2, 44, NULL, },
+  { "AR[K%], % in 0 - 7", 1, 1, 2, -1, NULL, },
+  { "AR[LC]", 26, 1, 2, 65, NULL, },
+  { "AR[PFS]", 26, 1, 0, 64, NULL, },
+  { "AR[PFS]", 26, 1, 2, 64, NULL, },
+  { "AR[PFS]", 26, 1, 2, 64, NULL, },
+  { "AR[RNAT]", 26, 1, 2, 19, NULL, },
+  { "AR[RSC]", 26, 1, 2, 16, NULL, },
+  { "AR[UNAT]{%}, % in 0 - 63", 2, 1, 2, -1, NULL, },
+  { "AR%, % in 8-15, 20, 22-23, 31, 33-35, 37-39, 41-43, 45-47, 67-111", 3, 1, 0, -1, NULL, },
+  { "AR%, % in 48 - 63, 112-127", 4, 1, 2, -1, NULL, },
+  { "BR%, % in 0 - 7", 5, 1, 2, -1, NULL, },
+  { "BR%, % in 0 - 7", 5, 1, 2, -1, NULL, },
+  { "BR%, % in 0 - 7", 5, 1, 2, -1, NULL, },
+  { "BR%, % in 0 - 7", 5, 1, 0, -1, NULL, },
+  { "CFM", 6, 1, 2, -1, NULL, },
+  { "CPUID#", 7, 1, 0, -1, NULL, },
+  { "CR[CMCV]", 27, 1, 2, 74, NULL, },
+  { "CR[DCR]", 27, 1, 2, 0, NULL, },
+  { "CR[EOI]", 27, 1, 7, 67, "SC Section 10.8.3.4", },
+  { "CR[GPTA]", 27, 1, 2, 9, NULL, },
+  { "CR[IFA]", 27, 1, 2, 20, NULL, },
+  { "CR[IFS]", 27, 1, 2, 23, NULL, },
+  { "CR[IHA]", 27, 1, 2, 25, NULL, },
+  { "CR[IIM]", 27, 1, 2, 24, NULL, },
+  { "CR[IIP]", 27, 1, 2, 19, NULL, },
+  { "CR[IIPA]", 27, 1, 2, 22, NULL, },
+  { "CR[IPSR]", 27, 1, 2, 16, NULL, },
+  { "CR[IRR%], % in 0 - 3", 8, 1, 2, -1, NULL, },
+  { "CR[ISR]", 27, 1, 2, 17, NULL, },
+  { "CR[ITIR]", 27, 1, 2, 21, NULL, },
+  { "CR[ITM]", 27, 1, 2, 1, NULL, },
+  { "CR[ITV]", 27, 1, 2, 72, NULL, },
+  { "CR[IVA]", 27, 1, 2, 2, NULL, },
+  { "CR[IVR]", 27, 1, 7, 65, "SC", },
+  { "CR[LID]", 27, 1, 7, 64, "SC", },
+  { "CR[LRR%], % in 0 - 1", 9, 1, 2, -1, NULL, },
+  { "CR[PMV]", 27, 1, 2, 73, NULL, },
+  { "CR[PTA]", 27, 1, 2, 8, NULL, },
+  { "CR[TPR]", 27, 1, 2, 66, NULL, },
+  { "CR%, % in 3-7, 10-15, 18, 26-63, 75-79, 82-127", 10, 1, 0, -1, NULL, },
+  { "DBR#", 11, 1, 2, -1, NULL, },
+  { "DTC", 0, 1, 0, -1, NULL, },
+  { "DTC", 0, 1, 2, -1, NULL, },
+  { "DTC", 0, 1, 2, -1, NULL, },
+  { "DTC_LIMIT*", 0, 1, 2, -1, NULL, },
+  { "DTR", 0, 1, 2, -1, NULL, },
+  { "DTR", 0, 1, 2, -1, NULL, },
+  { "DTR", 0, 1, 2, -1, NULL, },
+  { "DTR", 0, 1, 0, -1, NULL, },
+  { "FR%, % in 0 - 1", 12, 1, 0, -1, NULL, },
+  { "FR%, % in 2 - 127", 13, 1, 2, -1, NULL, },
+  { "GR0", 14, 1, 0, -1, NULL, },
+  { "GR%, % in 1 - 127", 15, 1, 2, -1, NULL, },
+  { "IBR#", 16, 1, 2, -1, NULL, },
+  { "InService*", 17, 1, 7, -1, "SC", },
+  { "IP", 0, 1, 0, -1, NULL, },
+  { "ITC", 0, 1, 0, -1, NULL, },
+  { "ITC", 0, 1, 2, -1, NULL, },
+  { "ITC", 0, 1, 2, -1, NULL, },
+  { "ITR", 0, 1, 2, -1, NULL, },
+  { "ITR", 0, 1, 2, -1, NULL, },
+  { "ITR", 0, 1, 0, -1, NULL, },
+  { "memory", 0, 1, 0, -1, NULL, },
+  { "MSR#", 18, 1, 7, -1, "SC", },
+  { "PKR#", 19, 1, 0, -1, NULL, },
+  { "PKR#", 19, 1, 0, -1, NULL, },
+  { "PKR#", 19, 1, 2, -1, NULL, },
+  { "PMC#", 20, 1, 2, -1, NULL, },
+  { "PMD#", 21, 1, 2, -1, NULL, },
+  { "PR0", 0, 1, 0, -1, NULL, },
+  { "PR%, % in 1 - 15", 22, 1, 0, -1, NULL, },
+  { "PR%, % in 1 - 15", 22, 1, 0, -1, NULL, },
+  { "PR%, % in 1 - 15", 22, 1, 2, -1, NULL, },
+  { "PR%, % in 1 - 15", 22, 1, 2, -1, NULL, },
+  { "PR%, % in 16 - 62", 23, 1, 0, -1, NULL, },
+  { "PR%, % in 16 - 62", 23, 1, 0, -1, NULL, },
+  { "PR%, % in 16 - 62", 23, 1, 2, -1, NULL, },
+  { "PR%, % in 16 - 62", 23, 1, 2, -1, NULL, },
+  { "PR63", 24, 1, 0, -1, NULL, },
+  { "PR63", 24, 1, 0, -1, NULL, },
+  { "PR63", 24, 1, 2, -1, NULL, },
+  { "PR63", 24, 1, 2, -1, NULL, },
+  { "PSR.ac", 28, 1, 2, 3, NULL, },
+  { "PSR.be", 28, 1, 2, 1, NULL, },
+  { "PSR.bn", 28, 1, 2, 44, NULL, },
+  { "PSR.cpl", 28, 1, 2, 32, NULL, },
+  { "PSR.da", 28, 1, 2, 38, NULL, },
+  { "PSR.db", 28, 1, 2, 24, NULL, },
+  { "PSR.dd", 28, 1, 2, 39, NULL, },
+  { "PSR.dfh", 28, 1, 2, 19, NULL, },
+  { "PSR.dfl", 28, 1, 2, 18, NULL, },
+  { "PSR.di", 28, 1, 2, 22, NULL, },
+  { "PSR.dt", 28, 1, 2, 17, NULL, },
+  { "PSR.ed", 28, 1, 2, 43, NULL, },
+  { "PSR.i", 28, 1, 2, 14, NULL, },
+  { "PSR.ia", 28, 1, 2, 14, NULL, },
+  { "PSR.ic", 28, 1, 2, 13, NULL, },
+  { "PSR.id", 28, 1, 2, 14, NULL, },
+  { "PSR.is", 28, 1, 2, 14, NULL, },
+  { "PSR.it", 28, 1, 2, 14, NULL, },
+  { "PSR.lp", 28, 1, 2, 25, NULL, },
+  { "PSR.mc", 28, 1, 2, 35, NULL, },
+  { "PSR.mfh", 28, 1, 0, 5, NULL, },
+  { "PSR.mfh", 28, 1, 2, 5, NULL, },
+  { "PSR.mfh", 28, 1, 2, 5, NULL, },
+  { "PSR.mfl", 28, 1, 0, 4, NULL, },
+  { "PSR.mfl", 28, 1, 2, 4, NULL, },
+  { "PSR.mfl", 28, 1, 2, 4, NULL, },
+  { "PSR.pk", 28, 1, 2, 15, NULL, },
+  { "PSR.pp", 28, 1, 2, 21, NULL, },
+  { "PSR.ri", 28, 1, 2, 41, NULL, },
+  { "PSR.rt", 28, 1, 2, 27, NULL, },
+  { "PSR.si", 28, 1, 2, 23, NULL, },
+  { "PSR.sp", 28, 1, 2, 20, NULL, },
+  { "PSR.ss", 28, 1, 2, 40, NULL, },
+  { "PSR.tb", 28, 1, 2, 26, NULL, },
+  { "PSR.up", 28, 1, 2, 2, NULL, },
+  { "RR#", 25, 1, 2, -1, NULL, },
+  { "RSE", 29, 1, 2, -1, NULL, },
+  { "PR63", 24, 2, 6, -1, NULL, },
+};
+
+static const unsigned short dep0[] = {
+  96, 267, 2139, 2312,
+};
+
+static const unsigned short dep1[] = {
+  40, 41, 96, 174, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 2312, 4135,
+  20613,
+};
+
+static const unsigned short dep2[] = {
+  96, 267, 2165, 2166, 2168, 2169, 2171, 2172, 2174, 2329, 2332, 2333, 2336,
+  2337, 2340, 2341,
+};
+
+static const unsigned short dep3[] = {
+  40, 41, 96, 174, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 2329, 2332,
+  2333, 2336, 2337, 2340, 2341, 4135, 20613,
+};
+
+static const unsigned short dep4[] = {
+  96, 267, 22645, 22646, 22648, 22649, 22651, 22652, 22654, 22809, 22812, 22813,
+  22816, 22817, 22820, 22821,
+};
+
+static const unsigned short dep5[] = {
+  40, 41, 96, 174, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 4135, 20613,
+  22809, 22812, 22813, 22816, 22817, 22820, 22821,
+};
+
+static const unsigned short dep6[] = {
+  96, 267, 2165, 2166, 2168, 2169, 2171, 2172, 2174, 2329, 2330, 2332, 2334,
+  2336, 2338, 2340,
+};
+
+static const unsigned short dep7[] = {
+  40, 41, 96, 174, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 2329, 2330,
+  2333, 2334, 2337, 2338, 2341, 4135, 20613,
+};
+
+static const unsigned short dep8[] = {
+  96, 267, 2165, 2166, 2168, 2169, 2171, 2172, 2174, 2329, 2331, 2333, 2335,
+  2337, 2339, 2341,
+};
+
+static const unsigned short dep9[] = {
+  40, 41, 96, 174, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 2329, 2331,
+  2332, 2335, 2336, 2339, 2340, 4135, 20613,
+};
+
+static const unsigned short dep10[] = {
+  96, 267, 2165, 2166, 2168, 2169, 2171, 2172, 2174, 2329, 2330, 2331, 2332,
+  2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341,
+};
+
+static const unsigned short dep11[] = {
+  40, 41, 96, 174, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 2329, 2330,
+  2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 4135, 20613,
+
+};
+
+static const unsigned short dep12[] = {
+  96, 267, 2379,
+};
+
+static const unsigned short dep13[] = {
+  40, 41, 96, 156, 174, 175, 267, 2082, 2083, 2165, 2167, 2168, 2170, 2171,
+  2173, 2174, 4135,
+};
+
+static const unsigned short dep14[] = {
+  96, 155, 267, 310, 2379, 28852, 29002,
+};
+
+static const unsigned short dep15[] = {
+  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
+  22, 23, 24, 25, 26, 28, 29, 30, 31, 32, 33, 40, 41, 96, 144, 156, 174, 175,
+  267, 310, 2082, 2083, 2165, 2167, 2168, 2170, 2171, 2173, 2174, 4135, 28852,
+  29002,
+};
+
+static const unsigned short dep16[] = {
+  1, 6, 40, 96, 134, 182, 187, 226, 267, 297, 2379, 28852, 29002,
+};
+
+static const unsigned short dep17[] = {
+  1, 25, 27, 38, 40, 41, 96, 156, 158, 159, 174, 175, 182, 187, 226, 267, 297,
+  2082, 2083, 2165, 2167, 2168, 2170, 2171, 2173, 2174, 4135, 28852, 29002,
+
+};
+
+static const unsigned short dep18[] = {
+  1, 40, 51, 96, 182, 226, 233, 267, 28852, 29002,
+};
+
+static const unsigned short dep19[] = {
+  1, 38, 40, 41, 96, 153, 174, 182, 226, 233, 267, 4135, 28852, 29002,
+};
+
+static const unsigned short dep20[] = {
+  40, 96, 226, 267,
+};
+
+static const unsigned short dep21[] = {
+  96, 174, 226, 267,
+};
+
+static const unsigned short dep22[] = {
+  1, 40, 96, 128, 129, 131, 132, 133, 134, 135, 138, 139, 140, 141, 142, 143,
+  144, 145, 146, 147, 148, 150, 151, 152, 153, 154, 155, 156, 159, 160, 161,
+  162, 163, 164, 165, 166, 169, 170, 171, 172, 173, 174, 175, 176, 177, 182,
+  226, 267, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306,
+  307, 308, 309, 310, 311, 312, 313, 315, 316, 318, 319, 320, 321, 322, 323,
+  324, 325, 326, 327, 328, 28852, 29002,
+};
+
+static const unsigned short dep23[] = {
+  1, 38, 40, 41, 50, 51, 55, 58, 72, 96, 134, 174, 182, 226, 267, 294, 295,
+  296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310,
+  311, 312, 313, 315, 316, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327,
+  328, 4135, 28852, 29002,
+};
+
+static const unsigned short dep24[] = {
+  96, 133, 267, 296,
+};
+
+static const unsigned short dep25[] = {
+  96, 134, 174, 267, 296,
+};
+
+static const unsigned short dep26[] = {
+  96, 134, 267, 297,
+};
+
+static const unsigned short dep27[] = {
+  25, 26, 96, 97, 100, 104, 107, 134, 156, 174, 267, 297,
+};
+
+static const unsigned short dep28[] = {
+  40, 41, 96, 174, 267, 2165, 2167, 2168, 2170, 2171, 2173, 2174, 4135,
+};
+
+static const unsigned short dep29[] = {
+  1, 25, 40, 96, 182, 214, 215, 226, 267, 2082, 2270, 2273, 2379, 28852, 29002,
+
+};
+
+static const unsigned short dep30[] = {
+  1, 6, 38, 40, 41, 96, 134, 156, 174, 175, 182, 214, 216, 226, 267, 2082, 2083,
+  2165, 2167, 2168, 2170, 2171, 2173, 2174, 2271, 2273, 4135, 28852, 29002,
+
+};
+
+static const unsigned short dep31[] = {
+  96, 267,
+};
+
+static const unsigned short dep32[] = {
+  96, 174, 267, 2082, 2084,
+};
+
+static const unsigned short dep33[] = {
+  40, 41, 96, 156, 174, 175, 267, 2165, 2167, 2168, 2170, 2171, 2173, 2174,
+  4135,
+};
+
+static const unsigned short dep34[] = {
+  6, 37, 38, 39, 96, 124, 125, 187, 226, 267, 292, 293, 2379,
+};
+
+static const unsigned short dep35[] = {
+  6, 37, 40, 41, 96, 156, 174, 175, 187, 226, 267, 292, 293, 331, 2165, 2167,
+  2168, 2170, 2171, 2173, 2174, 4135,
+};
+
+static const unsigned short dep36[] = {
+  24, 96, 213, 267, 2379,
+};
+
+static const unsigned short dep37[] = {
+  24, 40, 41, 96, 156, 174, 175, 213, 267, 2165, 2167, 2168, 2170, 2171, 2173,
+  2174, 4135,
+};
+
+static const unsigned short dep38[] = {
+  6, 24, 37, 38, 39, 96, 124, 125, 187, 213, 226, 267, 292, 293, 2379,
+};
+
+static const unsigned short dep39[] = {
+  6, 24, 37, 40, 41, 96, 156, 174, 175, 187, 213, 226, 267, 292, 293, 331, 2165,
+  2167, 2168, 2170, 2171, 2173, 2174, 4135,
+};
+
+static const unsigned short dep40[] = {
+  1, 6, 38, 40, 41, 96, 134, 156, 174, 175, 182, 214, 216, 226, 267, 2165, 2167,
+  2168, 2170, 2171, 2173, 2174, 2271, 2273, 4135, 28852, 29002,
+};
+
+static const unsigned short dep41[] = {
+  96, 174, 267,
+};
+
+static const unsigned short dep42[] = {
+  15, 96, 196, 197, 267, 2135, 2310, 18593, 18594, 18746, 18747, 18749, 18750,
+  22645, 22646, 22647, 22649, 22650, 22652, 22653, 22809, 22812, 22813, 22816,
+  22817, 22820, 22821,
+};
+
+static const unsigned short dep43[] = {
+  11, 19, 20, 40, 41, 96, 174, 196, 198, 267, 2134, 2135, 2136, 2165, 2166,
+  2169, 2172, 2310, 4135, 16524, 16526, 18746, 18748, 18749, 18751, 22809, 22812,
+  22813, 22816, 22817, 22820, 22821,
+};
+
+static const unsigned short dep44[] = {
+  15, 16, 17, 18, 96, 196, 197, 199, 200, 202, 203, 205, 206, 267, 2135, 2310,
+  18593, 18594, 18746, 18747, 18749, 18750, 22645, 22646, 22647, 22649, 22650,
+  22652, 22653, 22809, 22812, 22813, 22816, 22817, 22820, 22821,
+};
+
+static const unsigned short dep45[] = {
+  11, 12, 13, 14, 19, 20, 40, 41, 96, 174, 196, 198, 199, 201, 202, 204, 205,
+  207, 267, 2134, 2135, 2136, 2165, 2166, 2169, 2172, 2310, 4135, 16524, 16526,
+  18746, 18748, 18749, 18751, 22809, 22812, 22813, 22816, 22817, 22820, 22821,
+
+};
+
+static const unsigned short dep46[] = {
+  16, 96, 199, 200, 267, 2135, 2310, 18593, 18594, 18746, 18747, 18749, 18750,
+  22645, 22646, 22647, 22649, 22650, 22652, 22653, 22809, 22812, 22813, 22816,
+  22817, 22820, 22821,
+};
+
+static const unsigned short dep47[] = {
+  12, 19, 20, 40, 41, 96, 174, 199, 201, 267, 2134, 2135, 2136, 2165, 2166,
+  2169, 2172, 2310, 4135, 16524, 16526, 18746, 18748, 18749, 18751, 22809, 22812,
+  22813, 22816, 22817, 22820, 22821,
+};
+
+static const unsigned short dep48[] = {
+  17, 96, 202, 203, 267, 2135, 2310, 18593, 18594, 18746, 18747, 18749, 18750,
+  22645, 22646, 22647, 22649, 22650, 22652, 22653, 22809, 22812, 22813, 22816,
+  22817, 22820, 22821,
+};
+
+static const unsigned short dep49[] = {
+  13, 19, 20, 40, 41, 96, 174, 202, 204, 267, 2134, 2135, 2136, 2165, 2166,
+  2169, 2172, 2310, 4135, 16524, 16526, 18746, 18748, 18749, 18751, 22809, 22812,
+  22813, 22816, 22817, 22820, 22821,
+};
+
+static const unsigned short dep50[] = {
+  18, 96, 205, 206, 267, 2135, 2310, 18593, 18594, 18746, 18747, 18749, 18750,
+  22645, 22646, 22647, 22649, 22650, 22652, 22653, 22809, 22812, 22813, 22816,
+  22817, 22820, 22821,
+};
+
+static const unsigned short dep51[] = {
+  14, 19, 20, 40, 41, 96, 174, 205, 207, 267, 2134, 2135, 2136, 2165, 2166,
+  2169, 2172, 2310, 4135, 16524, 16526, 18746, 18748, 18749, 18751, 22809, 22812,
+  22813, 22816, 22817, 22820, 22821,
+};
+
+static const unsigned short dep52[] = {
+  15, 96, 196, 197, 267, 2135, 2310, 18593, 18594, 18746, 18747, 18749, 18750,
+
+};
+
+static const unsigned short dep53[] = {
+  11, 19, 20, 40, 41, 96, 174, 196, 198, 267, 2134, 2135, 2136, 2165, 2166,
+  2169, 2172, 2310, 4135, 16524, 16526, 18746, 18748, 18749, 18751,
+};
+
+static const unsigned short dep54[] = {
+  15, 16, 17, 18, 96, 196, 197, 199, 200, 202, 203, 205, 206, 267, 2135, 2310,
+  18593, 18594, 18746, 18747, 18749, 18750,
+};
+
+static const unsigned short dep55[] = {
+  11, 12, 13, 14, 19, 20, 40, 41, 96, 174, 196, 198, 199, 201, 202, 204, 205,
+  207, 267, 2134, 2135, 2136, 2165, 2166, 2169, 2172, 2310, 4135, 16524, 16526,
+  18746, 18748, 18749, 18751,
+};
+
+static const unsigned short dep56[] = {
+  16, 96, 199, 200, 267, 2135, 2310, 18593, 18594, 18746, 18747, 18749, 18750,
+
+};
+
+static const unsigned short dep57[] = {
+  12, 19, 20, 40, 41, 96, 174, 199, 201, 267, 2134, 2135, 2136, 2165, 2166,
+  2169, 2172, 2310, 4135, 16524, 16526, 18746, 18748, 18749, 18751,
+};
+
+static const unsigned short dep58[] = {
+  17, 96, 202, 203, 267, 2135, 2310, 18593, 18594, 18746, 18747, 18749, 18750,
+
+};
+
+static const unsigned short dep59[] = {
+  13, 19, 20, 40, 41, 96, 174, 202, 204, 267, 2134, 2135, 2136, 2165, 2166,
+  2169, 2172, 2310, 4135, 16524, 16526, 18746, 18748, 18749, 18751,
+};
+
+static const unsigned short dep60[] = {
+  18, 96, 205, 206, 267, 2135, 2310, 18593, 18594, 18746, 18747, 18749, 18750,
+
+};
+
+static const unsigned short dep61[] = {
+  14, 19, 20, 40, 41, 96, 174, 205, 207, 267, 2134, 2135, 2136, 2165, 2166,
+  2169, 2172, 2310, 4135, 16524, 16526, 18746, 18748, 18749, 18751,
+};
+
+static const unsigned short dep62[] = {
+  96, 267, 2135, 2310, 18593, 18594, 18746, 18747, 18749, 18750,
+};
+
+static const unsigned short dep63[] = {
+  40, 41, 96, 174, 267, 2134, 2135, 2136, 2165, 2166, 2169, 2172, 2310, 4135,
+  16524, 16526, 18746, 18748, 18749, 18751,
+};
+
+static const unsigned short dep64[] = {
+  11, 96, 192, 267,
+};
+
+static const unsigned short dep65[] = {
+  11, 40, 41, 96, 174, 192, 267, 2165, 2166, 2169, 2172, 4135,
+};
+
+static const unsigned short dep66[] = {
+  11, 40, 41, 96, 174, 267, 2165, 2166, 2169, 2172, 4135,
+};
+
+static const unsigned short dep67[] = {
+  12, 96, 193, 267,
+};
+
+static const unsigned short dep68[] = {
+  11, 40, 41, 96, 174, 193, 267, 2165, 2166, 2169, 2172, 4135,
+};
+
+static const unsigned short dep69[] = {
+  13, 96, 194, 267,
+};
+
+static const unsigned short dep70[] = {
+  11, 40, 41, 96, 174, 194, 267, 2165, 2166, 2169, 2172, 4135,
+};
+
+static const unsigned short dep71[] = {
+  14, 96, 195, 267,
+};
+
+static const unsigned short dep72[] = {
+  11, 40, 41, 96, 174, 195, 267, 2165, 2166, 2169, 2172, 4135,
+};
+
+static const unsigned short dep73[] = {
+  15, 96, 197, 198, 267,
+};
+
+static const unsigned short dep74[] = {
+  40, 41, 96, 174, 197, 198, 267, 2165, 2166, 2169, 2172, 4135,
+};
+
+static const unsigned short dep75[] = {
+  40, 41, 96, 174, 267, 2165, 2166, 2169, 2172, 4135,
+};
+
+static const unsigned short dep76[] = {
+  16, 96, 200, 201, 267,
+};
+
+static const unsigned short dep77[] = {
+  40, 41, 96, 174, 200, 201, 267, 2165, 2166, 2169, 2172, 4135,
+};
+
+static const unsigned short dep78[] = {
+  17, 96, 203, 204, 267,
+};
+
+static const unsigned short dep79[] = {
+  40, 41, 96, 174, 203, 204, 267, 2165, 2166, 2169, 2172, 4135,
+};
+
+static const unsigned short dep80[] = {
+  18, 96, 206, 207, 267,
+};
+
+static const unsigned short dep81[] = {
+  40, 41, 96, 174, 206, 207, 267, 2165, 2166, 2169, 2172, 4135,
+};
+
+static const unsigned short dep82[] = {
+  15, 19, 20, 40, 41, 96, 156, 174, 175, 267, 2165, 2166, 2169, 2172, 4135,
+
+};
+
+static const unsigned short dep83[] = {
+  15, 16, 19, 20, 40, 41, 96, 156, 174, 175, 267, 2165, 2166, 2169, 2172, 4135,
+
+};
+
+static const unsigned short dep84[] = {
+  15, 17, 19, 20, 40, 41, 96, 156, 174, 175, 267, 2165, 2166, 2169, 2172, 4135,
+
+};
+
+static const unsigned short dep85[] = {
+  15, 18, 19, 20, 40, 41, 96, 156, 174, 175, 267, 2165, 2166, 2169, 2172, 4135,
+
+};
+
+static const unsigned short dep86[] = {
+  15, 96, 196, 197, 267,
+};
+
+static const unsigned short dep87[] = {
+  11, 19, 20, 40, 41, 96, 174, 196, 198, 267, 2165, 2166, 2169, 2172, 4135,
+
+};
+
+static const unsigned short dep88[] = {
+  15, 16, 17, 18, 96, 196, 197, 199, 200, 202, 203, 205, 206, 267,
+};
+
+static const unsigned short dep89[] = {
+  11, 12, 13, 14, 19, 20, 40, 41, 96, 174, 196, 198, 199, 201, 202, 204, 205,
+  207, 267, 2165, 2166, 2169, 2172, 4135,
+};
+
+static const unsigned short dep90[] = {
+  16, 96, 199, 200, 267,
+};
+
+static const unsigned short dep91[] = {
+  12, 19, 20, 40, 41, 96, 174, 199, 201, 267, 2165, 2166, 2169, 2172, 4135,
+
+};
+
+static const unsigned short dep92[] = {
+  17, 96, 202, 203, 267,
+};
+
+static const unsigned short dep93[] = {
+  13, 19, 20, 40, 41, 96, 174, 202, 204, 267, 2165, 2166, 2169, 2172, 4135,
+
+};
+
+static const unsigned short dep94[] = {
+  18, 96, 205, 206, 267,
+};
+
+static const unsigned short dep95[] = {
+  14, 19, 20, 40, 41, 96, 174, 205, 207, 267, 2165, 2166, 2169, 2172, 4135,
+
+};
+
+static const unsigned short dep96[] = {
+  15, 96, 196, 197, 267, 2165, 2166, 2167, 2169, 2170, 2172, 2173, 2329, 2332,
+  2333, 2336, 2337, 2340, 2341,
+};
+
+static const unsigned short dep97[] = {
+  11, 19, 20, 40, 41, 96, 174, 196, 198, 267, 2134, 2135, 2136, 2165, 2166,
+  2169, 2172, 2329, 2332, 2333, 2336, 2337, 2340, 2341, 4135, 16524, 16526,
+
+};
+
+static const unsigned short dep98[] = {
+  15, 16, 17, 18, 96, 196, 197, 199, 200, 202, 203, 205, 206, 267, 2165, 2166,
+  2167, 2169, 2170, 2172, 2173, 2329, 2332, 2333, 2336, 2337, 2340, 2341,
+};
+
+static const unsigned short dep99[] = {
+  11, 12, 13, 14, 19, 20, 40, 41, 96, 174, 196, 198, 199, 201, 202, 204, 205,
+  207, 267, 2134, 2135, 2136, 2165, 2166, 2169, 2172, 2329, 2332, 2333, 2336,
+  2337, 2340, 2341, 4135, 16524, 16526,
+};
+
+static const unsigned short dep100[] = {
+  16, 96, 199, 200, 267, 2165, 2166, 2167, 2169, 2170, 2172, 2173, 2329, 2332,
+  2333, 2336, 2337, 2340, 2341,
+};
+
+static const unsigned short dep101[] = {
+  12, 19, 20, 40, 41, 96, 174, 199, 201, 267, 2134, 2135, 2136, 2165, 2166,
+  2169, 2172, 2329, 2332, 2333, 2336, 2337, 2340, 2341, 4135, 16524, 16526,
+
+};
+
+static const unsigned short dep102[] = {
+  17, 96, 202, 203, 267, 2165, 2166, 2167, 2169, 2170, 2172, 2173, 2329, 2332,
+  2333, 2336, 2337, 2340, 2341,
+};
+
+static const unsigned short dep103[] = {
+  13, 19, 20, 40, 41, 96, 174, 202, 204, 267, 2134, 2135, 2136, 2165, 2166,
+  2169, 2172, 2329, 2332, 2333, 2336, 2337, 2340, 2341, 4135, 16524, 16526,
+
+};
+
+static const unsigned short dep104[] = {
+  18, 96, 205, 206, 267, 2165, 2166, 2167, 2169, 2170, 2172, 2173, 2329, 2332,
+  2333, 2336, 2337, 2340, 2341,
+};
+
+static const unsigned short dep105[] = {
+  14, 19, 20, 40, 41, 96, 174, 205, 207, 267, 2134, 2135, 2136, 2165, 2166,
+  2169, 2172, 2329, 2332, 2333, 2336, 2337, 2340, 2341, 4135, 16524, 16526,
+
+};
+
+static const unsigned short dep106[] = {
+  15, 96, 196, 197, 267, 22645, 22646, 22647, 22649, 22650, 22652, 22653, 22809,
+  22812, 22813, 22816, 22817, 22820, 22821,
+};
+
+static const unsigned short dep107[] = {
+  11, 19, 20, 40, 41, 96, 174, 196, 198, 267, 2134, 2135, 2136, 2165, 2166,
+  2169, 2172, 4135, 16524, 16526, 22809, 22812, 22813, 22816, 22817, 22820,
+  22821,
+};
+
+static const unsigned short dep108[] = {
+  15, 16, 17, 18, 96, 196, 197, 199, 200, 202, 203, 205, 206, 267, 22645, 22646,
+  22647, 22649, 22650, 22652, 22653, 22809, 22812, 22813, 22816, 22817, 22820,
+  22821,
+};
+
+static const unsigned short dep109[] = {
+  11, 12, 13, 14, 19, 20, 40, 41, 96, 174, 196, 198, 199, 201, 202, 204, 205,
+  207, 267, 2134, 2135, 2136, 2165, 2166, 2169, 2172, 4135, 16524, 16526, 22809,
+  22812, 22813, 22816, 22817, 22820, 22821,
+};
+
+static const unsigned short dep110[] = {
+  16, 96, 199, 200, 267, 22645, 22646, 22647, 22649, 22650, 22652, 22653, 22809,
+  22812, 22813, 22816, 22817, 22820, 22821,
+};
+
+static const unsigned short dep111[] = {
+  12, 19, 20, 40, 41, 96, 174, 199, 201, 267, 2134, 2135, 2136, 2165, 2166,
+  2169, 2172, 4135, 16524, 16526, 22809, 22812, 22813, 22816, 22817, 22820,
+  22821,
+};
+
+static const unsigned short dep112[] = {
+  17, 96, 202, 203, 267, 22645, 22646, 22647, 22649, 22650, 22652, 22653, 22809,
+  22812, 22813, 22816, 22817, 22820, 22821,
+};
+
+static const unsigned short dep113[] = {
+  13, 19, 20, 40, 41, 96, 174, 202, 204, 267, 2134, 2135, 2136, 2165, 2166,
+  2169, 2172, 4135, 16524, 16526, 22809, 22812, 22813, 22816, 22817, 22820,
+  22821,
+};
+
+static const unsigned short dep114[] = {
+  18, 96, 205, 206, 267, 22645, 22646, 22647, 22649, 22650, 22652, 22653, 22809,
+  22812, 22813, 22816, 22817, 22820, 22821,
+};
+
+static const unsigned short dep115[] = {
+  14, 19, 20, 40, 41, 96, 174, 205, 207, 267, 2134, 2135, 2136, 2165, 2166,
+  2169, 2172, 4135, 16524, 16526, 22809, 22812, 22813, 22816, 22817, 22820,
+  22821,
+};
+
+static const unsigned short dep116[] = {
+  96, 267, 2165, 2166, 2167, 2169, 2170, 2172, 2173, 2329, 2332, 2333, 2336,
+  2337, 2340, 2341,
+};
+
+static const unsigned short dep117[] = {
+  40, 41, 96, 174, 267, 2134, 2135, 2136, 2165, 2166, 2169, 2172, 2329, 2332,
+  2333, 2336, 2337, 2340, 2341, 4135, 16524, 16526,
+};
+
+static const unsigned short dep118[] = {
+  96, 267, 22645, 22646, 22647, 22649, 22650, 22652, 22653, 22809, 22812, 22813,
+  22816, 22817, 22820, 22821,
+};
+
+static const unsigned short dep119[] = {
+  40, 41, 96, 174, 267, 2134, 2135, 2136, 2165, 2166, 2169, 2172, 4135, 16524,
+  16526, 22809, 22812, 22813, 22816, 22817, 22820, 22821,
+};
+
+static const unsigned short dep120[] = {
+  19, 20, 40, 41, 96, 174, 267, 2134, 2135, 2136, 2165, 2166, 2169, 2172, 2310,
+  4135, 16524, 16526, 18746, 18748, 18749, 18751,
+};
+
+static const unsigned short dep121[] = {
+  40, 41, 96, 156, 174, 175, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172,
+  4135, 20613,
+};
+
+static const unsigned short dep122[] = {
+  96, 267, 2083, 2084, 2271, 2272,
+};
+
+static const unsigned short dep123[] = {
+  40, 41, 96, 174, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 2270, 2272,
+  4135, 20613,
+};
+
+static const unsigned short dep124[] = {
+  40, 41, 96, 174, 267, 2082, 2084, 2165, 2166, 2169, 2172, 2312, 4135, 20613,
+
+};
+
+static const unsigned short dep125[] = {
+  96, 267, 14454, 14456, 14457, 14459, 14460, 14462, 14620, 14621, 14624, 14625,
+  14628, 14629,
+};
+
+static const unsigned short dep126[] = {
+  40, 41, 96, 174, 267, 2137, 2138, 2139, 4135, 14620, 14621, 14624, 14625,
+  14628, 14629, 20613, 24693, 24694, 24697, 24700,
+};
+
+static const unsigned short dep127[] = {
+  96, 121, 123, 124, 126, 267, 288, 289, 292, 293,
+};
+
+static const unsigned short dep128[] = {
+  40, 41, 96, 174, 267, 288, 289, 292, 293, 4135, 24693, 24694, 24697, 24700,
+
+};
+
+static const unsigned short dep129[] = {
+  40, 41, 96, 174, 267, 2165, 2166, 2169, 2172, 2312, 4135, 20613,
+};
+
+static const unsigned short dep130[] = {
+  40, 41, 96, 118, 121, 124, 174, 267, 2312, 4135, 20613, 24693,
+};
+
+static const unsigned short dep131[] = {
+  6, 24, 26, 27, 96, 187, 213, 216, 267, 2081, 2269,
+};
+
+static const unsigned short dep132[] = {
+  40, 41, 96, 174, 187, 213, 215, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172,
+  2269, 4135, 20613,
+};
+
+static const unsigned short dep133[] = {
+  6, 24, 25, 26, 40, 41, 96, 174, 267, 2081, 2165, 2166, 2169, 2172, 2312, 4135,
+  20613,
+};
+
+static const unsigned short dep134[] = {
+  0, 40, 41, 96, 156, 174, 175, 267, 2165, 2166, 2169, 2172, 4135,
+};
+
+static const unsigned short dep135[] = {
+  0, 96, 181, 267,
+};
+
+static const unsigned short dep136[] = {
+  0, 40, 41, 96, 156, 174, 175, 181, 267, 2165, 2166, 2169, 2172, 4135,
+};
+
+static const unsigned short dep137[] = {
+  40, 41, 96, 174, 181, 267, 2165, 2166, 2169, 2172, 4135,
+};
+
+static const unsigned short dep138[] = {
+  2, 28, 96, 183, 217, 267, 28852, 29002,
+};
+
+static const unsigned short dep139[] = {
+  1, 2, 28, 29, 96, 168, 169, 174, 183, 217, 267, 28852, 29002,
+};
+
+static const unsigned short dep140[] = {
+  1, 28, 29, 38, 40, 41, 96, 168, 169, 174, 183, 217, 267, 4135, 28852, 29002,
+
+};
+
+static const unsigned short dep141[] = {
+  0, 40, 41, 96, 174, 181, 267, 2165, 2166, 2169, 2172, 4135,
+};
+
+static const unsigned short dep142[] = {
+  1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
+  28, 29, 30, 31, 96, 182, 183, 184, 185, 186, 188, 189, 190, 191, 192, 193,
+  194, 195, 197, 198, 200, 201, 203, 204, 206, 207, 208, 209, 210, 211, 217,
+  218, 219, 267, 2071, 2081, 2260, 2269, 28852, 29002,
+};
+
+static const unsigned short dep143[] = {
+  29, 40, 41, 96, 134, 174, 182, 183, 184, 185, 186, 188, 189, 190, 191, 192,
+  193, 194, 195, 197, 198, 200, 201, 203, 204, 206, 207, 208, 209, 210, 211,
+  217, 218, 219, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 2260, 2269,
+  4135, 20613, 28852, 29002,
+};
+
+static const unsigned short dep144[] = {
+  96, 267, 14463, 14465, 14466, 14468, 14497, 14498, 14513, 14630, 14631, 14651,
+  14652, 14654, 14655, 14664,
+};
+
+static const unsigned short dep145[] = {
+  40, 41, 96, 173, 174, 267, 2165, 2166, 2169, 2172, 4135, 14630, 14631, 14651,
+  14652, 14654, 14655, 14664,
+};
+
+static const unsigned short dep146[] = {
+  14463, 14465, 14466, 14468, 14497, 14498, 14513, 14630, 14631, 14651, 14652,
+  14654, 14655, 14664,
+};
+
+static const unsigned short dep147[] = {
+  173, 14630, 14631, 14651, 14652, 14654, 14655, 14664,
+};
+
+static const unsigned short dep148[] = {
+  96, 267, 14464, 14465, 14467, 14468, 14476, 14477, 14478, 14479, 14480, 14481,
+  14482, 14483, 14485, 14488, 14489, 14497, 14498, 14499, 14500, 14501, 14506,
+  14507, 14508, 14509, 14513, 14630, 14631, 14637, 14638, 14639, 14640, 14642,
+  14644, 14651, 14652, 14654, 14655, 14656, 14657, 14660, 14661, 14664,
+};
+
+static const unsigned short dep149[] = {
+  40, 41, 72, 96, 134, 174, 267, 2165, 2166, 2169, 2172, 4135, 14630, 14631,
+  14637, 14638, 14639, 14640, 14642, 14644, 14651, 14652, 14654, 14655, 14656,
+  14657, 14660, 14661, 14664,
+};
+
+static const unsigned short dep150[] = {
+  1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
+  28, 29, 30, 31, 40, 41, 96, 134, 171, 174, 267, 2071, 2081, 2165, 2166, 2169,
+  2172, 2312, 4135, 20613, 28852,
+};
+
+static const unsigned short dep151[] = {
+  43, 44, 45, 46, 47, 48, 49, 50, 52, 53, 54, 55, 56, 57, 58, 60, 61, 62, 63,
+  64, 65, 67, 69, 70, 71, 72, 93, 95, 96, 228, 229, 230, 231, 232, 233, 234,
+  235, 236, 237, 238, 240, 241, 242, 243, 244, 246, 248, 249, 250, 266, 267,
+  2116, 2295,
+};
+
+static const unsigned short dep152[] = {
+  40, 41, 95, 96, 134, 153, 174, 228, 229, 230, 231, 232, 233, 234, 235, 236,
+  237, 238, 240, 241, 242, 243, 244, 246, 248, 249, 250, 266, 267, 2137, 2138,
+  2139, 2165, 2166, 2169, 2172, 2295, 4135, 20613,
+};
+
+static const unsigned short dep153[] = {
+  59, 94, 96, 239, 266, 267, 2139, 2312,
+};
+
+static const unsigned short dep154[] = {
+  40, 41, 43, 44, 46, 48, 49, 51, 52, 53, 54, 56, 57, 60, 61, 63, 64, 65, 66,
+  67, 69, 70, 71, 93, 94, 96, 134, 153, 174, 239, 266, 267, 2107, 2116, 2165,
+  2166, 2169, 2172, 2312, 4135, 20613,
+};
+
+static const unsigned short dep155[] = {
+  2, 28, 41, 96, 183, 217, 226, 267, 2139, 2312, 28852, 29002,
+};
+
+static const unsigned short dep156[] = {
+  2, 25, 26, 28, 29, 38, 40, 41, 96, 168, 169, 174, 183, 217, 226, 267, 2312,
+  4135, 20613, 28852, 29002,
+};
+
+static const unsigned short dep157[] = {
+  96, 128, 129, 131, 132, 136, 137, 140, 141, 142, 143, 144, 145, 146, 147,
+  149, 152, 153, 157, 158, 161, 162, 163, 164, 165, 167, 168, 170, 171, 172,
+  173, 175, 176, 177, 267, 294, 295, 299, 301, 302, 303, 304, 306, 308, 312,
+  315, 316, 318, 319, 320, 321, 323, 324, 325, 327, 328,
+};
+
+static const unsigned short dep158[] = {
+  40, 41, 72, 96, 134, 174, 267, 294, 295, 299, 301, 302, 303, 304, 306, 308,
+  312, 315, 316, 318, 319, 320, 321, 323, 324, 325, 327, 328, 2137, 2138, 2139,
+  2165, 2166, 2169, 2172, 4135, 20613,
+};
+
+static const unsigned short dep159[] = {
+  96, 127, 129, 130, 132, 161, 162, 177, 267, 294, 295, 315, 316, 318, 319,
+  328,
+};
+
+static const unsigned short dep160[] = {
+  40, 41, 96, 173, 174, 267, 294, 295, 315, 316, 318, 319, 328, 2137, 2138,
+  2139, 2165, 2166, 2169, 2172, 4135, 20613,
+};
+
+static const unsigned short dep161[] = {
+  40, 41, 96, 129, 132, 134, 137, 138, 141, 143, 145, 147, 149, 150, 152, 156,
+  157, 159, 160, 161, 162, 164, 165, 167, 169, 170, 172, 174, 176, 177, 267,
+  2165, 2166, 2169, 2172, 2312, 4135, 20613,
+};
+
+static const unsigned short dep162[] = {
+  40, 41, 96, 129, 132, 161, 162, 174, 177, 267, 2165, 2166, 2169, 2172, 2312,
+  4135, 20613,
+};
+
+static const unsigned short dep163[] = {
+  40, 41, 75, 76, 81, 83, 96, 110, 134, 163, 174, 178, 267, 2137, 2138, 2139,
+  2165, 2166, 2169, 2172, 2312, 4135, 20613,
+};
+
+static const unsigned short dep164[] = {
+  40, 41, 75, 76, 81, 83, 96, 110, 134, 135, 136, 138, 139, 163, 174, 178, 267,
+  2137, 2138, 2139, 2165, 2166, 2169, 2172, 4135, 20613,
+};
+
+static const unsigned short dep165[] = {
+  76, 77, 96, 100, 101, 254, 255, 267, 269, 270,
+};
+
+static const unsigned short dep166[] = {
+  40, 41, 47, 62, 77, 79, 85, 96, 98, 101, 134, 153, 174, 178, 254, 255, 267,
+  269, 270, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 4135, 20613,
+};
+
+static const unsigned short dep167[] = {
+  40, 41, 47, 62, 77, 79, 96, 98, 101, 103, 105, 134, 153, 174, 178, 254, 255,
+  267, 269, 270, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 4135, 20613,
+};
+
+static const unsigned short dep168[] = {
+  96, 267, 12466, 12467, 12617,
+};
+
+static const unsigned short dep169[] = {
+  40, 41, 96, 134, 174, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 4135,
+  12617, 20613,
+};
+
+static const unsigned short dep170[] = {
+  96, 267, 6218, 6219, 6396,
+};
+
+static const unsigned short dep171[] = {
+  40, 41, 96, 134, 174, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 4135,
+  6396, 20613,
+};
+
+static const unsigned short dep172[] = {
+  96, 267, 6236, 6409,
+};
+
+static const unsigned short dep173[] = {
+  40, 41, 96, 134, 174, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 4135,
+  6409, 20613,
+};
+
+static const unsigned short dep174[] = {
+  96, 267, 6254, 6255, 6256, 6257, 6420, 6422, 8469,
+};
+
+static const unsigned short dep175[] = {
+  40, 41, 96, 134, 174, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 4135,
+  6257, 6421, 6422, 8303, 8468, 20613,
+};
+
+static const unsigned short dep176[] = {
+  96, 267, 6258, 6259, 6423,
+};
+
+static const unsigned short dep177[] = {
+  40, 41, 96, 134, 174, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 4135,
+  6423, 20613,
+};
+
+static const unsigned short dep178[] = {
+  96, 267, 6260, 6424,
+};
+
+static const unsigned short dep179[] = {
+  40, 41, 96, 134, 174, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 4135,
+  6424, 20613,
+};
+
+static const unsigned short dep180[] = {
+  96, 267, 10349, 10515,
+};
+
+static const unsigned short dep181[] = {
+  40, 41, 96, 134, 174, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 4135,
+  10515, 20613,
+};
+
+static const unsigned short dep182[] = {
+  76, 77, 81, 82, 96, 100, 101, 254, 255, 257, 258, 267, 269, 270,
+};
+
+static const unsigned short dep183[] = {
+  40, 41, 47, 62, 77, 79, 82, 85, 96, 98, 101, 134, 153, 174, 178, 254, 255,
+  257, 259, 267, 269, 270, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 4135, 20613,
+
+};
+
+static const unsigned short dep184[] = {
+  76, 77, 96, 100, 101, 103, 104, 254, 255, 267, 269, 270, 271, 272,
+};
+
+static const unsigned short dep185[] = {
+  40, 41, 47, 62, 77, 79, 96, 98, 101, 103, 105, 134, 153, 174, 178, 254, 255,
+  267, 269, 270, 271, 272, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 4135, 20613,
+
+};
+
+static const unsigned short dep186[] = {
+  40, 41, 96, 134, 174, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 2312,
+  4135, 12467, 20613,
+};
+
+static const unsigned short dep187[] = {
+  40, 41, 96, 134, 174, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 2312,
+  4135, 6218, 20613,
+};
+
+static const unsigned short dep188[] = {
+  40, 41, 96, 134, 174, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 2312,
+  4135, 6236, 20613,
+};
+
+static const unsigned short dep189[] = {
+  40, 41, 96, 134, 174, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 2312,
+  4135, 6256, 8302, 20613,
+};
+
+static const unsigned short dep190[] = {
+  40, 41, 96, 134, 174, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 2312,
+  4135, 6258, 20613,
+};
+
+static const unsigned short dep191[] = {
+  40, 41, 96, 134, 173, 174, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172,
+  2312, 4135, 6259, 6260, 20613,
+};
+
+static const unsigned short dep192[] = {
+  40, 41, 96, 134, 174, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 2312,
+  4135, 10349, 20613,
+};
+
+static const unsigned short dep193[] = {
+  40, 41, 96, 174, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 2312, 4135,
+  6186, 20613,
+};
+
+static const unsigned short dep194[] = {
+  76, 78, 79, 96, 97, 98, 99, 253, 254, 267, 268, 269,
+};
+
+static const unsigned short dep195[] = {
+  40, 41, 77, 78, 82, 84, 96, 99, 101, 103, 106, 134, 174, 178, 253, 255, 267,
+  268, 270, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 4135, 20613,
+};
+
+static const unsigned short dep196[] = {
+  76, 78, 79, 80, 96, 97, 98, 99, 102, 253, 254, 256, 267, 268, 269,
+};
+
+static const unsigned short dep197[] = {
+  40, 41, 77, 78, 80, 82, 84, 96, 99, 101, 102, 103, 106, 134, 174, 178, 253,
+  255, 256, 267, 268, 270, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 4135, 20613,
+
+};
+
+static const unsigned short dep198[] = {
+  76, 78, 79, 83, 84, 85, 96, 97, 98, 99, 253, 254, 259, 260, 267, 268, 269,
+
+};
+
+static const unsigned short dep199[] = {
+  40, 41, 77, 78, 82, 84, 96, 99, 101, 134, 174, 178, 253, 255, 258, 260, 267,
+  268, 270, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 4135, 20613,
+};
+
+static const unsigned short dep200[] = {
+  76, 78, 79, 96, 97, 98, 99, 105, 106, 107, 253, 254, 267, 268, 269, 272, 273,
+
+};
+
+static const unsigned short dep201[] = {
+  40, 41, 77, 78, 96, 99, 101, 103, 106, 134, 174, 178, 253, 255, 267, 268,
+  270, 271, 273, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 4135, 20613,
+};
+
+static const unsigned short dep202[] = {
+  40, 41, 46, 70, 96, 174, 178, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172,
+  2312, 4135, 20613,
+};
+
+static const unsigned short dep203[] = {
+  40, 41, 96, 174, 178, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 2312,
+  4135, 20613,
+};
+
+static const unsigned short dep204[] = {
+  40, 41, 76, 81, 83, 96, 134, 174, 178, 267, 2137, 2138, 2139, 2165, 2166,
+  2169, 2172, 2312, 4135, 20613,
+};
+
+static const unsigned short dep205[] = {
+  40, 41, 96, 156, 174, 175, 267, 2134, 2135, 2136, 2137, 2138, 2139, 2165,
+  2166, 2169, 2172, 4135, 16524, 16526, 20613,
+};
+
+static const unsigned short dep206[] = {
+  40, 41, 76, 81, 83, 96, 174, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172,
+  4135, 20613,
+};
+
+static const unsigned short dep207[] = {
+  40, 41, 77, 78, 96, 99, 134, 174, 253, 255, 267, 268, 270, 2137, 2138, 2139,
+  2165, 2166, 2169, 2172, 4135, 20613,
+};
+
+static const unsigned short dep208[] = {
+  40, 41, 75, 76, 81, 83, 96, 108, 110, 127, 128, 130, 131, 134, 135, 136, 138,
+  139, 146, 163, 174, 178, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 2312,
+  4135, 20613,
+};
+
+static const unsigned short dep209[] = {
+  5, 96, 186, 267, 2139, 2312,
+};
+
+static const unsigned short dep210[] = {
+  40, 41, 75, 76, 81, 83, 96, 108, 110, 127, 128, 130, 131, 134, 135, 136, 138,
+  139, 146, 163, 174, 178, 186, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172,
+  2312, 4135, 20613,
+};
+
+static const unsigned short dep211[] = {
+  40, 41, 44, 75, 76, 81, 83, 96, 108, 110, 127, 128, 130, 131, 134, 135, 136,
+  138, 139, 146, 148, 163, 174, 178, 267, 2137, 2138, 2139, 2165, 2166, 2169,
+  2172, 2312, 4135, 20613,
+};
+
+static const unsigned short dep212[] = {
+  0, 96, 181, 267, 2139, 2312,
+};
+
+static const unsigned short dep213[] = {
+  0, 40, 41, 75, 76, 81, 83, 96, 108, 110, 127, 128, 130, 131, 134, 135, 136,
+  138, 139, 146, 163, 174, 178, 181, 267, 2137, 2138, 2139, 2165, 2166, 2169,
+  2172, 2312, 4135, 20613,
+};
+
+static const unsigned short dep214[] = {
+  0, 40, 41, 44, 75, 76, 81, 83, 96, 108, 110, 127, 128, 130, 131, 134, 135,
+  136, 138, 139, 146, 148, 163, 174, 178, 181, 267, 2137, 2138, 2139, 2165,
+  2166, 2169, 2172, 2312, 4135, 20613,
+};
+
+static const unsigned short dep215[] = {
+  31, 40, 41, 75, 76, 81, 83, 96, 108, 110, 127, 128, 130, 131, 134, 135, 136,
+  138, 139, 146, 163, 174, 178, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172,
+  2312, 4135, 20613,
+};
+
+static const unsigned short dep216[] = {
+  0, 96, 181, 267, 2312, 26714,
+};
+
+static const unsigned short dep217[] = {
+  0, 96, 108, 181, 267, 274,
+};
+
+static const unsigned short dep218[] = {
+  0, 40, 41, 75, 76, 81, 83, 96, 110, 127, 128, 130, 131, 134, 135, 136, 138,
+  139, 146, 163, 174, 178, 181, 267, 274, 2137, 2138, 2139, 2165, 2166, 2169,
+  2172, 4135, 20613,
+};
+
+static const unsigned short dep219[] = {
+  0, 5, 40, 41, 75, 76, 81, 83, 96, 110, 127, 128, 130, 131, 134, 135, 136,
+  138, 139, 146, 163, 174, 178, 181, 267, 274, 2137, 2138, 2139, 2165, 2166,
+  2169, 2172, 4135, 20613,
+};
+
+static const unsigned short dep220[] = {
+  0, 31, 96, 108, 181, 219, 267, 274,
+};
+
+static const unsigned short dep221[] = {
+  0, 40, 41, 75, 76, 81, 83, 96, 110, 127, 128, 130, 131, 134, 135, 136, 138,
+  139, 146, 163, 174, 178, 181, 219, 267, 274, 2137, 2138, 2139, 2165, 2166,
+  2169, 2172, 4135, 20613,
+};
+
+static const unsigned short dep222[] = {
+  0, 96, 108, 181, 267, 274, 2139, 2312,
+};
+
+static const unsigned short dep223[] = {
+  0, 4, 40, 41, 75, 76, 81, 83, 96, 108, 110, 127, 128, 130, 131, 134, 135,
+  136, 138, 139, 146, 163, 174, 178, 181, 267, 274, 2137, 2138, 2139, 2165,
+  2166, 2169, 2172, 2312, 4135, 20613,
+};
+
+static const unsigned short dep224[] = {
+  0, 4, 5, 40, 41, 75, 76, 81, 83, 96, 108, 110, 127, 128, 130, 131, 134, 135,
+  136, 138, 139, 146, 163, 174, 178, 181, 267, 274, 2137, 2138, 2139, 2165,
+  2166, 2169, 2172, 2312, 4135, 20613,
+};
+
+static const unsigned short dep225[] = {
+  0, 40, 41, 75, 76, 81, 83, 96, 108, 110, 127, 128, 130, 131, 134, 135, 136,
+  138, 139, 146, 163, 174, 178, 181, 267, 274, 2137, 2138, 2139, 2165, 2166,
+  2169, 2172, 2312, 4135, 20613,
+};
+
+static const unsigned short dep226[] = {
+  40, 41, 96, 174, 267, 2134, 2135, 2136, 2165, 2166, 2169, 2172, 2312, 4135,
+  16524, 16526, 20613,
+};
+
+static const unsigned short dep227[] = {
+  0, 40, 41, 75, 76, 81, 83, 96, 110, 127, 128, 130, 131, 134, 135, 136, 138,
+  139, 146, 163, 174, 178, 181, 267, 274, 2137, 2138, 2139, 2165, 2166, 2169,
+  2172, 2312, 4135, 20613,
+};
+
+static const unsigned short dep228[] = {
+  0, 31, 96, 108, 181, 219, 267, 274, 2139, 2312,
+};
+
+static const unsigned short dep229[] = {
+  0, 40, 41, 75, 76, 81, 83, 96, 110, 127, 128, 130, 131, 134, 135, 136, 138,
+  139, 146, 163, 174, 178, 181, 219, 267, 274, 2137, 2138, 2139, 2165, 2166,
+  2169, 2172, 2312, 4135, 20613,
+};
+
+static const unsigned short dep230[] = {
+  40, 41, 75, 76, 81, 83, 96, 108, 110, 127, 128, 130, 131, 134, 135, 136, 138,
+  139, 146, 163, 174, 178, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 2310,
+  4135, 16524, 16526, 18746, 18748, 18749, 18751, 20613,
+};
+
+static const unsigned short dep231[] = {
+  40, 41, 44, 75, 76, 81, 83, 96, 108, 110, 127, 128, 130, 131, 134, 135, 136,
+  138, 139, 146, 148, 163, 174, 178, 267, 2137, 2138, 2139, 2165, 2166, 2169,
+  2172, 2310, 4135, 16524, 16526, 18746, 18748, 18749, 18751, 20613,
+};
+
+static const unsigned short dep232[] = {
+  0, 96, 181, 267, 2135, 2310, 18593, 18594, 18746, 18747, 18749, 18750,
+};
+
+static const unsigned short dep233[] = {
+  0, 40, 41, 75, 76, 81, 83, 96, 108, 110, 127, 128, 130, 131, 134, 135, 136,
+  138, 139, 146, 163, 174, 178, 181, 267, 2137, 2138, 2139, 2165, 2166, 2169,
+  2172, 2310, 4135, 16524, 16526, 18746, 18748, 18749, 18751, 20613,
+};
+
+static const unsigned short dep234[] = {
+  0, 40, 41, 44, 75, 76, 81, 83, 96, 108, 110, 127, 128, 130, 131, 134, 135,
+  136, 138, 139, 146, 148, 163, 174, 178, 181, 267, 2137, 2138, 2139, 2165,
+  2166, 2169, 2172, 2310, 4135, 16524, 16526, 18746, 18748, 18749, 18751, 20613,
+
+};
+
+static const unsigned short dep235[] = {
+  0, 96, 181, 267, 2136, 2310, 18593, 18594, 18746, 18747, 18749, 18750,
+};
+
+static const unsigned short dep236[] = {
+  96, 267, 2135, 2139, 2310, 2312, 18593, 18594, 18746, 18747, 18749, 18750,
+
+};
+
+static const unsigned short dep237[] = {
+  40, 41, 75, 76, 81, 83, 96, 108, 110, 127, 128, 130, 131, 134, 135, 136, 138,
+  139, 146, 163, 174, 178, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 2310,
+  2312, 4135, 16524, 16526, 18746, 18748, 18749, 18751, 20613,
+};
+
+static const unsigned short dep238[] = {
+  40, 41, 44, 75, 76, 81, 83, 96, 108, 110, 127, 128, 130, 131, 134, 135, 136,
+  138, 139, 146, 148, 163, 174, 178, 267, 2137, 2138, 2139, 2165, 2166, 2169,
+  2172, 2310, 2312, 4135, 16524, 16526, 18746, 18748, 18749, 18751, 20613,
+};
+
+static const unsigned short dep239[] = {
+  0, 96, 181, 267, 2135, 2139, 2310, 2312, 18593, 18594, 18746, 18747, 18749,
+  18750,
+};
+
+static const unsigned short dep240[] = {
+  0, 40, 41, 75, 76, 81, 83, 96, 108, 110, 127, 128, 130, 131, 134, 135, 136,
+  138, 139, 146, 163, 174, 178, 181, 267, 2137, 2138, 2139, 2165, 2166, 2169,
+  2172, 2310, 2312, 4135, 16524, 16526, 18746, 18748, 18749, 18751, 20613,
+};
+
+static const unsigned short dep241[] = {
+  0, 40, 41, 44, 75, 76, 81, 83, 96, 108, 110, 127, 128, 130, 131, 134, 135,
+  136, 138, 139, 146, 148, 163, 174, 178, 181, 267, 2137, 2138, 2139, 2165,
+  2166, 2169, 2172, 2310, 2312, 4135, 16524, 16526, 18746, 18748, 18749, 18751,
+  20613,
+};
+
+static const unsigned short dep242[] = {
+  0, 96, 181, 267, 2136, 2139, 2310, 2312, 18593, 18594, 18746, 18747, 18749,
+  18750,
+};
+
+static const unsigned short dep243[] = {
+  0, 40, 41, 75, 76, 81, 83, 96, 110, 127, 128, 130, 131, 134, 135, 136, 138,
+  139, 146, 163, 174, 178, 181, 267, 274, 2134, 2135, 2136, 2137, 2138, 2139,
+  2165, 2166, 2169, 2172, 4135, 16524, 16526, 20613,
+};
+
+static const unsigned short dep244[] = {
+  40, 41, 75, 96, 134, 148, 174, 267, 2165, 2166, 2169, 2172, 4135,
+};
+
+static const unsigned short dep245[] = {
+  40, 41, 75, 96, 134, 135, 139, 148, 174, 267, 2165, 2166, 2169, 2172, 4135,
+
+};
+
+static const unsigned short dep246[] = {
+  40, 41, 75, 96, 134, 148, 174, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172,
+  2312, 4135, 20613,
+};
+
+static const unsigned short dep247[] = {
+  40, 41, 75, 96, 134, 135, 139, 148, 174, 267, 2137, 2138, 2139, 2165, 2166,
+  2169, 2172, 2312, 4135, 20613,
+};
+
+static const unsigned short dep248[] = {
+  40, 41, 96, 174, 267, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 2310, 4135,
+  16524, 16526, 18746, 18748, 18749, 18751, 20613,
+};
+
+static const unsigned short dep249[] = {
+  0, 40, 41, 75, 76, 81, 83, 96, 110, 127, 128, 130, 131, 134, 135, 136, 138,
+  139, 146, 163, 174, 178, 181, 267, 274, 2134, 2135, 2136, 2137, 2138, 2139,
+  2165, 2166, 2169, 2172, 2312, 4135, 16524, 16526, 20613,
+};
+
+static const unsigned short dep250[] = {
+  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
+  22, 24, 26, 27, 28, 29, 30, 31, 96, 182, 183, 184, 185, 186, 187, 188, 189,
+  190, 191, 192, 193, 194, 195, 197, 198, 200, 201, 203, 204, 206, 207, 208,
+  209, 210, 211, 213, 216, 217, 218, 219, 267, 2071, 2081, 2139, 2260, 2269,
+  2312, 28852, 29002,
+};
+
+static const unsigned short dep251[] = {
+  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
+  22, 24, 25, 26, 28, 29, 30, 31, 40, 41, 96, 134, 171, 174, 182, 183, 184,
+  185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 197, 198, 200, 201,
+  203, 204, 206, 207, 208, 209, 210, 211, 213, 215, 217, 218, 219, 267, 2071,
+  2081, 2137, 2138, 2139, 2165, 2166, 2169, 2172, 2260, 2269, 2312, 4135, 20613,
+  28852, 29002,
+};
+
+#define NELS(X) (sizeof(X)/sizeof(X[0]))
+static const struct ia64_opcode_dependency
+op_dependencies[] = {
+  { NELS(dep1), dep1, NELS(dep0), dep0, },
+  { NELS(dep3), dep3, NELS(dep2), dep2, },
+  { NELS(dep5), dep5, NELS(dep4), dep4, },
+  { NELS(dep7), dep7, NELS(dep6), dep6, },
+  { NELS(dep9), dep9, NELS(dep8), dep8, },
+  { NELS(dep11), dep11, NELS(dep10), dep10, },
+  { NELS(dep13), dep13, NELS(dep12), dep12, },
+  { NELS(dep15), dep15, NELS(dep14), dep14, },
+  { NELS(dep17), dep17, NELS(dep16), dep16, },
+  { NELS(dep19), dep19, NELS(dep18), dep18, },
+  { NELS(dep21), dep21, NELS(dep20), dep20, },
+  { NELS(dep23), dep23, NELS(dep22), dep22, },
+  { NELS(dep25), dep25, NELS(dep24), dep24, },
+  { NELS(dep27), dep27, NELS(dep26), dep26, },
+  { NELS(dep28), dep28, NELS(dep12), dep12, },
+  { NELS(dep30), dep30, NELS(dep29), dep29, },
+  { NELS(dep32), dep32, NELS(dep31), dep31, },
+  { NELS(dep33), dep33, NELS(dep12), dep12, },
+  { NELS(dep35), dep35, NELS(dep34), dep34, },
+  { NELS(dep37), dep37, NELS(dep36), dep36, },
+  { NELS(dep39), dep39, NELS(dep38), dep38, },
+  { NELS(dep40), dep40, NELS(dep29), dep29, },
+  { NELS(dep41), dep41, NELS(dep31), dep31, },
+  { NELS(dep43), dep43, NELS(dep42), dep42, },
+  { NELS(dep45), dep45, NELS(dep44), dep44, },
+  { NELS(dep47), dep47, NELS(dep46), dep46, },
+  { NELS(dep49), dep49, NELS(dep48), dep48, },
+  { NELS(dep51), dep51, NELS(dep50), dep50, },
+  { NELS(dep53), dep53, NELS(dep52), dep52, },
+  { NELS(dep55), dep55, NELS(dep54), dep54, },
+  { NELS(dep57), dep57, NELS(dep56), dep56, },
+  { NELS(dep59), dep59, NELS(dep58), dep58, },
+  { NELS(dep61), dep61, NELS(dep60), dep60, },
+  { NELS(dep63), dep63, NELS(dep62), dep62, },
+  { NELS(dep65), dep65, NELS(dep64), dep64, },
+  { NELS(dep66), dep66, NELS(dep31), dep31, },
+  { NELS(dep68), dep68, NELS(dep67), dep67, },
+  { NELS(dep70), dep70, NELS(dep69), dep69, },
+  { NELS(dep72), dep72, NELS(dep71), dep71, },
+  { NELS(dep74), dep74, NELS(dep73), dep73, },
+  { NELS(dep75), dep75, NELS(dep31), dep31, },
+  { NELS(dep77), dep77, NELS(dep76), dep76, },
+  { NELS(dep79), dep79, NELS(dep78), dep78, },
+  { NELS(dep81), dep81, NELS(dep80), dep80, },
+  { NELS(dep82), dep82, NELS(dep31), dep31, },
+  { NELS(dep83), dep83, NELS(dep31), dep31, },
+  { NELS(dep84), dep84, NELS(dep31), dep31, },
+  { NELS(dep85), dep85, NELS(dep31), dep31, },
+  { NELS(dep87), dep87, NELS(dep86), dep86, },
+  { NELS(dep89), dep89, NELS(dep88), dep88, },
+  { NELS(dep91), dep91, NELS(dep90), dep90, },
+  { NELS(dep93), dep93, NELS(dep92), dep92, },
+  { NELS(dep95), dep95, NELS(dep94), dep94, },
+  { NELS(dep97), dep97, NELS(dep96), dep96, },
+  { NELS(dep99), dep99, NELS(dep98), dep98, },
+  { NELS(dep101), dep101, NELS(dep100), dep100, },
+  { NELS(dep103), dep103, NELS(dep102), dep102, },
+  { NELS(dep105), dep105, NELS(dep104), dep104, },
+  { NELS(dep107), dep107, NELS(dep106), dep106, },
+  { NELS(dep109), dep109, NELS(dep108), dep108, },
+  { NELS(dep111), dep111, NELS(dep110), dep110, },
+  { NELS(dep113), dep113, NELS(dep112), dep112, },
+  { NELS(dep115), dep115, NELS(dep114), dep114, },
+  { NELS(dep117), dep117, NELS(dep116), dep116, },
+  { NELS(dep119), dep119, NELS(dep118), dep118, },
+  { NELS(dep120), dep120, NELS(dep62), dep62, },
+  { NELS(dep121), dep121, NELS(dep31), dep31, },
+  { NELS(dep123), dep123, NELS(dep122), dep122, },
+  { NELS(dep124), dep124, NELS(dep0), dep0, },
+  { NELS(dep126), dep126, NELS(dep125), dep125, },
+  { NELS(dep128), dep128, NELS(dep127), dep127, },
+  { NELS(dep129), dep129, NELS(dep0), dep0, },
+  { NELS(dep130), dep130, NELS(dep0), dep0, },
+  { NELS(dep132), dep132, NELS(dep131), dep131, },
+  { NELS(dep133), dep133, NELS(dep0), dep0, },
+  { NELS(dep134), dep134, NELS(dep31), dep31, },
+  { NELS(dep136), dep136, NELS(dep135), dep135, },
+  { NELS(dep137), dep137, NELS(dep135), dep135, },
+  { NELS(dep139), dep139, NELS(dep138), dep138, },
+  { NELS(dep140), dep140, NELS(dep138), dep138, },
+  { NELS(dep141), dep141, NELS(dep135), dep135, },
+  { NELS(dep143), dep143, NELS(dep142), dep142, },
+  { NELS(dep145), dep145, NELS(dep144), dep144, },
+  { NELS(dep147), dep147, NELS(dep146), dep146, },
+  { NELS(dep149), dep149, NELS(dep148), dep148, },
+  { NELS(dep150), dep150, NELS(dep0), dep0, },
+  { NELS(dep152), dep152, NELS(dep151), dep151, },
+  { NELS(dep154), dep154, NELS(dep153), dep153, },
+  { NELS(dep156), dep156, NELS(dep155), dep155, },
+  { NELS(dep158), dep158, NELS(dep157), dep157, },
+  { NELS(dep160), dep160, NELS(dep159), dep159, },
+  { NELS(dep161), dep161, NELS(dep0), dep0, },
+  { NELS(dep162), dep162, NELS(dep0), dep0, },
+  { NELS(dep163), dep163, NELS(dep0), dep0, },
+  { NELS(dep164), dep164, NELS(dep31), dep31, },
+  { NELS(dep166), dep166, NELS(dep165), dep165, },
+  { NELS(dep167), dep167, NELS(dep165), dep165, },
+  { NELS(dep169), dep169, NELS(dep168), dep168, },
+  { NELS(dep171), dep171, NELS(dep170), dep170, },
+  { NELS(dep173), dep173, NELS(dep172), dep172, },
+  { NELS(dep175), dep175, NELS(dep174), dep174, },
+  { NELS(dep177), dep177, NELS(dep176), dep176, },
+  { NELS(dep179), dep179, NELS(dep178), dep178, },
+  { NELS(dep181), dep181, NELS(dep180), dep180, },
+  { NELS(dep183), dep183, NELS(dep182), dep182, },
+  { NELS(dep185), dep185, NELS(dep184), dep184, },
+  { NELS(dep186), dep186, NELS(dep0), dep0, },
+  { NELS(dep187), dep187, NELS(dep0), dep0, },
+  { NELS(dep188), dep188, NELS(dep0), dep0, },
+  { NELS(dep189), dep189, NELS(dep0), dep0, },
+  { NELS(dep190), dep190, NELS(dep0), dep0, },
+  { NELS(dep191), dep191, NELS(dep0), dep0, },
+  { NELS(dep192), dep192, NELS(dep0), dep0, },
+  { NELS(dep193), dep193, NELS(dep0), dep0, },
+  { NELS(dep195), dep195, NELS(dep194), dep194, },
+  { NELS(dep197), dep197, NELS(dep196), dep196, },
+  { NELS(dep199), dep199, NELS(dep198), dep198, },
+  { NELS(dep201), dep201, NELS(dep200), dep200, },
+  { NELS(dep202), dep202, NELS(dep0), dep0, },
+  { NELS(dep203), dep203, NELS(dep0), dep0, },
+  { NELS(dep204), dep204, NELS(dep0), dep0, },
+  { NELS(dep205), dep205, NELS(dep31), dep31, },
+  { NELS(dep206), dep206, NELS(dep31), dep31, },
+  { NELS(dep207), dep207, NELS(dep194), dep194, },
+  { NELS(dep208), dep208, NELS(dep0), dep0, },
+  { NELS(dep210), dep210, NELS(dep209), dep209, },
+  { NELS(dep211), dep211, NELS(dep0), dep0, },
+  { NELS(dep213), dep213, NELS(dep212), dep212, },
+  { NELS(dep214), dep214, NELS(dep212), dep212, },
+  { NELS(dep215), dep215, NELS(dep0), dep0, },
+  { NELS(dep213), dep213, NELS(dep216), dep216, },
+  { NELS(dep218), dep218, NELS(dep217), dep217, },
+  { NELS(dep219), dep219, NELS(dep217), dep217, },
+  { NELS(dep221), dep221, NELS(dep220), dep220, },
+  { NELS(dep223), dep223, NELS(dep222), dep222, },
+  { NELS(dep224), dep224, NELS(dep222), dep222, },
+  { NELS(dep225), dep225, NELS(dep222), dep222, },
+  { NELS(dep226), dep226, NELS(dep0), dep0, },
+  { NELS(dep227), dep227, NELS(dep222), dep222, },
+  { NELS(dep229), dep229, NELS(dep228), dep228, },
+  { NELS(dep230), dep230, NELS(dep62), dep62, },
+  { NELS(dep231), dep231, NELS(dep62), dep62, },
+  { NELS(dep233), dep233, NELS(dep232), dep232, },
+  { NELS(dep234), dep234, NELS(dep232), dep232, },
+  { NELS(dep233), dep233, NELS(dep235), dep235, },
+  { NELS(dep237), dep237, NELS(dep236), dep236, },
+  { NELS(dep238), dep238, NELS(dep236), dep236, },
+  { NELS(dep240), dep240, NELS(dep239), dep239, },
+  { NELS(dep241), dep241, NELS(dep239), dep239, },
+  { NELS(dep240), dep240, NELS(dep242), dep242, },
+  { NELS(dep243), dep243, NELS(dep217), dep217, },
+  { NELS(dep244), dep244, NELS(dep31), dep31, },
+  { NELS(dep245), dep245, NELS(dep31), dep31, },
+  { NELS(dep246), dep246, NELS(dep0), dep0, },
+  { NELS(dep247), dep247, NELS(dep0), dep0, },
+  { NELS(dep248), dep248, NELS(dep62), dep62, },
+  { NELS(dep249), dep249, NELS(dep222), dep222, },
+  { 0, NULL, 0, NULL, },
+  { NELS(dep251), dep251, NELS(dep250), dep250, },
+};
+
+static const struct ia64_completer_table
+completer_table[] = {
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 88 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 88 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, 576, -1, 0, 1, 6 },
+  { 0x0, 0x0, 0, 639, -1, 0, 1, 17 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 157 },
+  { 0x0, 0x0, 0, 738, -1, 0, 1, 17 },
+  { 0x0, 0x0, 0, 2164, -1, 0, 1, 10 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 9 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 13 },
+  { 0x1, 0x1, 0, -1, -1, 13, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 33 },
+  { 0x0, 0x0, 0, 2372, -1, 0, 1, 29 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 29 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 29 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 33 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 33 },
+  { 0x0, 0x0, 0, 1122, -1, 0, 1, 122 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 44 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 40 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 78 },
+  { 0x0, 0x0, 0, 2212, -1, 0, 1, 29 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 29 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 29 },
+  { 0x0, 0x0, 0, 2439, -1, 0, 1, 29 },
+  { 0x0, 0x0, 0, 2216, -1, 0, 1, 29 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 33 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 33 },
+  { 0x0, 0x0, 0, 2218, -1, 0, 1, 29 },
+  { 0x0, 0x0, 0, 2448, -1, 0, 1, 29 },
+  { 0x0, 0x0, 0, 2451, -1, 0, 1, 29 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 33 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 33 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 33 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 29 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 29 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 29 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 29 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 29 },
+  { 0x0, 0x0, 0, 2473, -1, 0, 1, 29 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 29 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 33 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 33 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 29 },
+  { 0x0, 0x0, 0, 2476, -1, 0, 1, 29 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 24 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 24 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 24 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 24 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 33 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 35 },
+  { 0x0, 0x0, 0, 2484, -1, 0, 1, 29 },
+  { 0x0, 0x0, 0, 1391, -1, 0, 1, 33 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 40 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 33 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 157 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 77 },
+  { 0x0, 0x0, 0, 1439, -1, 0, 1, 124 },
+  { 0x0, 0x0, 0, 1448, -1, 0, 1, 124 },
+  { 0x0, 0x0, 0, 1457, -1, 0, 1, 124 },
+  { 0x0, 0x0, 0, 1459, -1, 0, 1, 125 },
+  { 0x0, 0x0, 0, 1461, -1, 0, 1, 125 },
+  { 0x0, 0x0, 0, 1470, -1, 0, 1, 124 },
+  { 0x0, 0x0, 0, 1479, -1, 0, 1, 124 },
+  { 0x0, 0x0, 0, 1488, -1, 0, 1, 124 },
+  { 0x0, 0x0, 0, 1497, -1, 0, 1, 124 },
+  { 0x0, 0x0, 0, 1506, -1, 0, 1, 124 },
+  { 0x0, 0x0, 0, 1515, -1, 0, 1, 124 },
+  { 0x0, 0x0, 0, 1525, -1, 0, 1, 124 },
+  { 0x0, 0x0, 0, 1535, -1, 0, 1, 124 },
+  { 0x0, 0x0, 0, 1545, -1, 0, 1, 124 },
+  { 0x0, 0x0, 0, 1554, -1, 0, 1, 140 },
+  { 0x0, 0x0, 0, 1560, -1, 0, 1, 145 },
+  { 0x0, 0x0, 0, 1566, -1, 0, 1, 145 },
+  { 0x0, 0x0, 0, 1572, -1, 0, 1, 140 },
+  { 0x0, 0x0, 0, 1578, -1, 0, 1, 145 },
+  { 0x0, 0x0, 0, 1584, -1, 0, 1, 145 },
+  { 0x0, 0x0, 0, 1590, -1, 0, 1, 140 },
+  { 0x0, 0x0, 0, 1596, -1, 0, 1, 145 },
+  { 0x0, 0x0, 0, 1602, -1, 0, 1, 145 },
+  { 0x0, 0x0, 0, 1608, -1, 0, 1, 140 },
+  { 0x0, 0x0, 0, 1614, -1, 0, 1, 145 },
+  { 0x0, 0x0, 0, 1620, -1, 0, 1, 140 },
+  { 0x0, 0x0, 0, 1626, -1, 0, 1, 145 },
+  { 0x0, 0x0, 0, 1632, -1, 0, 1, 140 },
+  { 0x0, 0x0, 0, 1638, -1, 0, 1, 145 },
+  { 0x0, 0x0, 0, 1644, -1, 0, 1, 140 },
+  { 0x0, 0x0, 0, 1650, -1, 0, 1, 145 },
+  { 0x0, 0x0, 0, 1656, -1, 0, 1, 145 },
+  { 0x0, 0x0, 0, 1660, -1, 0, 1, 151 },
+  { 0x0, 0x0, 0, 1664, -1, 0, 1, 153 },
+  { 0x0, 0x0, 0, 1668, -1, 0, 1, 153 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 79 },
+  { 0x0, 0x0, 0, 256, -1, 0, 1, 40 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 33 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 67 },
+  { 0x1, 0x1, 0, 1148, -1, 20, 1, 67 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 68 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 69 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 69 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 70 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 71 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 72 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 86 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 87 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 89 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 90 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 91 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 92 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 97 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 98 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 99 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 100 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 101 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 102 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 103 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 106 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 107 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 108 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 109 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 110 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 111 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 112 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 113 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 158 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 158 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 158 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 71 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 157 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, 2824, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, 2825, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, 2176, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, 2177, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, 2839, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, 2840, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, 2841, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, 2842, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, 2843, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, 2826, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, 2827, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 11 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 84 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 83 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x1, 0x1, 0, -1, -1, 13, 1, 0 },
+  { 0x0, 0x0, 0, 2845, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 84 },
+  { 0x0, 0x0, 0, 1948, -1, 0, 1, 131 },
+  { 0x0, 0x0, 0, 1950, -1, 0, 1, 138 },
+  { 0x0, 0x0, 0, 1952, -1, 0, 1, 132 },
+  { 0x0, 0x0, 0, 1954, -1, 0, 1, 132 },
+  { 0x0, 0x0, 0, 1956, -1, 0, 1, 131 },
+  { 0x0, 0x0, 0, 1958, -1, 0, 1, 138 },
+  { 0x0, 0x0, 0, 1960, -1, 0, 1, 131 },
+  { 0x0, 0x0, 0, 1962, -1, 0, 1, 138 },
+  { 0x0, 0x0, 0, 1965, -1, 0, 1, 131 },
+  { 0x0, 0x0, 0, 1968, -1, 0, 1, 138 },
+  { 0x0, 0x0, 0, 1971, -1, 0, 1, 150 },
+  { 0x0, 0x0, 0, 1972, -1, 0, 1, 156 },
+  { 0x0, 0x0, 0, 1973, -1, 0, 1, 150 },
+  { 0x0, 0x0, 0, 1974, -1, 0, 1, 156 },
+  { 0x0, 0x0, 0, 1975, -1, 0, 1, 150 },
+  { 0x0, 0x0, 0, 1976, -1, 0, 1, 156 },
+  { 0x0, 0x0, 0, 1977, -1, 0, 1, 150 },
+  { 0x0, 0x0, 0, 1978, -1, 0, 1, 156 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 82 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 120 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 118 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 120 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 119 },
+  { 0x0, 0x0, 0, 1669, -1, 0, 1, 136 },
+  { 0x0, 0x0, 0, 1670, -1, 0, 1, 136 },
+  { 0x0, 0x0, 0, 1671, -1, 0, 1, 136 },
+  { 0x0, 0x0, 0, 1672, -1, 0, 1, 136 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 1, 223, -1, 0, 1, 12 },
+  { 0x1, 0x1, 2, -1, -1, 27, 1, 12 },
+  { 0x0, 0x0, 3, -1, 1322, 0, 0, -1 },
+  { 0x0, 0x0, 3, -1, 1323, 0, 0, -1 },
+  { 0x1, 0x1, 3, 2715, 1432, 33, 1, 127 },
+  { 0x1, 0x1, 3, 2716, 1441, 33, 1, 127 },
+  { 0x1, 0x1, 3, 2717, 1450, 33, 1, 127 },
+  { 0x1, 0x1, 3, 2718, 1463, 33, 1, 127 },
+  { 0x1, 0x1, 3, 2719, 1472, 33, 1, 127 },
+  { 0x1, 0x1, 3, 2720, 1481, 33, 1, 127 },
+  { 0x1, 0x1, 3, 2721, 1490, 33, 1, 127 },
+  { 0x1, 0x1, 3, 2722, 1499, 33, 1, 127 },
+  { 0x1, 0x1, 3, 2723, 1508, 33, 1, 127 },
+  { 0x1, 0x1, 3, 2724, 1517, 33, 1, 127 },
+  { 0x1, 0x1, 3, 2725, 1527, 33, 1, 127 },
+  { 0x1, 0x1, 3, 2726, 1537, 33, 1, 127 },
+  { 0x1, 0x1, 3, 2727, 1550, 33, 1, 142 },
+  { 0x1, 0x1, 3, 2728, 1556, 33, 1, 147 },
+  { 0x1, 0x1, 3, 2729, 1562, 33, 1, 147 },
+  { 0x1, 0x1, 3, 2730, 1568, 33, 1, 142 },
+  { 0x1, 0x1, 3, 2731, 1574, 33, 1, 147 },
+  { 0x1, 0x1, 3, 2732, 1580, 33, 1, 147 },
+  { 0x1, 0x1, 3, 2733, 1586, 33, 1, 142 },
+  { 0x1, 0x1, 3, 2734, 1592, 33, 1, 147 },
+  { 0x1, 0x1, 3, 2735, 1598, 33, 1, 147 },
+  { 0x1, 0x1, 3, 2736, 1604, 33, 1, 142 },
+  { 0x1, 0x1, 3, 2737, 1610, 33, 1, 147 },
+  { 0x1, 0x1, 3, 2738, 1616, 33, 1, 142 },
+  { 0x1, 0x1, 3, 2739, 1622, 33, 1, 147 },
+  { 0x1, 0x1, 3, 2740, 1628, 33, 1, 142 },
+  { 0x1, 0x1, 3, 2741, 1634, 33, 1, 147 },
+  { 0x1, 0x1, 3, 2742, 1640, 33, 1, 142 },
+  { 0x1, 0x1, 3, 2743, 1646, 33, 1, 147 },
+  { 0x1, 0x1, 3, 2744, 1652, 33, 1, 147 },
+  { 0x1, 0x1, 3, -1, -1, 27, 1, 40 },
+  { 0x0, 0x0, 4, 2178, 1407, 0, 1, 135 },
+  { 0x0, 0x0, 4, 2179, 1409, 0, 1, 135 },
+  { 0x0, 0x0, 4, 2180, 1411, 0, 1, 134 },
+  { 0x0, 0x0, 4, 2181, 1413, 0, 1, 134 },
+  { 0x0, 0x0, 4, 2182, 1415, 0, 1, 134 },
+  { 0x0, 0x0, 4, 2183, 1417, 0, 1, 134 },
+  { 0x0, 0x0, 4, 2184, 1419, 0, 1, 134 },
+  { 0x0, 0x0, 4, 2185, 1421, 0, 1, 134 },
+  { 0x0, 0x0, 4, 2186, 1423, 0, 1, 134 },
+  { 0x0, 0x0, 4, 2187, 1425, 0, 1, 134 },
+  { 0x0, 0x0, 4, 2188, 1427, 0, 1, 136 },
+  { 0x0, 0x0, 4, 2189, 1429, 0, 1, 136 },
+  { 0x1, 0x1, 4, -1, 1436, 33, 1, 130 },
+  { 0x5, 0x5, 4, 534, 1435, 32, 1, 124 },
+  { 0x1, 0x1, 4, -1, 1445, 33, 1, 130 },
+  { 0x5, 0x5, 4, 535, 1444, 32, 1, 124 },
+  { 0x1, 0x1, 4, -1, 1454, 33, 1, 130 },
+  { 0x5, 0x5, 4, 536, 1453, 32, 1, 124 },
+  { 0x1, 0x1, 4, -1, 1458, 32, 1, 125 },
+  { 0x1, 0x1, 4, -1, 1460, 32, 1, 125 },
+  { 0x1, 0x1, 4, -1, 1467, 33, 1, 130 },
+  { 0x5, 0x5, 4, 537, 1466, 32, 1, 124 },
+  { 0x1, 0x1, 4, -1, 1476, 33, 1, 130 },
+  { 0x5, 0x5, 4, 538, 1475, 32, 1, 124 },
+  { 0x1, 0x1, 4, -1, 1485, 33, 1, 130 },
+  { 0x5, 0x5, 4, 539, 1484, 32, 1, 124 },
+  { 0x1, 0x1, 4, -1, 1494, 33, 1, 130 },
+  { 0x5, 0x5, 4, 540, 1493, 32, 1, 124 },
+  { 0x1, 0x1, 4, -1, 1503, 33, 1, 130 },
+  { 0x5, 0x5, 4, 541, 1502, 32, 1, 124 },
+  { 0x1, 0x1, 4, -1, 1512, 33, 1, 130 },
+  { 0x5, 0x5, 4, 542, 1511, 32, 1, 124 },
+  { 0x1, 0x1, 4, -1, 1522, 33, 1, 130 },
+  { 0x5, 0x5, 4, 1018, 1520, 32, 1, 124 },
+  { 0x1, 0x1, 4, -1, 1532, 33, 1, 130 },
+  { 0x5, 0x5, 4, 1019, 1530, 32, 1, 124 },
+  { 0x1, 0x1, 4, -1, 1542, 33, 1, 130 },
+  { 0x5, 0x5, 4, 1020, 1540, 32, 1, 124 },
+  { 0x1, 0x21, 10, 1991, -1, 33, 1, 3 },
+  { 0x200001, 0x200001, 10, 1992, -1, 12, 1, 3 },
+  { 0x1, 0x21, 10, 410, -1, 33, 1, 3 },
+  { 0x200001, 0x200001, 10, 2048, -1, 12, 1, 3 },
+  { 0x0, 0x0, 10, -1, 2049, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2050, 0, 0, -1 },
+  { 0x0, 0x0, 10, 1995, -1, 0, 1, 3 },
+  { 0x1, 0x1, 10, 1996, -1, 12, 1, 3 },
+  { 0x1, 0x1, 10, 1997, -1, 33, 1, 3 },
+  { 0x200001, 0x200001, 10, 1998, -1, 12, 1, 3 },
+  { 0x0, 0x0, 10, 420, -1, 0, 1, 3 },
+  { 0x1, 0x1, 10, 2054, -1, 12, 1, 3 },
+  { 0x1, 0x1, 10, 424, -1, 33, 1, 3 },
+  { 0x200001, 0x200001, 10, 2056, -1, 12, 1, 3 },
+  { 0x0, 0x0, 10, 428, -1, 0, 1, 3 },
+  { 0x1, 0x1, 10, 2058, -1, 12, 1, 3 },
+  { 0x1, 0x1, 10, 432, -1, 33, 1, 3 },
+  { 0x200001, 0x200001, 10, 2060, -1, 12, 1, 3 },
+  { 0x0, 0x0, 10, 436, -1, 0, 1, 3 },
+  { 0x1, 0x1, 10, 2062, -1, 12, 1, 3 },
+  { 0x1, 0x1, 10, 440, -1, 33, 1, 3 },
+  { 0x200001, 0x200001, 10, 2064, -1, 12, 1, 3 },
+  { 0x1, 0x21, 10, 2011, -1, 33, 1, 3 },
+  { 0x200001, 0x200001, 10, 2012, -1, 12, 1, 3 },
+  { 0x1, 0x21, 10, 450, -1, 33, 1, 3 },
+  { 0x200001, 0x200001, 10, 2070, -1, 12, 1, 3 },
+  { 0x0, 0x0, 10, -1, 2071, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2072, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2075, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2076, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2077, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2078, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2079, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2080, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2081, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2082, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2083, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2084, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2085, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2086, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2087, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2088, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2089, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2090, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2091, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2092, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2093, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2094, 0, 0, -1 },
+  { 0x1, 0x21, 10, 2015, -1, 33, 1, 3 },
+  { 0x200001, 0x200001, 10, 2016, -1, 12, 1, 3 },
+  { 0x1, 0x21, 10, 458, -1, 33, 1, 3 },
+  { 0x200001, 0x200001, 10, 2096, -1, 12, 1, 3 },
+  { 0x0, 0x0, 10, -1, 2097, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2098, 0, 0, -1 },
+  { 0x0, 0x0, 10, 2019, -1, 0, 1, 3 },
+  { 0x1, 0x1, 10, 2020, -1, 12, 1, 3 },
+  { 0x1, 0x1, 10, 2021, -1, 33, 1, 3 },
+  { 0x200001, 0x200001, 10, 2022, -1, 12, 1, 3 },
+  { 0x0, 0x0, 10, 468, -1, 0, 1, 3 },
+  { 0x1, 0x1, 10, 2102, -1, 12, 1, 3 },
+  { 0x1, 0x1, 10, 472, -1, 33, 1, 3 },
+  { 0x200001, 0x200001, 10, 2104, -1, 12, 1, 3 },
+  { 0x0, 0x0, 10, 476, -1, 0, 1, 3 },
+  { 0x1, 0x1, 10, 2106, -1, 12, 1, 3 },
+  { 0x1, 0x1, 10, 480, -1, 33, 1, 3 },
+  { 0x200001, 0x200001, 10, 2108, -1, 12, 1, 3 },
+  { 0x0, 0x0, 10, 484, -1, 0, 1, 3 },
+  { 0x1, 0x1, 10, 2110, -1, 12, 1, 3 },
+  { 0x1, 0x1, 10, 488, -1, 33, 1, 3 },
+  { 0x200001, 0x200001, 10, 2112, -1, 12, 1, 3 },
+  { 0x1, 0x21, 10, 2035, -1, 33, 1, 3 },
+  { 0x200001, 0x200001, 10, 2036, -1, 12, 1, 3 },
+  { 0x1, 0x21, 10, 498, -1, 33, 1, 3 },
+  { 0x200001, 0x200001, 10, 2118, -1, 12, 1, 3 },
+  { 0x0, 0x0, 10, -1, 2119, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2120, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2123, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2124, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2125, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2126, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2127, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2128, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2129, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2130, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2131, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2132, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2133, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2134, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2135, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2136, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2137, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2138, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2139, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2140, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2141, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2142, 0, 0, -1 },
+  { 0x1, 0x1, 10, 2039, -1, 36, 1, 3 },
+  { 0x1000001, 0x1000001, 10, 2040, -1, 12, 1, 3 },
+  { 0x1, 0x1, 10, 2041, -1, 36, 1, 3 },
+  { 0x1000001, 0x1000001, 10, 2042, -1, 12, 1, 3 },
+  { 0x0, 0x0, 10, -1, 2143, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2145, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2147, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2149, 0, 0, -1 },
+  { 0x1, 0x1, 10, 2043, -1, 36, 1, 3 },
+  { 0x1000001, 0x1000001, 10, 2044, -1, 12, 1, 3 },
+  { 0x1, 0x1, 10, 2045, -1, 36, 1, 3 },
+  { 0x1000001, 0x1000001, 10, 2046, -1, 12, 1, 3 },
+  { 0x0, 0x0, 10, -1, 2151, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2153, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2155, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 2157, 0, 0, -1 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x200001, 0x4200001, 11, 1993, -1, 12, 1, 3 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x1, 0x1, 11, 298, -1, 33, 1, 3 },
+  { 0x0, 0x0, 11, 2051, -1, 0, 1, 3 },
+  { 0x1, 0x1, 11, 2052, -1, 12, 1, 3 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x1, 0x1, 11, 1999, -1, 12, 1, 3 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x0, 0x0, 11, 306, -1, 0, 1, 3 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x200001, 0x200001, 11, 2001, -1, 12, 1, 3 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x1, 0x1, 11, 308, -1, 33, 1, 3 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x1, 0x1, 11, 2003, -1, 12, 1, 3 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x0, 0x0, 11, 310, -1, 0, 1, 3 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x200001, 0x200001, 11, 2005, -1, 12, 1, 3 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x1, 0x1, 11, 312, -1, 33, 1, 3 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x1, 0x1, 11, 2007, -1, 12, 1, 3 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x0, 0x0, 11, 314, -1, 0, 1, 3 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x200001, 0x200001, 11, 2009, -1, 12, 1, 3 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x1, 0x1, 11, 316, -1, 33, 1, 3 },
+  { 0x0, 0x0, 11, 2065, -1, 0, 1, 3 },
+  { 0x1, 0x1, 11, 2066, -1, 12, 1, 3 },
+  { 0x1, 0x1, 11, 2067, -1, 33, 1, 3 },
+  { 0x200001, 0x200001, 11, 2068, -1, 12, 1, 3 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x200001, 0x4200001, 11, 2013, -1, 12, 1, 3 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x1, 0x1, 11, 320, -1, 33, 1, 3 },
+  { 0x0, 0x0, 11, 2073, -1, 0, 1, 3 },
+  { 0x1, 0x1, 11, 2074, -1, 12, 1, 3 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x200001, 0x4200001, 11, 2017, -1, 12, 1, 3 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x1, 0x1, 11, 346, -1, 33, 1, 3 },
+  { 0x0, 0x0, 11, 2099, -1, 0, 1, 3 },
+  { 0x1, 0x1, 11, 2100, -1, 12, 1, 3 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x1, 0x1, 11, 2023, -1, 12, 1, 3 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x0, 0x0, 11, 354, -1, 0, 1, 3 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x200001, 0x200001, 11, 2025, -1, 12, 1, 3 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x1, 0x1, 11, 356, -1, 33, 1, 3 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x1, 0x1, 11, 2027, -1, 12, 1, 3 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x0, 0x0, 11, 358, -1, 0, 1, 3 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x200001, 0x200001, 11, 2029, -1, 12, 1, 3 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x1, 0x1, 11, 360, -1, 33, 1, 3 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x1, 0x1, 11, 2031, -1, 12, 1, 3 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x0, 0x0, 11, 362, -1, 0, 1, 3 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x200001, 0x200001, 11, 2033, -1, 12, 1, 3 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x1, 0x1, 11, 364, -1, 33, 1, 3 },
+  { 0x0, 0x0, 11, 2113, -1, 0, 1, 3 },
+  { 0x1, 0x1, 11, 2114, -1, 12, 1, 3 },
+  { 0x1, 0x1, 11, 2115, -1, 33, 1, 3 },
+  { 0x200001, 0x200001, 11, 2116, -1, 12, 1, 3 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x200001, 0x4200001, 11, 2037, -1, 12, 1, 3 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 5 },
+  { 0x1, 0x1, 11, 368, -1, 33, 1, 3 },
+  { 0x0, 0x0, 11, 2121, -1, 0, 1, 3 },
+  { 0x1, 0x1, 11, 2122, -1, 12, 1, 3 },
+  { 0x1, 0x1, 11, -1, -1, 36, 1, 5 },
+  { 0x1, 0x1, 11, -1, -1, 36, 1, 5 },
+  { 0x1, 0x1, 11, -1, -1, 36, 1, 5 },
+  { 0x1, 0x1, 11, -1, -1, 36, 1, 5 },
+  { 0x1, 0x1, 11, 2144, -1, 36, 1, 3 },
+  { 0x1000001, 0x1000001, 11, 2146, -1, 12, 1, 3 },
+  { 0x1, 0x1, 11, 2148, -1, 36, 1, 3 },
+  { 0x1000001, 0x1000001, 11, 2150, -1, 12, 1, 3 },
+  { 0x1, 0x1, 11, -1, -1, 36, 1, 5 },
+  { 0x1, 0x1, 11, -1, -1, 36, 1, 5 },
+  { 0x1, 0x1, 11, -1, -1, 36, 1, 5 },
+  { 0x1, 0x1, 11, -1, -1, 36, 1, 5 },
+  { 0x1, 0x1, 11, 2152, -1, 36, 1, 3 },
+  { 0x1000001, 0x1000001, 11, 2154, -1, 12, 1, 3 },
+  { 0x1, 0x1, 11, 2156, -1, 36, 1, 3 },
+  { 0x1000001, 0x1000001, 11, 2158, -1, 12, 1, 3 },
+  { 0x0, 0x0, 12, -1, -1, 0, 1, 14 },
+  { 0x0, 0x0, 12, -1, -1, 0, 1, 14 },
+  { 0x0, 0x0, 12, -1, -1, 0, 1, 14 },
+  { 0x1, 0x1, 13, 270, 1434, 34, 1, 124 },
+  { 0x1, 0x1, 13, 272, 1443, 34, 1, 124 },
+  { 0x1, 0x1, 13, 274, 1452, 34, 1, 124 },
+  { 0x1, 0x1, 13, 278, 1465, 34, 1, 124 },
+  { 0x1, 0x1, 13, 280, 1474, 34, 1, 124 },
+  { 0x1, 0x1, 13, 282, 1483, 34, 1, 124 },
+  { 0x1, 0x1, 13, 284, 1492, 34, 1, 124 },
+  { 0x1, 0x1, 13, 286, 1501, 34, 1, 124 },
+  { 0x1, 0x1, 13, 288, 1510, 34, 1, 124 },
+  { 0x1, 0x1, 13, 290, 1519, 34, 1, 124 },
+  { 0x1, 0x1, 13, 292, 1529, 34, 1, 124 },
+  { 0x1, 0x1, 13, 294, 1539, 34, 1, 124 },
+  { 0x0, 0x0, 19, -1, 777, 0, 0, -1 },
+  { 0x0, 0x0, 19, -1, 778, 0, 0, -1 },
+  { 0x0, 0x0, 19, -1, 779, 0, 0, -1 },
+  { 0x0, 0x0, 19, -1, 780, 0, 0, -1 },
+  { 0x0, 0x0, 19, -1, 781, 0, 0, -1 },
+  { 0x0, 0x0, 19, -1, 782, 0, 0, -1 },
+  { 0x0, 0x0, 19, -1, 783, 0, 0, -1 },
+  { 0x0, 0x0, 19, -1, 784, 0, 0, -1 },
+  { 0x0, 0x0, 19, -1, 785, 0, 0, -1 },
+  { 0x0, 0x0, 19, -1, 786, 0, 0, -1 },
+  { 0x0, 0x0, 19, -1, 787, 0, 0, -1 },
+  { 0x0, 0x0, 19, -1, 788, 0, 0, -1 },
+  { 0x0, 0x0, 19, -1, 789, 0, 0, -1 },
+  { 0x0, 0x0, 19, -1, 790, 0, 0, -1 },
+  { 0x0, 0x0, 19, -1, 791, 0, 0, -1 },
+  { 0x0, 0x0, 19, -1, 792, 0, 0, -1 },
+  { 0x0, 0x0, 19, -1, 793, 0, 0, -1 },
+  { 0x0, 0x0, 19, -1, 794, 0, 0, -1 },
+  { 0x0, 0x0, 19, -1, 795, 0, 0, -1 },
+  { 0x0, 0x0, 19, -1, 796, 0, 0, -1 },
+  { 0x0, 0x0, 19, -1, 797, 0, 0, -1 },
+  { 0x0, 0x0, 19, -1, 798, 0, 0, -1 },
+  { 0x0, 0x0, 19, -1, 799, 0, 0, -1 },
+  { 0x0, 0x0, 19, -1, 800, 0, 0, -1 },
+  { 0x0, 0x0, 19, -1, 801, 0, 0, -1 },
+  { 0x0, 0x0, 19, -1, 802, 0, 0, -1 },
+  { 0x0, 0x0, 19, -1, 803, 0, 0, -1 },
+  { 0x0, 0x0, 19, -1, 804, 0, 0, -1 },
+  { 0x0, 0x0, 19, -1, 805, 0, 0, -1 },
+  { 0x0, 0x0, 19, -1, 806, 0, 0, -1 },
+  { 0x0, 0x0, 20, -1, 2793, 0, 0, -1 },
+  { 0x0, 0x0, 20, -1, 2794, 0, 0, -1 },
+  { 0x0, 0x0, 20, -1, 2809, 0, 0, -1 },
+  { 0x0, 0x0, 20, -1, 2810, 0, 0, -1 },
+  { 0x0, 0x0, 20, -1, 2815, 0, 0, -1 },
+  { 0x0, 0x0, 20, -1, 2816, 0, 0, -1 },
+  { 0x0, 0x0, 21, 813, 2805, 0, 0, -1 },
+  { 0x0, 0x0, 21, 814, 2807, 0, 0, -1 },
+  { 0x0, 0x0, 23, -1, 2803, 0, 0, -1 },
+  { 0x0, 0x0, 23, -1, 2804, 0, 0, -1 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 6 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 6 },
+  { 0x1, 0x1, 24, 1254, -1, 35, 1, 6 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 6 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 6 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 6 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 6 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 6 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 6 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 6 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 6 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 6 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 6 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 6 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 6 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 6 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 6 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 6 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 6 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 7 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 7 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 7 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 7 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 7 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 7 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 7 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 7 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 6 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 6 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 6 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 6 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 6 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 6 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 6 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 6 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 7 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 7 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 7 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 7 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 8 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 8 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 8 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 8 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 8 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 8 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 8 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 8 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 8 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 8 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 8 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 8 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 15 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 15 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 15 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 15 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 15 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 15 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 15 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 15 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 15 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 15 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 15 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 15 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, 1275, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 18 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 18 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 18 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 18 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 18 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 18 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 18 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 18 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 18 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 18 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 18 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 18 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 18 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 18 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 18 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 18 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 18 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 18 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 18 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 18 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 18 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 18 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 18 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 18 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 19 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 19 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 19 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 19 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 19 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 19 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 19 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 19 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 19 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 19 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 19 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 19 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 20 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 20 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 20 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 20 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 20 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 20 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 20 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 20 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 20 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 20 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 20 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 20 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 20 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 20 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 20 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 20 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 20 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 20 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 20 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 20 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 20 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 20 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 20 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 20 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 21 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 21 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 21 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 21 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 21 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 21 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 21 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 21 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 21 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 21 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 21 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 21 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, 1308, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 21 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 21 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 21 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 21 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 21 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 21 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 21 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 21 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 21 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 21 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 21 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 21 },
+  { 0x1, 0x1, 24, -1, -1, 33, 1, 76 },
+  { 0x1, 0x1, 24, -1, -1, 33, 1, 76 },
+  { 0x1, 0x1, 24, 1324, 1437, 35, 1, 130 },
+  { 0x1, 0x1, 24, 1325, 1446, 35, 1, 130 },
+  { 0x1, 0x1, 24, 1326, 1455, 35, 1, 130 },
+  { 0x1, 0x1, 24, 1327, 1468, 35, 1, 130 },
+  { 0x1, 0x1, 24, 1328, 1477, 35, 1, 130 },
+  { 0x1, 0x1, 24, 1329, 1486, 35, 1, 130 },
+  { 0x1, 0x1, 24, 1330, 1495, 35, 1, 130 },
+  { 0x1, 0x1, 24, 1331, 1504, 35, 1, 130 },
+  { 0x1, 0x1, 24, 1332, 1513, 35, 1, 130 },
+  { 0x1, 0x1, 24, 1333, 1523, 35, 1, 130 },
+  { 0x1, 0x1, 24, 1334, 1533, 35, 1, 130 },
+  { 0x1, 0x1, 24, 1335, 1543, 35, 1, 130 },
+  { 0x1, 0x1, 24, 1336, 1552, 35, 1, 144 },
+  { 0x1, 0x1, 24, 1337, 1558, 35, 1, 149 },
+  { 0x1, 0x1, 24, 1338, 1564, 35, 1, 149 },
+  { 0x1, 0x1, 24, 1339, 1570, 35, 1, 144 },
+  { 0x1, 0x1, 24, 1340, 1576, 35, 1, 149 },
+  { 0x1, 0x1, 24, 1341, 1582, 35, 1, 149 },
+  { 0x1, 0x1, 24, 1342, 1588, 35, 1, 144 },
+  { 0x1, 0x1, 24, 1343, 1594, 35, 1, 149 },
+  { 0x1, 0x1, 24, 1344, 1600, 35, 1, 149 },
+  { 0x1, 0x1, 24, 1345, 1606, 35, 1, 144 },
+  { 0x1, 0x1, 24, 1346, 1612, 35, 1, 149 },
+  { 0x1, 0x1, 24, 1347, 1618, 35, 1, 144 },
+  { 0x1, 0x1, 24, 1348, 1624, 35, 1, 149 },
+  { 0x1, 0x1, 24, 1349, 1630, 35, 1, 144 },
+  { 0x1, 0x1, 24, 1350, 1636, 35, 1, 149 },
+  { 0x1, 0x1, 24, 1351, 1642, 35, 1, 144 },
+  { 0x1, 0x1, 24, 1352, 1648, 35, 1, 149 },
+  { 0x1, 0x1, 24, 1353, 1654, 35, 1, 149 },
+  { 0x0, 0x0, 33, 2787, 2785, 0, 0, -1 },
+  { 0x0, 0x0, 33, 2790, 2788, 0, 0, -1 },
+  { 0x0, 0x0, 33, 2796, 2795, 0, 0, -1 },
+  { 0x0, 0x0, 33, 2798, 2797, 0, 0, -1 },
+  { 0x0, 0x0, 33, 2812, 2811, 0, 0, -1 },
+  { 0x0, 0x0, 33, 2814, 2813, 0, 0, -1 },
+  { 0x0, 0x0, 35, -1, 2806, 0, 0, -1 },
+  { 0x0, 0x0, 35, -1, 2808, 0, 0, -1 },
+  { 0x1, 0x1, 38, -1, 2256, 37, 1, 29 },
+  { 0x1, 0x1, 38, -1, 2315, 37, 1, 29 },
+  { 0x0, 0x0, 38, -1, 2318, 0, 0, -1 },
+  { 0x1, 0x1, 38, -1, -1, 37, 1, 29 },
+  { 0x1, 0x1, 38, -1, 2323, 37, 1, 29 },
+  { 0x0, 0x0, 38, -1, 2326, 0, 0, -1 },
+  { 0x1, 0x1, 38, -1, -1, 37, 1, 29 },
+  { 0x0, 0x0, 38, -1, 2329, 0, 0, -1 },
+  { 0x1, 0x1, 38, -1, -1, 37, 1, 29 },
+  { 0x1, 0x1, 38, -1, 2332, 37, 1, 29 },
+  { 0x1, 0x1, 38, -1, 2335, 37, 1, 29 },
+  { 0x1, 0x1, 38, -1, 2368, 37, 1, 29 },
+  { 0x3, 0x3, 38, -1, -1, 30, 1, 137 },
+  { 0x0, 0x0, 38, 1124, -1, 0, 1, 95 },
+  { 0x0, 0x0, 38, -1, -1, 0, 1, 104 },
+  { 0x0, 0x0, 38, 1130, -1, 0, 1, 116 },
+  { 0x3, 0x3, 38, -1, -1, 30, 1, 155 },
+  { 0x0, 0x0, 38, 1131, -1, 0, 1, 40 },
+  { 0x0, 0x0, 40, -1, 955, 0, 0, -1 },
+  { 0x0, 0x0, 40, -1, 963, 0, 0, -1 },
+  { 0x0, 0x0, 40, 1133, 959, 0, 0, -1 },
+  { 0x3, 0x3, 40, -1, 604, 33, 1, 6 },
+  { 0x18000001, 0x18000001, 40, -1, 612, 6, 1, 7 },
+  { 0x3, 0x3, 40, 1134, 608, 33, 1, 6 },
+  { 0x0, 0x0, 40, -1, 967, 0, 0, -1 },
+  { 0x3, 0x3, 40, -1, 624, 33, 1, 8 },
+  { 0x0, 0x0, 40, -1, 971, 0, 0, -1 },
+  { 0x3, 0x3, 40, -1, 636, 33, 1, 15 },
+  { 0x0, 0x0, 40, -1, 976, 0, 0, -1 },
+  { 0x0, 0x0, 40, -1, 980, 0, 0, -1 },
+  { 0x3, 0x3, 40, -1, 659, 33, 1, 17 },
+  { 0x3, 0x3, 40, -1, 663, 33, 1, 17 },
+  { 0x0, 0x0, 40, -1, 984, 0, 0, -1 },
+  { 0x0, 0x0, 40, -1, 988, 0, 0, -1 },
+  { 0x3, 0x3, 40, -1, 683, 33, 1, 18 },
+  { 0x18000001, 0x18000001, 40, -1, 687, 6, 1, 18 },
+  { 0x0, 0x0, 40, -1, 992, 0, 0, -1 },
+  { 0x3, 0x3, 40, -1, 699, 33, 1, 19 },
+  { 0x0, 0x0, 40, -1, 996, 0, 0, -1 },
+  { 0x0, 0x0, 40, -1, 1000, 0, 0, -1 },
+  { 0x3, 0x3, 40, -1, 719, 33, 1, 20 },
+  { 0x18000001, 0x18000001, 40, -1, 723, 6, 1, 20 },
+  { 0x0, 0x0, 40, -1, 1004, 0, 0, -1 },
+  { 0x3, 0x3, 40, -1, 735, 33, 1, 21 },
+  { 0x0, 0x0, 40, -1, 1009, 0, 0, -1 },
+  { 0x0, 0x0, 40, -1, 1013, 0, 0, -1 },
+  { 0x3, 0x3, 40, -1, 758, 33, 1, 17 },
+  { 0x3, 0x3, 40, -1, 762, 33, 1, 17 },
+  { 0x0, 0x0, 40, -1, 1017, 0, 0, -1 },
+  { 0x3, 0x3, 40, -1, 774, 33, 1, 21 },
+  { 0x0, 0x0, 41, 833, 954, 0, 0, -1 },
+  { 0x0, 0x0, 41, 834, 962, 0, 0, -1 },
+  { 0x0, 0x0, 41, 835, 958, 0, 0, -1 },
+  { 0x1, 0x1, 41, 836, 603, 34, 1, 6 },
+  { 0x10000001, 0x10000001, 41, 837, 611, 6, 1, 7 },
+  { 0x1, 0x1, 41, 838, 607, 34, 1, 6 },
+  { 0x0, 0x0, 41, 839, 966, 0, 0, -1 },
+  { 0x1, 0x1, 41, 840, 623, 34, 1, 8 },
+  { 0x0, 0x0, 41, 841, 970, 0, 0, -1 },
+  { 0x1, 0x1, 41, 842, 635, 34, 1, 15 },
+  { 0x0, 0x0, 41, 843, 975, 0, 0, -1 },
+  { 0x0, 0x0, 41, 844, 979, 0, 0, -1 },
+  { 0x1, 0x1, 41, 845, 658, 34, 1, 17 },
+  { 0x1, 0x1, 41, 846, 662, 34, 1, 17 },
+  { 0x0, 0x0, 41, 847, 983, 0, 0, -1 },
+  { 0x0, 0x0, 41, 848, 987, 0, 0, -1 },
+  { 0x1, 0x1, 41, 849, 682, 34, 1, 18 },
+  { 0x10000001, 0x10000001, 41, 850, 686, 6, 1, 18 },
+  { 0x0, 0x0, 41, 851, 991, 0, 0, -1 },
+  { 0x1, 0x1, 41, 852, 698, 34, 1, 19 },
+  { 0x0, 0x0, 41, 853, 995, 0, 0, -1 },
+  { 0x0, 0x0, 41, 854, 999, 0, 0, -1 },
+  { 0x1, 0x1, 41, 855, 718, 34, 1, 20 },
+  { 0x10000001, 0x10000001, 41, 856, 722, 6, 1, 20 },
+  { 0x0, 0x0, 41, 857, 1003, 0, 0, -1 },
+  { 0x1, 0x1, 41, 858, 734, 34, 1, 21 },
+  { 0x0, 0x0, 41, 859, 1008, 0, 0, -1 },
+  { 0x0, 0x0, 41, 860, 1012, 0, 0, -1 },
+  { 0x1, 0x1, 41, 861, 757, 34, 1, 17 },
+  { 0x1, 0x1, 41, 862, 761, 34, 1, 17 },
+  { 0x0, 0x0, 41, 863, 1016, 0, 0, -1 },
+  { 0x1, 0x1, 41, 864, 773, 34, 1, 21 },
+  { 0x800001, 0x800001, 41, -1, 1138, 4, 1, 16 },
+  { 0x1, 0x1, 41, 2202, 1136, 4, 1, 16 },
+  { 0x1, 0x1, 41, 939, 1141, 4, 1, 22 },
+  { 0x2, 0x3, 41, -1, 1146, 20, 1, 67 },
+  { 0x1, 0x1, 41, 2203, 1144, 21, 1, 67 },
+  { 0x0, 0x0, 42, -1, -1, 0, 1, 80 },
+  { 0x0, 0x0, 42, -1, -1, 0, 1, 80 },
+  { 0x0, 0x0, 42, -1, -1, 0, 1, 123 },
+  { 0x1, 0x1, 44, 1354, 295, 38, 1, 1 },
+  { 0x1, 0x1, 44, 1355, 297, 38, 1, 1 },
+  { 0x0, 0x0, 44, -1, 300, 0, 0, -1 },
+  { 0x0, 0x0, 44, -1, 414, 0, 0, -1 },
+  { 0x1, 0x1, 44, 1359, 317, 38, 1, 1 },
+  { 0x1, 0x1, 44, 1360, 319, 38, 1, 1 },
+  { 0x0, 0x0, 44, -1, 322, 0, 0, -1 },
+  { 0x0, 0x0, 44, -1, 454, 0, 0, -1 },
+  { 0x0, 0x0, 44, -1, 324, 0, 0, -1 },
+  { 0x0, 0x0, 44, -1, 342, 0, 0, -1 },
+  { 0x1, 0x1, 44, 1366, 343, 38, 1, 1 },
+  { 0x1, 0x1, 44, 1367, 345, 38, 1, 1 },
+  { 0x0, 0x0, 44, -1, 348, 0, 0, -1 },
+  { 0x0, 0x0, 44, -1, 462, 0, 0, -1 },
+  { 0x1, 0x1, 44, 1371, 365, 38, 1, 1 },
+  { 0x1, 0x1, 44, 1372, 367, 38, 1, 1 },
+  { 0x0, 0x0, 44, -1, 370, 0, 0, -1 },
+  { 0x0, 0x0, 44, -1, 502, 0, 0, -1 },
+  { 0x0, 0x0, 44, -1, 372, 0, 0, -1 },
+  { 0x0, 0x0, 44, -1, 390, 0, 0, -1 },
+  { 0x0, 0x0, 44, 1230, 2263, 0, 0, -1 },
+  { 0x0, 0x0, 44, 1231, 2271, 0, 1, 54 },
+  { 0x0, 0x0, 44, 1232, 2938, 0, 1, 54 },
+  { 0x0, 0x0, 44, 1233, 2339, 0, 0, -1 },
+  { 0x0, 0x0, 44, 1234, -1, 0, 1, 49 },
+  { 0x0, 0x0, 44, 1102, -1, 0, 1, 0 },
+  { 0x0, 0x0, 44, 1103, -1, 0, 1, 0 },
+  { 0x0, 0x0, 44, 1104, -1, 0, 1, 0 },
+  { 0x1, 0x1, 45, -1, 1658, 30, 1, 152 },
+  { 0x1, 0x1, 45, 945, 1657, 30, 1, 151 },
+  { 0x1, 0x1, 45, -1, 1662, 30, 1, 154 },
+  { 0x1, 0x1, 45, 946, 1661, 30, 1, 153 },
+  { 0x1, 0x1, 45, -1, 1666, 30, 1, 154 },
+  { 0x1, 0x1, 45, 947, 1665, 30, 1, 153 },
+  { 0x3, 0x3, 46, -1, 1142, 3, 1, 22 },
+  { 0x1, 0x1, 47, 2223, -1, 30, 1, 137 },
+  { 0x1, 0x1, 47, 2254, -1, 30, 1, 155 },
+  { 0x0, 0x0, 49, -1, -1, 0, 1, 40 },
+  { 0x0, 0x0, 49, -1, -1, 0, 1, 40 },
+  { 0x0, 0x0, 49, -1, -1, 0, 1, 40 },
+  { 0x1, 0x1, 56, -1, 1659, 31, 1, 152 },
+  { 0x1, 0x1, 56, -1, 1663, 31, 1, 154 },
+  { 0x1, 0x1, 56, -1, 1667, 31, 1, 154 },
+  { 0x0, 0x0, 56, -1, -1, 0, 1, 94 },
+  { 0x2, 0x3, 56, -1, -1, 27, 1, 94 },
+  { 0x1, 0x1, 56, -1, -1, 28, 1, 94 },
+  { 0x0, 0x0, 65, 14, 574, 0, 1, 6 },
+  { 0x0, 0x0, 65, 1255, 577, 0, 1, 6 },
+  { 0x1, 0x1, 65, 1256, 579, 33, 1, 6 },
+  { 0x1, 0x1, 65, 1257, 581, 34, 1, 6 },
+  { 0x3, 0x3, 65, 1258, 583, 33, 1, 6 },
+  { 0x0, 0x0, 65, 1259, 585, 0, 1, 6 },
+  { 0x1, 0x1, 65, 1260, 587, 33, 1, 6 },
+  { 0x1, 0x1, 65, 1261, 589, 34, 1, 6 },
+  { 0x3, 0x3, 65, 1262, 591, 33, 1, 6 },
+  { 0x1, 0x1, 65, 1263, 593, 6, 1, 7 },
+  { 0x8000001, 0x8000001, 65, 1264, 595, 6, 1, 7 },
+  { 0x10000001, 0x10000001, 65, 1265, 597, 6, 1, 7 },
+  { 0x18000001, 0x18000001, 65, 1266, 599, 6, 1, 7 },
+  { 0x0, 0x0, 65, 1267, 613, 0, 1, 8 },
+  { 0x1, 0x1, 65, 1268, 615, 33, 1, 8 },
+  { 0x1, 0x1, 65, 1269, 617, 34, 1, 8 },
+  { 0x3, 0x3, 65, 1270, 619, 33, 1, 8 },
+  { 0x0, 0x0, 65, 1271, 625, 0, 1, 15 },
+  { 0x1, 0x1, 65, 1272, 627, 33, 1, 15 },
+  { 0x1, 0x1, 65, 1273, 629, 34, 1, 15 },
+  { 0x3, 0x3, 65, 1274, 631, 33, 1, 15 },
+  { 0x0, 0x0, 65, 15, 637, 0, 1, 17 },
+  { 0x0, 0x0, 65, 1276, 640, 0, 1, 17 },
+  { 0x1, 0x1, 65, 1277, 642, 33, 1, 17 },
+  { 0x1, 0x1, 65, 1278, 644, 34, 1, 17 },
+  { 0x3, 0x3, 65, 1279, 646, 33, 1, 17 },
+  { 0x0, 0x0, 65, 1280, 648, 0, 1, 17 },
+  { 0x1, 0x1, 65, 1281, 650, 33, 1, 17 },
+  { 0x1, 0x1, 65, 1282, 652, 34, 1, 17 },
+  { 0x3, 0x3, 65, 1283, 654, 33, 1, 17 },
+  { 0x0, 0x0, 65, 1284, 664, 0, 1, 18 },
+  { 0x1, 0x1, 65, 1285, 666, 33, 1, 18 },
+  { 0x1, 0x1, 65, 1286, 668, 34, 1, 18 },
+  { 0x3, 0x3, 65, 1287, 670, 33, 1, 18 },
+  { 0x1, 0x1, 65, 1288, 672, 6, 1, 18 },
+  { 0x8000001, 0x8000001, 65, 1289, 674, 6, 1, 18 },
+  { 0x10000001, 0x10000001, 65, 1290, 676, 6, 1, 18 },
+  { 0x18000001, 0x18000001, 65, 1291, 678, 6, 1, 18 },
+  { 0x0, 0x0, 65, 1292, 688, 0, 1, 19 },
+  { 0x1, 0x1, 65, 1293, 690, 33, 1, 19 },
+  { 0x1, 0x1, 65, 1294, 692, 34, 1, 19 },
+  { 0x3, 0x3, 65, 1295, 694, 33, 1, 19 },
+  { 0x0, 0x0, 65, 1296, 700, 0, 1, 20 },
+  { 0x1, 0x1, 65, 1297, 702, 33, 1, 20 },
+  { 0x1, 0x1, 65, 1298, 704, 34, 1, 20 },
+  { 0x3, 0x3, 65, 1299, 706, 33, 1, 20 },
+  { 0x1, 0x1, 65, 1300, 708, 6, 1, 20 },
+  { 0x8000001, 0x8000001, 65, 1301, 710, 6, 1, 20 },
+  { 0x10000001, 0x10000001, 65, 1302, 712, 6, 1, 20 },
+  { 0x18000001, 0x18000001, 65, 1303, 714, 6, 1, 20 },
+  { 0x0, 0x0, 65, 1304, 724, 0, 1, 21 },
+  { 0x1, 0x1, 65, 1305, 726, 33, 1, 21 },
+  { 0x1, 0x1, 65, 1306, 728, 34, 1, 21 },
+  { 0x3, 0x3, 65, 1307, 730, 33, 1, 21 },
+  { 0x0, 0x0, 65, 17, 736, 0, 1, 17 },
+  { 0x0, 0x0, 65, 1309, 739, 0, 1, 17 },
+  { 0x1, 0x1, 65, 1310, 741, 33, 1, 17 },
+  { 0x1, 0x1, 65, 1311, 743, 34, 1, 17 },
+  { 0x3, 0x3, 65, 1312, 745, 33, 1, 17 },
+  { 0x0, 0x0, 65, 1313, 747, 0, 1, 17 },
+  { 0x1, 0x1, 65, 1314, 749, 33, 1, 17 },
+  { 0x1, 0x1, 65, 1315, 751, 34, 1, 17 },
+  { 0x3, 0x3, 65, 1316, 753, 33, 1, 17 },
+  { 0x0, 0x0, 65, 1317, 763, 0, 1, 21 },
+  { 0x1, 0x1, 65, 1318, 765, 33, 1, 21 },
+  { 0x1, 0x1, 65, 1319, 767, 34, 1, 21 },
+  { 0x3, 0x3, 65, 1320, 769, 33, 1, 21 },
+  { 0x3, 0x3, 66, 543, 1521, 33, 1, 129 },
+  { 0x3, 0x3, 66, 544, 1531, 33, 1, 129 },
+  { 0x3, 0x3, 66, 545, 1541, 33, 1, 129 },
+  { 0x0, 0x0, 66, -1, 1546, 0, 1, 140 },
+  { 0x0, 0x0, 66, -1, 1547, 0, 1, 145 },
+  { 0x0, 0x0, 66, -1, 1548, 0, 1, 145 },
+  { 0x0, 0x0, 107, 1028, 2311, 0, 0, -1 },
+  { 0x0, 0x0, 107, 1029, 2830, 0, 1, 29 },
+  { 0x0, 0x0, 107, 1030, 2352, 0, 0, -1 },
+  { 0x0, 0x0, 107, 1031, 2834, 0, 1, 29 },
+  { 0x0, 0x0, 109, -1, 2313, 0, 0, -1 },
+  { 0x1, 0x1, 109, -1, 2831, 27, 1, 29 },
+  { 0x0, 0x0, 109, -1, 2354, 0, 0, -1 },
+  { 0x1, 0x1, 109, -1, 2835, 27, 1, 29 },
+  { 0x0, 0x0, 110, 1033, -1, 0, 1, 115 },
+  { 0x1, 0x1, 111, -1, -1, 27, 1, 115 },
+  { 0x0, 0x0, 112, 1064, 2860, 0, 1, 1 },
+  { 0x0, 0x0, 112, 1065, 2863, 0, 1, 1 },
+  { 0x0, 0x0, 112, 1206, 303, 0, 0, -1 },
+  { 0x0, 0x0, 112, 1207, 307, 0, 0, -1 },
+  { 0x0, 0x0, 112, 1167, 430, 0, 0, -1 },
+  { 0x0, 0x0, 112, 1168, 438, 0, 0, -1 },
+  { 0x0, 0x0, 112, -1, 446, 0, 0, -1 },
+  { 0x0, 0x0, 112, 1066, 2876, 0, 1, 1 },
+  { 0x0, 0x0, 112, 1067, 2879, 0, 1, 1 },
+  { 0x0, 0x0, 112, -1, 328, 0, 0, -1 },
+  { 0x0, 0x0, 112, -1, 332, 0, 0, -1 },
+  { 0x0, 0x0, 112, 1215, 333, 0, 0, -1 },
+  { 0x0, 0x0, 112, 1216, 337, 0, 0, -1 },
+  { 0x0, 0x0, 112, 1068, 2900, 0, 1, 1 },
+  { 0x0, 0x0, 112, 1069, 2903, 0, 1, 1 },
+  { 0x0, 0x0, 112, 1219, 351, 0, 0, -1 },
+  { 0x0, 0x0, 112, 1220, 355, 0, 0, -1 },
+  { 0x0, 0x0, 112, 1180, 478, 0, 0, -1 },
+  { 0x0, 0x0, 112, 1181, 486, 0, 0, -1 },
+  { 0x0, 0x0, 112, -1, 494, 0, 0, -1 },
+  { 0x0, 0x0, 112, 1373, 2914, 0, 1, 1 },
+  { 0x0, 0x0, 112, 1374, 2916, 0, 1, 1 },
+  { 0x0, 0x0, 112, -1, 376, 0, 0, -1 },
+  { 0x0, 0x0, 112, -1, 380, 0, 0, -1 },
+  { 0x0, 0x0, 112, 1228, 381, 0, 0, -1 },
+  { 0x0, 0x0, 112, 1229, 385, 0, 0, -1 },
+  { 0x0, 0x0, 112, -1, 2281, 0, 0, -1 },
+  { 0x1, 0x9, 112, -1, 2285, 33, 1, 54 },
+  { 0x1, 0x9, 112, -1, 2947, 33, 1, 54 },
+  { 0x2, 0x3, 112, 1390, 2348, 27, 1, 49 },
+  { 0x1, 0x1, 114, 1356, 2861, 37, 1, 1 },
+  { 0x1, 0x1, 114, 1357, 2864, 37, 1, 1 },
+  { 0x1, 0x1, 114, 1361, 2877, 37, 1, 1 },
+  { 0x1, 0x1, 114, 1362, 2880, 37, 1, 1 },
+  { 0x1, 0x1, 114, 1368, 2901, 37, 1, 1 },
+  { 0x1, 0x1, 114, 1369, 2904, 37, 1, 1 },
+  { 0x0, 0x0, 114, -1, 2924, 0, 1, 1 },
+  { 0x0, 0x0, 114, -1, 2925, 0, 1, 1 },
+  { 0x0, 0x0, 115, 1105, 2856, 0, 1, 1 },
+  { 0x0, 0x0, 115, 1106, 2858, 0, 1, 1 },
+  { 0x0, 0x0, 115, 1165, 301, 0, 0, -1 },
+  { 0x0, 0x0, 115, 1166, 305, 0, 0, -1 },
+  { 0x0, 0x0, 115, -1, 434, 0, 0, -1 },
+  { 0x0, 0x0, 115, -1, 442, 0, 0, -1 },
+  { 0x0, 0x0, 115, 1210, 444, 0, 0, -1 },
+  { 0x0, 0x0, 115, -1, 2874, 0, 1, 1 },
+  { 0x0, 0x0, 115, -1, 2875, 0, 1, 1 },
+  { 0x0, 0x0, 115, 1213, 326, 0, 0, -1 },
+  { 0x0, 0x0, 115, 1214, 330, 0, 0, -1 },
+  { 0x0, 0x0, 115, 1174, 335, 0, 0, -1 },
+  { 0x0, 0x0, 115, 1175, 339, 0, 0, -1 },
+  { 0x0, 0x0, 115, 1109, 2896, 0, 1, 1 },
+  { 0x0, 0x0, 115, 1110, 2898, 0, 1, 1 },
+  { 0x0, 0x0, 115, 1178, 349, 0, 0, -1 },
+  { 0x0, 0x0, 115, 1179, 353, 0, 0, -1 },
+  { 0x0, 0x0, 115, -1, 482, 0, 0, -1 },
+  { 0x0, 0x0, 115, -1, 490, 0, 0, -1 },
+  { 0x0, 0x0, 115, 1223, 492, 0, 0, -1 },
+  { 0x0, 0x0, 115, -1, 2912, 0, 1, 1 },
+  { 0x0, 0x0, 115, -1, 2913, 0, 1, 1 },
+  { 0x0, 0x0, 115, 1226, 374, 0, 0, -1 },
+  { 0x0, 0x0, 115, 1227, 378, 0, 0, -1 },
+  { 0x0, 0x0, 115, 1187, 383, 0, 0, -1 },
+  { 0x0, 0x0, 115, 1188, 387, 0, 0, -1 },
+  { 0x0, 0x0, 115, 1060, 2279, 0, 0, -1 },
+  { 0x0, 0x0, 115, 1061, 2283, 0, 1, 54 },
+  { 0x0, 0x0, 115, 1062, 2946, 0, 1, 54 },
+  { 0x0, 0x0, 115, 1063, 2347, 0, 1, 49 },
+  { 0x1, 0x1, 115, -1, -1, 27, 1, 0 },
+  { 0x1, 0x1, 115, -1, -1, 27, 1, 0 },
+  { 0x1, 0x1, 115, -1, -1, 27, 1, 0 },
+  { 0x1, 0x1, 116, -1, 2857, 37, 1, 1 },
+  { 0x1, 0x1, 116, -1, 2859, 37, 1, 1 },
+  { 0x0, 0x0, 116, -1, 2884, 0, 1, 1 },
+  { 0x0, 0x0, 116, -1, 2885, 0, 1, 1 },
+  { 0x1, 0x1, 116, -1, 2897, 37, 1, 1 },
+  { 0x1, 0x1, 116, -1, 2899, 37, 1, 1 },
+  { 0x0, 0x0, 116, -1, 2922, 0, 1, 1 },
+  { 0x0, 0x0, 116, -1, 2923, 0, 1, 1 },
+  { 0x0, 0x0, 117, 1158, -1, 0, 1, 0 },
+  { 0x0, 0x0, 117, 1159, -1, 0, 1, 0 },
+  { 0x0, 0x0, 117, 1160, -1, 0, 1, 0 },
+  { 0x3, 0x3, 117, 1118, -1, 34, 1, 33 },
+  { 0x3, 0x3, 117, 1119, -1, 34, 1, 40 },
+  { 0x1, 0x1, 119, -1, -1, 35, 1, 33 },
+  { 0x1, 0x1, 119, -1, -1, 35, 1, 40 },
+  { 0x0, 0x0, 120, -1, -1, 0, 1, 40 },
+  { 0x0, 0x0, 120, -1, -1, 0, 1, 66 },
+  { 0x1, 0x1, 120, -1, -1, 36, 1, 122 },
+  { 0x0, 0x0, 120, -1, -1, 0, 1, 40 },
+  { 0x1, 0x1, 120, -1, -1, 27, 1, 96 },
+  { 0x0, 0x0, 120, -1, -1, 0, 1, 105 },
+  { 0x0, 0x0, 120, -1, -1, 0, 1, 73 },
+  { 0x0, 0x0, 120, -1, -1, 0, 1, 73 },
+  { 0x0, 0x0, 120, -1, -1, 0, 1, 74 },
+  { 0x0, 0x0, 120, -1, -1, 0, 1, 40 },
+  { 0x1, 0x1, 120, -1, -1, 27, 1, 117 },
+  { 0x1, 0x1, 120, -1, -1, 27, 1, 40 },
+  { 0x0, 0x0, 120, -1, -1, 0, 1, 40 },
+  { 0x0, 0x0, 121, -1, 2786, 0, 0, -1 },
+  { 0x0, 0x0, 121, -1, 2789, 0, 0, -1 },
+  { 0x1, 0x1, 122, -1, -1, 35, 1, 16 },
+  { 0x1, 0x1, 122, -1, -1, 35, 1, 16 },
+  { 0x1, 0x1, 122, -1, -1, 35, 1, 16 },
+  { 0x1, 0x1, 122, -1, -1, 35, 1, 16 },
+  { 0x1, 0x1, 122, -1, -1, 35, 1, 22 },
+  { 0x1, 0x1, 122, -1, -1, 35, 1, 22 },
+  { 0x1, 0x1, 122, -1, -1, 35, 1, 22 },
+  { 0x1, 0x1, 122, -1, -1, 35, 1, 22 },
+  { 0x1, 0x1, 122, -1, -1, 23, 1, 67 },
+  { 0x1, 0x1, 122, -1, -1, 23, 1, 67 },
+  { 0x1, 0x1, 122, -1, -1, 23, 1, 67 },
+  { 0x1, 0x1, 122, -1, -1, 23, 1, 67 },
+  { 0x1, 0x1, 122, 900, -1, 23, 1, 67 },
+  { 0x9, 0x9, 122, 901, -1, 20, 1, 67 },
+  { 0x0, 0x0, 126, 2165, -1, 0, 1, 0 },
+  { 0x0, 0x0, 126, 2166, -1, 0, 1, 0 },
+  { 0x1, 0x1, 126, -1, -1, 28, 1, 33 },
+  { 0x1, 0x1, 126, -1, -1, 27, 1, 33 },
+  { 0x1, 0x1, 126, -1, -1, 29, 1, 0 },
+  { 0x1, 0x1, 126, -1, -1, 29, 1, 0 },
+  { 0x1, 0x1, 126, -1, -1, 29, 1, 0 },
+  { 0x1, 0x1, 126, -1, -1, 29, 1, 0 },
+  { 0x0, 0x0, 126, -1, -1, 0, 1, 114 },
+  { 0x1, 0x1, 126, -1, -1, 29, 1, 0 },
+  { 0x1, 0x1, 126, -1, -1, 29, 1, 0 },
+  { 0x1, 0x1, 126, -1, -1, 29, 1, 0 },
+  { 0x0, 0x0, 126, 1116, -1, 0, 1, 33 },
+  { 0x0, 0x0, 126, 1244, -1, 0, 1, 40 },
+  { 0x0, 0x0, 140, 1194, 2852, 0, 1, 1 },
+  { 0x0, 0x0, 140, 1195, 2854, 0, 1, 1 },
+  { 0x0, 0x0, 140, 1036, 302, 0, 0, -1 },
+  { 0x0, 0x0, 140, 1037, 422, 0, 0, -1 },
+  { 0x0, 0x0, 140, 1076, 311, 0, 0, -1 },
+  { 0x0, 0x0, 140, 1077, 315, 0, 0, -1 },
+  { 0x0, 0x0, 140, 1078, 443, 0, 0, -1 },
+  { 0x0, 0x0, 140, -1, 2872, 0, 1, 1 },
+  { 0x0, 0x0, 140, -1, 2873, 0, 1, 1 },
+  { 0x0, 0x0, 140, 1081, 325, 0, 0, -1 },
+  { 0x0, 0x0, 140, 1082, 329, 0, 0, -1 },
+  { 0x0, 0x0, 140, -1, 336, 0, 0, -1 },
+  { 0x0, 0x0, 140, -1, 340, 0, 0, -1 },
+  { 0x0, 0x0, 140, 1198, 2892, 0, 1, 1 },
+  { 0x0, 0x0, 140, 1199, 2894, 0, 1, 1 },
+  { 0x0, 0x0, 140, 1049, 350, 0, 0, -1 },
+  { 0x0, 0x0, 140, 1050, 470, 0, 0, -1 },
+  { 0x0, 0x0, 140, 1089, 359, 0, 0, -1 },
+  { 0x0, 0x0, 140, 1090, 363, 0, 0, -1 },
+  { 0x0, 0x0, 140, 1091, 491, 0, 0, -1 },
+  { 0x0, 0x0, 140, -1, 2910, 0, 1, 1 },
+  { 0x0, 0x0, 140, -1, 2911, 0, 1, 1 },
+  { 0x0, 0x0, 140, 1094, 373, 0, 0, -1 },
+  { 0x0, 0x0, 140, 1095, 377, 0, 0, -1 },
+  { 0x0, 0x0, 140, -1, 384, 0, 0, -1 },
+  { 0x0, 0x0, 140, -1, 388, 0, 0, -1 },
+  { 0x0, 0x0, 140, 2974, 2267, 0, 0, -1 },
+  { 0x1, 0x1, 140, 2975, 2275, 33, 1, 54 },
+  { 0x1, 0x1, 140, 2976, 2940, 33, 1, 54 },
+  { 0x0, 0x0, 140, 2977, 2341, 0, 0, -1 },
+  { 0x1, 0x1, 140, 2978, -1, 28, 1, 49 },
+  { 0x1, 0x1, 141, -1, 2853, 37, 1, 1 },
+  { 0x1, 0x1, 141, -1, 2855, 37, 1, 1 },
+  { 0x0, 0x0, 141, -1, 2882, 0, 1, 1 },
+  { 0x0, 0x0, 141, -1, 2883, 0, 1, 1 },
+  { 0x1, 0x1, 141, -1, 2893, 37, 1, 1 },
+  { 0x1, 0x1, 141, -1, 2895, 37, 1, 1 },
+  { 0x0, 0x0, 141, -1, 2920, 0, 1, 1 },
+  { 0x0, 0x0, 141, -1, 2921, 0, 1, 1 },
+  { 0x1, 0x1, 144, 899, 1140, 3, 1, 22 },
+  { 0x0, 0x0, 145, 2167, -1, 0, 1, 33 },
+  { 0x0, 0x0, 146, 905, 2846, 0, 1, 1 },
+  { 0x0, 0x0, 146, 906, 2849, 0, 1, 1 },
+  { 0x0, 0x0, 146, -1, 304, 0, 0, -1 },
+  { 0x0, 0x0, 146, -1, 426, 0, 0, -1 },
+  { 0x0, 0x0, 146, 1038, 309, 0, 0, -1 },
+  { 0x0, 0x0, 146, 1039, 313, 0, 0, -1 },
+  { 0x0, 0x0, 146, 1040, 445, 0, 0, -1 },
+  { 0x0, 0x0, 146, 909, 2866, 0, 1, 1 },
+  { 0x0, 0x0, 146, 910, 2869, 0, 1, 1 },
+  { 0x0, 0x0, 146, 1043, 327, 0, 0, -1 },
+  { 0x0, 0x0, 146, 1044, 331, 0, 0, -1 },
+  { 0x0, 0x0, 146, 1083, 334, 0, 0, -1 },
+  { 0x0, 0x0, 146, 1084, 338, 0, 0, -1 },
+  { 0x0, 0x0, 146, 915, 2886, 0, 1, 1 },
+  { 0x0, 0x0, 146, 916, 2889, 0, 1, 1 },
+  { 0x0, 0x0, 146, -1, 352, 0, 0, -1 },
+  { 0x0, 0x0, 146, -1, 474, 0, 0, -1 },
+  { 0x0, 0x0, 146, 1051, 357, 0, 0, -1 },
+  { 0x0, 0x0, 146, 1052, 361, 0, 0, -1 },
+  { 0x0, 0x0, 146, 1053, 493, 0, 0, -1 },
+  { 0x0, 0x0, 146, 919, 2906, 0, 1, 1 },
+  { 0x0, 0x0, 146, 920, 2908, 0, 1, 1 },
+  { 0x0, 0x0, 146, 1056, 375, 0, 0, -1 },
+  { 0x0, 0x0, 146, 1057, 379, 0, 0, -1 },
+  { 0x0, 0x0, 146, 1096, 382, 0, 0, -1 },
+  { 0x0, 0x0, 146, 1097, 386, 0, 0, -1 },
+  { 0x0, 0x0, 146, 1189, 2265, 0, 0, -1 },
+  { 0x1, 0x1, 146, 1190, 2273, 36, 1, 54 },
+  { 0x1, 0x1, 146, 1191, 2939, 36, 1, 54 },
+  { 0x0, 0x0, 146, 1192, 2340, 0, 0, -1 },
+  { 0x1, 0x1, 146, 1193, -1, 27, 1, 49 },
+  { 0x1, 0x1, 147, -1, 2848, 37, 1, 1 },
+  { 0x1, 0x1, 147, -1, 2851, 37, 1, 1 },
+  { 0x1, 0x1, 147, -1, 2868, 37, 1, 1 },
+  { 0x1, 0x1, 147, -1, 2871, 37, 1, 1 },
+  { 0x1, 0x1, 147, -1, 2888, 37, 1, 1 },
+  { 0x1, 0x1, 147, -1, 2891, 37, 1, 1 },
+  { 0x0, 0x0, 147, -1, 2918, 0, 1, 1 },
+  { 0x0, 0x0, 147, -1, 2919, 0, 1, 1 },
+  { 0x0, 0x0, 148, -1, -1, 0, 1, 33 },
+  { 0x0, 0x0, 148, 1117, -1, 0, 1, 40 },
+  { 0x0, 0x0, 149, -1, -1, 0, 1, 40 },
+  { 0x0, 0x0, 149, -1, -1, 0, 1, 66 },
+  { 0x0, 0x0, 149, -1, 2926, 0, 1, 63 },
+  { 0x0, 0x0, 149, -1, 2927, 0, 1, 63 },
+  { 0x0, 0x0, 149, -1, -1, 0, 1, 40 },
+  { 0x0, 0x0, 149, -1, -1, 0, 1, 81 },
+  { 0x0, 0x0, 149, -1, -1, 0, 1, 81 },
+  { 0x0, 0x0, 149, -1, -1, 0, 1, 85 },
+  { 0x0, 0x0, 149, -1, -1, 0, 1, 40 },
+  { 0x1, 0x1, 150, -1, 575, 12, 1, 6 },
+  { 0x1, 0x1, 150, -1, 578, 12, 1, 6 },
+  { 0x200001, 0x200001, 150, -1, 580, 12, 1, 6 },
+  { 0x400001, 0x400001, 150, -1, 582, 12, 1, 6 },
+  { 0x600001, 0x600001, 150, -1, 584, 12, 1, 6 },
+  { 0x1, 0x1, 150, -1, 586, 12, 1, 6 },
+  { 0x200001, 0x200001, 150, -1, 588, 12, 1, 6 },
+  { 0x400001, 0x400001, 150, -1, 590, 12, 1, 6 },
+  { 0x600001, 0x600001, 150, -1, 592, 12, 1, 6 },
+  { 0x41, 0x41, 150, -1, 594, 6, 1, 7 },
+  { 0x8000041, 0x8000041, 150, -1, 596, 6, 1, 7 },
+  { 0x10000041, 0x10000041, 150, -1, 598, 6, 1, 7 },
+  { 0x18000041, 0x18000041, 150, -1, 600, 6, 1, 7 },
+  { 0x1, 0x1, 150, -1, 614, 12, 1, 8 },
+  { 0x200001, 0x200001, 150, -1, 616, 12, 1, 8 },
+  { 0x400001, 0x400001, 150, -1, 618, 12, 1, 8 },
+  { 0x600001, 0x600001, 150, -1, 620, 12, 1, 8 },
+  { 0x1, 0x1, 150, -1, 626, 12, 1, 15 },
+  { 0x200001, 0x200001, 150, -1, 628, 12, 1, 15 },
+  { 0x400001, 0x400001, 150, -1, 630, 12, 1, 15 },
+  { 0x600001, 0x600001, 150, -1, 632, 12, 1, 15 },
+  { 0x1, 0x1, 150, -1, 638, 12, 1, 17 },
+  { 0x1, 0x1, 150, -1, 641, 12, 1, 17 },
+  { 0x200001, 0x200001, 150, -1, 643, 12, 1, 17 },
+  { 0x400001, 0x400001, 150, -1, 645, 12, 1, 17 },
+  { 0x600001, 0x600001, 150, -1, 647, 12, 1, 17 },
+  { 0x1, 0x1, 150, -1, 649, 12, 1, 17 },
+  { 0x200001, 0x200001, 150, -1, 651, 12, 1, 17 },
+  { 0x400001, 0x400001, 150, -1, 653, 12, 1, 17 },
+  { 0x600001, 0x600001, 150, -1, 655, 12, 1, 17 },
+  { 0x1, 0x1, 150, -1, 665, 12, 1, 18 },
+  { 0x200001, 0x200001, 150, -1, 667, 12, 1, 18 },
+  { 0x400001, 0x400001, 150, -1, 669, 12, 1, 18 },
+  { 0x600001, 0x600001, 150, -1, 671, 12, 1, 18 },
+  { 0x41, 0x41, 150, -1, 673, 6, 1, 18 },
+  { 0x8000041, 0x8000041, 150, -1, 675, 6, 1, 18 },
+  { 0x10000041, 0x10000041, 150, -1, 677, 6, 1, 18 },
+  { 0x18000041, 0x18000041, 150, -1, 679, 6, 1, 18 },
+  { 0x1, 0x1, 150, -1, 689, 12, 1, 19 },
+  { 0x200001, 0x200001, 150, -1, 691, 12, 1, 19 },
+  { 0x400001, 0x400001, 150, -1, 693, 12, 1, 19 },
+  { 0x600001, 0x600001, 150, -1, 695, 12, 1, 19 },
+  { 0x1, 0x1, 150, -1, 701, 12, 1, 20 },
+  { 0x200001, 0x200001, 150, -1, 703, 12, 1, 20 },
+  { 0x400001, 0x400001, 150, -1, 705, 12, 1, 20 },
+  { 0x600001, 0x600001, 150, -1, 707, 12, 1, 20 },
+  { 0x41, 0x41, 150, -1, 709, 6, 1, 20 },
+  { 0x8000041, 0x8000041, 150, -1, 711, 6, 1, 20 },
+  { 0x10000041, 0x10000041, 150, -1, 713, 6, 1, 20 },
+  { 0x18000041, 0x18000041, 150, -1, 715, 6, 1, 20 },
+  { 0x1, 0x1, 150, -1, 725, 12, 1, 21 },
+  { 0x200001, 0x200001, 150, -1, 727, 12, 1, 21 },
+  { 0x400001, 0x400001, 150, -1, 729, 12, 1, 21 },
+  { 0x600001, 0x600001, 150, -1, 731, 12, 1, 21 },
+  { 0x1, 0x1, 150, -1, 737, 12, 1, 17 },
+  { 0x1, 0x1, 150, -1, 740, 12, 1, 17 },
+  { 0x200001, 0x200001, 150, -1, 742, 12, 1, 17 },
+  { 0x400001, 0x400001, 150, -1, 744, 12, 1, 17 },
+  { 0x600001, 0x600001, 150, -1, 746, 12, 1, 17 },
+  { 0x1, 0x1, 150, -1, 748, 12, 1, 17 },
+  { 0x200001, 0x200001, 150, -1, 750, 12, 1, 17 },
+  { 0x400001, 0x400001, 150, -1, 752, 12, 1, 17 },
+  { 0x600001, 0x600001, 150, -1, 754, 12, 1, 17 },
+  { 0x1, 0x1, 150, -1, 764, 12, 1, 21 },
+  { 0x200001, 0x200001, 150, -1, 766, 12, 1, 21 },
+  { 0x400001, 0x400001, 150, -1, 768, 12, 1, 21 },
+  { 0x600001, 0x600001, 150, -1, 770, 12, 1, 21 },
+  { 0x0, 0x0, 155, -1, -1, 0, 1, 124 },
+  { 0x0, 0x0, 159, 775, -1, 0, 1, 75 },
+  { 0x0, 0x0, 159, 776, -1, 0, 1, 75 },
+  { 0x9, 0x9, 159, -1, 1438, 32, 1, 130 },
+  { 0x9, 0x9, 159, -1, 1447, 32, 1, 130 },
+  { 0x9, 0x9, 159, -1, 1456, 32, 1, 130 },
+  { 0x9, 0x9, 159, -1, 1469, 32, 1, 130 },
+  { 0x9, 0x9, 159, -1, 1478, 32, 1, 130 },
+  { 0x9, 0x9, 159, -1, 1487, 32, 1, 130 },
+  { 0x9, 0x9, 159, -1, 1496, 32, 1, 130 },
+  { 0x9, 0x9, 159, -1, 1505, 32, 1, 130 },
+  { 0x9, 0x9, 159, -1, 1514, 32, 1, 130 },
+  { 0x9, 0x9, 159, -1, 1524, 32, 1, 130 },
+  { 0x9, 0x9, 159, -1, 1534, 32, 1, 130 },
+  { 0x9, 0x9, 159, -1, 1544, 32, 1, 130 },
+  { 0x9, 0x9, 159, -1, 1553, 32, 1, 144 },
+  { 0x9, 0x9, 159, -1, 1559, 32, 1, 149 },
+  { 0x9, 0x9, 159, -1, 1565, 32, 1, 149 },
+  { 0x9, 0x9, 159, -1, 1571, 32, 1, 144 },
+  { 0x9, 0x9, 159, -1, 1577, 32, 1, 149 },
+  { 0x9, 0x9, 159, -1, 1583, 32, 1, 149 },
+  { 0x9, 0x9, 159, -1, 1589, 32, 1, 144 },
+  { 0x9, 0x9, 159, -1, 1595, 32, 1, 149 },
+  { 0x9, 0x9, 159, -1, 1601, 32, 1, 149 },
+  { 0x9, 0x9, 159, -1, 1607, 32, 1, 144 },
+  { 0x9, 0x9, 159, -1, 1613, 32, 1, 149 },
+  { 0x9, 0x9, 159, -1, 1619, 32, 1, 144 },
+  { 0x9, 0x9, 159, -1, 1625, 32, 1, 149 },
+  { 0x9, 0x9, 159, -1, 1631, 32, 1, 144 },
+  { 0x9, 0x9, 159, -1, 1637, 32, 1, 149 },
+  { 0x9, 0x9, 159, -1, 1643, 32, 1, 144 },
+  { 0x9, 0x9, 159, -1, 1649, 32, 1, 149 },
+  { 0x9, 0x9, 159, -1, 1655, 32, 1, 149 },
+  { 0x0, 0x0, 160, 1235, 296, 0, 0, -1 },
+  { 0x0, 0x0, 160, 1236, 412, 0, 0, -1 },
+  { 0x1, 0x1, 160, -1, 2862, 38, 1, 1 },
+  { 0x1, 0x1, 160, 907, 2865, 38, 1, 1 },
+  { 0x0, 0x0, 160, 908, 413, 0, 0, -1 },
+  { 0x0, 0x0, 160, 1237, 318, 0, 0, -1 },
+  { 0x0, 0x0, 160, 1238, 452, 0, 0, -1 },
+  { 0x1, 0x1, 160, -1, 2878, 38, 1, 1 },
+  { 0x1, 0x1, 160, 911, 2881, 38, 1, 1 },
+  { 0x0, 0x0, 160, 912, 453, 0, 0, -1 },
+  { 0x0, 0x0, 160, 913, 323, 0, 0, -1 },
+  { 0x0, 0x0, 160, 914, 341, 0, 0, -1 },
+  { 0x0, 0x0, 160, 1239, 344, 0, 0, -1 },
+  { 0x0, 0x0, 160, 1240, 460, 0, 0, -1 },
+  { 0x1, 0x1, 160, -1, 2902, 38, 1, 1 },
+  { 0x1, 0x1, 160, 917, 2905, 38, 1, 1 },
+  { 0x0, 0x0, 160, 918, 461, 0, 0, -1 },
+  { 0x0, 0x0, 160, -1, 366, 0, 0, -1 },
+  { 0x0, 0x0, 160, -1, 500, 0, 0, -1 },
+  { 0x1, 0x1, 160, -1, 2915, 38, 1, 1 },
+  { 0x1, 0x1, 160, 921, 2917, 38, 1, 1 },
+  { 0x0, 0x0, 160, 922, 501, 0, 0, -1 },
+  { 0x0, 0x0, 160, 923, 371, 0, 0, -1 },
+  { 0x0, 0x0, 160, 924, 389, 0, 0, -1 },
+  { 0x0, 0x0, 161, 1397, 2287, 0, 0, -1 },
+  { 0x0, 0x0, 161, 1398, 2295, 0, 1, 54 },
+  { 0x0, 0x0, 161, 1399, 2956, 0, 1, 54 },
+  { 0x0, 0x0, 161, 1400, 2343, 0, 0, -1 },
+  { 0x1, 0x1, 161, 1401, -1, 29, 1, 49 },
+  { 0x0, 0x0, 162, -1, 2305, 0, 0, -1 },
+  { 0x1, 0x9, 162, -1, 2309, 33, 1, 54 },
+  { 0x1, 0x9, 162, -1, 2965, 33, 1, 54 },
+  { 0x6, 0x7, 162, -1, 2350, 27, 1, 49 },
+  { 0x0, 0x0, 163, 1383, 2303, 0, 0, -1 },
+  { 0x0, 0x0, 163, 1384, 2307, 0, 1, 54 },
+  { 0x0, 0x0, 163, 1385, 2964, 0, 1, 54 },
+  { 0x1, 0x1, 163, 1386, 2349, 29, 1, 49 },
+  { 0x1, 0x1, 164, 1404, -1, 27, 1, 33 },
+  { 0x0, 0x0, 165, 2159, 2291, 0, 0, -1 },
+  { 0x1, 0x1, 165, 2160, 2299, 33, 1, 54 },
+  { 0x1, 0x1, 165, 2161, 2958, 33, 1, 54 },
+  { 0x0, 0x0, 165, 2162, 2345, 0, 0, -1 },
+  { 0x3, 0x3, 165, 2163, -1, 28, 1, 49 },
+  { 0x0, 0x0, 166, 1392, 2289, 0, 0, -1 },
+  { 0x1, 0x1, 166, 1393, 2297, 36, 1, 54 },
+  { 0x1, 0x1, 166, 1394, 2957, 36, 1, 54 },
+  { 0x0, 0x0, 166, 1395, 2344, 0, 0, -1 },
+  { 0x5, 0x5, 166, 1396, -1, 27, 1, 49 },
+  { 0x0, 0x0, 167, -1, 2928, 0, 1, 63 },
+  { 0x0, 0x0, 167, -1, 2929, 0, 1, 63 },
+  { 0x1, 0x1, 169, -1, -1, 28, 1, 33 },
+  { 0x1, 0x1, 170, 2745, -1, 27, 1, 33 },
+  { 0x1, 0x1, 170, 2746, -1, 27, 1, 33 },
+  { 0x1, 0x1, 171, 1685, -1, 28, 1, 135 },
+  { 0x1, 0x1, 171, 1686, -1, 28, 1, 135 },
+  { 0x1, 0x1, 171, 1687, -1, 28, 1, 135 },
+  { 0x1, 0x1, 171, 1688, -1, 28, 1, 135 },
+  { 0x1, 0x1, 171, 1689, -1, 28, 1, 134 },
+  { 0x1, 0x1, 171, 1690, -1, 28, 1, 134 },
+  { 0x1, 0x1, 171, 1691, -1, 28, 1, 134 },
+  { 0x1, 0x1, 171, 1692, -1, 28, 1, 134 },
+  { 0x1, 0x1, 171, 1693, -1, 28, 1, 134 },
+  { 0x1, 0x1, 171, 1694, -1, 28, 1, 134 },
+  { 0x1, 0x1, 171, 1695, -1, 28, 1, 134 },
+  { 0x1, 0x1, 171, 1696, -1, 28, 1, 134 },
+  { 0x1, 0x1, 171, 1697, -1, 28, 1, 134 },
+  { 0x1, 0x1, 171, 1698, -1, 28, 1, 134 },
+  { 0x1, 0x1, 171, 1699, -1, 28, 1, 134 },
+  { 0x1, 0x1, 171, 1700, -1, 28, 1, 134 },
+  { 0x1, 0x1, 171, 1701, -1, 28, 1, 134 },
+  { 0x1, 0x1, 171, 1702, -1, 28, 1, 134 },
+  { 0x1, 0x1, 171, 1703, -1, 28, 1, 134 },
+  { 0x1, 0x1, 171, 1704, -1, 28, 1, 134 },
+  { 0x1, 0x1, 171, 1705, -1, 28, 1, 136 },
+  { 0x1, 0x1, 171, 1706, -1, 28, 1, 136 },
+  { 0x1, 0x1, 171, 1707, -1, 28, 1, 136 },
+  { 0x1, 0x1, 171, 1708, -1, 28, 1, 136 },
+  { 0x1, 0x1, 171, 1709, -1, 28, 1, 126 },
+  { 0x1, 0x1, 171, 1710, -1, 28, 1, 127 },
+  { 0x1, 0x1, 171, 1711, -1, 28, 1, 128 },
+  { 0x1, 0x1, 171, 1712, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1713, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1714, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1715, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1716, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1717, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1718, -1, 28, 1, 126 },
+  { 0x1, 0x1, 171, 1719, -1, 28, 1, 127 },
+  { 0x1, 0x1, 171, 1720, -1, 28, 1, 128 },
+  { 0x1, 0x1, 171, 1721, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1722, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1723, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1724, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1725, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1726, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1727, -1, 28, 1, 126 },
+  { 0x1, 0x1, 171, 1728, -1, 28, 1, 127 },
+  { 0x1, 0x1, 171, 1729, -1, 28, 1, 128 },
+  { 0x1, 0x1, 171, 1730, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1731, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1732, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1733, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1734, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1735, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1736, -1, 28, 1, 125 },
+  { 0x1, 0x1, 171, 1737, -1, 28, 1, 125 },
+  { 0x1, 0x1, 171, 1738, -1, 28, 1, 125 },
+  { 0x1, 0x1, 171, 1739, -1, 28, 1, 125 },
+  { 0x1, 0x1, 171, 1740, -1, 28, 1, 126 },
+  { 0x1, 0x1, 171, 1741, -1, 28, 1, 127 },
+  { 0x1, 0x1, 171, 1742, -1, 28, 1, 128 },
+  { 0x1, 0x1, 171, 1743, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1744, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1745, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1746, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1747, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1748, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1749, -1, 28, 1, 126 },
+  { 0x1, 0x1, 171, 1750, -1, 28, 1, 127 },
+  { 0x1, 0x1, 171, 1751, -1, 28, 1, 128 },
+  { 0x1, 0x1, 171, 1752, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1753, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1754, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1755, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1756, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1757, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1758, -1, 28, 1, 126 },
+  { 0x1, 0x1, 171, 1759, -1, 28, 1, 127 },
+  { 0x1, 0x1, 171, 1760, -1, 28, 1, 128 },
+  { 0x1, 0x1, 171, 1761, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1762, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1763, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1764, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1765, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1766, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1767, -1, 28, 1, 126 },
+  { 0x1, 0x1, 171, 1768, -1, 28, 1, 127 },
+  { 0x1, 0x1, 171, 1769, -1, 28, 1, 128 },
+  { 0x1, 0x1, 171, 1770, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1771, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1772, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1773, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1774, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1775, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1776, -1, 28, 1, 126 },
+  { 0x1, 0x1, 171, 1777, -1, 28, 1, 127 },
+  { 0x1, 0x1, 171, 1778, -1, 28, 1, 128 },
+  { 0x1, 0x1, 171, 1779, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1780, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1781, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1782, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1783, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1784, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1785, -1, 28, 1, 126 },
+  { 0x1, 0x1, 171, 1786, -1, 28, 1, 127 },
+  { 0x1, 0x1, 171, 1787, -1, 28, 1, 128 },
+  { 0x1, 0x1, 171, 1788, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1789, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1790, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1791, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1792, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1793, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1794, -1, 28, 1, 126 },
+  { 0x1, 0x1, 171, 1795, -1, 28, 1, 127 },
+  { 0x1, 0x1, 171, 1796, -1, 28, 1, 128 },
+  { 0x1, 0x1, 171, 1797, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1798, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1799, -1, 28, 1, 129 },
+  { 0x1, 0x1, 171, 1800, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1801, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1802, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1803, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1804, -1, 28, 1, 126 },
+  { 0x1, 0x1, 171, 1805, -1, 28, 1, 127 },
+  { 0x1, 0x1, 171, 1806, -1, 28, 1, 128 },
+  { 0x1, 0x1, 171, 1807, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1808, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1809, -1, 28, 1, 129 },
+  { 0x1, 0x1, 171, 1810, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1811, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1812, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1813, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1814, -1, 28, 1, 126 },
+  { 0x1, 0x1, 171, 1815, -1, 28, 1, 127 },
+  { 0x1, 0x1, 171, 1816, -1, 28, 1, 128 },
+  { 0x1, 0x1, 171, 1817, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1818, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1819, -1, 28, 1, 129 },
+  { 0x1, 0x1, 171, 1820, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1821, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1822, -1, 28, 1, 130 },
+  { 0x1, 0x1, 171, 1823, -1, 28, 1, 124 },
+  { 0x1, 0x1, 171, 1824, -1, 28, 1, 140 },
+  { 0x1, 0x1, 171, 1825, -1, 28, 1, 145 },
+  { 0x1, 0x1, 171, 1826, -1, 28, 1, 145 },
+  { 0x1, 0x1, 171, 1827, -1, 28, 1, 141 },
+  { 0x1, 0x1, 171, 1828, -1, 28, 1, 142 },
+  { 0x1, 0x1, 171, 1829, -1, 28, 1, 143 },
+  { 0x1, 0x1, 171, 1830, -1, 28, 1, 144 },
+  { 0x1, 0x1, 171, 1831, -1, 28, 1, 144 },
+  { 0x1, 0x1, 171, 1832, -1, 28, 1, 140 },
+  { 0x1, 0x1, 171, 1833, -1, 28, 1, 146 },
+  { 0x1, 0x1, 171, 1834, -1, 28, 1, 147 },
+  { 0x1, 0x1, 171, 1835, -1, 28, 1, 148 },
+  { 0x1, 0x1, 171, 1836, -1, 28, 1, 149 },
+  { 0x1, 0x1, 171, 1837, -1, 28, 1, 149 },
+  { 0x1, 0x1, 171, 1838, -1, 28, 1, 145 },
+  { 0x1, 0x1, 171, 1839, -1, 28, 1, 146 },
+  { 0x1, 0x1, 171, 1840, -1, 28, 1, 147 },
+  { 0x1, 0x1, 171, 1841, -1, 28, 1, 148 },
+  { 0x1, 0x1, 171, 1842, -1, 28, 1, 149 },
+  { 0x1, 0x1, 171, 1843, -1, 28, 1, 149 },
+  { 0x1, 0x1, 171, 1844, -1, 28, 1, 145 },
+  { 0x1, 0x1, 171, 1845, -1, 28, 1, 141 },
+  { 0x1, 0x1, 171, 1846, -1, 28, 1, 142 },
+  { 0x1, 0x1, 171, 1847, -1, 28, 1, 143 },
+  { 0x1, 0x1, 171, 1848, -1, 28, 1, 144 },
+  { 0x1, 0x1, 171, 1849, -1, 28, 1, 144 },
+  { 0x1, 0x1, 171, 1850, -1, 28, 1, 140 },
+  { 0x1, 0x1, 171, 1851, -1, 28, 1, 146 },
+  { 0x1, 0x1, 171, 1852, -1, 28, 1, 147 },
+  { 0x1, 0x1, 171, 1853, -1, 28, 1, 148 },
+  { 0x1, 0x1, 171, 1854, -1, 28, 1, 149 },
+  { 0x1, 0x1, 171, 1855, -1, 28, 1, 149 },
+  { 0x1, 0x1, 171, 1856, -1, 28, 1, 145 },
+  { 0x1, 0x1, 171, 1857, -1, 28, 1, 146 },
+  { 0x1, 0x1, 171, 1858, -1, 28, 1, 147 },
+  { 0x1, 0x1, 171, 1859, -1, 28, 1, 148 },
+  { 0x1, 0x1, 171, 1860, -1, 28, 1, 149 },
+  { 0x1, 0x1, 171, 1861, -1, 28, 1, 149 },
+  { 0x1, 0x1, 171, 1862, -1, 28, 1, 145 },
+  { 0x1, 0x1, 171, 1863, -1, 28, 1, 141 },
+  { 0x1, 0x1, 171, 1864, -1, 28, 1, 142 },
+  { 0x1, 0x1, 171, 1865, -1, 28, 1, 143 },
+  { 0x1, 0x1, 171, 1866, -1, 28, 1, 144 },
+  { 0x1, 0x1, 171, 1867, -1, 28, 1, 144 },
+  { 0x1, 0x1, 171, 1868, -1, 28, 1, 140 },
+  { 0x1, 0x1, 171, 1869, -1, 28, 1, 146 },
+  { 0x1, 0x1, 171, 1870, -1, 28, 1, 147 },
+  { 0x1, 0x1, 171, 1871, -1, 28, 1, 148 },
+  { 0x1, 0x1, 171, 1872, -1, 28, 1, 149 },
+  { 0x1, 0x1, 171, 1873, -1, 28, 1, 149 },
+  { 0x1, 0x1, 171, 1874, -1, 28, 1, 145 },
+  { 0x1, 0x1, 171, 1875, -1, 28, 1, 146 },
+  { 0x1, 0x1, 171, 1876, -1, 28, 1, 147 },
+  { 0x1, 0x1, 171, 1877, -1, 28, 1, 148 },
+  { 0x1, 0x1, 171, 1878, -1, 28, 1, 149 },
+  { 0x1, 0x1, 171, 1879, -1, 28, 1, 149 },
+  { 0x1, 0x1, 171, 1880, -1, 28, 1, 145 },
+  { 0x1, 0x1, 171, 1881, -1, 28, 1, 141 },
+  { 0x1, 0x1, 171, 1882, -1, 28, 1, 142 },
+  { 0x1, 0x1, 171, 1883, -1, 28, 1, 143 },
+  { 0x1, 0x1, 171, 1884, -1, 28, 1, 144 },
+  { 0x1, 0x1, 171, 1885, -1, 28, 1, 144 },
+  { 0x1, 0x1, 171, 1886, -1, 28, 1, 140 },
+  { 0x1, 0x1, 171, 1887, -1, 28, 1, 146 },
+  { 0x1, 0x1, 171, 1888, -1, 28, 1, 147 },
+  { 0x1, 0x1, 171, 1889, -1, 28, 1, 148 },
+  { 0x1, 0x1, 171, 1890, -1, 28, 1, 149 },
+  { 0x1, 0x1, 171, 1891, -1, 28, 1, 149 },
+  { 0x1, 0x1, 171, 1892, -1, 28, 1, 145 },
+  { 0x1, 0x1, 171, 1893, -1, 28, 1, 141 },
+  { 0x1, 0x1, 171, 1894, -1, 28, 1, 142 },
+  { 0x1, 0x1, 171, 1895, -1, 28, 1, 143 },
+  { 0x1, 0x1, 171, 1896, -1, 28, 1, 144 },
+  { 0x1, 0x1, 171, 1897, -1, 28, 1, 144 },
+  { 0x1, 0x1, 171, 1898, -1, 28, 1, 140 },
+  { 0x1, 0x1, 171, 1899, -1, 28, 1, 146 },
+  { 0x1, 0x1, 171, 1900, -1, 28, 1, 147 },
+  { 0x1, 0x1, 171, 1901, -1, 28, 1, 148 },
+  { 0x1, 0x1, 171, 1902, -1, 28, 1, 149 },
+  { 0x1, 0x1, 171, 1903, -1, 28, 1, 149 },
+  { 0x1, 0x1, 171, 1904, -1, 28, 1, 145 },
+  { 0x1, 0x1, 171, 1905, -1, 28, 1, 141 },
+  { 0x1, 0x1, 171, 1906, -1, 28, 1, 142 },
+  { 0x1, 0x1, 171, 1907, -1, 28, 1, 143 },
+  { 0x1, 0x1, 171, 1908, -1, 28, 1, 144 },
+  { 0x1, 0x1, 171, 1909, -1, 28, 1, 144 },
+  { 0x1, 0x1, 171, 1910, -1, 28, 1, 140 },
+  { 0x1, 0x1, 171, 1911, -1, 28, 1, 146 },
+  { 0x1, 0x1, 171, 1912, -1, 28, 1, 147 },
+  { 0x1, 0x1, 171, 1913, -1, 28, 1, 148 },
+  { 0x1, 0x1, 171, 1914, -1, 28, 1, 149 },
+  { 0x1, 0x1, 171, 1915, -1, 28, 1, 149 },
+  { 0x1, 0x1, 171, 1916, -1, 28, 1, 145 },
+  { 0x1, 0x1, 171, 1917, -1, 28, 1, 141 },
+  { 0x1, 0x1, 171, 1918, -1, 28, 1, 142 },
+  { 0x1, 0x1, 171, 1919, -1, 28, 1, 143 },
+  { 0x1, 0x1, 171, 1920, -1, 28, 1, 144 },
+  { 0x1, 0x1, 171, 1921, -1, 28, 1, 144 },
+  { 0x1, 0x1, 171, 1922, -1, 28, 1, 140 },
+  { 0x1, 0x1, 171, 1923, -1, 28, 1, 146 },
+  { 0x1, 0x1, 171, 1924, -1, 28, 1, 147 },
+  { 0x1, 0x1, 171, 1925, -1, 28, 1, 148 },
+  { 0x1, 0x1, 171, 1926, -1, 28, 1, 149 },
+  { 0x1, 0x1, 171, 1927, -1, 28, 1, 149 },
+  { 0x1, 0x1, 171, 1928, -1, 28, 1, 145 },
+  { 0x1, 0x1, 171, 1929, -1, 28, 1, 146 },
+  { 0x1, 0x1, 171, 1930, -1, 28, 1, 147 },
+  { 0x1, 0x1, 171, 1931, -1, 28, 1, 148 },
+  { 0x1, 0x1, 171, 1932, -1, 28, 1, 149 },
+  { 0x1, 0x1, 171, 1933, -1, 28, 1, 149 },
+  { 0x1, 0x1, 171, 1934, -1, 28, 1, 145 },
+  { 0x1, 0x1, 171, 1673, -1, 28, 1, 151 },
+  { 0x1, 0x1, 171, 1674, -1, 28, 1, 152 },
+  { 0x1, 0x1, 171, 1675, -1, 28, 1, 152 },
+  { 0x1, 0x1, 171, 1676, -1, 28, 1, 151 },
+  { 0x1, 0x1, 171, 1677, -1, 28, 1, 153 },
+  { 0x1, 0x1, 171, 1678, -1, 28, 1, 154 },
+  { 0x1, 0x1, 171, 1679, -1, 28, 1, 154 },
+  { 0x1, 0x1, 171, 1680, -1, 28, 1, 153 },
+  { 0x1, 0x1, 171, 1681, -1, 28, 1, 153 },
+  { 0x1, 0x1, 171, 1682, -1, 28, 1, 154 },
+  { 0x1, 0x1, 171, 1683, -1, 28, 1, 154 },
+  { 0x1, 0x1, 171, 1684, -1, 28, 1, 153 },
+  { 0x1, 0x1, 171, 1979, -1, 28, 1, 136 },
+  { 0x1, 0x1, 171, 1980, -1, 28, 1, 136 },
+  { 0x1, 0x1, 171, 1981, -1, 28, 1, 136 },
+  { 0x1, 0x1, 171, 1982, -1, 28, 1, 136 },
+  { 0x1, 0x1, 172, 1935, -1, 29, 1, 151 },
+  { 0x1, 0x1, 172, 1936, -1, 29, 1, 152 },
+  { 0x1, 0x1, 172, 1937, -1, 29, 1, 152 },
+  { 0x1, 0x1, 172, 1938, -1, 29, 1, 151 },
+  { 0x1, 0x1, 172, 1939, -1, 29, 1, 153 },
+  { 0x1, 0x1, 172, 1940, -1, 29, 1, 154 },
+  { 0x1, 0x1, 172, 1941, -1, 29, 1, 154 },
+  { 0x1, 0x1, 172, 1942, -1, 29, 1, 153 },
+  { 0x1, 0x1, 172, 1943, -1, 29, 1, 153 },
+  { 0x1, 0x1, 172, 1944, -1, 29, 1, 154 },
+  { 0x1, 0x1, 172, 1945, -1, 29, 1, 154 },
+  { 0x1, 0x1, 172, 1946, -1, 29, 1, 153 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 135 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 135 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 135 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 135 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 134 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 134 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 134 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 134 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 134 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 134 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 134 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 134 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 134 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 134 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 134 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 134 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 134 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 134 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 134 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 134 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 136 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 136 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 136 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 136 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 126 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 127 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 128 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, 269, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, 2224, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 126 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 127 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 128 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, 271, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, 2225, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 126 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 127 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 128 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, 273, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, 2226, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 125 },
+  { 0x3, 0x3, 173, 275, -1, 28, 1, 125 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 125 },
+  { 0x3, 0x3, 173, 276, -1, 28, 1, 125 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 126 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 127 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 128 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, 277, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, 2227, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 126 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 127 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 128 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, 279, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, 2228, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 126 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 127 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 128 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, 281, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, 2229, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 126 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 127 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 128 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, 283, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, 2230, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 126 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 127 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 128 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, 285, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, 2231, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 126 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 127 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 128 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, 287, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, 2232, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 126 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 127 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 128 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 129 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, 289, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, 2233, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 126 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 127 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 128 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 129 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, 291, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, 2234, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 126 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 127 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 128 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 129 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, 293, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 130 },
+  { 0x3, 0x3, 173, 2235, -1, 28, 1, 124 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 140 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 145 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 145 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 141 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 142 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 143 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 144 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 144 },
+  { 0x3, 0x3, 173, 2236, -1, 28, 1, 140 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 146 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 147 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 148 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 149 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 149 },
+  { 0x3, 0x3, 173, 2237, -1, 28, 1, 145 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 146 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 147 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 148 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 149 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 149 },
+  { 0x3, 0x3, 173, 2238, -1, 28, 1, 145 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 141 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 142 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 143 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 144 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 144 },
+  { 0x3, 0x3, 173, 2239, -1, 28, 1, 140 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 146 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 147 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 148 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 149 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 149 },
+  { 0x3, 0x3, 173, 2240, -1, 28, 1, 145 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 146 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 147 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 148 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 149 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 149 },
+  { 0x3, 0x3, 173, 2241, -1, 28, 1, 145 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 141 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 142 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 143 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 144 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 144 },
+  { 0x3, 0x3, 173, 2242, -1, 28, 1, 140 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 146 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 147 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 148 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 149 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 149 },
+  { 0x3, 0x3, 173, 2243, -1, 28, 1, 145 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 146 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 147 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 148 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 149 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 149 },
+  { 0x3, 0x3, 173, 2244, -1, 28, 1, 145 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 141 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 142 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 143 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 144 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 144 },
+  { 0x3, 0x3, 173, 2245, -1, 28, 1, 140 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 146 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 147 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 148 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 149 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 149 },
+  { 0x3, 0x3, 173, 2246, -1, 28, 1, 145 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 141 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 142 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 143 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 144 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 144 },
+  { 0x3, 0x3, 173, 2247, -1, 28, 1, 140 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 146 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 147 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 148 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 149 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 149 },
+  { 0x3, 0x3, 173, 2248, -1, 28, 1, 145 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 141 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 142 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 143 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 144 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 144 },
+  { 0x3, 0x3, 173, 2249, -1, 28, 1, 140 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 146 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 147 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 148 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 149 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 149 },
+  { 0x3, 0x3, 173, 2250, -1, 28, 1, 145 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 141 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 142 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 143 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 144 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 144 },
+  { 0x3, 0x3, 173, 2251, -1, 28, 1, 140 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 146 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 147 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 148 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 149 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 149 },
+  { 0x3, 0x3, 173, 2252, -1, 28, 1, 145 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 146 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 147 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 148 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 149 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 149 },
+  { 0x3, 0x3, 173, 2253, -1, 28, 1, 145 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 151 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 152 },
+  { 0x3, 0x3, 173, 933, -1, 28, 1, 152 },
+  { 0x3, 0x3, 173, 934, -1, 28, 1, 151 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 153 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 154 },
+  { 0x3, 0x3, 173, 935, -1, 28, 1, 154 },
+  { 0x3, 0x3, 173, 936, -1, 28, 1, 153 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 153 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 154 },
+  { 0x3, 0x3, 173, 937, -1, 28, 1, 154 },
+  { 0x3, 0x3, 173, 938, -1, 28, 1, 153 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 131 },
+  { 0x3, 0x3, 173, 2190, -1, 28, 1, 131 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 138 },
+  { 0x3, 0x3, 173, 2191, -1, 28, 1, 138 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 132 },
+  { 0x3, 0x3, 173, 2192, -1, 28, 1, 132 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 132 },
+  { 0x3, 0x3, 173, 2193, -1, 28, 1, 132 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 131 },
+  { 0x3, 0x3, 173, 2194, -1, 28, 1, 131 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 138 },
+  { 0x3, 0x3, 173, 2195, -1, 28, 1, 138 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 131 },
+  { 0x3, 0x3, 173, 2196, -1, 28, 1, 131 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 138 },
+  { 0x3, 0x3, 173, 2197, -1, 28, 1, 138 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 131 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 133 },
+  { 0x3, 0x3, 173, 2198, -1, 28, 1, 131 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 138 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 139 },
+  { 0x3, 0x3, 173, 2199, -1, 28, 1, 138 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 150 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 156 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 150 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 156 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 150 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 156 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 150 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 156 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 150 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 156 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 136 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 136 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 136 },
+  { 0x3, 0x3, 173, -1, -1, 28, 1, 136 },
+  { 0x0, 0x0, 174, -1, 392, 0, 0, -1 },
+  { 0x0, 0x0, 174, -1, 394, 0, 0, -1 },
+  { 0x0, 0x0, 174, 3004, 2968, 0, 1, 1 },
+  { 0x0, 0x0, 174, 3005, 2969, 0, 1, 1 },
+  { 0x0, 0x0, 174, -1, 400, 0, 0, -1 },
+  { 0x0, 0x0, 174, -1, 402, 0, 0, -1 },
+  { 0x0, 0x0, 174, 3008, 2972, 0, 1, 1 },
+  { 0x0, 0x0, 174, 3009, 2973, 0, 1, 1 },
+  { 0x11, 0x31, 175, 2847, 407, 33, 1, 4 },
+  { 0x2200001, 0x2200001, 175, -1, 408, 12, 1, 4 },
+  { 0x11, 0x31, 175, 2047, 409, 33, 1, 4 },
+  { 0x2200001, 0x2200001, 175, -1, 411, 12, 1, 4 },
+  { 0x1, 0x1, 175, -1, 415, 37, 1, 4 },
+  { 0x2000001, 0x2000001, 175, -1, 416, 12, 1, 4 },
+  { 0x11, 0x11, 175, -1, 417, 33, 1, 4 },
+  { 0x2200001, 0x2200001, 175, -1, 418, 12, 1, 4 },
+  { 0x1, 0x1, 175, 2053, 419, 37, 1, 4 },
+  { 0x2000001, 0x2000001, 175, -1, 421, 12, 1, 4 },
+  { 0x11, 0x11, 175, 2055, 423, 33, 1, 4 },
+  { 0x2200001, 0x2200001, 175, -1, 425, 12, 1, 4 },
+  { 0x1, 0x1, 175, 2057, 427, 37, 1, 4 },
+  { 0x2000001, 0x2000001, 175, -1, 429, 12, 1, 4 },
+  { 0x11, 0x11, 175, 2059, 431, 33, 1, 4 },
+  { 0x2200001, 0x2200001, 175, -1, 433, 12, 1, 4 },
+  { 0x1, 0x1, 175, 2061, 435, 37, 1, 4 },
+  { 0x2000001, 0x2000001, 175, -1, 437, 12, 1, 4 },
+  { 0x11, 0x11, 175, 2063, 439, 33, 1, 4 },
+  { 0x2200001, 0x2200001, 175, -1, 441, 12, 1, 4 },
+  { 0x11, 0x31, 175, 2867, 447, 33, 1, 4 },
+  { 0x2200001, 0x2200001, 175, -1, 448, 12, 1, 4 },
+  { 0x11, 0x31, 175, 2069, 449, 33, 1, 4 },
+  { 0x2200001, 0x2200001, 175, -1, 451, 12, 1, 4 },
+  { 0x11, 0x31, 175, 2887, 455, 33, 1, 4 },
+  { 0x2200001, 0x2200001, 175, -1, 456, 12, 1, 4 },
+  { 0x11, 0x31, 175, 2095, 457, 33, 1, 4 },
+  { 0x2200001, 0x2200001, 175, -1, 459, 12, 1, 4 },
+  { 0x1, 0x1, 175, -1, 463, 37, 1, 4 },
+  { 0x2000001, 0x2000001, 175, -1, 464, 12, 1, 4 },
+  { 0x11, 0x11, 175, -1, 465, 33, 1, 4 },
+  { 0x2200001, 0x2200001, 175, -1, 466, 12, 1, 4 },
+  { 0x1, 0x1, 175, 2101, 467, 37, 1, 4 },
+  { 0x2000001, 0x2000001, 175, -1, 469, 12, 1, 4 },
+  { 0x11, 0x11, 175, 2103, 471, 33, 1, 4 },
+  { 0x2200001, 0x2200001, 175, -1, 473, 12, 1, 4 },
+  { 0x1, 0x1, 175, 2105, 475, 37, 1, 4 },
+  { 0x2000001, 0x2000001, 175, -1, 477, 12, 1, 4 },
+  { 0x11, 0x11, 175, 2107, 479, 33, 1, 4 },
+  { 0x2200001, 0x2200001, 175, -1, 481, 12, 1, 4 },
+  { 0x1, 0x1, 175, 2109, 483, 37, 1, 4 },
+  { 0x2000001, 0x2000001, 175, -1, 485, 12, 1, 4 },
+  { 0x11, 0x11, 175, 2111, 487, 33, 1, 4 },
+  { 0x2200001, 0x2200001, 175, -1, 489, 12, 1, 4 },
+  { 0x11, 0x31, 175, 2907, 495, 33, 1, 4 },
+  { 0x2200001, 0x2200001, 175, -1, 496, 12, 1, 4 },
+  { 0x11, 0x31, 175, 2117, 497, 33, 1, 4 },
+  { 0x2200001, 0x2200001, 175, -1, 499, 12, 1, 4 },
+  { 0x1, 0x1, 175, -1, 503, 33, 1, 4 },
+  { 0x200001, 0x200001, 175, -1, 504, 12, 1, 4 },
+  { 0x1, 0x1, 175, -1, 505, 33, 1, 4 },
+  { 0x200001, 0x200001, 175, -1, 506, 12, 1, 4 },
+  { 0x1, 0x1, 175, -1, 511, 33, 1, 4 },
+  { 0x200001, 0x200001, 175, -1, 512, 12, 1, 4 },
+  { 0x1, 0x1, 175, -1, 513, 33, 1, 4 },
+  { 0x200001, 0x200001, 175, -1, 514, 12, 1, 4 },
+  { 0x2200001, 0x6200001, 176, 2850, -1, 12, 1, 4 },
+  { 0x11, 0x11, 176, 1994, -1, 33, 1, 4 },
+  { 0x1, 0x1, 176, -1, -1, 33, 1, 5 },
+  { 0x4200001, 0x4200001, 176, -1, -1, 12, 1, 5 },
+  { 0x1, 0x1, 176, -1, -1, 37, 1, 4 },
+  { 0x2000001, 0x2000001, 176, -1, -1, 12, 1, 4 },
+  { 0x2000001, 0x2000001, 176, -1, -1, 12, 1, 4 },
+  { 0x1, 0x1, 176, 2000, -1, 37, 1, 4 },
+  { 0x2200001, 0x2200001, 176, -1, -1, 12, 1, 4 },
+  { 0x11, 0x11, 176, 2002, -1, 33, 1, 4 },
+  { 0x2000001, 0x2000001, 176, -1, -1, 12, 1, 4 },
+  { 0x1, 0x1, 176, 2004, -1, 37, 1, 4 },
+  { 0x2200001, 0x2200001, 176, -1, -1, 12, 1, 4 },
+  { 0x11, 0x11, 176, 2006, -1, 33, 1, 4 },
+  { 0x2000001, 0x2000001, 176, -1, -1, 12, 1, 4 },
+  { 0x1, 0x1, 176, 2008, -1, 37, 1, 4 },
+  { 0x2200001, 0x2200001, 176, -1, -1, 12, 1, 4 },
+  { 0x11, 0x11, 176, 2010, -1, 33, 1, 4 },
+  { 0x1, 0x1, 176, -1, -1, 37, 1, 4 },
+  { 0x2000001, 0x2000001, 176, -1, -1, 12, 1, 4 },
+  { 0x11, 0x11, 176, -1, -1, 33, 1, 4 },
+  { 0x2200001, 0x2200001, 176, -1, -1, 12, 1, 4 },
+  { 0x2200001, 0x6200001, 176, 2870, -1, 12, 1, 4 },
+  { 0x11, 0x11, 176, 2014, -1, 33, 1, 4 },
+  { 0x1, 0x1, 176, -1, -1, 33, 1, 5 },
+  { 0x4200001, 0x4200001, 176, -1, -1, 12, 1, 5 },
+  { 0x1, 0x1, 176, -1, -1, 37, 1, 4 },
+  { 0x2000001, 0x2000001, 176, -1, -1, 12, 1, 4 },
+  { 0x0, 0x0, 176, -1, -1, 0, 1, 5 },
+  { 0x1, 0x1, 176, -1, -1, 12, 1, 5 },
+  { 0x0, 0x0, 176, -1, -1, 0, 1, 5 },
+  { 0x1, 0x1, 176, -1, -1, 12, 1, 5 },
+  { 0x1, 0x1, 176, -1, -1, 33, 1, 5 },
+  { 0x200001, 0x200001, 176, -1, -1, 12, 1, 5 },
+  { 0x0, 0x0, 176, -1, -1, 0, 1, 5 },
+  { 0x1, 0x1, 176, -1, -1, 12, 1, 5 },
+  { 0x1, 0x1, 176, -1, -1, 33, 1, 5 },
+  { 0x200001, 0x200001, 176, -1, -1, 12, 1, 5 },
+  { 0x0, 0x0, 176, -1, -1, 0, 1, 5 },
+  { 0x1, 0x1, 176, -1, -1, 12, 1, 5 },
+  { 0x1, 0x1, 176, -1, -1, 33, 1, 5 },
+  { 0x200001, 0x200001, 176, -1, -1, 12, 1, 5 },
+  { 0x0, 0x0, 176, -1, -1, 0, 1, 5 },
+  { 0x1, 0x1, 176, -1, -1, 12, 1, 5 },
+  { 0x1, 0x1, 176, -1, -1, 33, 1, 5 },
+  { 0x200001, 0x200001, 176, -1, -1, 12, 1, 5 },
+  { 0x0, 0x0, 176, -1, -1, 0, 1, 5 },
+  { 0x1, 0x1, 176, -1, -1, 12, 1, 5 },
+  { 0x2200001, 0x6200001, 176, 2890, -1, 12, 1, 4 },
+  { 0x11, 0x11, 176, 2018, -1, 33, 1, 4 },
+  { 0x1, 0x1, 176, -1, -1, 33, 1, 5 },
+  { 0x4200001, 0x4200001, 176, -1, -1, 12, 1, 5 },
+  { 0x1, 0x1, 176, -1, -1, 37, 1, 4 },
+  { 0x2000001, 0x2000001, 176, -1, -1, 12, 1, 4 },
+  { 0x2000001, 0x2000001, 176, -1, -1, 12, 1, 4 },
+  { 0x1, 0x1, 176, 2024, -1, 37, 1, 4 },
+  { 0x2200001, 0x2200001, 176, -1, -1, 12, 1, 4 },
+  { 0x11, 0x11, 176, 2026, -1, 33, 1, 4 },
+  { 0x2000001, 0x2000001, 176, -1, -1, 12, 1, 4 },
+  { 0x1, 0x1, 176, 2028, -1, 37, 1, 4 },
+  { 0x2200001, 0x2200001, 176, -1, -1, 12, 1, 4 },
+  { 0x11, 0x11, 176, 2030, -1, 33, 1, 4 },
+  { 0x2000001, 0x2000001, 176, -1, -1, 12, 1, 4 },
+  { 0x1, 0x1, 176, 2032, -1, 37, 1, 4 },
+  { 0x2200001, 0x2200001, 176, -1, -1, 12, 1, 4 },
+  { 0x11, 0x11, 176, 2034, -1, 33, 1, 4 },
+  { 0x1, 0x1, 176, -1, -1, 37, 1, 4 },
+  { 0x2000001, 0x2000001, 176, -1, -1, 12, 1, 4 },
+  { 0x11, 0x11, 176, -1, -1, 33, 1, 4 },
+  { 0x2200001, 0x2200001, 176, -1, -1, 12, 1, 4 },
+  { 0x2200001, 0x6200001, 176, 2909, -1, 12, 1, 4 },
+  { 0x11, 0x11, 176, 2038, -1, 33, 1, 4 },
+  { 0x1, 0x1, 176, -1, -1, 33, 1, 5 },
+  { 0x4200001, 0x4200001, 176, -1, -1, 12, 1, 5 },
+  { 0x1, 0x1, 176, -1, -1, 37, 1, 4 },
+  { 0x2000001, 0x2000001, 176, -1, -1, 12, 1, 4 },
+  { 0x0, 0x0, 176, -1, -1, 0, 1, 5 },
+  { 0x1, 0x1, 176, -1, -1, 12, 1, 5 },
+  { 0x0, 0x0, 176, -1, -1, 0, 1, 5 },
+  { 0x1, 0x1, 176, -1, -1, 12, 1, 5 },
+  { 0x1, 0x1, 176, -1, -1, 33, 1, 5 },
+  { 0x200001, 0x200001, 176, -1, -1, 12, 1, 5 },
+  { 0x0, 0x0, 176, -1, -1, 0, 1, 5 },
+  { 0x1, 0x1, 176, -1, -1, 12, 1, 5 },
+  { 0x1, 0x1, 176, -1, -1, 33, 1, 5 },
+  { 0x200001, 0x200001, 176, -1, -1, 12, 1, 5 },
+  { 0x0, 0x0, 176, -1, -1, 0, 1, 5 },
+  { 0x1, 0x1, 176, -1, -1, 12, 1, 5 },
+  { 0x1, 0x1, 176, -1, -1, 33, 1, 5 },
+  { 0x200001, 0x200001, 176, -1, -1, 12, 1, 5 },
+  { 0x0, 0x0, 176, -1, -1, 0, 1, 5 },
+  { 0x1, 0x1, 176, -1, -1, 12, 1, 5 },
+  { 0x1, 0x1, 176, -1, -1, 33, 1, 5 },
+  { 0x200001, 0x200001, 176, -1, -1, 12, 1, 5 },
+  { 0x0, 0x0, 176, -1, -1, 0, 1, 5 },
+  { 0x1, 0x1, 176, -1, -1, 12, 1, 5 },
+  { 0x9, 0x9, 176, -1, -1, 33, 1, 5 },
+  { 0x1, 0x1, 176, 395, -1, 33, 1, 4 },
+  { 0x1200001, 0x1200001, 176, -1, -1, 12, 1, 5 },
+  { 0x200001, 0x200001, 176, 396, -1, 12, 1, 4 },
+  { 0x9, 0x9, 176, -1, -1, 33, 1, 5 },
+  { 0x1, 0x1, 176, 397, -1, 33, 1, 4 },
+  { 0x1200001, 0x1200001, 176, -1, -1, 12, 1, 5 },
+  { 0x200001, 0x200001, 176, 398, -1, 12, 1, 4 },
+  { 0x9, 0x9, 176, -1, -1, 33, 1, 5 },
+  { 0x1, 0x1, 176, 403, -1, 33, 1, 4 },
+  { 0x1200001, 0x1200001, 176, -1, -1, 12, 1, 5 },
+  { 0x200001, 0x200001, 176, 404, -1, 12, 1, 4 },
+  { 0x9, 0x9, 176, -1, -1, 33, 1, 5 },
+  { 0x1, 0x1, 176, 405, -1, 33, 1, 4 },
+  { 0x1200001, 0x1200001, 176, -1, -1, 12, 1, 5 },
+  { 0x200001, 0x200001, 176, 406, -1, 12, 1, 4 },
+  { 0x0, 0x0, 177, -1, 2293, 0, 0, -1 },
+  { 0x9, 0x9, 177, -1, 2301, 33, 1, 49 },
+  { 0x9, 0x9, 177, -1, 2959, 33, 1, 49 },
+  { 0x0, 0x0, 177, -1, 2346, 0, 0, -1 },
+  { 0x7, 0x7, 177, -1, -1, 27, 1, 49 },
+  { 0x1, 0x1, 197, -1, -1, 27, 1, 10 },
+  { 0x1, 0x1, 211, -1, -1, 29, 1, 0 },
+  { 0x1, 0x1, 211, -1, -1, 29, 1, 0 },
+  { 0x2, 0x3, 211, 1151, -1, 27, 1, 33 },
+  { 0x0, 0x0, 211, 1152, -1, 0, 1, 33 },
+  { 0x0, 0x0, 211, 1153, -1, 0, 1, 0 },
+  { 0x0, 0x0, 211, 1154, -1, 0, 1, 0 },
+  { 0x0, 0x0, 211, 1155, -1, 0, 1, 0 },
+  { 0x0, 0x0, 211, 1156, -1, 0, 1, 0 },
+  { 0x0, 0x0, 211, 2988, -1, 0, 1, 93 },
+  { 0x0, 0x0, 211, 2989, -1, 0, 1, 93 },
+  { 0x0, 0x0, 211, 2990, 949, 0, 0, -1 },
+  { 0x1, 0x1, 212, -1, -1, 27, 1, 0 },
+  { 0x1, 0x1, 212, -1, -1, 27, 1, 0 },
+  { 0x1, 0x1, 213, -1, 1408, 32, 1, 135 },
+  { 0x1, 0x1, 213, -1, 1410, 32, 1, 135 },
+  { 0x1, 0x1, 213, -1, 1412, 32, 1, 134 },
+  { 0x1, 0x1, 213, -1, 1414, 32, 1, 134 },
+  { 0x1, 0x1, 213, -1, 1416, 32, 1, 134 },
+  { 0x1, 0x1, 213, -1, 1418, 32, 1, 134 },
+  { 0x1, 0x1, 213, -1, 1420, 32, 1, 134 },
+  { 0x1, 0x1, 213, -1, 1422, 32, 1, 134 },
+  { 0x1, 0x1, 213, -1, 1424, 32, 1, 134 },
+  { 0x1, 0x1, 213, -1, 1426, 32, 1, 134 },
+  { 0x1, 0x1, 213, -1, 1428, 32, 1, 136 },
+  { 0x1, 0x1, 213, -1, 1430, 32, 1, 136 },
+  { 0x1, 0x1, 213, -1, 1947, 32, 1, 131 },
+  { 0x1, 0x1, 213, -1, 1949, 32, 1, 138 },
+  { 0x1, 0x1, 213, -1, 1951, 32, 1, 132 },
+  { 0x1, 0x1, 213, -1, 1953, 32, 1, 132 },
+  { 0x1, 0x1, 213, -1, 1955, 32, 1, 131 },
+  { 0x1, 0x1, 213, -1, 1957, 32, 1, 138 },
+  { 0x1, 0x1, 213, -1, 1959, 32, 1, 131 },
+  { 0x1, 0x1, 213, -1, 1961, 32, 1, 138 },
+  { 0x1, 0x1, 213, 2749, 1963, 32, 1, 131 },
+  { 0x1, 0x1, 213, 2750, 1966, 32, 1, 138 },
+  { 0x0, 0x0, 214, -1, 2791, 0, 0, -1 },
+  { 0x0, 0x0, 214, -1, 2792, 0, 0, -1 },
+  { 0x0, 0x0, 214, -1, 2817, 0, 0, -1 },
+  { 0x5, 0x5, 214, -1, 2820, 20, 1, 67 },
+  { 0x0, 0x0, 218, 2175, 948, 0, 0, -1 },
+  { 0x0, 0x0, 219, -1, 1121, 0, 0, -1 },
+  { 0x0, 0x0, 219, -1, 1246, 0, 0, -1 },
+  { 0x0, 0x0, 219, -1, -1, 0, 1, 121 },
+  { 0x0, 0x0, 219, -1, -1, 0, 1, 66 },
+  { 0x1, 0x1, 219, 815, 2255, 36, 1, 65 },
+  { 0x1, 0x1, 219, 816, 2314, 36, 1, 65 },
+  { 0x0, 0x0, 219, 817, 2317, 0, 0, -1 },
+  { 0x1, 0x1, 219, 818, -1, 36, 1, 65 },
+  { 0x0, 0x0, 219, 1405, -1, 0, 1, 33 },
+  { 0x1, 0x1, 219, 819, 2322, 36, 1, 65 },
+  { 0x0, 0x0, 219, 820, 2325, 0, 0, -1 },
+  { 0x1, 0x1, 219, 821, -1, 36, 1, 65 },
+  { 0x0, 0x0, 219, 822, 2328, 0, 0, -1 },
+  { 0x1, 0x1, 219, 823, -1, 36, 1, 65 },
+  { 0x1, 0x1, 219, 824, 2331, 36, 1, 65 },
+  { 0x1, 0x1, 219, 825, 2334, 36, 1, 65 },
+  { 0x0, 0x0, 219, 1406, -1, 0, 1, 33 },
+  { 0x1, 0x1, 219, 826, 2367, 36, 1, 65 },
+  { 0x1, 0x1, 219, 827, -1, 31, 1, 137 },
+  { 0x1, 0x1, 219, 226, 1431, 32, 1, 126 },
+  { 0x1, 0x1, 219, 227, 1440, 32, 1, 126 },
+  { 0x1, 0x1, 219, 228, 1449, 32, 1, 126 },
+  { 0x1, 0x1, 219, 229, 1462, 32, 1, 126 },
+  { 0x1, 0x1, 219, 230, 1471, 32, 1, 126 },
+  { 0x1, 0x1, 219, 231, 1480, 32, 1, 126 },
+  { 0x1, 0x1, 219, 232, 1489, 32, 1, 126 },
+  { 0x1, 0x1, 219, 233, 1498, 32, 1, 126 },
+  { 0x1, 0x1, 219, 234, 1507, 32, 1, 126 },
+  { 0x1, 0x1, 219, 235, 1516, 32, 1, 126 },
+  { 0x1, 0x1, 219, 236, 1526, 32, 1, 126 },
+  { 0x1, 0x1, 219, 237, 1536, 32, 1, 126 },
+  { 0x1, 0x1, 219, 238, 1549, 32, 1, 141 },
+  { 0x1, 0x1, 219, 239, 1555, 32, 1, 146 },
+  { 0x1, 0x1, 219, 240, 1561, 32, 1, 146 },
+  { 0x1, 0x1, 219, 241, 1567, 32, 1, 141 },
+  { 0x1, 0x1, 219, 242, 1573, 32, 1, 146 },
+  { 0x1, 0x1, 219, 243, 1579, 32, 1, 146 },
+  { 0x1, 0x1, 219, 244, 1585, 32, 1, 141 },
+  { 0x1, 0x1, 219, 245, 1591, 32, 1, 146 },
+  { 0x1, 0x1, 219, 246, 1597, 32, 1, 146 },
+  { 0x1, 0x1, 219, 247, 1603, 32, 1, 141 },
+  { 0x1, 0x1, 219, 248, 1609, 32, 1, 146 },
+  { 0x1, 0x1, 219, 249, 1615, 32, 1, 141 },
+  { 0x1, 0x1, 219, 250, 1621, 32, 1, 146 },
+  { 0x1, 0x1, 219, 251, 1627, 32, 1, 141 },
+  { 0x1, 0x1, 219, 252, 1633, 32, 1, 146 },
+  { 0x1, 0x1, 219, 253, 1639, 32, 1, 141 },
+  { 0x1, 0x1, 219, 254, 1645, 32, 1, 146 },
+  { 0x1, 0x1, 219, 255, 1651, 32, 1, 146 },
+  { 0x1, 0x1, 219, 831, -1, 31, 1, 155 },
+  { 0x0, 0x0, 220, 2370, -1, 0, 1, 65 },
+  { 0x0, 0x0, 220, 2371, -1, 0, 1, 28 },
+  { 0x0, 0x0, 220, 25, -1, 0, 1, 28 },
+  { 0x0, 0x0, 220, 2373, -1, 0, 1, 28 },
+  { 0x0, 0x0, 220, 2374, -1, 0, 1, 28 },
+  { 0x0, 0x0, 220, 2375, -1, 0, 1, 44 },
+  { 0x0, 0x0, 220, 2376, -1, 0, 1, 39 },
+  { 0x1, 0x1, 220, 2377, -1, 12, 1, 58 },
+  { 0x0, 0x0, 220, 2378, -1, 0, 1, 53 },
+  { 0x1000001, 0x1000001, 220, 2379, -1, 12, 1, 58 },
+  { 0x1, 0x1, 220, 2380, -1, 36, 1, 53 },
+  { 0x200001, 0x200001, 220, 2381, -1, 12, 1, 58 },
+  { 0x1, 0x1, 220, 2382, -1, 33, 1, 53 },
+  { 0x1200001, 0x1200001, 220, 2383, -1, 12, 1, 48 },
+  { 0x9, 0x9, 220, 2384, -1, 33, 1, 48 },
+  { 0x0, 0x0, 220, 2385, -1, 0, 1, 58 },
+  { 0x0, 0x0, 220, 2386, -1, 0, 1, 53 },
+  { 0x0, 0x0, 220, 2387, -1, 0, 1, 58 },
+  { 0x0, 0x0, 220, 2388, -1, 0, 1, 53 },
+  { 0x0, 0x0, 220, 2389, -1, 0, 1, 58 },
+  { 0x0, 0x0, 220, 2390, -1, 0, 1, 53 },
+  { 0x0, 0x0, 220, 2391, -1, 0, 1, 48 },
+  { 0x0, 0x0, 220, 2392, -1, 0, 1, 48 },
+  { 0x1, 0x1, 220, 2393, -1, 12, 1, 58 },
+  { 0x0, 0x0, 220, 2394, -1, 0, 1, 53 },
+  { 0x200001, 0x1200001, 220, 2395, -1, 12, 1, 58 },
+  { 0x1, 0x9, 220, 2396, -1, 33, 1, 53 },
+  { 0x0, 0x0, 220, 2397, -1, 0, 1, 58 },
+  { 0x0, 0x0, 220, 2398, -1, 0, 1, 53 },
+  { 0x0, 0x0, 220, 2399, -1, 0, 1, 58 },
+  { 0x0, 0x0, 220, 2400, -1, 0, 1, 53 },
+  { 0x1, 0x1, 220, 2401, -1, 12, 1, 58 },
+  { 0x0, 0x0, 220, 2402, -1, 0, 1, 53 },
+  { 0x1000001, 0x1000001, 220, 2403, -1, 12, 1, 58 },
+  { 0x1, 0x1, 220, 2404, -1, 36, 1, 53 },
+  { 0x200001, 0x200001, 220, 2405, -1, 12, 1, 58 },
+  { 0x1, 0x1, 220, 2406, -1, 33, 1, 53 },
+  { 0x1200001, 0x1200001, 220, 2407, -1, 12, 1, 48 },
+  { 0x9, 0x9, 220, 2408, -1, 33, 1, 48 },
+  { 0x0, 0x0, 220, 2409, -1, 0, 1, 58 },
+  { 0x0, 0x0, 220, 2410, -1, 0, 1, 53 },
+  { 0x0, 0x0, 220, 2411, -1, 0, 1, 58 },
+  { 0x0, 0x0, 220, 2412, -1, 0, 1, 53 },
+  { 0x0, 0x0, 220, 2413, -1, 0, 1, 58 },
+  { 0x0, 0x0, 220, 2414, -1, 0, 1, 53 },
+  { 0x0, 0x0, 220, 2415, -1, 0, 1, 48 },
+  { 0x0, 0x0, 220, 2416, -1, 0, 1, 48 },
+  { 0x1, 0x1, 220, 2417, -1, 12, 1, 58 },
+  { 0x0, 0x0, 220, 2418, -1, 0, 1, 53 },
+  { 0x200001, 0x1200001, 220, 2419, -1, 12, 1, 58 },
+  { 0x1, 0x9, 220, 2420, -1, 33, 1, 53 },
+  { 0x0, 0x0, 220, 2421, -1, 0, 1, 58 },
+  { 0x0, 0x0, 220, 2422, -1, 0, 1, 53 },
+  { 0x0, 0x0, 220, 2423, -1, 0, 1, 58 },
+  { 0x0, 0x0, 220, 2424, -1, 0, 1, 53 },
+  { 0x1, 0x1, 220, 2425, -1, 28, 1, 28 },
+  { 0x0, 0x0, 220, 2426, -1, 0, 1, 28 },
+  { 0x3, 0x3, 220, 2427, -1, 27, 1, 28 },
+  { 0x1, 0x1, 220, 2428, -1, 27, 1, 28 },
+  { 0x0, 0x0, 220, 2429, -1, 0, 1, 65 },
+  { 0x0, 0x0, 220, 2430, -1, 0, 1, 28 },
+  { 0x0, 0x0, 220, 2431, -1, 0, 1, 28 },
+  { 0x1, 0x1, 220, 2432, -1, 36, 1, 65 },
+  { 0x1, 0x1, 220, 2433, -1, 37, 1, 28 },
+  { 0x0, 0x0, 220, 2434, -1, 0, 1, 28 },
+  { 0x0, 0x0, 220, 2435, -1, 0, 1, 28 },
+  { 0x0, 0x0, 220, 2436, -1, 0, 1, 28 },
+  { 0x0, 0x0, 220, 2437, -1, 0, 1, 65 },
+  { 0x0, 0x0, 220, 2438, -1, 0, 1, 28 },
+  { 0x0, 0x0, 220, 37, -1, 0, 1, 28 },
+  { 0x1, 0x1, 220, 2440, -1, 36, 1, 65 },
+  { 0x1, 0x1, 220, 2441, -1, 37, 1, 28 },
+  { 0x0, 0x0, 220, 2442, -1, 0, 1, 28 },
+  { 0x1, 0x1, 220, 2443, -1, 36, 1, 65 },
+  { 0x1, 0x1, 220, 2444, -1, 37, 1, 28 },
+  { 0x0, 0x0, 220, 2445, -1, 0, 1, 28 },
+  { 0x0, 0x0, 220, 2446, -1, 0, 1, 65 },
+  { 0x0, 0x0, 220, 2447, -1, 0, 1, 28 },
+  { 0x0, 0x0, 220, 42, -1, 0, 1, 28 },
+  { 0x0, 0x0, 220, 2449, -1, 0, 1, 65 },
+  { 0x0, 0x0, 220, 2450, -1, 0, 1, 28 },
+  { 0x0, 0x0, 220, 43, -1, 0, 1, 28 },
+  { 0x0, 0x0, 220, 2452, -1, 0, 1, 28 },
+  { 0x0, 0x0, 220, 2453, -1, 0, 1, 28 },
+  { 0x0, 0x0, 220, 2454, -1, 0, 1, 48 },
+  { 0x1, 0x1, 220, 2455, -1, 27, 1, 48 },
+  { 0x1, 0x1, 220, 2456, -1, 28, 1, 48 },
+  { 0x3, 0x3, 220, 2457, -1, 27, 1, 48 },
+  { 0x1, 0x1, 220, 2458, -1, 29, 1, 48 },
+  { 0x5, 0x5, 220, 2459, -1, 27, 1, 48 },
+  { 0x3, 0x3, 220, 2460, -1, 28, 1, 48 },
+  { 0x7, 0x7, 220, 2461, -1, 27, 1, 48 },
+  { 0x0, 0x0, 220, 2462, -1, 0, 1, 48 },
+  { 0x0, 0x0, 220, 2463, -1, 0, 1, 48 },
+  { 0x0, 0x0, 220, 2464, -1, 0, 1, 48 },
+  { 0x0, 0x0, 220, 2465, -1, 0, 1, 48 },
+  { 0x1, 0x1, 220, 2466, -1, 28, 1, 28 },
+  { 0x0, 0x0, 220, 2467, -1, 0, 1, 28 },
+  { 0x3, 0x3, 220, 2468, -1, 27, 1, 28 },
+  { 0x1, 0x1, 220, 2469, -1, 27, 1, 28 },
+  { 0x0, 0x0, 220, 2470, -1, 0, 1, 28 },
+  { 0x0, 0x0, 220, 2471, -1, 0, 1, 28 },
+  { 0x0, 0x0, 220, 2472, -1, 0, 1, 28 },
+  { 0x0, 0x0, 220, 52, -1, 0, 1, 28 },
+  { 0x0, 0x0, 220, 2474, -1, 0, 1, 28 },
+  { 0x0, 0x0, 220, 2475, -1, 0, 1, 28 },
+  { 0x0, 0x0, 220, 57, -1, 0, 1, 28 },
+  { 0x0, 0x0, 220, 2477, -1, 0, 1, 23 },
+  { 0x0, 0x0, 220, 2478, -1, 0, 1, 23 },
+  { 0x0, 0x0, 220, 2479, -1, 0, 1, 23 },
+  { 0x0, 0x0, 220, 2480, -1, 0, 1, 23 },
+  { 0x0, 0x0, 220, 2481, -1, 0, 1, 34 },
+  { 0x0, 0x0, 220, 2482, -1, 0, 1, 65 },
+  { 0x0, 0x0, 220, 2483, -1, 0, 1, 28 },
+  { 0x0, 0x0, 220, 64, -1, 0, 1, 28 },
+  { 0x1, 0x1, 221, 2485, -1, 34, 1, 65 },
+  { 0x1, 0x1, 221, 2486, -1, 34, 1, 30 },
+  { 0x1, 0x1, 221, 2487, -1, 34, 1, 30 },
+  { 0x1, 0x1, 221, 2488, -1, 34, 1, 30 },
+  { 0x1, 0x1, 221, 2489, -1, 34, 1, 30 },
+  { 0x1, 0x1, 221, 2490, -1, 34, 1, 45 },
+  { 0x1, 0x1, 221, 2491, -1, 34, 1, 41 },
+  { 0x400001, 0x400001, 221, 2492, -1, 12, 1, 60 },
+  { 0x1, 0x1, 221, 2493, -1, 34, 1, 55 },
+  { 0x1400001, 0x1400001, 221, 2494, -1, 12, 1, 60 },
+  { 0x5, 0x5, 221, 2495, -1, 34, 1, 55 },
+  { 0x600001, 0x600001, 221, 2496, -1, 12, 1, 60 },
+  { 0x3, 0x3, 221, 2497, -1, 33, 1, 55 },
+  { 0x1600001, 0x1600001, 221, 2498, -1, 12, 1, 50 },
+  { 0xb, 0xb, 221, 2499, -1, 33, 1, 50 },
+  { 0x1, 0x1, 221, 2500, -1, 34, 1, 60 },
+  { 0x1, 0x1, 221, 2501, -1, 34, 1, 55 },
+  { 0x1, 0x1, 221, 2502, -1, 34, 1, 60 },
+  { 0x1, 0x1, 221, 2503, -1, 34, 1, 55 },
+  { 0x1, 0x1, 221, 2504, -1, 34, 1, 60 },
+  { 0x1, 0x1, 221, 2505, -1, 34, 1, 55 },
+  { 0x1, 0x1, 221, 2506, -1, 34, 1, 50 },
+  { 0x1, 0x1, 221, 2507, -1, 34, 1, 50 },
+  { 0x400001, 0x400001, 221, 2508, -1, 12, 1, 60 },
+  { 0x1, 0x1, 221, 2509, -1, 34, 1, 55 },
+  { 0x600001, 0x1600001, 221, 2510, -1, 12, 1, 60 },
+  { 0x3, 0xb, 221, 2511, -1, 33, 1, 55 },
+  { 0x1, 0x1, 221, 2512, -1, 34, 1, 60 },
+  { 0x1, 0x1, 221, 2513, -1, 34, 1, 55 },
+  { 0x1, 0x1, 221, 2514, -1, 34, 1, 60 },
+  { 0x1, 0x1, 221, 2515, -1, 34, 1, 55 },
+  { 0x400001, 0x400001, 221, 2516, -1, 12, 1, 60 },
+  { 0x1, 0x1, 221, 2517, -1, 34, 1, 55 },
+  { 0x1400001, 0x1400001, 221, 2518, -1, 12, 1, 60 },
+  { 0x5, 0x5, 221, 2519, -1, 34, 1, 55 },
+  { 0x600001, 0x600001, 221, 2520, -1, 12, 1, 60 },
+  { 0x3, 0x3, 221, 2521, -1, 33, 1, 55 },
+  { 0x1600001, 0x1600001, 221, 2522, -1, 12, 1, 50 },
+  { 0xb, 0xb, 221, 2523, -1, 33, 1, 50 },
+  { 0x1, 0x1, 221, 2524, -1, 34, 1, 60 },
+  { 0x1, 0x1, 221, 2525, -1, 34, 1, 55 },
+  { 0x1, 0x1, 221, 2526, -1, 34, 1, 60 },
+  { 0x1, 0x1, 221, 2527, -1, 34, 1, 55 },
+  { 0x1, 0x1, 221, 2528, -1, 34, 1, 60 },
+  { 0x1, 0x1, 221, 2529, -1, 34, 1, 55 },
+  { 0x1, 0x1, 221, 2530, -1, 34, 1, 50 },
+  { 0x1, 0x1, 221, 2531, -1, 34, 1, 50 },
+  { 0x400001, 0x400001, 221, 2532, -1, 12, 1, 60 },
+  { 0x1, 0x1, 221, 2533, -1, 34, 1, 55 },
+  { 0x600001, 0x1600001, 221, 2534, -1, 12, 1, 60 },
+  { 0x3, 0xb, 221, 2535, -1, 33, 1, 55 },
+  { 0x1, 0x1, 221, 2536, -1, 34, 1, 60 },
+  { 0x1, 0x1, 221, 2537, -1, 34, 1, 55 },
+  { 0x1, 0x1, 221, 2538, -1, 34, 1, 60 },
+  { 0x1, 0x1, 221, 2539, -1, 34, 1, 55 },
+  { 0x41, 0x41, 221, 2540, -1, 28, 1, 30 },
+  { 0x1, 0x1, 221, 2541, -1, 34, 1, 30 },
+  { 0x83, 0x83, 221, 2542, -1, 27, 1, 30 },
+  { 0x81, 0x81, 221, 2543, -1, 27, 1, 30 },
+  { 0x1, 0x1, 221, 2544, -1, 34, 1, 65 },
+  { 0x1, 0x1, 221, 2545, -1, 34, 1, 30 },
+  { 0x1, 0x1, 221, 2546, -1, 34, 1, 30 },
+  { 0x5, 0x5, 221, 2547, -1, 34, 1, 65 },
+  { 0x9, 0x9, 221, 2548, -1, 34, 1, 30 },
+  { 0x1, 0x1, 221, 2549, -1, 34, 1, 30 },
+  { 0x1, 0x1, 221, 2550, -1, 34, 1, 30 },
+  { 0x1, 0x1, 221, 2551, -1, 34, 1, 30 },
+  { 0x1, 0x1, 221, 2552, -1, 34, 1, 65 },
+  { 0x1, 0x1, 221, 2553, -1, 34, 1, 30 },
+  { 0x1, 0x1, 221, 2554, -1, 34, 1, 30 },
+  { 0x5, 0x5, 221, 2555, -1, 34, 1, 65 },
+  { 0x9, 0x9, 221, 2556, -1, 34, 1, 30 },
+  { 0x1, 0x1, 221, 2557, -1, 34, 1, 30 },
+  { 0x5, 0x5, 221, 2558, -1, 34, 1, 65 },
+  { 0x9, 0x9, 221, 2559, -1, 34, 1, 30 },
+  { 0x1, 0x1, 221, 2560, -1, 34, 1, 30 },
+  { 0x1, 0x1, 221, 2561, -1, 34, 1, 65 },
+  { 0x1, 0x1, 221, 2562, -1, 34, 1, 30 },
+  { 0x1, 0x1, 221, 2563, -1, 34, 1, 30 },
+  { 0x1, 0x1, 221, 2564, -1, 34, 1, 65 },
+  { 0x1, 0x1, 221, 2565, -1, 34, 1, 30 },
+  { 0x1, 0x1, 221, 2566, -1, 34, 1, 30 },
+  { 0x1, 0x1, 221, 2567, -1, 34, 1, 30 },
+  { 0x1, 0x1, 221, 2568, -1, 34, 1, 30 },
+  { 0x1, 0x1, 221, 2569, -1, 34, 1, 50 },
+  { 0x81, 0x81, 221, 2570, -1, 27, 1, 50 },
+  { 0x41, 0x41, 221, 2571, -1, 28, 1, 50 },
+  { 0x83, 0x83, 221, 2572, -1, 27, 1, 50 },
+  { 0x21, 0x21, 221, 2573, -1, 29, 1, 50 },
+  { 0x85, 0x85, 221, 2574, -1, 27, 1, 50 },
+  { 0x43, 0x43, 221, 2575, -1, 28, 1, 50 },
+  { 0x87, 0x87, 221, 2576, -1, 27, 1, 50 },
+  { 0x1, 0x1, 221, 2577, -1, 34, 1, 50 },
+  { 0x1, 0x1, 221, 2578, -1, 34, 1, 50 },
+  { 0x1, 0x1, 221, 2579, -1, 34, 1, 50 },
+  { 0x1, 0x1, 221, 2580, -1, 34, 1, 50 },
+  { 0x41, 0x41, 221, 2581, -1, 28, 1, 30 },
+  { 0x1, 0x1, 221, 2582, -1, 34, 1, 30 },
+  { 0x83, 0x83, 221, 2583, -1, 27, 1, 30 },
+  { 0x81, 0x81, 221, 2584, -1, 27, 1, 30 },
+  { 0x1, 0x1, 221, 2585, -1, 34, 1, 30 },
+  { 0x1, 0x1, 221, 2586, -1, 34, 1, 30 },
+  { 0x1, 0x1, 221, 2587, -1, 34, 1, 30 },
+  { 0x1, 0x1, 221, 2588, -1, 34, 1, 30 },
+  { 0x1, 0x1, 221, 2589, -1, 34, 1, 30 },
+  { 0x1, 0x1, 221, 2590, -1, 34, 1, 30 },
+  { 0x1, 0x1, 221, 2591, -1, 34, 1, 30 },
+  { 0x1, 0x1, 221, 2592, -1, 34, 1, 25 },
+  { 0x1, 0x1, 221, 2593, -1, 34, 1, 25 },
+  { 0x1, 0x1, 221, 2594, -1, 34, 1, 25 },
+  { 0x1, 0x1, 221, 2595, -1, 34, 1, 25 },
+  { 0x1, 0x1, 221, 2596, -1, 34, 1, 36 },
+  { 0x1, 0x1, 221, 2597, -1, 34, 1, 65 },
+  { 0x1, 0x1, 221, 2598, -1, 34, 1, 30 },
+  { 0x1, 0x1, 221, 2599, -1, 34, 1, 30 },
+  { 0x1, 0x1, 222, 2600, -1, 35, 1, 65 },
+  { 0x1, 0x1, 222, 2601, -1, 35, 1, 31 },
+  { 0x1, 0x1, 222, 2602, -1, 35, 1, 31 },
+  { 0x1, 0x1, 222, 2603, -1, 35, 1, 31 },
+  { 0x1, 0x1, 222, 2604, -1, 35, 1, 31 },
+  { 0x1, 0x1, 222, 2605, -1, 35, 1, 46 },
+  { 0x1, 0x1, 222, 2606, -1, 35, 1, 42 },
+  { 0x800001, 0x800001, 222, 2607, -1, 12, 1, 61 },
+  { 0x1, 0x1, 222, 2608, -1, 35, 1, 56 },
+  { 0x1800001, 0x1800001, 222, 2609, -1, 12, 1, 61 },
+  { 0x3, 0x3, 222, 2610, -1, 35, 1, 56 },
+  { 0xa00001, 0xa00001, 222, 2611, -1, 12, 1, 61 },
+  { 0x5, 0x5, 222, 2612, -1, 33, 1, 56 },
+  { 0x1a00001, 0x1a00001, 222, 2613, -1, 12, 1, 51 },
+  { 0xd, 0xd, 222, 2614, -1, 33, 1, 51 },
+  { 0x1, 0x1, 222, 2615, -1, 35, 1, 61 },
+  { 0x1, 0x1, 222, 2616, -1, 35, 1, 56 },
+  { 0x1, 0x1, 222, 2617, -1, 35, 1, 61 },
+  { 0x1, 0x1, 222, 2618, -1, 35, 1, 56 },
+  { 0x1, 0x1, 222, 2619, -1, 35, 1, 61 },
+  { 0x1, 0x1, 222, 2620, -1, 35, 1, 56 },
+  { 0x1, 0x1, 222, 2621, -1, 35, 1, 51 },
+  { 0x1, 0x1, 222, 2622, -1, 35, 1, 51 },
+  { 0x800001, 0x800001, 222, 2623, -1, 12, 1, 61 },
+  { 0x1, 0x1, 222, 2624, -1, 35, 1, 56 },
+  { 0xa00001, 0x1a00001, 222, 2625, -1, 12, 1, 61 },
+  { 0x5, 0xd, 222, 2626, -1, 33, 1, 56 },
+  { 0x1, 0x1, 222, 2627, -1, 35, 1, 61 },
+  { 0x1, 0x1, 222, 2628, -1, 35, 1, 56 },
+  { 0x1, 0x1, 222, 2629, -1, 35, 1, 61 },
+  { 0x1, 0x1, 222, 2630, -1, 35, 1, 56 },
+  { 0x800001, 0x800001, 222, 2631, -1, 12, 1, 61 },
+  { 0x1, 0x1, 222, 2632, -1, 35, 1, 56 },
+  { 0x1800001, 0x1800001, 222, 2633, -1, 12, 1, 61 },
+  { 0x3, 0x3, 222, 2634, -1, 35, 1, 56 },
+  { 0xa00001, 0xa00001, 222, 2635, -1, 12, 1, 61 },
+  { 0x5, 0x5, 222, 2636, -1, 33, 1, 56 },
+  { 0x1a00001, 0x1a00001, 222, 2637, -1, 12, 1, 51 },
+  { 0xd, 0xd, 222, 2638, -1, 33, 1, 51 },
+  { 0x1, 0x1, 222, 2639, -1, 35, 1, 61 },
+  { 0x1, 0x1, 222, 2640, -1, 35, 1, 56 },
+  { 0x1, 0x1, 222, 2641, -1, 35, 1, 61 },
+  { 0x1, 0x1, 222, 2642, -1, 35, 1, 56 },
+  { 0x1, 0x1, 222, 2643, -1, 35, 1, 61 },
+  { 0x1, 0x1, 222, 2644, -1, 35, 1, 56 },
+  { 0x1, 0x1, 222, 2645, -1, 35, 1, 51 },
+  { 0x1, 0x1, 222, 2646, -1, 35, 1, 51 },
+  { 0x800001, 0x800001, 222, 2647, -1, 12, 1, 61 },
+  { 0x1, 0x1, 222, 2648, -1, 35, 1, 56 },
+  { 0xa00001, 0x1a00001, 222, 2649, -1, 12, 1, 61 },
+  { 0x5, 0xd, 222, 2650, -1, 33, 1, 56 },
+  { 0x1, 0x1, 222, 2651, -1, 35, 1, 61 },
+  { 0x1, 0x1, 222, 2652, -1, 35, 1, 56 },
+  { 0x1, 0x1, 222, 2653, -1, 35, 1, 61 },
+  { 0x1, 0x1, 222, 2654, -1, 35, 1, 56 },
+  { 0x81, 0x81, 222, 2655, -1, 28, 1, 31 },
+  { 0x1, 0x1, 222, 2656, -1, 35, 1, 31 },
+  { 0x103, 0x103, 222, 2657, -1, 27, 1, 31 },
+  { 0x101, 0x101, 222, 2658, -1, 27, 1, 31 },
+  { 0x1, 0x1, 222, 2659, -1, 35, 1, 65 },
+  { 0x1, 0x1, 222, 2660, -1, 35, 1, 31 },
+  { 0x1, 0x1, 222, 2661, -1, 35, 1, 31 },
+  { 0x3, 0x3, 222, 2662, -1, 35, 1, 65 },
+  { 0x5, 0x5, 222, 2663, -1, 35, 1, 31 },
+  { 0x1, 0x1, 222, 2664, -1, 35, 1, 31 },
+  { 0x1, 0x1, 222, 2665, -1, 35, 1, 31 },
+  { 0x1, 0x1, 222, 2666, -1, 35, 1, 31 },
+  { 0x1, 0x1, 222, 2667, -1, 35, 1, 65 },
+  { 0x1, 0x1, 222, 2668, -1, 35, 1, 31 },
+  { 0x1, 0x1, 222, 2669, -1, 35, 1, 31 },
+  { 0x3, 0x3, 222, 2670, -1, 35, 1, 65 },
+  { 0x5, 0x5, 222, 2671, -1, 35, 1, 31 },
+  { 0x1, 0x1, 222, 2672, -1, 35, 1, 31 },
+  { 0x3, 0x3, 222, 2673, -1, 35, 1, 65 },
+  { 0x5, 0x5, 222, 2674, -1, 35, 1, 31 },
+  { 0x1, 0x1, 222, 2675, -1, 35, 1, 31 },
+  { 0x1, 0x1, 222, 2676, -1, 35, 1, 65 },
+  { 0x1, 0x1, 222, 2677, -1, 35, 1, 31 },
+  { 0x1, 0x1, 222, 2678, -1, 35, 1, 31 },
+  { 0x1, 0x1, 222, 2679, -1, 35, 1, 65 },
+  { 0x1, 0x1, 222, 2680, -1, 35, 1, 31 },
+  { 0x1, 0x1, 222, 2681, -1, 35, 1, 31 },
+  { 0x1, 0x1, 222, 2682, -1, 35, 1, 31 },
+  { 0x1, 0x1, 222, 2683, -1, 35, 1, 31 },
+  { 0x1, 0x1, 222, 2684, -1, 35, 1, 51 },
+  { 0x101, 0x101, 222, 2685, -1, 27, 1, 51 },
+  { 0x81, 0x81, 222, 2686, -1, 28, 1, 51 },
+  { 0x103, 0x103, 222, 2687, -1, 27, 1, 51 },
+  { 0x41, 0x41, 222, 2688, -1, 29, 1, 51 },
+  { 0x105, 0x105, 222, 2689, -1, 27, 1, 51 },
+  { 0x83, 0x83, 222, 2690, -1, 28, 1, 51 },
+  { 0x107, 0x107, 222, 2691, -1, 27, 1, 51 },
+  { 0x1, 0x1, 222, 2692, -1, 35, 1, 51 },
+  { 0x1, 0x1, 222, 2693, -1, 35, 1, 51 },
+  { 0x1, 0x1, 222, 2694, -1, 35, 1, 51 },
+  { 0x1, 0x1, 222, 2695, -1, 35, 1, 51 },
+  { 0x81, 0x81, 222, 2696, -1, 28, 1, 31 },
+  { 0x1, 0x1, 222, 2697, -1, 35, 1, 31 },
+  { 0x103, 0x103, 222, 2698, -1, 27, 1, 31 },
+  { 0x101, 0x101, 222, 2699, -1, 27, 1, 31 },
+  { 0x1, 0x1, 222, 2700, -1, 35, 1, 31 },
+  { 0x1, 0x1, 222, 2701, -1, 35, 1, 31 },
+  { 0x1, 0x1, 222, 2702, -1, 35, 1, 31 },
+  { 0x1, 0x1, 222, 2703, -1, 35, 1, 31 },
+  { 0x1, 0x1, 222, 2704, -1, 35, 1, 31 },
+  { 0x1, 0x1, 222, 2705, -1, 35, 1, 31 },
+  { 0x1, 0x1, 222, 2706, -1, 35, 1, 31 },
+  { 0x1, 0x1, 222, 2707, -1, 35, 1, 26 },
+  { 0x1, 0x1, 222, 2708, -1, 35, 1, 26 },
+  { 0x1, 0x1, 222, 2709, -1, 35, 1, 26 },
+  { 0x1, 0x1, 222, 2710, -1, 35, 1, 26 },
+  { 0x1, 0x1, 222, 2711, -1, 35, 1, 37 },
+  { 0x1, 0x1, 222, 2712, -1, 35, 1, 65 },
+  { 0x1, 0x1, 222, 2713, -1, 35, 1, 31 },
+  { 0x1, 0x1, 222, 2714, -1, 35, 1, 31 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 65 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 32 },
+  { 0x3, 0x3, 223, 2209, -1, 34, 1, 32 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 32 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 32 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 47 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 43 },
+  { 0xc00001, 0xc00001, 223, -1, -1, 12, 1, 62 },
+  { 0x3, 0x3, 223, 2930, -1, 34, 1, 57 },
+  { 0x1c00001, 0x1c00001, 223, -1, -1, 12, 1, 62 },
+  { 0x7, 0x7, 223, 2931, -1, 34, 1, 57 },
+  { 0xe00001, 0xe00001, 223, -1, -1, 12, 1, 62 },
+  { 0x7, 0x7, 223, 2932, -1, 33, 1, 57 },
+  { 0x1e00001, 0x1e00001, 223, -1, -1, 12, 1, 52 },
+  { 0xf, 0xf, 223, 2933, -1, 33, 1, 52 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 62 },
+  { 0x3, 0x3, 223, 2934, -1, 34, 1, 57 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 62 },
+  { 0x3, 0x3, 223, 2935, -1, 34, 1, 57 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 62 },
+  { 0x3, 0x3, 223, 2936, -1, 34, 1, 57 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 52 },
+  { 0x3, 0x3, 223, 2937, -1, 34, 1, 52 },
+  { 0xc00001, 0xc00001, 223, -1, -1, 12, 1, 62 },
+  { 0x3, 0x3, 223, 2942, -1, 34, 1, 57 },
+  { 0xe00001, 0x1e00001, 223, -1, -1, 12, 1, 62 },
+  { 0x7, 0xf, 223, 2943, -1, 33, 1, 57 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 62 },
+  { 0x3, 0x3, 223, 2944, -1, 34, 1, 57 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 62 },
+  { 0x3, 0x3, 223, 2945, -1, 34, 1, 57 },
+  { 0xc00001, 0xc00001, 223, -1, -1, 12, 1, 62 },
+  { 0x3, 0x3, 223, 2948, -1, 34, 1, 57 },
+  { 0x1c00001, 0x1c00001, 223, -1, -1, 12, 1, 62 },
+  { 0x7, 0x7, 223, 2949, -1, 34, 1, 57 },
+  { 0xe00001, 0xe00001, 223, -1, -1, 12, 1, 62 },
+  { 0x7, 0x7, 223, 2950, -1, 33, 1, 57 },
+  { 0x1e00001, 0x1e00001, 223, -1, -1, 12, 1, 52 },
+  { 0xf, 0xf, 223, 2951, -1, 33, 1, 52 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 62 },
+  { 0x3, 0x3, 223, 2952, -1, 34, 1, 57 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 62 },
+  { 0x3, 0x3, 223, 2953, -1, 34, 1, 57 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 62 },
+  { 0x3, 0x3, 223, 2954, -1, 34, 1, 57 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 52 },
+  { 0x3, 0x3, 223, 2955, -1, 34, 1, 52 },
+  { 0xc00001, 0xc00001, 223, -1, -1, 12, 1, 62 },
+  { 0x3, 0x3, 223, 2960, -1, 34, 1, 57 },
+  { 0xe00001, 0x1e00001, 223, -1, -1, 12, 1, 62 },
+  { 0x7, 0xf, 223, 2961, -1, 33, 1, 57 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 62 },
+  { 0x3, 0x3, 223, 2962, -1, 34, 1, 57 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 62 },
+  { 0x3, 0x3, 223, 2963, -1, 34, 1, 57 },
+  { 0xc1, 0xc1, 223, -1, -1, 28, 1, 32 },
+  { 0x3, 0x3, 223, 2828, -1, 34, 1, 32 },
+  { 0x183, 0x183, 223, -1, -1, 27, 1, 32 },
+  { 0x181, 0x181, 223, 2829, -1, 27, 1, 32 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 65 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 32 },
+  { 0x3, 0x3, 223, 2210, -1, 34, 1, 32 },
+  { 0x7, 0x7, 223, -1, -1, 34, 1, 65 },
+  { 0xb, 0xb, 223, -1, -1, 34, 1, 32 },
+  { 0x3, 0x3, 223, 2211, -1, 34, 1, 32 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 32 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 32 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 65 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 32 },
+  { 0x3, 0x3, 223, 2214, -1, 34, 1, 32 },
+  { 0x7, 0x7, 223, -1, -1, 34, 1, 65 },
+  { 0xb, 0xb, 223, -1, -1, 34, 1, 32 },
+  { 0x3, 0x3, 223, 2215, -1, 34, 1, 32 },
+  { 0x7, 0x7, 223, -1, -1, 34, 1, 65 },
+  { 0xb, 0xb, 223, -1, -1, 34, 1, 32 },
+  { 0x3, 0x3, 223, 2217, -1, 34, 1, 32 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 65 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 32 },
+  { 0x3, 0x3, 223, 2219, -1, 34, 1, 32 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 65 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 32 },
+  { 0x3, 0x3, 223, 2220, -1, 34, 1, 32 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 32 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 32 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 52 },
+  { 0x181, 0x181, 223, -1, -1, 27, 1, 52 },
+  { 0xc1, 0xc1, 223, -1, -1, 28, 1, 52 },
+  { 0x183, 0x183, 223, -1, -1, 27, 1, 52 },
+  { 0x61, 0x61, 223, -1, -1, 29, 1, 52 },
+  { 0x185, 0x185, 223, -1, -1, 27, 1, 52 },
+  { 0xc3, 0xc3, 223, -1, -1, 28, 1, 52 },
+  { 0x187, 0x187, 223, -1, -1, 27, 1, 52 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 52 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 52 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 52 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 52 },
+  { 0xc1, 0xc1, 223, -1, -1, 28, 1, 32 },
+  { 0x3, 0x3, 223, 2832, -1, 34, 1, 32 },
+  { 0x183, 0x183, 223, -1, -1, 27, 1, 32 },
+  { 0x181, 0x181, 223, 2833, -1, 27, 1, 32 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 32 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 32 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 32 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 32 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 32 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 32 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 32 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 27 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 27 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 27 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 27 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 38 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 65 },
+  { 0x3, 0x3, 223, -1, -1, 34, 1, 32 },
+  { 0x3, 0x3, 223, 2222, -1, 34, 1, 32 },
+  { 0x3, 0x3, 224, 522, 1433, 32, 1, 128 },
+  { 0x3, 0x3, 224, 523, 1442, 32, 1, 128 },
+  { 0x3, 0x3, 224, 524, 1451, 32, 1, 128 },
+  { 0x3, 0x3, 224, 525, 1464, 32, 1, 128 },
+  { 0x3, 0x3, 224, 526, 1473, 32, 1, 128 },
+  { 0x3, 0x3, 224, 527, 1482, 32, 1, 128 },
+  { 0x3, 0x3, 224, 528, 1491, 32, 1, 128 },
+  { 0x3, 0x3, 224, 529, 1500, 32, 1, 128 },
+  { 0x3, 0x3, 224, 530, 1509, 32, 1, 128 },
+  { 0x3, 0x3, 224, 531, 1518, 32, 1, 128 },
+  { 0x3, 0x3, 224, 532, 1528, 32, 1, 128 },
+  { 0x3, 0x3, 224, 533, 1538, 32, 1, 128 },
+  { 0x3, 0x3, 224, 546, 1551, 32, 1, 143 },
+  { 0x3, 0x3, 224, 547, 1557, 32, 1, 148 },
+  { 0x3, 0x3, 224, 548, 1563, 32, 1, 148 },
+  { 0x3, 0x3, 224, 549, 1569, 32, 1, 143 },
+  { 0x3, 0x3, 224, 550, 1575, 32, 1, 148 },
+  { 0x3, 0x3, 224, 551, 1581, 32, 1, 148 },
+  { 0x3, 0x3, 224, 552, 1587, 32, 1, 143 },
+  { 0x3, 0x3, 224, 553, 1593, 32, 1, 148 },
+  { 0x3, 0x3, 224, 554, 1599, 32, 1, 148 },
+  { 0x3, 0x3, 224, 555, 1605, 32, 1, 143 },
+  { 0x3, 0x3, 224, 556, 1611, 32, 1, 148 },
+  { 0x3, 0x3, 224, 557, 1617, 32, 1, 143 },
+  { 0x3, 0x3, 224, 558, 1623, 32, 1, 148 },
+  { 0x3, 0x3, 224, 559, 1629, 32, 1, 143 },
+  { 0x3, 0x3, 224, 560, 1635, 32, 1, 148 },
+  { 0x3, 0x3, 224, 561, 1641, 32, 1, 143 },
+  { 0x3, 0x3, 224, 562, 1647, 32, 1, 148 },
+  { 0x3, 0x3, 224, 563, 1653, 32, 1, 148 },
+  { 0x1, 0x1, 225, -1, -1, 28, 1, 33 },
+  { 0x1, 0x1, 225, -1, -1, 28, 1, 33 },
+  { 0x0, 0x0, 232, 940, -1, 0, 1, 137 },
+  { 0x0, 0x0, 232, 941, -1, 0, 1, 155 },
+  { 0x1, 0x1, 233, -1, 1964, 33, 1, 133 },
+  { 0x1, 0x1, 233, -1, 1967, 33, 1, 139 },
+  { 0x0, 0x0, 233, -1, 1969, 0, 1, 150 },
+  { 0x0, 0x0, 233, -1, 1970, 0, 1, 156 },
+  { 0x0, 0x0, 234, 865, 953, 0, 0, -1 },
+  { 0x0, 0x0, 234, 866, 961, 0, 0, -1 },
+  { 0x0, 0x0, 234, 867, 957, 0, 0, -1 },
+  { 0x1, 0x1, 234, 868, 602, 33, 1, 6 },
+  { 0x8000001, 0x8000001, 234, 869, 610, 6, 1, 7 },
+  { 0x1, 0x1, 234, 870, 606, 33, 1, 6 },
+  { 0x0, 0x0, 234, 871, 965, 0, 0, -1 },
+  { 0x1, 0x1, 234, 872, 622, 33, 1, 8 },
+  { 0x0, 0x0, 234, 873, 969, 0, 0, -1 },
+  { 0x1, 0x1, 234, 874, 634, 33, 1, 15 },
+  { 0x0, 0x0, 234, 875, 974, 0, 0, -1 },
+  { 0x0, 0x0, 234, 876, 978, 0, 0, -1 },
+  { 0x1, 0x1, 234, 877, 657, 33, 1, 17 },
+  { 0x1, 0x1, 234, 878, 661, 33, 1, 17 },
+  { 0x0, 0x0, 234, 879, 982, 0, 0, -1 },
+  { 0x0, 0x0, 234, 880, 986, 0, 0, -1 },
+  { 0x1, 0x1, 234, 881, 681, 33, 1, 18 },
+  { 0x8000001, 0x8000001, 234, 882, 685, 6, 1, 18 },
+  { 0x0, 0x0, 234, 883, 990, 0, 0, -1 },
+  { 0x1, 0x1, 234, 884, 697, 33, 1, 19 },
+  { 0x0, 0x0, 234, 885, 994, 0, 0, -1 },
+  { 0x0, 0x0, 234, 886, 998, 0, 0, -1 },
+  { 0x1, 0x1, 234, 887, 717, 33, 1, 20 },
+  { 0x8000001, 0x8000001, 234, 888, 721, 6, 1, 20 },
+  { 0x0, 0x0, 234, 889, 1002, 0, 0, -1 },
+  { 0x1, 0x1, 234, 890, 733, 33, 1, 21 },
+  { 0x0, 0x0, 234, 891, 1007, 0, 0, -1 },
+  { 0x0, 0x0, 234, 892, 1011, 0, 0, -1 },
+  { 0x1, 0x1, 234, 893, 756, 33, 1, 17 },
+  { 0x1, 0x1, 234, 894, 760, 33, 1, 17 },
+  { 0x0, 0x0, 234, 895, 1015, 0, 0, -1 },
+  { 0x1, 0x1, 234, 896, 772, 33, 1, 21 },
+  { 0x0, 0x0, 235, 2753, 952, 0, 0, -1 },
+  { 0x0, 0x0, 235, 2754, 960, 0, 0, -1 },
+  { 0x0, 0x0, 235, 2755, 956, 0, 0, -1 },
+  { 0x0, 0x0, 235, 2756, 601, 0, 1, 6 },
+  { 0x1, 0x1, 235, 2757, 609, 6, 1, 7 },
+  { 0x0, 0x0, 235, 2758, 605, 0, 1, 6 },
+  { 0x0, 0x0, 235, 2759, 964, 0, 0, -1 },
+  { 0x0, 0x0, 235, 2760, 621, 0, 1, 8 },
+  { 0x0, 0x0, 235, 2761, 968, 0, 0, -1 },
+  { 0x0, 0x0, 235, 2762, 633, 0, 1, 15 },
+  { 0x0, 0x0, 235, 2763, 973, 0, 0, -1 },
+  { 0x0, 0x0, 235, 2764, 977, 0, 0, -1 },
+  { 0x0, 0x0, 235, 2765, 656, 0, 1, 17 },
+  { 0x0, 0x0, 235, 2766, 660, 0, 1, 17 },
+  { 0x0, 0x0, 235, 2767, 981, 0, 0, -1 },
+  { 0x0, 0x0, 235, 2768, 985, 0, 0, -1 },
+  { 0x0, 0x0, 235, 2769, 680, 0, 1, 18 },
+  { 0x1, 0x1, 235, 2770, 684, 6, 1, 18 },
+  { 0x0, 0x0, 235, 2771, 989, 0, 0, -1 },
+  { 0x0, 0x0, 235, 2772, 696, 0, 1, 19 },
+  { 0x0, 0x0, 235, 2773, 993, 0, 0, -1 },
+  { 0x0, 0x0, 235, 2774, 997, 0, 0, -1 },
+  { 0x0, 0x0, 235, 2775, 716, 0, 1, 20 },
+  { 0x1, 0x1, 235, 2776, 720, 6, 1, 20 },
+  { 0x0, 0x0, 235, 2777, 1001, 0, 0, -1 },
+  { 0x0, 0x0, 235, 2778, 732, 0, 1, 21 },
+  { 0x0, 0x0, 235, 2779, 1006, 0, 0, -1 },
+  { 0x0, 0x0, 235, 2780, 1010, 0, 0, -1 },
+  { 0x0, 0x0, 235, 2781, 755, 0, 1, 17 },
+  { 0x0, 0x0, 235, 2782, 759, 0, 1, 17 },
+  { 0x0, 0x0, 235, 2783, 1014, 0, 0, -1 },
+  { 0x0, 0x0, 235, 2784, 771, 0, 1, 21 },
+  { 0x1, 0x1, 235, 897, 1137, 27, 1, 16 },
+  { 0x0, 0x0, 235, 898, 1135, 0, 1, 16 },
+  { 0x0, 0x0, 235, 1202, 1139, 0, 1, 22 },
+  { 0x0, 0x1, 235, 1147, 1145, 20, 1, 67 },
+  { 0x0, 0x0, 235, 111, 1143, 0, 1, 67 },
+  { 0x1, 0x1, 238, -1, -1, 29, 1, 0 },
+  { 0x0, 0x0, 238, -1, -1, 0, 1, 0 },
+  { 0x1, 0x1, 238, 2984, -1, 27, 1, 0 },
+  { 0x1, 0x1, 238, 2985, -1, 27, 1, 0 },
+  { 0x1, 0x1, 238, 2986, -1, 27, 1, 0 },
+  { 0x1, 0x1, 238, 2987, -1, 27, 1, 0 },
+  { 0x0, 0x0, 260, -1, 2310, 0, 0, -1 },
+  { 0x0, 0x0, 260, -1, 2312, 0, 0, -1 },
+  { 0x1, 0x1, 260, -1, -1, 28, 1, 29 },
+  { 0x1, 0x1, 260, -1, -1, 28, 1, 29 },
+  { 0x0, 0x0, 260, -1, 2351, 0, 0, -1 },
+  { 0x0, 0x0, 260, -1, 2353, 0, 0, -1 },
+  { 0x1, 0x1, 260, -1, -1, 28, 1, 29 },
+  { 0x1, 0x1, 260, -1, -1, 28, 1, 29 },
+  { 0x0, 0x0, 262, 23, -1, 0, 1, 0 },
+  { 0x0, 0x0, 262, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 262, -1, -1, 0, 1, 0 },
+  { 0x0, 0x1, 262, -1, -1, 29, 1, 0 },
+  { 0x0, 0x1, 262, -1, -1, 29, 1, 0 },
+  { 0x0, 0x1, 262, -1, -1, 29, 1, 0 },
+  { 0x0, 0x1, 262, -1, -1, 29, 1, 0 },
+  { 0x0, 0x1, 262, -1, -1, 29, 1, 0 },
+  { 0x0, 0x0, 262, 180, -1, 0, 1, 0 },
+  { 0x0, 0x1, 262, -1, -1, 29, 1, 0 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, 299, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, 321, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, 347, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, 369, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 64 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 64 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 64 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 64 },
+  { 0x0, 0x0, 263, -1, 2262, 0, 0, -1 },
+  { 0x0, 0x0, 263, -1, 2264, 0, 0, -1 },
+  { 0x0, 0x0, 263, -1, 2266, 0, 0, -1 },
+  { 0x0, 0x0, 263, -1, 2268, 0, 0, -1 },
+  { 0x1, 0x1, 263, -1, 2270, 12, 1, 59 },
+  { 0x1, 0x1, 263, -1, 2272, 12, 1, 59 },
+  { 0x1, 0x1, 263, -1, 2274, 12, 1, 59 },
+  { 0x1, 0x1, 263, -1, 2276, 12, 1, 49 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 59 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 59 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 59 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 49 },
+  { 0x0, 0x0, 263, -1, 2278, 0, 0, -1 },
+  { 0x0, 0x0, 263, -1, 2280, 0, 0, -1 },
+  { 0x1, 0x1, 263, -1, 2282, 12, 1, 59 },
+  { 0x1, 0x1, 263, -1, 2284, 12, 1, 59 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 59 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 59 },
+  { 0x0, 0x0, 263, -1, 2286, 0, 0, -1 },
+  { 0x0, 0x0, 263, -1, 2288, 0, 0, -1 },
+  { 0x0, 0x0, 263, -1, 2290, 0, 0, -1 },
+  { 0x0, 0x0, 263, -1, 2292, 0, 0, -1 },
+  { 0x1, 0x1, 263, -1, 2294, 12, 1, 59 },
+  { 0x1, 0x1, 263, -1, 2296, 12, 1, 59 },
+  { 0x1, 0x1, 263, -1, 2298, 12, 1, 59 },
+  { 0x1, 0x1, 263, -1, 2300, 12, 1, 49 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 59 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 59 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 59 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 49 },
+  { 0x0, 0x0, 263, -1, 2302, 0, 0, -1 },
+  { 0x0, 0x0, 263, -1, 2304, 0, 0, -1 },
+  { 0x1, 0x1, 263, -1, 2306, 12, 1, 59 },
+  { 0x1, 0x1, 263, -1, 2308, 12, 1, 59 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 59 },
+  { 0x1, 0x1, 263, -1, -1, 12, 1, 59 },
+  { 0x1, 0x1, 263, 391, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, 393, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, 507, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, 509, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, 399, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, 401, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, 515, -1, 12, 1, 2 },
+  { 0x1, 0x1, 263, 517, -1, 12, 1, 2 },
+  { 0x0, 0x0, 264, -1, 2269, 0, 0, -1 },
+  { 0x9, 0x9, 264, -1, 2277, 33, 1, 49 },
+  { 0x9, 0x9, 264, -1, 2941, 33, 1, 49 },
+  { 0x0, 0x0, 264, 1381, 2342, 0, 0, -1 },
+  { 0x3, 0x3, 264, 1382, -1, 27, 1, 49 },
+  { 0x0, 0x0, 268, 2822, -1, 0, 1, 0 },
+  { 0x3, 0x3, 269, -1, -1, 27, 1, 0 },
+  { 0x3, 0x3, 269, -1, -1, 27, 1, 0 },
+  { 0x3, 0x3, 269, -1, -1, 27, 1, 0 },
+  { 0x3, 0x3, 269, -1, -1, 27, 1, 0 },
+  { 0x1, 0x1, 270, 2980, -1, 28, 1, 0 },
+  { 0x1, 0x1, 270, 2981, -1, 28, 1, 0 },
+  { 0x1, 0x1, 270, 2982, -1, 28, 1, 0 },
+  { 0x1, 0x1, 270, 2983, -1, 28, 1, 0 },
+  { 0x1, 0x1, 271, -1, -1, 27, 1, 93 },
+  { 0x1, 0x1, 271, -1, -1, 27, 1, 93 },
+  { 0x0, 0x0, 271, -1, 950, 0, 0, -1 },
+  { 0x0, 0x0, 272, 2993, 2799, 0, 0, -1 },
+  { 0x0, 0x0, 272, 2994, 2801, 0, 0, -1 },
+  { 0x0, 0x0, 273, -1, 2800, 0, 0, -1 },
+  { 0x0, 0x0, 273, -1, 2802, 0, 0, -1 },
+  { 0x0, 0x0, 274, -1, -1, 0, 1, 40 },
+  { 0x0, 0x0, 274, -1, -1, 0, 1, 40 },
+  { 0x0, 0x0, 274, -1, -1, 0, 1, 40 },
+  { 0x0, 0x0, 279, -1, -1, 0, 1, 33 },
+  { 0x0, 0x0, 283, -1, 2316, 0, 1, 29 },
+  { 0x0, 0x0, 284, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 284, -1, -1, 0, 1, 71 },
+  { 0x0, 0x0, 284, 1983, 2966, 0, 1, 1 },
+  { 0x0, 0x0, 284, 1984, 2967, 0, 1, 1 },
+  { 0x0, 0x0, 284, -1, 508, 0, 0, -1 },
+  { 0x0, 0x0, 284, -1, 510, 0, 0, -1 },
+  { 0x0, 0x0, 284, 1987, 2970, 0, 1, 1 },
+  { 0x0, 0x0, 284, 1988, 2971, 0, 1, 1 },
+  { 0x0, 0x0, 284, -1, 516, 0, 0, -1 },
+  { 0x0, 0x0, 284, -1, 518, 0, 0, -1 },
+};
+
+static const struct ia64_main_table
+main_table[] = {
+  { 5, 1, 1, 0x0000010000000000ull, 0x000001eff8000000ull, { 24, 25, 26, 0, 0 }, 0x0, 0, },
+  { 5, 1, 1, 0x0000010008000000ull, 0x000001eff8000000ull, { 24, 25, 26, 4, 0 }, 0x0, 1, },
+  { 5, 7, 1, 0x0000000000000000ull, 0x0000000000000000ull, { 24, 66, 27, 0, 0 }, 0x0, 2, },
+  { 5, 7, 1, 0x0000000000000000ull, 0x0000000000000000ull, { 24, 63, 26, 0, 0 }, 0x0, 3, },
+  { 6, 1, 1, 0x0000012000000000ull, 0x000001e000000000ull, { 24, 66, 27, 0, 0 }, 0x0, 4, },
+  { 7, 1, 1, 0x0000010040000000ull, 0x000001eff8000000ull, { 24, 25, 26, 0, 0 }, 0x0, 5, },
+  { 7, 1, 1, 0x0000010c00000000ull, 0x000001ee00000000ull, { 24, 63, 26, 0, 0 }, 0x0, 6, },
+  { 8, 1, 1, 0x0000010800000000ull, 0x000001ee00000000ull, { 24, 63, 26, 0, 0 }, 0x0, 7, },
+  { 9, 3, 1, 0x0000002c00000000ull, 0x000001ee00000000ull, { 24, 3, 52, 53, 54 }, 0x221, 8, },
+  { 9, 3, 1, 0x0000002c00000000ull, 0x000001ee00000000ull, { 24, 52, 53, 54, 0 }, 0x261, 9, },
+  { 10, 1, 1, 0x0000010060000000ull, 0x000001eff8000000ull, { 24, 25, 26, 0, 0 }, 0x0, 10, },
+  { 10, 1, 1, 0x0000010160000000ull, 0x000001eff8000000ull, { 24, 55, 26, 0, 0 }, 0x0, 11, },
+  { 11, 1, 1, 0x0000010068000000ull, 0x000001eff8000000ull, { 24, 25, 26, 0, 0 }, 0x0, 12, },
+  { 11, 1, 1, 0x0000010168000000ull, 0x000001eff8000000ull, { 24, 55, 26, 0, 0 }, 0x0, 13, },
+  { 14, 4, 0, 0x0000000100000000ull, 0x000001eff80011ffull, { 16, 0, 0, 0, 0 }, 0x40, 951, },
+  { 14, 4, 0, 0x0000000100000000ull, 0x000001eff80011c0ull, { 16, 0, 0, 0, 0 }, 0x0, 807, },
+  { 14, 4, 0, 0x0000000100000000ull, 0x000001eff80011c0ull, { 16, 0, 0, 0, 0 }, 0x40, 808, },
+  { 14, 4, 0, 0x0000000108000100ull, 0x000001eff80011c0ull, { 16, 0, 0, 0, 0 }, 0x200, 2200, },
+  { 14, 4, 0, 0x0000000108000100ull, 0x000001eff80011c0ull, { 16, 0, 0, 0, 0 }, 0x240, 2201, },
+  { 14, 4, 1, 0x0000002100000000ull, 0x000001ef00001000ull, { 15, 16, 0, 0, 0 }, 0x0, 564, },
+  { 14, 4, 1, 0x0000002100000000ull, 0x000001ef00001000ull, { 15, 16, 0, 0, 0 }, 0x40, 565, },
+  { 14, 4, 0, 0x0000008000000000ull, 0x000001ee000011ffull, { 81, 0, 0, 0, 0 }, 0x40, 972, },
+  { 14, 4, 0, 0x0000008000000000ull, 0x000001ee000011c0ull, { 81, 0, 0, 0, 0 }, 0x0, 809, },
+  { 14, 4, 0, 0x0000008000000000ull, 0x000001ee000011c0ull, { 81, 0, 0, 0, 0 }, 0x40, 810, },
+  { 14, 4, 0, 0x0000008000000080ull, 0x000001ee000011c0ull, { 81, 0, 0, 0, 0 }, 0x210, 2991, },
+  { 14, 4, 0, 0x0000008000000080ull, 0x000001ee000011c0ull, { 81, 0, 0, 0, 0 }, 0x250, 2992, },
+  { 14, 4, 0, 0x0000008000000140ull, 0x000001ee000011c0ull, { 81, 0, 0, 0, 0 }, 0x30, 572, },
+  { 14, 4, 0, 0x0000008000000140ull, 0x000001ee000011c0ull, { 81, 0, 0, 0, 0 }, 0x70, 573, },
+  { 14, 4, 0, 0x0000008000000180ull, 0x000001ee000011c0ull, { 81, 0, 0, 0, 0 }, 0x230, 570, },
+  { 14, 4, 0, 0x0000008000000180ull, 0x000001ee000011c0ull, { 81, 0, 0, 0, 0 }, 0x270, 571, },
+  { 14, 4, 1, 0x000000a000000000ull, 0x000001ee00001000ull, { 15, 81, 0, 0, 0 }, 0x0, 566, },
+  { 14, 4, 1, 0x000000a000000000ull, 0x000001ee00001000ull, { 15, 81, 0, 0, 0 }, 0x40, 567, },
+  { 15, 4, 0, 0x0000000000000000ull, 0x000001e1f8000000ull, { 65, 0, 0, 0, 0 }, 0x0, 519, },
+  { 15, 5, 0, 0x0000000000000000ull, 0x000001e3f8000000ull, { 65, 0, 0, 0, 0 }, 0x0, 942, },
+  { 15, 2, 0, 0x0000000000000000ull, 0x000001eff8000000ull, { 65, 0, 0, 0, 0 }, 0x2, 1120, },
+  { 15, 3, 0, 0x0000000000000000ull, 0x000001eff8000000ull, { 65, 0, 0, 0, 0 }, 0x0, 1245, },
+  { 15, 6, 0, 0x0000000000000000ull, 0x000001eff8000000ull, { 69, 0, 0, 0, 0 }, 0x0, 2995, },
+  { 15, 7, 0, 0x0000000000000000ull, 0x0000000000000000ull, { 65, 0, 0, 0, 0 }, 0x0, 16, },
+  { 16, 6, 0, 0x0000018000000000ull, 0x000001ee000011ffull, { 82, 0, 0, 0, 0 }, 0x40, 1005, },
+  { 16, 6, 0, 0x0000018000000000ull, 0x000001ee000011c0ull, { 82, 0, 0, 0, 0 }, 0x0, 811, },
+  { 16, 6, 0, 0x0000018000000000ull, 0x000001ee000011c0ull, { 82, 0, 0, 0, 0 }, 0x40, 812, },
+  { 16, 6, 1, 0x000001a000000000ull, 0x000001ee00001000ull, { 15, 82, 0, 0, 0 }, 0x0, 568, },
+  { 16, 6, 1, 0x000001a000000000ull, 0x000001ee00001000ull, { 15, 82, 0, 0, 0 }, 0x40, 569, },
+  { 17, 4, 0, 0x0000004080000000ull, 0x000001e9f8000018ull, { 16, 77, 0, 0, 0 }, 0x20, 2818, },
+  { 17, 4, 0, 0x000000e000000000ull, 0x000001e800000018ull, { 81, 77, 0, 0, 0 }, 0x20, 2819, },
+  { 18, 4, 0, 0x0000000060000000ull, 0x000001e1f8000000ull, { 0, 0, 0, 0, 0 }, 0x2c, 222, },
+  { 22, 2, 0, 0x0000000200000000ull, 0x000001ee00000000ull, { 25, 80, 0, 0, 0 }, 0x0, 2205, },
+  { 22, 3, 0, 0x0000000800000000ull, 0x000001ee00000000ull, { 24, 81, 0, 0, 0 }, 0x0, 224, },
+  { 22, 3, 0, 0x0000000c00000000ull, 0x000001ee00000000ull, { 18, 81, 0, 0, 0 }, 0x0, 225, },
+  { 22, 3, 0, 0x0000002200000000ull, 0x000001ee00000000ull, { 25, 80, 0, 0, 0 }, 0x0, 2206, },
+  { 22, 3, 0, 0x0000002600000000ull, 0x000001ee00000000ull, { 19, 80, 0, 0, 0 }, 0x0, 2207, },
+  { 22, 7, 0, 0x0000000000000000ull, 0x0000000000000000ull, { 25, 80, 0, 0, 0 }, 0x0, 2208, },
+  { 25, 4, 0, 0x0000000020000000ull, 0x000001e1f8000000ull, { 0, 0, 0, 0, 0 }, 0x224, 18, },
+  { 26, 1, 2, 0x0000018000000000ull, 0x000001fe00001000ull, { 22, 23, 25, 26, 0 }, 0x0, 1204, },
+  { 26, 1, 1, 0x0000018000000000ull, 0x000001fe00001000ull, { 22, 25, 26, 0, 0 }, 0x40, 1205, },
+  { 26, 1, 2, 0x0000018000000000ull, 0x000001fe00001000ull, { 23, 22, 26, 25, 0 }, 0x0, 1163, },
+  { 26, 1, 1, 0x0000018000000000ull, 0x000001fe00001000ull, { 23, 26, 25, 0, 0 }, 0x40, 1164, },
+  { 26, 1, 2, 0x0000018000000000ull, 0x000001fe00001000ull, { 22, 23, 26, 25, 0 }, 0x0, 1072, },
+  { 26, 1, 1, 0x0000018000000000ull, 0x000001fe00001000ull, { 22, 26, 25, 0, 0 }, 0x40, 1073, },
+  { 26, 1, 2, 0x0000018000000000ull, 0x000001fe00001000ull, { 23, 22, 25, 26, 0 }, 0x0, 1034, },
+  { 26, 1, 1, 0x0000018000000000ull, 0x000001fe00001000ull, { 23, 25, 26, 0, 0 }, 0x40, 1035, },
+  { 26, 1, 2, 0x0000018200000000ull, 0x000001fe00001000ull, { 22, 23, 25, 26, 0 }, 0x40, 1358, },
+  { 26, 1, 2, 0x0000019000000000ull, 0x000001fe00001000ull, { 22, 23, 7, 26, 0 }, 0x0, 1074, },
+  { 26, 1, 1, 0x0000019000000000ull, 0x000001fe00001000ull, { 22, 7, 26, 0, 0 }, 0x40, 1075, },
+  { 26, 1, 2, 0x0000019000000000ull, 0x000001fe00001000ull, { 22, 23, 26, 7, 0 }, 0x40, 1208, },
+  { 26, 1, 1, 0x0000019000000000ull, 0x000001fe00001000ull, { 22, 26, 7, 0, 0 }, 0x40, 1209, },
+  { 26, 1, 2, 0x0000019000000000ull, 0x000001fe00001000ull, { 22, 23, 7, 26, 0 }, 0x40, 1169, },
+  { 26, 1, 2, 0x0000018800000000ull, 0x000001ee00001000ull, { 22, 23, 55, 26, 0 }, 0x0, 1211, },
+  { 26, 1, 1, 0x0000018800000000ull, 0x000001ee00001000ull, { 22, 55, 26, 0, 0 }, 0x40, 1212, },
+  { 26, 1, 2, 0x0000018800000000ull, 0x000001ee00001000ull, { 22, 23, 57, 26, 0 }, 0x0, 1170, },
+  { 26, 1, 1, 0x0000018800000000ull, 0x000001ee00001000ull, { 22, 57, 26, 0, 0 }, 0x40, 1171, },
+  { 26, 1, 2, 0x0000018800000000ull, 0x000001ee00001000ull, { 23, 22, 57, 26, 0 }, 0x0, 1079, },
+  { 26, 1, 1, 0x0000018800000000ull, 0x000001ee00001000ull, { 23, 57, 26, 0, 0 }, 0x40, 1080, },
+  { 26, 1, 2, 0x0000018800000000ull, 0x000001ee00001000ull, { 23, 22, 55, 26, 0 }, 0x0, 1041, },
+  { 26, 1, 1, 0x0000018800000000ull, 0x000001ee00001000ull, { 23, 55, 26, 0, 0 }, 0x40, 1042, },
+  { 26, 1, 2, 0x0000018a00000000ull, 0x000001ee00001000ull, { 22, 23, 55, 26, 0 }, 0x40, 1363, },
+  { 26, 1, 2, 0x000001a800000000ull, 0x000001ee00001000ull, { 22, 23, 59, 26, 0 }, 0x0, 1196, },
+  { 26, 1, 1, 0x000001a800000000ull, 0x000001ee00001000ull, { 22, 59, 26, 0, 0 }, 0x40, 1197, },
+  { 26, 1, 2, 0x000001a800000000ull, 0x000001ee00001000ull, { 23, 22, 59, 26, 0 }, 0x0, 1107, },
+  { 26, 1, 1, 0x000001a800000000ull, 0x000001ee00001000ull, { 23, 59, 26, 0, 0 }, 0x40, 1108, },
+  { 26, 1, 2, 0x000001c200000000ull, 0x000001fe00001000ull, { 23, 22, 25, 26, 0 }, 0x40, 1364, },
+  { 26, 1, 2, 0x000001d000000000ull, 0x000001fe00001000ull, { 23, 22, 7, 26, 0 }, 0x40, 1172, },
+  { 26, 1, 1, 0x000001d000000000ull, 0x000001fe00001000ull, { 23, 7, 26, 0, 0 }, 0x40, 1173, },
+  { 26, 1, 2, 0x000001d000000000ull, 0x000001fe00001000ull, { 23, 22, 26, 7, 0 }, 0x40, 1045, },
+  { 26, 1, 1, 0x000001d000000000ull, 0x000001fe00001000ull, { 23, 26, 7, 0, 0 }, 0x40, 1046, },
+  { 26, 1, 2, 0x000001ca00000000ull, 0x000001ee00001000ull, { 23, 22, 55, 26, 0 }, 0x40, 1365, },
+  { 27, 1, 2, 0x0000018400000000ull, 0x000001fe00001000ull, { 22, 23, 25, 26, 0 }, 0x0, 1217, },
+  { 27, 1, 1, 0x0000018400000000ull, 0x000001fe00001000ull, { 22, 25, 26, 0, 0 }, 0x40, 1218, },
+  { 27, 1, 2, 0x0000018400000000ull, 0x000001fe00001000ull, { 23, 22, 26, 25, 0 }, 0x0, 1176, },
+  { 27, 1, 1, 0x0000018400000000ull, 0x000001fe00001000ull, { 23, 26, 25, 0, 0 }, 0x40, 1177, },
+  { 27, 1, 2, 0x0000018400000000ull, 0x000001fe00001000ull, { 22, 23, 26, 25, 0 }, 0x0, 1085, },
+  { 27, 1, 1, 0x0000018400000000ull, 0x000001fe00001000ull, { 22, 26, 25, 0, 0 }, 0x40, 1086, },
+  { 27, 1, 2, 0x0000018400000000ull, 0x000001fe00001000ull, { 23, 22, 25, 26, 0 }, 0x0, 1047, },
+  { 27, 1, 1, 0x0000018400000000ull, 0x000001fe00001000ull, { 23, 25, 26, 0, 0 }, 0x40, 1048, },
+  { 27, 1, 2, 0x0000018600000000ull, 0x000001fe00001000ull, { 22, 23, 25, 26, 0 }, 0x40, 1370, },
+  { 27, 1, 2, 0x0000019400000000ull, 0x000001fe00001000ull, { 22, 23, 7, 26, 0 }, 0x0, 1087, },
+  { 27, 1, 1, 0x0000019400000000ull, 0x000001fe00001000ull, { 22, 7, 26, 0, 0 }, 0x40, 1088, },
+  { 27, 1, 2, 0x0000019400000000ull, 0x000001fe00001000ull, { 22, 23, 26, 7, 0 }, 0x40, 1221, },
+  { 27, 1, 1, 0x0000019400000000ull, 0x000001fe00001000ull, { 22, 26, 7, 0, 0 }, 0x40, 1222, },
+  { 27, 1, 2, 0x0000019400000000ull, 0x000001fe00001000ull, { 22, 23, 7, 26, 0 }, 0x40, 1182, },
+  { 27, 1, 2, 0x0000018c00000000ull, 0x000001ee00001000ull, { 22, 23, 55, 26, 0 }, 0x0, 1224, },
+  { 27, 1, 1, 0x0000018c00000000ull, 0x000001ee00001000ull, { 22, 55, 26, 0, 0 }, 0x40, 1225, },
+  { 27, 1, 2, 0x0000018c00000000ull, 0x000001ee00001000ull, { 22, 23, 57, 26, 0 }, 0x0, 1183, },
+  { 27, 1, 1, 0x0000018c00000000ull, 0x000001ee00001000ull, { 22, 57, 26, 0, 0 }, 0x40, 1184, },
+  { 27, 1, 2, 0x0000018c00000000ull, 0x000001ee00001000ull, { 23, 22, 57, 26, 0 }, 0x0, 1092, },
+  { 27, 1, 1, 0x0000018c00000000ull, 0x000001ee00001000ull, { 23, 57, 26, 0, 0 }, 0x40, 1093, },
+  { 27, 1, 2, 0x0000018c00000000ull, 0x000001ee00001000ull, { 23, 22, 55, 26, 0 }, 0x0, 1054, },
+  { 27, 1, 1, 0x0000018c00000000ull, 0x000001ee00001000ull, { 23, 55, 26, 0, 0 }, 0x40, 1055, },
+  { 27, 1, 2, 0x0000018e00000000ull, 0x000001ee00001000ull, { 22, 23, 55, 26, 0 }, 0x40, 1375, },
+  { 27, 1, 2, 0x000001ac00000000ull, 0x000001ee00001000ull, { 22, 23, 56, 26, 0 }, 0x0, 1241, },
+  { 27, 1, 1, 0x000001ac00000000ull, 0x000001ee00001000ull, { 22, 56, 26, 0, 0 }, 0x40, 1242, },
+  { 27, 1, 2, 0x000001ac00000000ull, 0x000001ee00001000ull, { 22, 23, 58, 26, 0 }, 0x0, 1200, },
+  { 27, 1, 1, 0x000001ac00000000ull, 0x000001ee00001000ull, { 22, 58, 26, 0, 0 }, 0x40, 1201, },
+  { 27, 1, 2, 0x000001ac00000000ull, 0x000001ee00001000ull, { 23, 22, 58, 26, 0 }, 0x0, 1111, },
+  { 27, 1, 1, 0x000001ac00000000ull, 0x000001ee00001000ull, { 23, 58, 26, 0, 0 }, 0x40, 1112, },
+  { 27, 1, 2, 0x000001ac00000000ull, 0x000001ee00001000ull, { 23, 22, 56, 26, 0 }, 0x0, 1070, },
+  { 27, 1, 1, 0x000001ac00000000ull, 0x000001ee00001000ull, { 23, 56, 26, 0, 0 }, 0x40, 1071, },
+  { 27, 1, 2, 0x000001c600000000ull, 0x000001fe00001000ull, { 23, 22, 25, 26, 0 }, 0x40, 1376, },
+  { 27, 1, 2, 0x000001d400000000ull, 0x000001fe00001000ull, { 23, 22, 7, 26, 0 }, 0x40, 1185, },
+  { 27, 1, 1, 0x000001d400000000ull, 0x000001fe00001000ull, { 23, 7, 26, 0, 0 }, 0x40, 1186, },
+  { 27, 1, 2, 0x000001d400000000ull, 0x000001fe00001000ull, { 23, 22, 26, 7, 0 }, 0x40, 1058, },
+  { 27, 1, 1, 0x000001d400000000ull, 0x000001fe00001000ull, { 23, 26, 7, 0, 0 }, 0x40, 1059, },
+  { 27, 1, 2, 0x000001ce00000000ull, 0x000001ee00001000ull, { 23, 22, 55, 26, 0 }, 0x40, 1377, },
+  { 28, 3, 1, 0x0000008808000000ull, 0x000001fff8000000ull, { 24, 33, 25, 1, 2 }, 0x0, 257, },
+  { 28, 3, 1, 0x0000008808000000ull, 0x000001fff8000000ull, { 24, 33, 25, 0, 0 }, 0x40, 258, },
+  { 29, 3, 1, 0x0000008008000000ull, 0x000001fff8000000ull, { 24, 33, 25, 2, 0 }, 0x0, 259, },
+  { 29, 3, 1, 0x0000008008000000ull, 0x000001fff8000000ull, { 24, 33, 25, 0, 0 }, 0x40, 260, },
+  { 30, 3, 1, 0x0000008048000000ull, 0x000001fff8000000ull, { 24, 33, 25, 2, 0 }, 0x0, 261, },
+  { 30, 3, 1, 0x0000008048000000ull, 0x000001fff8000000ull, { 24, 33, 25, 0, 0 }, 0x40, 262, },
+  { 31, 3, 1, 0x0000008088000000ull, 0x000001fff8000000ull, { 24, 33, 25, 2, 0 }, 0x0, 263, },
+  { 31, 3, 1, 0x0000008088000000ull, 0x000001fff8000000ull, { 24, 33, 25, 0, 0 }, 0x40, 264, },
+  { 32, 3, 1, 0x00000080c8000000ull, 0x000001fff8000000ull, { 24, 33, 25, 2, 0 }, 0x0, 265, },
+  { 32, 3, 1, 0x00000080c8000000ull, 0x000001fff8000000ull, { 24, 33, 25, 0, 0 }, 0x40, 266, },
+  { 34, 4, 0, 0x0000000010000000ull, 0x000001e1f8000000ull, { 0, 0, 0, 0, 0 }, 0x224, 19, },
+  { 36, 2, 1, 0x00000000c0000000ull, 0x000001eff8000000ull, { 24, 26, 0, 0, 0 }, 0x0, 1149, },
+  { 37, 2, 1, 0x00000000c8000000ull, 0x000001eff8000000ull, { 24, 26, 0, 0, 0 }, 0x0, 1150, },
+  { 39, 2, 1, 0x0000008000000000ull, 0x000001e000000000ull, { 24, 25, 26, 47, 72 }, 0x0, 20, },
+  { 39, 2, 1, 0x000000a600000000ull, 0x000001ee04000000ull, { 24, 25, 45, 73, 0 }, 0x0, 3000, },
+  { 39, 2, 1, 0x000000a604000000ull, 0x000001ee04000000ull, { 24, 55, 45, 73, 0 }, 0x0, 3001, },
+  { 39, 2, 1, 0x000000ae00000000ull, 0x000001ee00000000ull, { 24, 48, 26, 46, 73 }, 0x0, 21, },
+  { 43, 4, 0, 0x0000000080000000ull, 0x000001e1f8000000ull, { 0, 0, 0, 0, 0 }, 0x20, 22, },
+  { 48, 2, 1, 0x000000a400000000ull, 0x000001ee00002000ull, { 24, 26, 76, 73, 0 }, 0x0, 2836, },
+  { 50, 5, 1, 0x0000000080000000ull, 0x000001e3f80fe000ull, { 18, 20, 0, 0, 0 }, 0x40, 24, },
+  { 51, 5, 1, 0x0000010008000000ull, 0x000001fff8000000ull, { 18, 20, 19, 0, 0 }, 0x40, 2257, },
+  { 52, 5, 1, 0x00000000b8000000ull, 0x000001eff8000000ull, { 18, 19, 20, 0, 0 }, 0x0, 2258, },
+  { 52, 5, 1, 0x00000000b8000000ull, 0x000001eff8000000ull, { 18, 19, 20, 0, 0 }, 0x40, 26, },
+  { 53, 5, 1, 0x00000000b0000000ull, 0x000001eff8000000ull, { 18, 19, 20, 0, 0 }, 0x0, 2259, },
+  { 53, 5, 1, 0x00000000b0000000ull, 0x000001eff8000000ull, { 18, 19, 20, 0, 0 }, 0x40, 27, },
+  { 54, 5, 1, 0x0000000160000000ull, 0x000001e3f8000000ull, { 18, 19, 20, 0, 0 }, 0x0, 28, },
+  { 55, 5, 1, 0x0000000168000000ull, 0x000001e3f8000000ull, { 18, 19, 20, 0, 0 }, 0x0, 29, },
+  { 57, 3, 0, 0x0000002180000000ull, 0x000001fff8000000ull, { 26, 0, 0, 0, 0 }, 0x0, 30, },
+  { 58, 5, 0, 0x0000000040000000ull, 0x000001eff8000000ull, { 79, 0, 0, 0, 0 }, 0x0, 2260, },
+  { 58, 5, 0, 0x0000000040000000ull, 0x000001eff8000000ull, { 79, 0, 0, 0, 0 }, 0x40, 31, },
+  { 59, 5, 2, 0x000000a000000000ull, 0x000001e000001000ull, { 22, 23, 19, 60, 0 }, 0x0, 1247, },
+  { 59, 5, 1, 0x000000a000000000ull, 0x000001e000001000ull, { 22, 19, 60, 0, 0 }, 0x40, 1248, },
+  { 59, 5, 2, 0x000000a000000000ull, 0x000001e000001000ull, { 23, 22, 19, 60, 0 }, 0x40, 1402, },
+  { 59, 5, 1, 0x000000a000000000ull, 0x000001e000001000ull, { 23, 19, 60, 0, 0 }, 0x40, 1403, },
+  { 60, 5, 0, 0x0000000028000000ull, 0x000001eff8000000ull, { 0, 0, 0, 0, 0 }, 0x0, 2261, },
+  { 60, 5, 0, 0x0000000028000000ull, 0x000001eff8000000ull, { 0, 0, 0, 0, 0 }, 0x40, 32, },
+  { 61, 5, 2, 0x0000008000000000ull, 0x000001fe00001000ull, { 22, 23, 19, 20, 0 }, 0x0, 925, },
+  { 61, 5, 1, 0x0000008000000000ull, 0x000001fe00001000ull, { 22, 19, 20, 0, 0 }, 0x40, 926, },
+  { 61, 5, 2, 0x0000008000000000ull, 0x000001fe00001000ull, { 22, 23, 19, 20, 0 }, 0x40, 927, },
+  { 61, 5, 2, 0x0000009000000000ull, 0x000001fe00001000ull, { 22, 23, 20, 19, 0 }, 0x0, 1098, },
+  { 61, 5, 1, 0x0000009000000000ull, 0x000001fe00001000ull, { 22, 20, 19, 0, 0 }, 0x40, 1099, },
+  { 61, 5, 2, 0x0000009000000000ull, 0x000001fe00001000ull, { 22, 23, 20, 19, 0 }, 0x40, 1100, },
+  { 61, 5, 2, 0x0000008000000000ull, 0x000001fe00001000ull, { 23, 22, 19, 20, 0 }, 0x0, 1378, },
+  { 61, 5, 1, 0x0000008000000000ull, 0x000001fe00001000ull, { 23, 19, 20, 0, 0 }, 0x40, 1379, },
+  { 61, 5, 2, 0x0000008000000000ull, 0x000001fe00001000ull, { 23, 22, 19, 20, 0 }, 0x40, 1380, },
+  { 61, 5, 2, 0x0000009000000000ull, 0x000001fe00001000ull, { 23, 22, 20, 19, 0 }, 0x0, 1387, },
+  { 61, 5, 1, 0x0000009000000000ull, 0x000001fe00001000ull, { 23, 20, 19, 0, 0 }, 0x40, 1388, },
+  { 61, 5, 2, 0x0000009000000000ull, 0x000001fe00001000ull, { 23, 22, 20, 19, 0 }, 0x40, 1389, },
+  { 62, 5, 1, 0x00000000c0000000ull, 0x000001eff8000000ull, { 18, 19, 0, 0, 0 }, 0x0, 1024, },
+  { 62, 5, 1, 0x00000000c0000000ull, 0x000001eff8000000ull, { 18, 19, 0, 0, 0 }, 0x40, 1025, },
+  { 62, 5, 1, 0x00000000e0000000ull, 0x000001e3f8000000ull, { 18, 19, 0, 0, 0 }, 0x0, 2998, },
+  { 62, 5, 1, 0x0000010008000000ull, 0x000001fff80fe000ull, { 18, 20, 0, 0, 0 }, 0x40, 2999, },
+  { 63, 3, 1, 0x0000008488000000ull, 0x000001fff8000000ull, { 24, 33, 71, 0, 0 }, 0x0, 267, },
+  { 64, 3, 1, 0x00000084c8000000ull, 0x000001fff8000000ull, { 24, 33, 71, 0, 0 }, 0x0, 268, },
+  { 67, 3, 0, 0x0000000060000000ull, 0x000001eff8000000ull, { 0, 0, 0, 0, 0 }, 0x21, 33, },
+  { 68, 5, 1, 0x0000010000000000ull, 0x000001fc00000000ull, { 18, 20, 21, 19, 0 }, 0x0, 2319, },
+  { 68, 5, 1, 0x0000010000000000ull, 0x000001fc00000000ull, { 18, 20, 21, 19, 0 }, 0x40, 34, },
+  { 69, 5, 1, 0x00000000a8000000ull, 0x000001eff8000000ull, { 18, 19, 20, 0, 0 }, 0x0, 2320, },
+  { 69, 5, 1, 0x00000000a8000000ull, 0x000001eff8000000ull, { 18, 19, 20, 0, 0 }, 0x40, 35, },
+  { 70, 5, 1, 0x0000000080000000ull, 0x000001e3f8000000ull, { 18, 19, 20, 0, 0 }, 0x0, 2213, },
+  { 71, 5, 1, 0x00000000a0000000ull, 0x000001eff8000000ull, { 18, 19, 20, 0, 0 }, 0x0, 2321, },
+  { 71, 5, 1, 0x00000000a0000000ull, 0x000001eff8000000ull, { 18, 19, 20, 0, 0 }, 0x40, 36, },
+  { 72, 5, 1, 0x00000001c8000000ull, 0x000001e3f8000000ull, { 18, 19, 20, 0, 0 }, 0x0, 1203, },
+  { 73, 5, 1, 0x0000010000000000ull, 0x000001fc000fe000ull, { 18, 20, 21, 0, 0 }, 0x40, 2324, },
+  { 74, 5, 1, 0x0000014000000000ull, 0x000001fc00000000ull, { 18, 20, 21, 19, 0 }, 0x0, 2327, },
+  { 74, 5, 1, 0x0000014000000000ull, 0x000001fc00000000ull, { 18, 20, 21, 19, 0 }, 0x40, 38, },
+  { 75, 5, 1, 0x0000000088000000ull, 0x000001e3f8000000ull, { 18, 20, 0, 0, 0 }, 0xc0, 39, },
+  { 76, 5, 1, 0x0000000088000000ull, 0x000001e3f80fe000ull, { 18, 20, 0, 0, 0 }, 0x40, 40, },
+  { 77, 5, 1, 0x0000018000000000ull, 0x000001fc00000000ull, { 18, 20, 21, 19, 0 }, 0x0, 2330, },
+  { 77, 5, 1, 0x0000018000000000ull, 0x000001fc00000000ull, { 18, 20, 21, 19, 0 }, 0x40, 41, },
+  { 78, 5, 1, 0x0000018000000000ull, 0x000001fc000fe000ull, { 18, 20, 21, 0, 0 }, 0x40, 2333, },
+  { 79, 5, 1, 0x0000010008000000ull, 0x000001fff80fe000ull, { 18, 20, 0, 0, 0 }, 0x40, 2336, },
+  { 80, 5, 1, 0x0000000170000000ull, 0x000001e3f8000000ull, { 18, 19, 20, 0, 0 }, 0x0, 44, },
+  { 81, 5, 1, 0x0000002080000000ull, 0x000001e3f80fe000ull, { 18, 20, 0, 0, 0 }, 0x40, 45, },
+  { 82, 5, 1, 0x0000000140000000ull, 0x000001e3f8000000ull, { 18, 19, 20, 0, 0 }, 0x0, 46, },
+  { 83, 5, 1, 0x00000020b8000000ull, 0x000001eff8000000ull, { 18, 19, 20, 0, 0 }, 0x0, 2337, },
+  { 83, 5, 1, 0x00000020b8000000ull, 0x000001eff8000000ull, { 18, 19, 20, 0, 0 }, 0x40, 47, },
+  { 84, 5, 1, 0x00000020b0000000ull, 0x000001eff8000000ull, { 18, 19, 20, 0, 0 }, 0x0, 2338, },
+  { 84, 5, 1, 0x00000020b0000000ull, 0x000001eff8000000ull, { 18, 19, 20, 0, 0 }, 0x40, 48, },
+  { 85, 5, 1, 0x0000002180000000ull, 0x000001eff8000000ull, { 18, 19, 20, 0, 0 }, 0x0, 928, },
+  { 85, 5, 1, 0x0000002180000000ull, 0x000001eff8000000ull, { 18, 19, 20, 0, 0 }, 0x40, 929, },
+  { 85, 5, 1, 0x0000002188000000ull, 0x000001eff8000000ull, { 18, 20, 19, 0, 0 }, 0x40, 1101, },
+  { 86, 5, 1, 0x00000020c0000000ull, 0x000001eff8000000ull, { 18, 19, 0, 0, 0 }, 0x0, 1026, },
+  { 86, 5, 1, 0x00000020c0000000ull, 0x000001eff8000000ull, { 18, 19, 0, 0, 0 }, 0x40, 1027, },
+  { 87, 5, 1, 0x0000013000000000ull, 0x000001fc00000000ull, { 18, 20, 21, 19, 0 }, 0x0, 2355, },
+  { 87, 5, 1, 0x0000013000000000ull, 0x000001fc00000000ull, { 18, 20, 21, 19, 0 }, 0x40, 49, },
+  { 88, 5, 1, 0x00000020a8000000ull, 0x000001eff8000000ull, { 18, 19, 20, 0, 0 }, 0x0, 2356, },
+  { 88, 5, 1, 0x00000020a8000000ull, 0x000001eff8000000ull, { 18, 19, 20, 0, 0 }, 0x40, 50, },
+  { 89, 5, 1, 0x0000002080000000ull, 0x000001e3f8000000ull, { 18, 19, 20, 0, 0 }, 0x0, 2221, },
+  { 90, 5, 1, 0x00000020a0000000ull, 0x000001eff8000000ull, { 18, 19, 20, 0, 0 }, 0x0, 2357, },
+  { 90, 5, 1, 0x00000020a0000000ull, 0x000001eff8000000ull, { 18, 19, 20, 0, 0 }, 0x40, 51, },
+  { 91, 5, 1, 0x0000013000000000ull, 0x000001fc000fe000ull, { 18, 20, 21, 0, 0 }, 0x40, 2358, },
+  { 92, 5, 1, 0x0000017000000000ull, 0x000001fc00000000ull, { 18, 20, 21, 19, 0 }, 0x0, 2359, },
+  { 92, 5, 1, 0x0000017000000000ull, 0x000001fc00000000ull, { 18, 20, 21, 19, 0 }, 0x40, 53, },
+  { 93, 5, 1, 0x0000002088000000ull, 0x000001e3f8000000ull, { 18, 20, 0, 0, 0 }, 0xc0, 54, },
+  { 94, 5, 1, 0x0000002088000000ull, 0x000001e3f80fe000ull, { 18, 20, 0, 0, 0 }, 0x40, 55, },
+  { 95, 5, 1, 0x000001b000000000ull, 0x000001fc00000000ull, { 18, 20, 21, 19, 0 }, 0x0, 2360, },
+  { 95, 5, 1, 0x000001b000000000ull, 0x000001fc00000000ull, { 18, 20, 21, 19, 0 }, 0x40, 56, },
+  { 96, 5, 1, 0x000001b000000000ull, 0x000001fc000fe000ull, { 18, 20, 21, 0, 0 }, 0x40, 2361, },
+  { 97, 5, 2, 0x0000002200000000ull, 0x000001fe00000000ull, { 18, 23, 19, 20, 0 }, 0x0, 2362, },
+  { 97, 5, 2, 0x0000002200000000ull, 0x000001fe00000000ull, { 18, 23, 19, 20, 0 }, 0x40, 58, },
+  { 98, 5, 2, 0x0000003200000000ull, 0x000001fe00000000ull, { 18, 23, 20, 0, 0 }, 0x0, 2363, },
+  { 98, 5, 2, 0x0000003200000000ull, 0x000001fe00000000ull, { 18, 23, 20, 0, 0 }, 0x40, 59, },
+  { 99, 5, 2, 0x0000000200000000ull, 0x000001fe00000000ull, { 18, 23, 19, 20, 0 }, 0x0, 2364, },
+  { 99, 5, 2, 0x0000000200000000ull, 0x000001fe00000000ull, { 18, 23, 19, 20, 0 }, 0x40, 60, },
+  { 100, 5, 2, 0x0000001200000000ull, 0x000001fe00000000ull, { 18, 23, 20, 0, 0 }, 0x0, 2365, },
+  { 100, 5, 2, 0x0000001200000000ull, 0x000001fe00000000ull, { 18, 23, 20, 0, 0 }, 0x40, 61, },
+  { 101, 5, 1, 0x000001c000000000ull, 0x000001f000000000ull, { 18, 20, 21, 19, 0 }, 0x0, 62, },
+  { 102, 5, 0, 0x0000000020000000ull, 0x000001eff8000000ull, { 50, 51, 0, 0, 0 }, 0x0, 2366, },
+  { 102, 5, 0, 0x0000000020000000ull, 0x000001eff8000000ull, { 50, 51, 0, 0, 0 }, 0x40, 63, },
+  { 103, 5, 1, 0x0000014008000000ull, 0x000001fff8000000ull, { 18, 20, 19, 0, 0 }, 0x40, 2369, },
+  { 104, 5, 1, 0x00000001a0000000ull, 0x000001e3f8000000ull, { 18, 19, 20, 0, 0 }, 0x0, 65, },
+  { 105, 5, 1, 0x00000001e0000000ull, 0x000001e3f8000000ull, { 18, 19, 20, 0, 0 }, 0x0, 2168, },
+  { 106, 3, 0, 0x0000000100000000ull, 0x000001eff8000000ull, { 0, 0, 0, 0, 0 }, 0x0, 66, },
+  { 108, 5, 1, 0x0000000178000000ull, 0x000001e3f8000000ull, { 18, 19, 20, 0, 0 }, 0x0, 67, },
+  { 113, 3, 1, 0x0000008708000000ull, 0x000001ffc8000000ull, { 24, 19, 0, 0, 0 }, 0x0, 2747, },
+  { 118, 4, 0, 0x0000004008000000ull, 0x000001e1f8000000ull, { 65, 0, 0, 0, 0 }, 0x0, 520, },
+  { 118, 5, 0, 0x000000000c000000ull, 0x000001e3fc000000ull, { 65, 0, 0, 0, 0 }, 0x0, 943, },
+  { 118, 2, 0, 0x000000000c000000ull, 0x000001effc000000ull, { 65, 0, 0, 0, 0 }, 0x2, 1123, },
+  { 118, 3, 0, 0x000000000c000000ull, 0x000001effc000000ull, { 65, 0, 0, 0, 0 }, 0x0, 1249, },
+  { 118, 6, 0, 0x000000000c000000ull, 0x000001effc000000ull, { 69, 0, 0, 0, 0 }, 0x0, 2996, },
+  { 118, 7, 0, 0x0000000000000000ull, 0x0000000000000000ull, { 65, 0, 0, 0, 0 }, 0x0, 68, },
+  { 123, 3, 0, 0x0000000080000000ull, 0x000001eff8000000ull, { 0, 0, 0, 0, 0 }, 0x0, 69, },
+  { 123, 3, 0, 0x0000000090000000ull, 0x000001eff8000000ull, { 24, 0, 0, 0, 0 }, 0x0, 902, },
+  { 123, 3, 0, 0x0000000098000000ull, 0x000001eff8000000ull, { 18, 0, 0, 0, 0 }, 0x0, 903, },
+  { 124, 3, 0, 0x0000002170000000ull, 0x000001eff8000000ull, { 25, 0, 0, 0, 0 }, 0xc, 828, },
+  { 125, 3, 1, 0x0000002070000000ull, 0x000001eff8000000ull, { 30, 25, 0, 0, 0 }, 0x8, 829, },
+  { 125, 3, 1, 0x0000002078000000ull, 0x000001eff8000000ull, { 31, 25, 0, 0, 0 }, 0x8, 1125, },
+  { 127, 3, 1, 0x0000008000000000ull, 0x000001fff8000000ull, { 24, 33, 0, 0, 0 }, 0x0, 70, },
+  { 127, 3, 1, 0x0000009000000000ull, 0x000001fff8000000ull, { 24, 33, 25, 0, 0 }, 0x400, 71, },
+  { 127, 3, 1, 0x000000a000000000ull, 0x000001eff0000000ull, { 24, 33, 62, 0, 0 }, 0x400, 72, },
+  { 128, 3, 2, 0x0000008a08000000ull, 0x000001fff8000000ull, { 24, 1, 33, 0, 0 }, 0x0, 73, },
+  { 128, 3, 1, 0x0000008a08000000ull, 0x000001fff8000000ull, { 24, 33, 0, 0, 0 }, 0x40, 74, },
+  { 129, 3, 1, 0x0000008040000000ull, 0x000001fff8000000ull, { 24, 33, 0, 0, 0 }, 0x0, 75, },
+  { 129, 3, 1, 0x0000009040000000ull, 0x000001fff8000000ull, { 24, 33, 25, 0, 0 }, 0x400, 76, },
+  { 129, 3, 1, 0x000000a040000000ull, 0x000001eff0000000ull, { 24, 33, 62, 0, 0 }, 0x400, 77, },
+  { 130, 3, 1, 0x0000008080000000ull, 0x000001fff8000000ull, { 24, 33, 0, 0, 0 }, 0x0, 78, },
+  { 130, 3, 1, 0x0000009080000000ull, 0x000001fff8000000ull, { 24, 33, 25, 0, 0 }, 0x400, 79, },
+  { 130, 3, 1, 0x000000a080000000ull, 0x000001eff0000000ull, { 24, 33, 62, 0, 0 }, 0x400, 80, },
+  { 131, 3, 1, 0x00000080c0000000ull, 0x000001fff8000000ull, { 24, 33, 0, 0, 0 }, 0x0, 81, },
+  { 131, 3, 1, 0x00000080c0000000ull, 0x000001fff8000000ull, { 24, 33, 83, 0, 0 }, 0x0, 1321, },
+  { 131, 3, 1, 0x00000090c0000000ull, 0x000001fff8000000ull, { 24, 33, 25, 0, 0 }, 0x400, 82, },
+  { 131, 3, 1, 0x000000a0c0000000ull, 0x000001eff0000000ull, { 24, 33, 62, 0, 0 }, 0x400, 83, },
+  { 132, 3, 1, 0x000000c6c0000000ull, 0x000001fff8000000ull, { 18, 33, 0, 0, 0 }, 0x0, 1021, },
+  { 132, 3, 1, 0x000000d6c0000000ull, 0x000001fff8000000ull, { 18, 33, 25, 0, 0 }, 0x400, 1022, },
+  { 132, 3, 1, 0x000000e6c0000000ull, 0x000001eff0000000ull, { 18, 33, 62, 0, 0 }, 0x400, 1023, },
+  { 133, 3, 1, 0x000000c040000000ull, 0x000001fff8000000ull, { 18, 33, 0, 0, 0 }, 0x0, 84, },
+  { 133, 3, 1, 0x000000d040000000ull, 0x000001fff8000000ull, { 18, 33, 25, 0, 0 }, 0x400, 85, },
+  { 133, 3, 1, 0x000000e040000000ull, 0x000001eff0000000ull, { 18, 33, 62, 0, 0 }, 0x400, 86, },
+  { 134, 3, 1, 0x000000c0c0000000ull, 0x000001fff8000000ull, { 18, 33, 0, 0, 0 }, 0x0, 87, },
+  { 134, 3, 1, 0x000000d0c0000000ull, 0x000001fff8000000ull, { 18, 33, 25, 0, 0 }, 0x400, 88, },
+  { 134, 3, 1, 0x000000e0c0000000ull, 0x000001eff0000000ull, { 18, 33, 62, 0, 0 }, 0x400, 89, },
+  { 135, 3, 1, 0x000000c000000000ull, 0x000001fff8000000ull, { 18, 33, 0, 0, 0 }, 0x0, 90, },
+  { 135, 3, 1, 0x000000d000000000ull, 0x000001fff8000000ull, { 18, 33, 25, 0, 0 }, 0x400, 91, },
+  { 135, 3, 1, 0x000000e000000000ull, 0x000001eff0000000ull, { 18, 33, 62, 0, 0 }, 0x400, 92, },
+  { 136, 3, 2, 0x000000c048000000ull, 0x000001fff8000000ull, { 18, 19, 33, 0, 0 }, 0x0, 93, },
+  { 136, 3, 2, 0x000000d048000000ull, 0x000001fff8000000ull, { 18, 19, 33, 6, 0 }, 0x400, 94, },
+  { 137, 3, 2, 0x000000c0c8000000ull, 0x000001fff8000000ull, { 18, 19, 33, 0, 0 }, 0x0, 95, },
+  { 137, 3, 2, 0x000000d0c8000000ull, 0x000001fff8000000ull, { 18, 19, 33, 6, 0 }, 0x400, 96, },
+  { 138, 3, 2, 0x000000c088000000ull, 0x000001fff8000000ull, { 18, 19, 33, 0, 0 }, 0x0, 97, },
+  { 138, 3, 2, 0x000000d088000000ull, 0x000001fff8000000ull, { 18, 19, 33, 5, 0 }, 0x400, 98, },
+  { 139, 3, 1, 0x000000c080000000ull, 0x000001fff8000000ull, { 18, 33, 0, 0, 0 }, 0x0, 99, },
+  { 139, 3, 1, 0x000000d080000000ull, 0x000001fff8000000ull, { 18, 33, 25, 0, 0 }, 0x400, 100, },
+  { 139, 3, 1, 0x000000e080000000ull, 0x000001eff0000000ull, { 18, 33, 62, 0, 0 }, 0x400, 101, },
+  { 142, 3, 0, 0x000000cb00000000ull, 0x000001fff8000000ull, { 33, 0, 0, 0, 0 }, 0x0, 102, },
+  { 142, 3, 0, 0x000000db00000000ull, 0x000001fff8000000ull, { 33, 25, 0, 0, 0 }, 0x400, 103, },
+  { 142, 3, 0, 0x000000eb00000000ull, 0x000001eff0000000ull, { 33, 62, 0, 0, 0 }, 0x400, 104, },
+  { 143, 3, 0, 0x0000000050000000ull, 0x000001eff8000000ull, { 0, 0, 0, 0, 0 }, 0x21, 105, },
+  { 151, 3, 0, 0x0000000110000000ull, 0x000001eff8000000ull, { 0, 0, 0, 0, 0 }, 0x0, 106, },
+  { 152, 2, 1, 0x000000e880000000ull, 0x000001fff0000000ull, { 24, 25, 26, 0, 0 }, 0x0, 2169, },
+  { 153, 2, 1, 0x000000ea80000000ull, 0x000001fff0000000ull, { 24, 25, 26, 0, 0 }, 0x0, 2170, },
+  { 154, 2, 1, 0x000000f880000000ull, 0x000001fff0000000ull, { 24, 25, 26, 0, 0 }, 0x0, 2171, },
+  { 155, 1, 1, 0x0000010800000000ull, 0x000001fff80fe000ull, { 24, 26, 0, 0, 0 }, 0x0, 107, },
+  { 155, 1, 1, 0x0000012000000000ull, 0x000001e000300000ull, { 24, 66, 0, 0, 0 }, 0x40, 108, },
+  { 155, 5, 1, 0x0000000080000000ull, 0x000001e3f8000000ull, { 18, 20, 0, 0, 0 }, 0xc0, 109, },
+  { 155, 2, 1, 0x0000000e00100000ull, 0x000001ee00f00000ull, { 15, 25, 0, 0, 0 }, 0x40, 110, },
+  { 155, 2, 1, 0x0000000e00000000ull, 0x000001ee00f00000ull, { 15, 25, 78, 0, 0 }, 0x0, 2821, },
+  { 155, 2, 1, 0x0000000188000000ull, 0x000001eff8000000ull, { 24, 16, 0, 0, 0 }, 0x0, 112, },
+  { 155, 2, 1, 0x0000000600000000ull, 0x000001ee00000000ull, { 9, 25, 64, 0, 0 }, 0x0, 113, },
+  { 155, 2, 1, 0x00000016ff001fc0ull, 0x000001feff001fc0ull, { 9, 25, 0, 0, 0 }, 0x40, 114, },
+  { 155, 2, 1, 0x0000000400000000ull, 0x000001ee00000000ull, { 10, 68, 0, 0, 0 }, 0x0, 115, },
+  { 155, 2, 1, 0x0000000180000000ull, 0x000001eff8000000ull, { 24, 8, 0, 0, 0 }, 0x0, 116, },
+  { 155, 2, 1, 0x0000000198000000ull, 0x000001eff8000000ull, { 24, 9, 0, 0, 0 }, 0x0, 117, },
+  { 155, 2, 1, 0x0000000150000000ull, 0x000001eff8000000ull, { 14, 25, 0, 0, 0 }, 0x0, 1126, },
+  { 155, 2, 1, 0x0000000050000000ull, 0x000001eff8000000ull, { 14, 55, 0, 0, 0 }, 0x0, 1127, },
+  { 155, 2, 1, 0x0000000190000000ull, 0x000001eff8000000ull, { 24, 14, 0, 0, 0 }, 0x0, 1128, },
+  { 155, 3, 1, 0x0000000140000000ull, 0x000001eff8000000ull, { 14, 55, 0, 0, 0 }, 0x0, 1250, },
+  { 155, 3, 1, 0x0000002150000000ull, 0x000001eff8000000ull, { 14, 25, 0, 0, 0 }, 0x0, 1251, },
+  { 155, 3, 1, 0x0000002110000000ull, 0x000001eff8000000ull, { 24, 14, 0, 0, 0 }, 0x0, 1252, },
+  { 155, 3, 1, 0x0000002160000000ull, 0x000001eff8000000ull, { 17, 25, 0, 0, 0 }, 0x8, 118, },
+  { 155, 3, 1, 0x0000002120000000ull, 0x000001eff8000000ull, { 24, 17, 0, 0, 0 }, 0x8, 119, },
+  { 155, 3, 1, 0x0000002168000000ull, 0x000001eff8000000ull, { 12, 25, 0, 0, 0 }, 0x8, 120, },
+  { 155, 3, 1, 0x0000002148000000ull, 0x000001eff8000000ull, { 13, 25, 0, 0, 0 }, 0x0, 121, },
+  { 155, 3, 1, 0x0000002128000000ull, 0x000001eff8000000ull, { 24, 11, 0, 0, 0 }, 0x8, 122, },
+  { 155, 3, 1, 0x0000002108000000ull, 0x000001eff8000000ull, { 24, 13, 0, 0, 0 }, 0x0, 123, },
+  { 155, 3, 1, 0x0000002000000000ull, 0x000001eff8000000ull, { 38, 25, 0, 0, 0 }, 0x8, 124, },
+  { 155, 3, 1, 0x0000002008000000ull, 0x000001eff8000000ull, { 29, 25, 0, 0, 0 }, 0x8, 125, },
+  { 155, 3, 1, 0x0000002010000000ull, 0x000001eff8000000ull, { 32, 25, 0, 0, 0 }, 0x8, 126, },
+  { 155, 3, 1, 0x0000002018000000ull, 0x000001eff8000000ull, { 35, 25, 0, 0, 0 }, 0x8, 127, },
+  { 155, 3, 1, 0x0000002020000000ull, 0x000001eff8000000ull, { 36, 25, 0, 0, 0 }, 0x8, 128, },
+  { 155, 3, 1, 0x0000002028000000ull, 0x000001eff8000000ull, { 37, 25, 0, 0, 0 }, 0x8, 129, },
+  { 155, 3, 1, 0x0000002030000000ull, 0x000001eff8000000ull, { 34, 25, 0, 0, 0 }, 0x8, 130, },
+  { 155, 3, 1, 0x0000002080000000ull, 0x000001eff8000000ull, { 24, 38, 0, 0, 0 }, 0x8, 131, },
+  { 155, 3, 1, 0x0000002088000000ull, 0x000001eff8000000ull, { 24, 29, 0, 0, 0 }, 0x8, 132, },
+  { 155, 3, 1, 0x0000002090000000ull, 0x000001eff8000000ull, { 24, 32, 0, 0, 0 }, 0x8, 133, },
+  { 155, 3, 1, 0x0000002098000000ull, 0x000001eff8000000ull, { 24, 35, 0, 0, 0 }, 0x8, 134, },
+  { 155, 3, 1, 0x00000020a0000000ull, 0x000001eff8000000ull, { 24, 36, 0, 0, 0 }, 0x8, 135, },
+  { 155, 3, 1, 0x00000020a8000000ull, 0x000001eff8000000ull, { 24, 37, 0, 0, 0 }, 0x0, 136, },
+  { 155, 3, 1, 0x00000020b0000000ull, 0x000001eff8000000ull, { 24, 34, 0, 0, 0 }, 0x8, 137, },
+  { 155, 3, 1, 0x00000020b8000000ull, 0x000001eff8000000ull, { 24, 28, 0, 0, 0 }, 0x0, 138, },
+  { 155, 7, 1, 0x0000000000000000ull, 0x0000000000000000ull, { 24, 14, 0, 0, 0 }, 0x0, 139, },
+  { 155, 7, 1, 0x0000000000000000ull, 0x0000000000000000ull, { 14, 55, 0, 0, 0 }, 0x0, 140, },
+  { 155, 7, 1, 0x0000000000000000ull, 0x0000000000000000ull, { 14, 25, 0, 0, 0 }, 0x0, 141, },
+  { 156, 6, 1, 0x000000c000000000ull, 0x000001e000100000ull, { 24, 70, 0, 0, 0 }, 0x0, 142, },
+  { 157, 2, 1, 0x000000eca0000000ull, 0x000001fff0000000ull, { 24, 25, 74, 0, 0 }, 0x0, 143, },
+  { 158, 2, 1, 0x000000eea0000000ull, 0x000001fff0000000ull, { 24, 25, 75, 0, 0 }, 0x0, 144, },
+  { 168, 4, 0, 0x0000004000000000ull, 0x000001e1f8000000ull, { 65, 0, 0, 0, 0 }, 0x0, 521, },
+  { 168, 5, 0, 0x0000000008000000ull, 0x000001e3fc000000ull, { 65, 0, 0, 0, 0 }, 0x0, 944, },
+  { 168, 2, 0, 0x0000000008000000ull, 0x000001effc000000ull, { 65, 0, 0, 0, 0 }, 0x2, 1129, },
+  { 168, 3, 0, 0x0000000008000000ull, 0x000001effc000000ull, { 65, 0, 0, 0, 0 }, 0x0, 1253, },
+  { 168, 6, 0, 0x0000000008000000ull, 0x000001effc000000ull, { 69, 0, 0, 0, 0 }, 0x0, 2997, },
+  { 168, 7, 0, 0x0000000000000000ull, 0x0000000000000000ull, { 65, 0, 0, 0, 0 }, 0x0, 145, },
+  { 175, 1, 1, 0x0000010070000000ull, 0x000001eff8000000ull, { 24, 25, 26, 0, 0 }, 0x0, 146, },
+  { 175, 1, 1, 0x0000010170000000ull, 0x000001eff8000000ull, { 24, 55, 26, 0, 0 }, 0x0, 147, },
+  { 178, 2, 1, 0x000000ea00000000ull, 0x000001fff0000000ull, { 24, 25, 26, 0, 0 }, 0x0, 2979, },
+  { 179, 2, 1, 0x000000f820000000ull, 0x000001fff0000000ull, { 24, 25, 26, 0, 0 }, 0x0, 2823, },
+  { 180, 1, 1, 0x0000010400000000ull, 0x000001fff8000000ull, { 24, 25, 26, 0, 0 }, 0x0, 148, },
+  { 181, 1, 1, 0x0000010600000000ull, 0x000001fff8000000ull, { 24, 25, 26, 0, 0 }, 0x0, 149, },
+  { 182, 1, 1, 0x0000011400000000ull, 0x000001fff8000000ull, { 24, 25, 26, 0, 0 }, 0x0, 150, },
+  { 183, 1, 1, 0x0000010450000000ull, 0x000001fff8000000ull, { 24, 25, 26, 0, 0 }, 0x0, 151, },
+  { 184, 1, 1, 0x0000010650000000ull, 0x000001fff8000000ull, { 24, 25, 26, 0, 0 }, 0x0, 152, },
+  { 185, 1, 1, 0x0000010470000000ull, 0x000001fff8000000ull, { 24, 25, 26, 0, 0 }, 0x0, 153, },
+  { 186, 1, 1, 0x0000010670000000ull, 0x000001fff8000000ull, { 24, 25, 26, 0, 0 }, 0x0, 154, },
+  { 187, 1, 1, 0x0000010520000000ull, 0x000001fff8000000ull, { 24, 25, 26, 0, 0 }, 0x0, 930, },
+  { 188, 1, 1, 0x0000010720000000ull, 0x000001fff8000000ull, { 24, 25, 26, 0, 0 }, 0x0, 931, },
+  { 189, 1, 1, 0x0000011520000000ull, 0x000001fff8000000ull, { 24, 25, 26, 0, 0 }, 0x0, 932, },
+  { 190, 2, 1, 0x000000e850000000ull, 0x000001fff0000000ull, { 24, 25, 26, 0, 0 }, 0x0, 2837, },
+  { 191, 2, 1, 0x000000ea70000000ull, 0x000001fff0000000ull, { 24, 25, 26, 0, 0 }, 0x0, 155, },
+  { 192, 2, 1, 0x000000e810000000ull, 0x000001fff0000000ull, { 24, 25, 26, 0, 0 }, 0x0, 2838, },
+  { 193, 2, 1, 0x000000ea30000000ull, 0x000001fff0000000ull, { 24, 25, 26, 0, 0 }, 0x0, 156, },
+  { 194, 2, 1, 0x000000ead0000000ull, 0x000001fff0000000ull, { 24, 25, 26, 0, 0 }, 0x0, 2172, },
+  { 195, 2, 1, 0x000000e230000000ull, 0x000001ff30000000ull, { 24, 25, 26, 42, 0 }, 0x0, 157, },
+  { 196, 2, 1, 0x000000e690000000ull, 0x000001fff0000000ull, { 24, 26, 0, 0, 0 }, 0x0, 158, },
+  { 198, 3, 1, 0x00000021c0000000ull, 0x000001eff8000000ull, { 24, 26, 25, 0, 0 }, 0x0, 2173, },
+  { 198, 3, 1, 0x00000020c0000000ull, 0x000001eff8000000ull, { 24, 26, 49, 0, 0 }, 0x0, 2174, },
+  { 198, 3, 0, 0x0000002188000000ull, 0x000001eff8000000ull, { 26, 49, 0, 0, 0 }, 0x0, 2204, },
+  { 199, 2, 1, 0x000000e8b0000000ull, 0x000001fff0000000ull, { 24, 25, 26, 0, 0 }, 0x0, 159, },
+  { 200, 2, 1, 0x000000e240000000ull, 0x000001fff0000000ull, { 24, 25, 26, 0, 0 }, 0x0, 160, },
+  { 200, 2, 1, 0x000000ee50000000ull, 0x000001fff0000000ull, { 24, 25, 39, 0, 0 }, 0x0, 161, },
+  { 201, 2, 1, 0x000000f040000000ull, 0x000001fff0000000ull, { 24, 25, 26, 0, 0 }, 0x0, 162, },
+  { 201, 2, 1, 0x000000fc50000000ull, 0x000001fff0000000ull, { 24, 25, 39, 0, 0 }, 0x0, 163, },
+  { 202, 1, 1, 0x0000010680000000ull, 0x000001ffe0000000ull, { 24, 25, 41, 26, 0 }, 0x0, 164, },
+  { 203, 2, 1, 0x000000e220000000ull, 0x000001fff0000000ull, { 24, 26, 25, 0, 0 }, 0x0, 165, },
+  { 203, 2, 1, 0x000000e630000000ull, 0x000001fff0000000ull, { 24, 26, 43, 0, 0 }, 0x0, 166, },
+  { 204, 2, 1, 0x000000f020000000ull, 0x000001fff0000000ull, { 24, 26, 25, 0, 0 }, 0x0, 167, },
+  { 204, 2, 1, 0x000000f430000000ull, 0x000001fff0000000ull, { 24, 26, 43, 0, 0 }, 0x0, 168, },
+  { 205, 1, 1, 0x00000106c0000000ull, 0x000001ffe0000000ull, { 24, 25, 41, 26, 0 }, 0x0, 169, },
+  { 206, 1, 1, 0x0000010420000000ull, 0x000001fff8000000ull, { 24, 25, 26, 0, 0 }, 0x0, 170, },
+  { 207, 1, 1, 0x0000010620000000ull, 0x000001fff8000000ull, { 24, 25, 26, 0, 0 }, 0x0, 171, },
+  { 208, 1, 1, 0x0000011420000000ull, 0x000001fff8000000ull, { 24, 25, 26, 0, 0 }, 0x0, 172, },
+  { 209, 3, 0, 0x0000002048000000ull, 0x000001eff8000000ull, { 26, 25, 0, 0, 0 }, 0x8, 1157, },
+  { 209, 3, 0, 0x0000002050000000ull, 0x000001eff8000000ull, { 26, 25, 0, 0, 0 }, 0xc, 1032, },
+  { 209, 3, 0, 0x00000021a0000000ull, 0x000001eff8000000ull, { 26, 0, 0, 0, 0 }, 0x8, 904, },
+  { 210, 3, 0, 0x0000002060000000ull, 0x000001eff8000000ull, { 26, 25, 0, 0, 0 }, 0x8, 830, },
+  { 215, 4, 0, 0x0000000040000000ull, 0x000001e1f8000000ull, { 0, 0, 0, 0, 0 }, 0x22c, 173, },
+  { 216, 3, 0, 0x0000000038000000ull, 0x000001ee78000000ull, { 67, 0, 0, 0, 0 }, 0x8, 174, },
+  { 217, 3, 0, 0x0000000028000000ull, 0x000001ee78000000ull, { 67, 0, 0, 0, 0 }, 0x0, 175, },
+  { 226, 3, 1, 0x000000c708000000ull, 0x000001ffc8000000ull, { 18, 25, 0, 0, 0 }, 0x0, 2748, },
+  { 227, 2, 1, 0x000000a600000000ull, 0x000001ee04000000ull, { 24, 25, 45, 0, 0 }, 0x140, 176, },
+  { 227, 2, 1, 0x000000f240000000ull, 0x000001fff0000000ull, { 24, 25, 26, 0, 0 }, 0x0, 177, },
+  { 228, 1, 1, 0x0000010080000000ull, 0x000001efe0000000ull, { 24, 25, 40, 26, 0 }, 0x0, 178, },
+  { 229, 1, 1, 0x00000100c0000000ull, 0x000001efe0000000ull, { 24, 25, 40, 26, 0 }, 0x0, 179, },
+  { 230, 2, 1, 0x000000a400000000ull, 0x000001ee00002000ull, { 24, 26, 76, 0, 0 }, 0x140, 2844, },
+  { 230, 2, 1, 0x000000f220000000ull, 0x000001fff0000000ull, { 24, 26, 25, 0, 0 }, 0x0, 181, },
+  { 231, 2, 1, 0x000000ac00000000ull, 0x000001ee00000000ull, { 24, 25, 26, 44, 0 }, 0x0, 182, },
+  { 236, 3, 0, 0x0000000180000000ull, 0x000001eff8000000ull, { 0, 0, 0, 0, 0 }, 0x0, 832, },
+  { 237, 3, 0, 0x0000000030000000ull, 0x000001ee78000000ull, { 67, 0, 0, 0, 0 }, 0x8, 183, },
+  { 239, 3, 1, 0x0000008c00000000ull, 0x000001fff8000000ull, { 33, 25, 0, 0, 0 }, 0x0, 184, },
+  { 239, 3, 1, 0x000000ac00000000ull, 0x000001eff0000000ull, { 33, 25, 61, 0, 0 }, 0x400, 185, },
+  { 240, 3, 1, 0x0000008c08000000ull, 0x000001fff8000000ull, { 33, 25, 1, 0, 0 }, 0x0, 186, },
+  { 240, 3, 1, 0x0000008c08000000ull, 0x000001fff8000000ull, { 33, 25, 0, 0, 0 }, 0x40, 187, },
+  { 241, 3, 1, 0x0000008c40000000ull, 0x000001fff8000000ull, { 33, 25, 0, 0, 0 }, 0x0, 188, },
+  { 241, 3, 1, 0x000000ac40000000ull, 0x000001eff0000000ull, { 33, 25, 61, 0, 0 }, 0x400, 189, },
+  { 242, 3, 1, 0x0000008c80000000ull, 0x000001fff8000000ull, { 33, 25, 0, 0, 0 }, 0x0, 190, },
+  { 242, 3, 1, 0x000000ac80000000ull, 0x000001eff0000000ull, { 33, 25, 61, 0, 0 }, 0x400, 191, },
+  { 243, 3, 1, 0x0000008cc0000000ull, 0x000001fff8000000ull, { 33, 25, 0, 0, 0 }, 0x0, 192, },
+  { 243, 3, 1, 0x000000acc0000000ull, 0x000001eff0000000ull, { 33, 25, 61, 0, 0 }, 0x400, 193, },
+  { 244, 3, 1, 0x000000cec0000000ull, 0x000001fff8000000ull, { 33, 19, 0, 0, 0 }, 0x0, 2751, },
+  { 244, 3, 1, 0x000000eec0000000ull, 0x000001eff0000000ull, { 33, 19, 61, 0, 0 }, 0x400, 2752, },
+  { 245, 3, 1, 0x000000cc40000000ull, 0x000001fff8000000ull, { 33, 19, 0, 0, 0 }, 0x0, 194, },
+  { 245, 3, 1, 0x000000ec40000000ull, 0x000001eff0000000ull, { 33, 19, 61, 0, 0 }, 0x400, 195, },
+  { 246, 3, 1, 0x000000ccc0000000ull, 0x000001fff8000000ull, { 33, 19, 0, 0, 0 }, 0x0, 196, },
+  { 246, 3, 1, 0x000000ecc0000000ull, 0x000001eff0000000ull, { 33, 19, 61, 0, 0 }, 0x400, 197, },
+  { 247, 3, 1, 0x000000cc00000000ull, 0x000001fff8000000ull, { 33, 19, 0, 0, 0 }, 0x0, 198, },
+  { 247, 3, 1, 0x000000ec00000000ull, 0x000001eff0000000ull, { 33, 19, 61, 0, 0 }, 0x400, 199, },
+  { 248, 3, 1, 0x000000cc80000000ull, 0x000001fff8000000ull, { 33, 19, 0, 0, 0 }, 0x0, 200, },
+  { 248, 3, 1, 0x000000ec80000000ull, 0x000001eff0000000ull, { 33, 19, 61, 0, 0 }, 0x400, 201, },
+  { 249, 1, 1, 0x0000010028000000ull, 0x000001eff8000000ull, { 24, 25, 26, 0, 0 }, 0x0, 202, },
+  { 249, 1, 1, 0x0000010020000000ull, 0x000001eff8000000ull, { 24, 25, 26, 4, 0 }, 0x0, 203, },
+  { 249, 1, 1, 0x0000010128000000ull, 0x000001eff8000000ull, { 24, 55, 26, 0, 0 }, 0x0, 204, },
+  { 250, 3, 0, 0x0000000020000000ull, 0x000001ee78000000ull, { 67, 0, 0, 0, 0 }, 0x0, 205, },
+  { 251, 2, 1, 0x00000000a0000000ull, 0x000001eff8000000ull, { 24, 26, 0, 0, 0 }, 0x0, 206, },
+  { 252, 2, 1, 0x00000000a8000000ull, 0x000001eff8000000ull, { 24, 26, 0, 0, 0 }, 0x0, 207, },
+  { 253, 2, 1, 0x00000000b0000000ull, 0x000001eff8000000ull, { 24, 26, 0, 0, 0 }, 0x0, 208, },
+  { 254, 3, 0, 0x0000000198000000ull, 0x000001eff8000000ull, { 0, 0, 0, 0, 0 }, 0x0, 1132, },
+  { 255, 3, 1, 0x00000020f8000000ull, 0x000001eff8000000ull, { 24, 26, 0, 0, 0 }, 0x8, 209, },
+  { 256, 2, 2, 0x000000a000000000ull, 0x000001fe00003000ull, { 22, 23, 26, 76, 0 }, 0x0, 3002, },
+  { 256, 2, 1, 0x000000a000000000ull, 0x000001fe00003000ull, { 22, 26, 76, 0, 0 }, 0x40, 3003, },
+  { 256, 2, 2, 0x000000a000000000ull, 0x000001fe00003000ull, { 23, 22, 26, 76, 0 }, 0x40, 1985, },
+  { 256, 2, 1, 0x000000a000000000ull, 0x000001fe00003000ull, { 23, 26, 76, 0, 0 }, 0x40, 1986, },
+  { 257, 3, 1, 0x00000020d0000000ull, 0x000001eff8000000ull, { 24, 26, 0, 0, 0 }, 0x0, 210, },
+  { 258, 2, 2, 0x000000a000002000ull, 0x000001fe00003000ull, { 22, 23, 26, 0, 0 }, 0x0, 3006, },
+  { 258, 2, 1, 0x000000a000002000ull, 0x000001fe00003000ull, { 22, 26, 0, 0, 0 }, 0x40, 3007, },
+  { 258, 2, 2, 0x000000a000002000ull, 0x000001fe00003000ull, { 23, 22, 26, 0, 0 }, 0x40, 1989, },
+  { 258, 2, 1, 0x000000a000002000ull, 0x000001fe00003000ull, { 23, 26, 0, 0, 0 }, 0x40, 1990, },
+  { 259, 3, 1, 0x00000020f0000000ull, 0x000001eff8000000ull, { 24, 26, 0, 0, 0 }, 0x8, 211, },
+  { 261, 3, 1, 0x00000020d8000000ull, 0x000001eff8000000ull, { 24, 26, 0, 0, 0 }, 0x0, 212, },
+  { 265, 2, 1, 0x000000e840000000ull, 0x000001fff0000000ull, { 24, 25, 26, 0, 0 }, 0x0, 1113, },
+  { 266, 2, 1, 0x000000ea40000000ull, 0x000001fff0000000ull, { 24, 25, 26, 0, 0 }, 0x0, 1114, },
+  { 267, 2, 1, 0x000000f840000000ull, 0x000001fff0000000ull, { 24, 25, 26, 0, 0 }, 0x0, 1115, },
+  { 275, 3, 1, 0x0000008208000000ull, 0x000001fff8000000ull, { 24, 33, 25, 0, 0 }, 0x0, 213, },
+  { 276, 3, 1, 0x0000008248000000ull, 0x000001fff8000000ull, { 24, 33, 25, 0, 0 }, 0x0, 214, },
+  { 277, 3, 1, 0x0000008288000000ull, 0x000001fff8000000ull, { 24, 33, 25, 0, 0 }, 0x0, 215, },
+  { 278, 3, 1, 0x00000082c8000000ull, 0x000001fff8000000ull, { 24, 33, 25, 0, 0 }, 0x0, 216, },
+  { 280, 5, 1, 0x000001d000000000ull, 0x000001fc00000000ull, { 18, 20, 21, 19, 0 }, 0x0, 1161, },
+  { 280, 5, 1, 0x000001d000000000ull, 0x000001fc00000000ull, { 18, 20, 21, 19, 0 }, 0x40, 1243, },
+  { 281, 5, 1, 0x000001d000000000ull, 0x000001fc000fe000ull, { 18, 20, 21, 0, 0 }, 0x40, 1162, },
+  { 282, 1, 1, 0x0000010078000000ull, 0x000001eff8000000ull, { 24, 25, 26, 0, 0 }, 0x0, 217, },
+  { 282, 1, 1, 0x0000010178000000ull, 0x000001eff8000000ull, { 24, 55, 26, 0, 0 }, 0x0, 218, },
+  { 285, 2, 1, 0x0000000080000000ull, 0x000001eff8000000ull, { 24, 26, 0, 0, 0 }, 0x0, 219, },
+  { 286, 2, 1, 0x0000000088000000ull, 0x000001eff8000000ull, { 24, 26, 0, 0, 0 }, 0x0, 220, },
+  { 287, 2, 1, 0x0000000090000000ull, 0x000001eff8000000ull, { 24, 26, 0, 0, 0 }, 0x0, 221, },
+};
+
+static const char dis_table[] = {
+0xa0, 0xc5, 0xe8, 0xa0, 0x2e, 0x98, 0xa0, 0x2c, 0x80, 0xa0, 0x1b, 0xc0,
+0x98, 0xb0, 0x02, 0x50, 0x90, 0x50, 0x90, 0x28, 0x24, 0x38, 0x28, 0x24,
+0x38, 0x20, 0x90, 0x28, 0x24, 0x38, 0x18, 0x24, 0x38, 0x10, 0x91, 0x60,
+0x90, 0x28, 0x24, 0x38, 0x00, 0x10, 0x10, 0x58, 0x41, 0x61, 0xbf, 0xc0,
+0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
+0x10, 0x10, 0x52, 0xc0, 0xc0, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
+0x10, 0x10, 0x10, 0x24, 0x23, 0x70, 0x90, 0x28, 0x24, 0x37, 0xf0, 0x24,
+0x37, 0xe8, 0xa8, 0x0b, 0x48, 0x15, 0x20, 0x97, 0x20, 0x95, 0xc8, 0x9a,
+0xb8, 0x05, 0x38, 0x91, 0x18, 0x90, 0xa0, 0x90, 0x60, 0x80, 0x90, 0x20,
+0x34, 0x86, 0xa4, 0x24, 0x00, 0x34, 0x83, 0x80, 0xa4, 0x35, 0xa0, 0x36,
+0xb9, 0x90, 0x50, 0x90, 0x28, 0x80, 0x36, 0xaf, 0x80, 0x34, 0x66, 0x81,
+0x33, 0xe2, 0x90, 0xe0, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x23, 0x10, 0x34,
+0x63, 0xa4, 0x1f, 0x08, 0x34, 0x60, 0x90, 0x38, 0xa4, 0x37, 0xa0, 0x36,
+0xfa, 0xa4, 0x37, 0x48, 0x36, 0xee, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x36,
+0x20, 0x36, 0xcf, 0xa4, 0x35, 0xf8, 0x36, 0xca, 0x80, 0xa4, 0x22, 0xf0,
+0x34, 0x5f, 0x92, 0x18, 0x91, 0xc0, 0x80, 0x91, 0x80, 0x90, 0xf8, 0xdb,
+0x84, 0x60, 0xf9, 0x40, 0xc0, 0xc0, 0x80, 0xa4, 0x41, 0x58, 0x8c, 0x42,
+0xb8, 0x84, 0x38, 0x61, 0xc0, 0xc0, 0x80, 0xa4, 0x41, 0x48, 0x8c, 0x42,
+0x98, 0x84, 0x38, 0x5f, 0xd3, 0x82, 0x40, 0x50, 0xc0, 0xc0, 0x81, 0x38,
+0x13, 0x50, 0xc0, 0xc0, 0x81, 0x38, 0x11, 0xa4, 0x1f, 0x18, 0x33, 0xe4,
+0x80, 0x90, 0x28, 0x80, 0x33, 0xe0, 0x80, 0x34, 0x68, 0x81, 0x90, 0x38,
+0xa4, 0x23, 0x80, 0x34, 0x6b, 0xa4, 0x23, 0x48, 0x34, 0x65, 0xc0, 0x40,
+0x10, 0x10, 0x90, 0x38, 0xa4, 0x1e, 0xf0, 0x33, 0xdf, 0xa4, 0x1e, 0xe0,
+0x33, 0xdd, 0x18, 0x24, 0x23, 0xf8, 0x83, 0x90, 0xa8, 0xd3, 0x82, 0xc0,
+0xc0, 0xc0, 0x80, 0xa4, 0x41, 0x28, 0x38, 0x4b, 0xc0, 0xc0, 0x80, 0xa4,
+0x41, 0x18, 0x38, 0x47, 0xd3, 0x82, 0x40, 0x50, 0xc0, 0xc0, 0x81, 0x38,
+0x0d, 0x50, 0xc0, 0xc0, 0x81, 0x38, 0x0b, 0x92, 0xb8, 0x99, 0x84, 0x23,
+0x68, 0x90, 0x78, 0x90, 0x50, 0x10, 0x10, 0x80, 0xa4, 0x35, 0x98, 0x36,
+0xb8, 0x82, 0x36, 0xae, 0x90, 0x80, 0x10, 0x10, 0x90, 0x38, 0xa4, 0x37,
+0x98, 0x36, 0xf9, 0xa4, 0x37, 0x40, 0x36, 0xed, 0x80, 0x90, 0x38, 0xa4,
+0x36, 0x18, 0x36, 0xce, 0xa4, 0x35, 0xf0, 0x36, 0xc9, 0x83, 0x90, 0xa8,
+0xd3, 0x82, 0xc0, 0xc0, 0xc0, 0x80, 0xa4, 0x40, 0xf8, 0x38, 0x3f, 0xc0,
+0xc0, 0x80, 0xa4, 0x40, 0xe8, 0x38, 0x3b, 0xd3, 0x82, 0x40, 0x50, 0xc0,
+0xc0, 0x81, 0x38, 0x07, 0x50, 0xc0, 0xc0, 0x81, 0x38, 0x05, 0x18, 0x24,
+0x23, 0x78, 0x83, 0x90, 0xa8, 0xd3, 0x82, 0xc0, 0xc0, 0xc0, 0x80, 0xa4,
+0x40, 0xc8, 0x38, 0x33, 0xc0, 0xc0, 0x80, 0xa4, 0x40, 0xb8, 0x38, 0x2f,
+0xd3, 0x82, 0x40, 0x50, 0xc0, 0xc0, 0x81, 0x38, 0x01, 0x50, 0xc0, 0xc0,
+0x81, 0x37, 0xff, 0x94, 0x50, 0x92, 0xf8, 0x99, 0x84, 0x1f, 0x48, 0x90,
+0x78, 0x90, 0x50, 0x10, 0x10, 0x80, 0xa4, 0x35, 0x90, 0x36, 0xb7, 0x82,
+0x36, 0xad, 0x90, 0x80, 0x10, 0x10, 0x90, 0x38, 0xa4, 0x37, 0x90, 0x36,
+0xf8, 0xa4, 0x37, 0x38, 0x36, 0xec, 0x80, 0x90, 0x38, 0xa4, 0x36, 0x10,
+0x36, 0xcd, 0xa4, 0x35, 0xe8, 0x36, 0xc8, 0x83, 0x90, 0xe8, 0xd3, 0x83,
+0xc0, 0xc0, 0xc0, 0x80, 0xa4, 0x41, 0x68, 0x8c, 0x42, 0xd8, 0x84, 0x38,
+0x63, 0xc0, 0xc0, 0x80, 0xa4, 0x41, 0x50, 0x8c, 0x42, 0xa8, 0x84, 0x38,
+0x60, 0xd3, 0x82, 0x40, 0x50, 0xc0, 0xc0, 0x81, 0x38, 0x15, 0x50, 0xc0,
+0xc0, 0x81, 0x38, 0x12, 0x18, 0x24, 0x1f, 0x40, 0x83, 0x90, 0xa8, 0xd3,
+0x82, 0xc0, 0xc0, 0xc0, 0x80, 0xa4, 0x41, 0x38, 0x38, 0x4f, 0xc0, 0xc0,
+0x80, 0xa4, 0x41, 0x20, 0x38, 0x49, 0xd3, 0x82, 0x40, 0x50, 0xc0, 0xc0,
+0x81, 0x38, 0x0f, 0x50, 0xc0, 0xc0, 0x81, 0x38, 0x0c, 0x92, 0xb8, 0x99,
+0x84, 0x1f, 0x38, 0x90, 0x78, 0x90, 0x50, 0x10, 0x10, 0x80, 0xa4, 0x35,
+0x88, 0x36, 0xb6, 0x82, 0x36, 0xac, 0x90, 0x80, 0x10, 0x10, 0x90, 0x38,
+0xa4, 0x37, 0x88, 0x36, 0xf7, 0xa4, 0x37, 0x30, 0x36, 0xeb, 0x80, 0x90,
+0x38, 0xa4, 0x36, 0x08, 0x36, 0xcc, 0xa4, 0x35, 0xe0, 0x36, 0xc7, 0x83,
+0x90, 0xa8, 0xd3, 0x82, 0xc0, 0xc0, 0xc0, 0x80, 0xa4, 0x41, 0x08, 0x38,
+0x43, 0xc0, 0xc0, 0x80, 0xa4, 0x40, 0xf0, 0x38, 0x3d, 0xd3, 0x82, 0x40,
+0x50, 0xc0, 0xc0, 0x81, 0x38, 0x09, 0x50, 0xc0, 0xc0, 0x81, 0x38, 0x06,
+0x18, 0x20, 0x01, 0x48, 0x83, 0x90, 0xa8, 0xd3, 0x82, 0xc0, 0xc0, 0xc0,
+0x80, 0xa4, 0x40, 0xd8, 0x38, 0x37, 0xc0, 0xc0, 0x80, 0xa4, 0x40, 0xc0,
+0x38, 0x31, 0xd3, 0x82, 0x40, 0x50, 0xc0, 0xc0, 0x81, 0x38, 0x03, 0x50,
+0xc0, 0xc0, 0x81, 0x38, 0x00, 0xda, 0x06, 0xe0, 0xf9, 0x80, 0x90, 0x60,
+0x90, 0x38, 0xa4, 0x23, 0xe8, 0x34, 0x7b, 0x80, 0x34, 0x78, 0x90, 0x38,
+0xa4, 0x23, 0x90, 0x34, 0x76, 0x80, 0x34, 0x73, 0x90, 0x60, 0x90, 0x38,
+0xa4, 0x23, 0xd0, 0x34, 0x7c, 0x80, 0x34, 0x79, 0x90, 0x38, 0xa4, 0x23,
+0xa8, 0x34, 0x77, 0x80, 0x34, 0x74, 0xc8, 0x40, 0x19, 0x00, 0x91, 0x58,
+0x90, 0x60, 0x82, 0x90, 0x20, 0x36, 0xab, 0xa4, 0x35, 0x48, 0x36, 0xaa,
+0x90, 0xc0, 0x80, 0x90, 0x90, 0x90, 0x48, 0xc9, 0xe1, 0xb9, 0x00, 0x85,
+0x36, 0xe3, 0xc9, 0xe1, 0xb8, 0x40, 0x85, 0x36, 0xe0, 0x80, 0x36, 0xdf,
+0x10, 0x10, 0x81, 0x36, 0xbb, 0x90, 0xa8, 0x10, 0x10, 0x90, 0x28, 0x81,
+0x36, 0xd9, 0x90, 0x38, 0xa4, 0x36, 0xa0, 0x36, 0xd5, 0xa4, 0x36, 0x90,
+0x36, 0xd3, 0x90, 0x70, 0x10, 0x10, 0x90, 0x38, 0xa4, 0x36, 0xb8, 0x36,
+0xd8, 0x80, 0x36, 0xd6, 0x90, 0x60, 0x90, 0x28, 0x24, 0x36, 0xf0, 0xa4,
+0x36, 0xe0, 0x36, 0xdd, 0x80, 0xa4, 0x36, 0xd0, 0x36, 0xdb, 0x80, 0x90,
+0xf8, 0x90, 0x90, 0x90, 0x50, 0x90, 0x28, 0x80, 0x37, 0xf7, 0x80, 0x37,
+0xfe, 0x80, 0xa4, 0x3f, 0xe0, 0x37, 0xfd, 0x90, 0x28, 0x81, 0x37, 0xfb,
+0x80, 0xa4, 0x3f, 0xc8, 0x37, 0xfa, 0x83, 0x37, 0xf8, 0x98, 0xe8, 0x01,
+0xb0, 0x90, 0x88, 0x90, 0x60, 0xa4, 0x35, 0x38, 0x10, 0x10, 0x10, 0x10,
+0x83, 0x33, 0xb7, 0x24, 0x35, 0x30, 0x90, 0x28, 0x24, 0x35, 0x28, 0x24,
+0x35, 0x20, 0x90, 0x88, 0x90, 0x60, 0xa4, 0x35, 0x10, 0x10, 0x10, 0x10,
+0x10, 0x83, 0x33, 0xb6, 0x24, 0x35, 0x08, 0x90, 0x28, 0x24, 0x35, 0x00,
+0x24, 0x34, 0xf8, 0xa8, 0x09, 0x00, 0x0e, 0x20, 0x96, 0x48, 0x95, 0xe8,
+0x93, 0x38, 0x91, 0xa0, 0x90, 0xd0, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x1e,
+0x60, 0x33, 0xcd, 0xa4, 0x1e, 0x50, 0x33, 0xcb, 0x90, 0x38, 0xa4, 0x1e,
+0x40, 0x33, 0xc9, 0x80, 0x33, 0xc7, 0x90, 0x60, 0x90, 0x28, 0x24, 0x1e,
+0x00, 0xa4, 0x1d, 0xf0, 0x33, 0xbf, 0x90, 0x38, 0xa4, 0x1d, 0xe0, 0x33,
+0xbd, 0xa4, 0x1e, 0x28, 0x33, 0xc6, 0x90, 0xe0, 0x90, 0x70, 0x90, 0x38,
+0xa4, 0x1e, 0x18, 0x33, 0xc4, 0xa4, 0x1e, 0x08, 0x33, 0xc2, 0x90, 0x38,
+0xa4, 0x34, 0xb0, 0x36, 0x9c, 0xa4, 0x34, 0x50, 0x36, 0x90, 0x90, 0x70,
+0x90, 0x38, 0xa4, 0x31, 0x90, 0x36, 0x3e, 0xa4, 0x31, 0x60, 0x36, 0x38,
+0x10, 0x10, 0xa4, 0x1d, 0xd0, 0x33, 0xbb, 0x99, 0x60, 0x02, 0x70, 0x90,
+0x90, 0x90, 0x50, 0x90, 0x28, 0x24, 0x1e, 0x90, 0x80, 0x33, 0xda, 0x80,
+0xa4, 0x1e, 0x98, 0x33, 0xd8, 0x90, 0x50, 0x90, 0x28, 0x24, 0x1e, 0xa0,
+0x80, 0x33, 0xdb, 0x90, 0x38, 0xa4, 0x1e, 0xa8, 0x33, 0xd9, 0xa4, 0x1e,
+0x70, 0x33, 0xcf, 0x90, 0xe0, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x33, 0xe8,
+0x36, 0x85, 0xa4, 0x33, 0x48, 0x36, 0x72, 0x90, 0x38, 0xa4, 0x32, 0xe0,
+0x36, 0x63, 0xa4, 0x32, 0x50, 0x36, 0x52, 0x81, 0xa4, 0x1e, 0x80, 0x33,
+0xd1, 0xe4, 0xa1, 0xfc, 0x40, 0x37, 0xf3, 0x18, 0x24, 0x1d, 0xc8, 0xe4,
+0xe1, 0xfa, 0xc0, 0x37, 0xed, 0x92, 0x40, 0x91, 0x08, 0x10, 0x10, 0x90,
+0x80, 0x10, 0x10, 0x90, 0x38, 0xa4, 0x34, 0xa8, 0x36, 0x9b, 0xa4, 0x34,
+0x48, 0x36, 0x8f, 0x80, 0x90, 0x38, 0xa4, 0x31, 0x88, 0x36, 0x3d, 0xa4,
+0x31, 0x58, 0x36, 0x37, 0x18, 0x20, 0x00, 0xf8, 0x80, 0x90, 0x70, 0x90,
+0x38, 0xa4, 0x33, 0xd8, 0x36, 0x84, 0xa4, 0x33, 0x40, 0x36, 0x70, 0x90,
+0x38, 0xa4, 0x32, 0xd0, 0x36, 0x62, 0xa4, 0x32, 0x48, 0x36, 0x50, 0xe4,
+0xa1, 0xf9, 0x40, 0x37, 0xe7, 0x18, 0x24, 0x1d, 0xc0, 0xe4, 0xe1, 0xf7,
+0xc0, 0x37, 0xe1, 0x92, 0x90, 0x92, 0x40, 0x91, 0x08, 0x10, 0x10, 0x90,
+0x80, 0x10, 0x10, 0x90, 0x38, 0xa4, 0x34, 0xa0, 0x36, 0x9a, 0xa4, 0x34,
+0x40, 0x36, 0x8e, 0x80, 0x90, 0x38, 0xa4, 0x31, 0x80, 0x36, 0x3c, 0xa4,
+0x31, 0x50, 0x36, 0x36, 0x18, 0x20, 0x00, 0xf8, 0x80, 0x90, 0x70, 0x90,
+0x38, 0xa4, 0x33, 0xc8, 0x36, 0x83, 0xa4, 0x33, 0x38, 0x36, 0x6e, 0x90,
+0x38, 0xa4, 0x32, 0xc0, 0x36, 0x61, 0xa4, 0x32, 0x40, 0x36, 0x4e, 0xe4,
+0xa1, 0xfc, 0x80, 0x37, 0xf5, 0x10, 0x10, 0xe4, 0xe1, 0xfb, 0x00, 0x37,
+0xef, 0x92, 0x50, 0x99, 0x1c, 0x1e, 0xb0, 0x10, 0x10, 0x90, 0x80, 0x10,
+0x10, 0x90, 0x38, 0xa4, 0x34, 0x98, 0x36, 0x99, 0xa4, 0x34, 0x38, 0x36,
+0x8d, 0x80, 0x90, 0x38, 0xa4, 0x31, 0x78, 0x36, 0x3b, 0xa4, 0x31, 0x48,
+0x36, 0x35, 0x18, 0x20, 0x00, 0xf8, 0x80, 0x90, 0x70, 0x90, 0x38, 0xa4,
+0x33, 0xb8, 0x36, 0x82, 0xa4, 0x33, 0x30, 0x36, 0x6c, 0x90, 0x38, 0xa4,
+0x32, 0xb0, 0x36, 0x60, 0xa4, 0x32, 0x38, 0x36, 0x4c, 0xe4, 0xa1, 0xf9,
+0x80, 0x37, 0xe9, 0x10, 0x10, 0xe4, 0xe1, 0xf8, 0x00, 0x37, 0xe3, 0xc0,
+0x40, 0x80, 0x10, 0x10, 0x81, 0x90, 0x90, 0x90, 0x48, 0xc9, 0xe1, 0x90,
+0x80, 0x85, 0x36, 0x46, 0xc9, 0xe1, 0x91, 0x00, 0x85, 0x36, 0x43, 0x80,
+0x36, 0x41, 0x80, 0xd8, 0x47, 0x80, 0x0d, 0xc0, 0xc0, 0x80, 0x10, 0x10,
+0x82, 0x90, 0x58, 0xd5, 0x81, 0x80, 0x80, 0x37, 0xdd, 0x80, 0x37, 0xdb,
+0xd5, 0x81, 0x80, 0x80, 0x37, 0xd9, 0x80, 0x37, 0xd7, 0xc0, 0x80, 0x10,
+0x10, 0x82, 0x90, 0x58, 0xd5, 0x81, 0x80, 0x80, 0x37, 0xde, 0x80, 0x37,
+0xdc, 0xd5, 0x81, 0x80, 0x80, 0x37, 0xda, 0x80, 0x37, 0xd8, 0xc0, 0x80,
+0x83, 0xa4, 0x3e, 0xa8, 0x37, 0xd6, 0xa0, 0x57, 0xc0, 0xa0, 0x41, 0xe0,
+0xa8, 0x1e, 0xb0, 0x34, 0x88, 0xa0, 0x12, 0x38, 0xa0, 0x0b, 0x48, 0x96,
+0x00, 0x9a, 0xf0, 0x05, 0xc0, 0x91, 0x70, 0x90, 0xb8, 0x90, 0x70, 0x90,
+0x38, 0xa4, 0x15, 0x58, 0x33, 0xb5, 0xa4, 0x15, 0x78, 0x33, 0xb4, 0x10,
+0x10, 0xa4, 0x15, 0x68, 0x33, 0xb3, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x14,
+0xf8, 0x33, 0x9a, 0xa4, 0x15, 0x18, 0x33, 0x99, 0x10, 0x10, 0xa4, 0x15,
+0x08, 0x33, 0x98, 0x90, 0xb8, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x14, 0x98,
+0x33, 0x7f, 0xa4, 0x14, 0xb8, 0x33, 0x7e, 0x10, 0x10, 0xa4, 0x14, 0xa8,
+0x33, 0x7d, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x14, 0x38, 0x33, 0x63, 0xa4,
+0x14, 0x58, 0x33, 0x62, 0x10, 0x10, 0xa4, 0x14, 0x48, 0x33, 0x61, 0x91,
+0x70, 0x90, 0xb8, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x15, 0x28, 0x33, 0xb0,
+0xa4, 0x15, 0x48, 0x33, 0xb2, 0x10, 0x10, 0xa4, 0x15, 0x38, 0x33, 0xb1,
+0x90, 0x70, 0x90, 0x38, 0xa4, 0x14, 0xc8, 0x33, 0x95, 0xa4, 0x14, 0xe8,
+0x33, 0x97, 0x10, 0x10, 0xa4, 0x14, 0xd8, 0x33, 0x96, 0x90, 0xb8, 0x90,
+0x70, 0x90, 0x38, 0xa4, 0x14, 0x68, 0x33, 0x7a, 0xa4, 0x14, 0x88, 0x33,
+0x7c, 0x10, 0x10, 0xa4, 0x14, 0x78, 0x33, 0x7b, 0x90, 0x70, 0x90, 0x38,
+0xa4, 0x14, 0x08, 0x33, 0x5e, 0xa4, 0x14, 0x28, 0x33, 0x60, 0x10, 0x10,
+0xa4, 0x14, 0x18, 0x33, 0x5f, 0xe4, 0xe1, 0x83, 0x40, 0x36, 0x21, 0x9a,
+0xf0, 0x05, 0x00, 0x91, 0x70, 0x90, 0xb8, 0x90, 0x70, 0x90, 0x38, 0xa4,
+0x13, 0xa0, 0x33, 0xad, 0xa4, 0x13, 0x98, 0x33, 0xaf, 0x10, 0x10, 0xa4,
+0x13, 0x90, 0x33, 0xae, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x13, 0x88, 0x33,
+0x92, 0xa4, 0x13, 0x80, 0x33, 0x94, 0x10, 0x10, 0xa4, 0x13, 0x78, 0x33,
+0x93, 0x90, 0xb8, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x13, 0x70, 0x33, 0x77,
+0xa4, 0x13, 0x68, 0x33, 0x79, 0x10, 0x10, 0xa4, 0x13, 0x60, 0x33, 0x78,
+0x90, 0x70, 0x90, 0x38, 0xa4, 0x13, 0x58, 0x33, 0x5b, 0xa4, 0x13, 0x50,
+0x33, 0x5d, 0x10, 0x10, 0xa4, 0x13, 0x48, 0x33, 0x5c, 0x91, 0x10, 0x90,
+0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0xaa, 0x80, 0x33, 0xac, 0x10,
+0x10, 0x80, 0x33, 0xab, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0x8f, 0x80,
+0x33, 0x91, 0x10, 0x10, 0x80, 0x33, 0x90, 0x90, 0x88, 0x90, 0x50, 0x90,
+0x28, 0x80, 0x33, 0x74, 0x80, 0x33, 0x76, 0x10, 0x10, 0x80, 0x33, 0x75,
+0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0x58, 0x80, 0x33, 0x5a, 0x10, 0x10,
+0x80, 0x33, 0x59, 0xe4, 0xe1, 0x5e, 0x40, 0x35, 0xa1, 0x95, 0x40, 0x9a,
+0x90, 0x05, 0x00, 0x91, 0x10, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80,
+0x33, 0xa7, 0x80, 0x33, 0xa9, 0x10, 0x10, 0x80, 0x33, 0xa8, 0x90, 0x50,
+0x90, 0x28, 0x80, 0x33, 0x8c, 0x80, 0x33, 0x8e, 0x10, 0x10, 0x80, 0x33,
+0x8d, 0x90, 0xb8, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x13, 0x30, 0x33, 0x71,
+0xa4, 0x13, 0x40, 0x33, 0x73, 0x10, 0x10, 0xa4, 0x13, 0x38, 0x33, 0x72,
+0x90, 0x70, 0x90, 0x38, 0xa4, 0x13, 0x00, 0x33, 0x55, 0xa4, 0x13, 0x10,
+0x33, 0x57, 0x10, 0x10, 0xa4, 0x13, 0x08, 0x33, 0x56, 0x91, 0x10, 0x90,
+0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0xa4, 0x80, 0x33, 0xa6, 0x10,
+0x10, 0x80, 0x33, 0xa5, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0x89, 0x80,
+0x33, 0x8b, 0x10, 0x10, 0x80, 0x33, 0x8a, 0x90, 0xb8, 0x90, 0x70, 0x90,
+0x38, 0xa4, 0x13, 0x18, 0x33, 0x6e, 0xa4, 0x13, 0x28, 0x33, 0x70, 0x10,
+0x10, 0xa4, 0x13, 0x20, 0x33, 0x6f, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x12,
+0xe8, 0x33, 0x52, 0xa4, 0x12, 0xf8, 0x33, 0x54, 0x10, 0x10, 0xa4, 0x12,
+0xf0, 0x33, 0x53, 0xe4, 0xe1, 0x82, 0x40, 0x36, 0x1d, 0x98, 0xb8, 0x01,
+0x68, 0x10, 0x10, 0x10, 0x10, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0x4f,
+0x80, 0x33, 0x51, 0x10, 0x10, 0x80, 0x33, 0x50, 0x90, 0x60, 0x90, 0x30,
+0x60, 0xa0, 0x97, 0x00, 0x60, 0xa0, 0x96, 0xc0, 0x90, 0x30, 0x60, 0xa0,
+0x96, 0x80, 0x60, 0xa0, 0x96, 0x40, 0xe4, 0xe1, 0x5c, 0x40, 0x35, 0x99,
+0xa0, 0x08, 0x08, 0x94, 0xe0, 0x9a, 0x60, 0x04, 0xa0, 0x91, 0x40, 0x90,
+0xb8, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x13, 0xd8, 0x33, 0x9e, 0xa4, 0x13,
+0xf8, 0x33, 0xa3, 0x10, 0x10, 0xa4, 0x13, 0xe8, 0x33, 0xa2, 0x90, 0x50,
+0x90, 0x28, 0x80, 0x33, 0x83, 0x80, 0x33, 0x88, 0x10, 0x10, 0x80, 0x33,
+0x87, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0x68, 0x80, 0x33,
+0x6d, 0x10, 0x10, 0x80, 0x33, 0x6c, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33,
+0x49, 0x80, 0x33, 0x4e, 0x10, 0x10, 0x80, 0x33, 0x4d, 0x91, 0x40, 0x90,
+0xb8, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x13, 0xa8, 0x33, 0x9b, 0xa4, 0x13,
+0xc8, 0x33, 0x9d, 0x10, 0x10, 0xa4, 0x13, 0xb8, 0x33, 0x9c, 0x90, 0x50,
+0x90, 0x28, 0x80, 0x33, 0x80, 0x80, 0x33, 0x82, 0x10, 0x10, 0x80, 0x33,
+0x81, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0x65, 0x80, 0x33,
+0x67, 0x10, 0x10, 0x80, 0x33, 0x66, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33,
+0x46, 0x80, 0x33, 0x48, 0x10, 0x10, 0x80, 0x33, 0x47, 0xe4, 0xe1, 0x81,
+0x40, 0x36, 0x19, 0x9a, 0x60, 0x02, 0xe0, 0x91, 0x40, 0x90, 0xb8, 0x90,
+0x70, 0x90, 0x38, 0xa4, 0x1a, 0x20, 0x33, 0x9f, 0xa4, 0x1a, 0x10, 0x33,
+0xa1, 0x10, 0x10, 0xa4, 0x1a, 0x00, 0x33, 0xa0, 0x90, 0x50, 0x90, 0x28,
+0x80, 0x33, 0x84, 0x80, 0x33, 0x86, 0x10, 0x10, 0x80, 0x33, 0x85, 0x90,
+0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0x69, 0x80, 0x33, 0x6b, 0x10,
+0x10, 0x80, 0x33, 0x6a, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0x4a, 0x80,
+0x33, 0x4c, 0x10, 0x10, 0x80, 0x33, 0x4b, 0x81, 0x90, 0x50, 0x90, 0x28,
+0x24, 0x19, 0xd0, 0x24, 0x19, 0xf0, 0x10, 0x10, 0x24, 0x19, 0xe0, 0xe4,
+0xe1, 0x5a, 0x40, 0x35, 0x91, 0x93, 0x90, 0x99, 0xb8, 0x03, 0x50, 0x90,
+0xe8, 0x90, 0x88, 0x90, 0x40, 0x80, 0xa4, 0x15, 0xb8, 0x32, 0xca, 0x10,
+0x10, 0xa4, 0x15, 0xa8, 0x32, 0xc9, 0x90, 0x28, 0x81, 0x32, 0xc6, 0x10,
+0x10, 0x80, 0x32, 0xc5, 0x90, 0x60, 0x90, 0x28, 0x81, 0x32, 0xc2, 0x10,
+0x10, 0x80, 0x32, 0xc1, 0x90, 0x28, 0x81, 0x32, 0xbe, 0x10, 0x10, 0x80,
+0x32, 0xbd, 0x90, 0xe8, 0x90, 0x88, 0x90, 0x40, 0x80, 0xa4, 0x15, 0x88,
+0x32, 0xc7, 0x10, 0x10, 0xa4, 0x15, 0x98, 0x32, 0xc8, 0x90, 0x28, 0x81,
+0x32, 0xc3, 0x10, 0x10, 0x80, 0x32, 0xc4, 0x90, 0x60, 0x90, 0x28, 0x81,
+0x32, 0xbf, 0x10, 0x10, 0x80, 0x32, 0xc0, 0x90, 0x28, 0x81, 0x32, 0xbb,
+0x10, 0x10, 0x80, 0x32, 0xbc, 0xe4, 0xe1, 0x80, 0x40, 0x36, 0x15, 0x88,
+0x00, 0x88, 0x10, 0x10, 0x10, 0x10, 0x90, 0x28, 0x81, 0x32, 0xb9, 0x10,
+0x10, 0x80, 0x32, 0xba, 0xe4, 0xe1, 0x58, 0x40, 0x35, 0x89, 0xa0, 0x0e,
+0x80, 0xa0, 0x09, 0x08, 0x94, 0x80, 0x9a, 0x30, 0x04, 0x40, 0x91, 0x10,
+0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0x39, 0x80, 0x33, 0x38,
+0x10, 0x10, 0x80, 0x33, 0x37, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0x1e,
+0x80, 0x33, 0x1d, 0x10, 0x10, 0x80, 0x33, 0x1c, 0x90, 0x88, 0x90, 0x50,
+0x90, 0x28, 0x80, 0x33, 0x03, 0x80, 0x33, 0x02, 0x10, 0x10, 0x80, 0x33,
+0x01, 0x90, 0x50, 0x90, 0x28, 0x80, 0x32, 0xe8, 0x80, 0x32, 0xe7, 0x10,
+0x10, 0x80, 0x32, 0xe6, 0x91, 0x10, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28,
+0x80, 0x33, 0x34, 0x80, 0x33, 0x36, 0x10, 0x10, 0x80, 0x33, 0x35, 0x90,
+0x50, 0x90, 0x28, 0x80, 0x33, 0x19, 0x80, 0x33, 0x1b, 0x10, 0x10, 0x80,
+0x33, 0x1a, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x32, 0xfe, 0x80,
+0x33, 0x00, 0x10, 0x10, 0x80, 0x32, 0xff, 0x90, 0x50, 0x90, 0x28, 0x80,
+0x32, 0xe3, 0x80, 0x32, 0xe5, 0x10, 0x10, 0x80, 0x32, 0xe4, 0xe4, 0xe1,
+0x72, 0x40, 0x35, 0xf1, 0x9a, 0x30, 0x04, 0x40, 0x91, 0x10, 0x90, 0x88,
+0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0x31, 0x80, 0x33, 0x33, 0x10, 0x10,
+0x80, 0x33, 0x32, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0x16, 0x80, 0x33,
+0x18, 0x10, 0x10, 0x80, 0x33, 0x17, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28,
+0x80, 0x32, 0xfb, 0x80, 0x32, 0xfd, 0x10, 0x10, 0x80, 0x32, 0xfc, 0x90,
+0x50, 0x90, 0x28, 0x80, 0x32, 0xe0, 0x80, 0x32, 0xe2, 0x10, 0x10, 0x80,
+0x32, 0xe1, 0x91, 0x10, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33,
+0x2e, 0x80, 0x33, 0x30, 0x10, 0x10, 0x80, 0x33, 0x2f, 0x90, 0x50, 0x90,
+0x28, 0x80, 0x33, 0x13, 0x80, 0x33, 0x15, 0x10, 0x10, 0x80, 0x33, 0x14,
+0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x32, 0xf8, 0x80, 0x32, 0xfa,
+0x10, 0x10, 0x80, 0x32, 0xf9, 0x90, 0x50, 0x90, 0x28, 0x80, 0x32, 0xdd,
+0x80, 0x32, 0xdf, 0x10, 0x10, 0x80, 0x32, 0xde, 0xe4, 0xe1, 0x51, 0x40,
+0x35, 0x59, 0x94, 0x80, 0x9a, 0x30, 0x04, 0x40, 0x91, 0x10, 0x90, 0x88,
+0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0x2b, 0x80, 0x33, 0x2d, 0x10, 0x10,
+0x80, 0x33, 0x2c, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0x10, 0x80, 0x33,
+0x12, 0x10, 0x10, 0x80, 0x33, 0x11, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28,
+0x80, 0x32, 0xf5, 0x80, 0x32, 0xf7, 0x10, 0x10, 0x80, 0x32, 0xf6, 0x90,
+0x50, 0x90, 0x28, 0x80, 0x32, 0xda, 0x80, 0x32, 0xdc, 0x10, 0x10, 0x80,
+0x32, 0xdb, 0x91, 0x10, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33,
+0x28, 0x80, 0x33, 0x2a, 0x10, 0x10, 0x80, 0x33, 0x29, 0x90, 0x50, 0x90,
+0x28, 0x80, 0x33, 0x0d, 0x80, 0x33, 0x0f, 0x10, 0x10, 0x80, 0x33, 0x0e,
+0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x32, 0xf2, 0x80, 0x32, 0xf4,
+0x10, 0x10, 0x80, 0x32, 0xf3, 0x90, 0x50, 0x90, 0x28, 0x80, 0x32, 0xd7,
+0x80, 0x32, 0xd9, 0x10, 0x10, 0x80, 0x32, 0xd8, 0xe4, 0xe1, 0x70, 0x40,
+0x35, 0xe9, 0x88, 0x00, 0xb0, 0x10, 0x10, 0x10, 0x10, 0x90, 0x50, 0x90,
+0x28, 0x80, 0x32, 0xd4, 0x80, 0x32, 0xd6, 0x10, 0x10, 0x80, 0x32, 0xd5,
+0xe4, 0xe1, 0x50, 0x40, 0x35, 0x55, 0x96, 0xe8, 0x94, 0x80, 0x9a, 0x30,
+0x04, 0x40, 0x91, 0x10, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33,
+0x22, 0x80, 0x33, 0x27, 0x10, 0x10, 0x80, 0x33, 0x26, 0x90, 0x50, 0x90,
+0x28, 0x80, 0x33, 0x07, 0x80, 0x33, 0x0c, 0x10, 0x10, 0x80, 0x33, 0x0b,
+0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x32, 0xec, 0x80, 0x32, 0xf1,
+0x10, 0x10, 0x80, 0x32, 0xf0, 0x90, 0x50, 0x90, 0x28, 0x80, 0x32, 0xce,
+0x80, 0x32, 0xd3, 0x10, 0x10, 0x80, 0x32, 0xd2, 0x91, 0x10, 0x90, 0x88,
+0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0x1f, 0x80, 0x33, 0x21, 0x10, 0x10,
+0x80, 0x33, 0x20, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0x04, 0x80, 0x33,
+0x06, 0x10, 0x10, 0x80, 0x33, 0x05, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28,
+0x80, 0x32, 0xe9, 0x80, 0x32, 0xeb, 0x10, 0x10, 0x80, 0x32, 0xea, 0x90,
+0x50, 0x90, 0x28, 0x80, 0x32, 0xcb, 0x80, 0x32, 0xcd, 0x10, 0x10, 0x80,
+0x32, 0xcc, 0xe4, 0xe1, 0x6e, 0x40, 0x35, 0xe1, 0x88, 0x02, 0x28, 0x91,
+0x10, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0x23, 0x80, 0x33,
+0x25, 0x10, 0x10, 0x80, 0x33, 0x24, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33,
+0x08, 0x80, 0x33, 0x0a, 0x10, 0x10, 0x80, 0x33, 0x09, 0x90, 0x88, 0x90,
+0x50, 0x90, 0x28, 0x80, 0x32, 0xed, 0x80, 0x32, 0xef, 0x10, 0x10, 0x80,
+0x32, 0xee, 0x90, 0x50, 0x90, 0x28, 0x80, 0x32, 0xcf, 0x80, 0x32, 0xd1,
+0x10, 0x10, 0x80, 0x32, 0xd0, 0xe4, 0xe1, 0x4f, 0x40, 0x35, 0x51, 0x90,
+0x40, 0xe5, 0x21, 0x6c, 0x40, 0x35, 0xd9, 0xe5, 0x21, 0x4e, 0x40, 0x35,
+0x4d, 0x9e, 0xb4, 0x22, 0xe8, 0x93, 0x70, 0x91, 0xd8, 0xd5, 0x07, 0x80,
+0xd0, 0xc4, 0x40, 0x90, 0x48, 0x80, 0x8c, 0x3e, 0x38, 0x84, 0x37, 0xd1,
+0xa4, 0x3c, 0x18, 0x37, 0x9b, 0x90, 0x28, 0x24, 0x3b, 0x58, 0xa4, 0x39,
+0xd8, 0x37, 0x53, 0xd0, 0xc4, 0x40, 0x90, 0x48, 0x80, 0x8c, 0x3e, 0x18,
+0x84, 0x37, 0xcf, 0xa4, 0x3c, 0x08, 0x37, 0x99, 0x90, 0x28, 0x24, 0x3b,
+0x48, 0xa4, 0x39, 0xc8, 0x37, 0x51, 0xd5, 0x06, 0x80, 0xd0, 0xc3, 0x40,
+0x90, 0x28, 0x80, 0x37, 0xbb, 0xa4, 0x3b, 0xe8, 0x37, 0x95, 0x90, 0x28,
+0x24, 0x3b, 0x28, 0xa4, 0x39, 0xa8, 0x37, 0x4d, 0xd0, 0xc3, 0x40, 0x90,
+0x28, 0x80, 0x37, 0xb7, 0xa4, 0x3b, 0xd8, 0x37, 0x93, 0x90, 0x28, 0x24,
+0x3b, 0x18, 0xa4, 0x39, 0x98, 0x37, 0x4b, 0x91, 0x98, 0xd5, 0x06, 0x80,
+0xd0, 0xc3, 0x40, 0x90, 0x28, 0x80, 0x37, 0xaf, 0xa4, 0x3b, 0xb8, 0x37,
+0x8f, 0x90, 0x28, 0x24, 0x3a, 0xf8, 0xa4, 0x39, 0x78, 0x37, 0x47, 0xd0,
+0xc3, 0x40, 0x90, 0x28, 0x80, 0x37, 0xab, 0xa4, 0x3b, 0xa8, 0x37, 0x8d,
+0x90, 0x28, 0x24, 0x3a, 0xe8, 0xa4, 0x39, 0x68, 0x37, 0x45, 0xd5, 0x06,
+0x80, 0xd0, 0xc3, 0x40, 0x90, 0x28, 0x80, 0x37, 0xa3, 0xa4, 0x3b, 0x88,
+0x37, 0x89, 0x90, 0x28, 0x24, 0x3a, 0xc8, 0xa4, 0x39, 0x48, 0x37, 0x41,
+0xd0, 0xc3, 0x40, 0x90, 0x28, 0x80, 0x37, 0x9f, 0xa4, 0x3b, 0x78, 0x37,
+0x87, 0x90, 0x28, 0x24, 0x3a, 0xb8, 0xa4, 0x39, 0x38, 0x37, 0x3f, 0x93,
+0x70, 0x91, 0xd8, 0xd5, 0x07, 0x80, 0xd0, 0xc4, 0x40, 0x90, 0x48, 0x80,
+0x8c, 0x3e, 0x58, 0x84, 0x37, 0xd3, 0xa4, 0x3c, 0x28, 0x37, 0x9d, 0x90,
+0x28, 0x24, 0x3b, 0x68, 0xa4, 0x39, 0xe8, 0x37, 0x55, 0xd0, 0xc4, 0x40,
+0x90, 0x48, 0x80, 0x8c, 0x3e, 0x28, 0x84, 0x37, 0xd0, 0xa4, 0x3c, 0x10,
+0x37, 0x9a, 0x90, 0x28, 0x24, 0x3b, 0x50, 0xa4, 0x39, 0xd0, 0x37, 0x52,
+0xd5, 0x06, 0x80, 0xd0, 0xc3, 0x40, 0x90, 0x28, 0x80, 0x37, 0xbf, 0xa4,
+0x3b, 0xf8, 0x37, 0x97, 0x90, 0x28, 0x24, 0x3b, 0x38, 0xa4, 0x39, 0xb8,
+0x37, 0x4f, 0xd0, 0xc3, 0x40, 0x90, 0x28, 0x80, 0x37, 0xb9, 0xa4, 0x3b,
+0xe0, 0x37, 0x94, 0x90, 0x28, 0x24, 0x3b, 0x20, 0xa4, 0x39, 0xa0, 0x37,
+0x4c, 0x91, 0x98, 0xd5, 0x06, 0x80, 0xd0, 0xc3, 0x40, 0x90, 0x28, 0x80,
+0x37, 0xb3, 0xa4, 0x3b, 0xc8, 0x37, 0x91, 0x90, 0x28, 0x24, 0x3b, 0x08,
+0xa4, 0x39, 0x88, 0x37, 0x49, 0xd0, 0xc3, 0x40, 0x90, 0x28, 0x80, 0x37,
+0xad, 0xa4, 0x3b, 0xb0, 0x37, 0x8e, 0x90, 0x28, 0x24, 0x3a, 0xf0, 0xa4,
+0x39, 0x70, 0x37, 0x46, 0xd5, 0x06, 0x80, 0xd0, 0xc3, 0x40, 0x90, 0x28,
+0x80, 0x37, 0xa7, 0xa4, 0x3b, 0x98, 0x37, 0x8b, 0x90, 0x28, 0x24, 0x3a,
+0xd8, 0xa4, 0x39, 0x58, 0x37, 0x43, 0xd0, 0xc3, 0x40, 0x90, 0x28, 0x80,
+0x37, 0xa1, 0xa4, 0x3b, 0x80, 0x37, 0x88, 0x90, 0x28, 0x24, 0x3a, 0xc0,
+0xa4, 0x39, 0x40, 0x37, 0x40, 0x99, 0x08, 0x01, 0xf0, 0x81, 0x90, 0x78,
+0xd4, 0xc2, 0x00, 0xa4, 0x22, 0x80, 0x34, 0x40, 0xa4, 0x21, 0x80, 0x34,
+0x20, 0xd4, 0xc2, 0x00, 0xa4, 0x21, 0xa0, 0x34, 0x44, 0xa4, 0x20, 0xa0,
+0x34, 0x24, 0x81, 0x90, 0x78, 0xd4, 0xc2, 0x00, 0xa4, 0x21, 0xe0, 0x34,
+0x4c, 0xa4, 0x20, 0xe0, 0x34, 0x2c, 0xd4, 0xc2, 0x00, 0xa4, 0x21, 0xc0,
+0x34, 0x48, 0xa4, 0x20, 0xc0, 0x34, 0x28, 0xa8, 0x0b, 0x18, 0x13, 0xa8,
+0x96, 0x80, 0x93, 0x40, 0x99, 0x90, 0x03, 0x00, 0x90, 0xc0, 0x90, 0x60,
+0x90, 0x38, 0xa4, 0x12, 0xb8, 0x32, 0x58, 0x24, 0x12, 0xb0, 0x90, 0x38,
+0xa4, 0x11, 0xe0, 0x32, 0x3d, 0x24, 0x11, 0xd8, 0x90, 0x60, 0x90, 0x38,
+0xa4, 0x11, 0x08, 0x32, 0x22, 0x24, 0x11, 0x00, 0x90, 0x38, 0xa4, 0x10,
+0x30, 0x32, 0x07, 0x24, 0x10, 0x28, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x38,
+0xa4, 0x12, 0xa8, 0x32, 0x53, 0x24, 0x12, 0xa0, 0x90, 0x38, 0xa4, 0x11,
+0xd0, 0x32, 0x38, 0x24, 0x11, 0xc8, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x10,
+0xf8, 0x32, 0x1d, 0x24, 0x10, 0xf0, 0x90, 0x38, 0xa4, 0x10, 0x20, 0x32,
+0x02, 0x24, 0x10, 0x18, 0xe4, 0xe1, 0xc8, 0x40, 0x37, 0x23, 0x99, 0x90,
+0x03, 0x00, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x12, 0x90, 0x32,
+0x50, 0x24, 0x12, 0x88, 0x90, 0x38, 0xa4, 0x11, 0xb8, 0x32, 0x35, 0x24,
+0x11, 0xb0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x10, 0xe0, 0x32, 0x1a, 0x24,
+0x10, 0xd8, 0x90, 0x38, 0xa4, 0x10, 0x08, 0x31, 0xff, 0x24, 0x10, 0x00,
+0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x12, 0x78, 0x32, 0x4d, 0x24,
+0x12, 0x70, 0x90, 0x38, 0xa4, 0x11, 0xa0, 0x32, 0x32, 0x24, 0x11, 0x98,
+0x90, 0x60, 0x90, 0x38, 0xa4, 0x10, 0xc8, 0x32, 0x17, 0x24, 0x10, 0xc0,
+0x90, 0x38, 0xa4, 0x0f, 0xf0, 0x31, 0xfc, 0x24, 0x0f, 0xe8, 0xe4, 0xe1,
+0xc6, 0xc0, 0x37, 0x1d, 0x93, 0x78, 0x99, 0x90, 0x03, 0x00, 0x90, 0xc0,
+0x90, 0x60, 0x90, 0x38, 0xa4, 0x12, 0x60, 0x32, 0x4a, 0x24, 0x12, 0x58,
+0x90, 0x38, 0xa4, 0x11, 0x88, 0x32, 0x2f, 0x24, 0x11, 0x80, 0x90, 0x60,
+0x90, 0x38, 0xa4, 0x10, 0xb0, 0x32, 0x14, 0x24, 0x10, 0xa8, 0x90, 0x38,
+0xa4, 0x0f, 0xd8, 0x31, 0xf9, 0x24, 0x0f, 0xd0, 0x90, 0xc0, 0x90, 0x60,
+0x90, 0x38, 0xa4, 0x12, 0x48, 0x32, 0x47, 0x24, 0x12, 0x40, 0x90, 0x38,
+0xa4, 0x11, 0x70, 0x32, 0x2c, 0x24, 0x11, 0x68, 0x90, 0x60, 0x90, 0x38,
+0xa4, 0x10, 0x98, 0x32, 0x11, 0x24, 0x10, 0x90, 0x90, 0x38, 0xa4, 0x0f,
+0xc0, 0x31, 0xf6, 0x24, 0x0f, 0xb8, 0xec, 0xa1, 0x16, 0x00, 0x02, 0x00,
+0x34, 0x5a, 0xa4, 0x38, 0xa8, 0x37, 0x17, 0x88, 0x00, 0x88, 0x10, 0x10,
+0x10, 0x10, 0x90, 0x38, 0xa4, 0x0f, 0xa8, 0x31, 0xf3, 0x24, 0x0f, 0xa0,
+0xe9, 0x61, 0x15, 0x40, 0x02, 0x00, 0x34, 0x56, 0xe3, 0x61, 0xc3, 0xc0,
+0x37, 0x11, 0x95, 0x08, 0x93, 0x40, 0x99, 0x90, 0x03, 0x00, 0x90, 0xc0,
+0x90, 0x60, 0x90, 0x38, 0xa4, 0x12, 0x30, 0x32, 0x41, 0x24, 0x12, 0x28,
+0x90, 0x38, 0xa4, 0x11, 0x58, 0x32, 0x26, 0x24, 0x11, 0x50, 0x90, 0x60,
+0x90, 0x38, 0xa4, 0x10, 0x80, 0x32, 0x0b, 0x24, 0x10, 0x78, 0x90, 0x38,
+0xa4, 0x0f, 0x90, 0x31, 0xed, 0x24, 0x0f, 0x88, 0x90, 0xc0, 0x90, 0x60,
+0x90, 0x38, 0xa4, 0x12, 0x00, 0x32, 0x3e, 0x24, 0x11, 0xf8, 0x90, 0x38,
+0xa4, 0x11, 0x28, 0x32, 0x23, 0x24, 0x11, 0x20, 0x90, 0x60, 0x90, 0x38,
+0xa4, 0x10, 0x50, 0x32, 0x08, 0x24, 0x10, 0x48, 0x90, 0x38, 0xa4, 0x0f,
+0x60, 0x31, 0xea, 0x24, 0x0f, 0x58, 0xe4, 0xe1, 0xc8, 0x80, 0x37, 0x25,
+0x88, 0x01, 0x88, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x12, 0x20,
+0x32, 0x42, 0x24, 0x12, 0x18, 0x90, 0x38, 0xa4, 0x11, 0x48, 0x32, 0x27,
+0x24, 0x11, 0x40, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x10, 0x70, 0x32, 0x0c,
+0x24, 0x10, 0x68, 0x90, 0x38, 0xa4, 0x0f, 0x80, 0x31, 0xee, 0x24, 0x0f,
+0x78, 0xe4, 0xe1, 0xc7, 0x00, 0x37, 0x1f, 0x92, 0xd0, 0x99, 0x50, 0x02,
+0x80, 0x90, 0xa0, 0x90, 0x50, 0x90, 0x28, 0x80, 0x31, 0xe9, 0x24, 0x0f,
+0x40, 0x90, 0x28, 0x80, 0x31, 0xe5, 0x24, 0x0f, 0x20, 0x90, 0x50, 0x90,
+0x28, 0x80, 0x31, 0xe1, 0x24, 0x0f, 0x00, 0x90, 0x28, 0x80, 0x31, 0xdd,
+0x24, 0x0e, 0xe0, 0x90, 0xa0, 0x90, 0x50, 0x90, 0x28, 0x80, 0x31, 0xe6,
+0x24, 0x0f, 0x38, 0x90, 0x28, 0x80, 0x31, 0xe2, 0x24, 0x0f, 0x18, 0x90,
+0x50, 0x90, 0x28, 0x80, 0x31, 0xde, 0x24, 0x0e, 0xf8, 0x90, 0x28, 0x80,
+0x31, 0xda, 0x24, 0x0e, 0xd8, 0xec, 0xe1, 0xc5, 0xa1, 0x17, 0x00, 0x37,
+0x19, 0x88, 0x00, 0x78, 0x10, 0x10, 0x10, 0x10, 0x90, 0x28, 0x80, 0x31,
+0xd8, 0x24, 0x0e, 0xc8, 0xec, 0xe1, 0xc4, 0x21, 0x15, 0x00, 0x37, 0x13,
+0xe5, 0xa1, 0x4d, 0x40, 0x35, 0x31, 0xa0, 0x2a, 0x10, 0xa8, 0x16, 0x60,
+0x29, 0xd8, 0xa0, 0x0c, 0x48, 0xa0, 0x0a, 0xc8, 0x95, 0x60, 0x92, 0xb0,
+0x91, 0x40, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x31, 0xa1, 0x80,
+0x31, 0xa0, 0x10, 0x10, 0x80, 0x31, 0x9f, 0x90, 0x70, 0x90, 0x38, 0xa4,
+0x08, 0x98, 0x31, 0xb3, 0xa4, 0x08, 0x90, 0x31, 0xb2, 0x10, 0x10, 0xa4,
+0x08, 0x88, 0x31, 0xb1, 0x90, 0xb8, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x09,
+0xb8, 0x31, 0xd7, 0xa4, 0x09, 0xb0, 0x31, 0xd6, 0x10, 0x10, 0xa4, 0x09,
+0xa8, 0x31, 0xd5, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x09, 0x28, 0x31, 0xc5,
+0xa4, 0x09, 0x20, 0x31, 0xc4, 0x10, 0x10, 0xa4, 0x09, 0x18, 0x31, 0xc3,
+0x91, 0x40, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x31, 0x9c, 0x80,
+0x31, 0x9e, 0x10, 0x10, 0x80, 0x31, 0x9d, 0x90, 0x70, 0x90, 0x38, 0xa4,
+0x08, 0x70, 0x31, 0xae, 0xa4, 0x08, 0x80, 0x31, 0xb0, 0x10, 0x10, 0xa4,
+0x08, 0x78, 0x31, 0xaf, 0x90, 0xb8, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x09,
+0x90, 0x31, 0xd2, 0xa4, 0x09, 0xa0, 0x31, 0xd4, 0x10, 0x10, 0xa4, 0x09,
+0x98, 0x31, 0xd3, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x09, 0x00, 0x31, 0xc0,
+0xa4, 0x09, 0x10, 0x31, 0xc2, 0x10, 0x10, 0xa4, 0x09, 0x08, 0x31, 0xc1,
+0x92, 0xb0, 0x91, 0x40, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x31,
+0x99, 0x80, 0x31, 0x9b, 0x10, 0x10, 0x80, 0x31, 0x9a, 0x90, 0x70, 0x90,
+0x38, 0xa4, 0x08, 0x58, 0x31, 0xab, 0xa4, 0x08, 0x68, 0x31, 0xad, 0x10,
+0x10, 0xa4, 0x08, 0x60, 0x31, 0xac, 0x90, 0xb8, 0x90, 0x70, 0x90, 0x38,
+0xa4, 0x09, 0x78, 0x31, 0xcf, 0xa4, 0x09, 0x88, 0x31, 0xd1, 0x10, 0x10,
+0xa4, 0x09, 0x80, 0x31, 0xd0, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x08, 0xe8,
+0x31, 0xbd, 0xa4, 0x08, 0xf8, 0x31, 0xbf, 0x10, 0x10, 0xa4, 0x08, 0xf0,
+0x31, 0xbe, 0x91, 0x40, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x31,
+0x96, 0x80, 0x31, 0x98, 0x10, 0x10, 0x80, 0x31, 0x97, 0x90, 0x70, 0x90,
+0x38, 0xa4, 0x08, 0x40, 0x31, 0xa8, 0xa4, 0x08, 0x50, 0x31, 0xaa, 0x10,
+0x10, 0xa4, 0x08, 0x48, 0x31, 0xa9, 0x90, 0xb8, 0x90, 0x70, 0x90, 0x38,
+0xa4, 0x09, 0x60, 0x31, 0xcc, 0xa4, 0x09, 0x70, 0x31, 0xce, 0x10, 0x10,
+0xa4, 0x09, 0x68, 0x31, 0xcd, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x08, 0xd0,
+0x31, 0xba, 0xa4, 0x08, 0xe0, 0x31, 0xbc, 0x10, 0x10, 0xa4, 0x08, 0xd8,
+0x31, 0xbb, 0x10, 0x10, 0x90, 0xa8, 0x10, 0x10, 0x10, 0x10, 0x90, 0x50,
+0x90, 0x28, 0x80, 0x31, 0x8d, 0x80, 0x31, 0x8f, 0x10, 0x10, 0x80, 0x31,
+0x8e, 0x90, 0x60, 0x90, 0x30, 0x60, 0xa0, 0x2a, 0xc0, 0x60, 0xa0, 0x2a,
+0x80, 0x90, 0x30, 0x60, 0xa0, 0x2a, 0x40, 0x60, 0xa0, 0x2a, 0x00, 0x97,
+0xf0, 0x95, 0x60, 0x92, 0xb0, 0x91, 0x40, 0x90, 0x88, 0x90, 0x50, 0x90,
+0x28, 0x80, 0x31, 0x93, 0x80, 0x31, 0x95, 0x10, 0x10, 0x80, 0x31, 0x94,
+0x90, 0x70, 0x90, 0x38, 0xa4, 0x08, 0x28, 0x31, 0xa5, 0xa4, 0x08, 0x38,
+0x31, 0xa7, 0x10, 0x10, 0xa4, 0x08, 0x30, 0x31, 0xa6, 0x90, 0xb8, 0x90,
+0x70, 0x90, 0x38, 0xa4, 0x09, 0x48, 0x31, 0xc9, 0xa4, 0x09, 0x58, 0x31,
+0xcb, 0x10, 0x10, 0xa4, 0x09, 0x50, 0x31, 0xca, 0x90, 0x70, 0x90, 0x38,
+0xa4, 0x08, 0xb8, 0x31, 0xb7, 0xa4, 0x08, 0xc8, 0x31, 0xb9, 0x10, 0x10,
+0xa4, 0x08, 0xc0, 0x31, 0xb8, 0x91, 0x40, 0x90, 0x88, 0x90, 0x50, 0x90,
+0x28, 0x80, 0x31, 0x90, 0x80, 0x31, 0x92, 0x10, 0x10, 0x80, 0x31, 0x91,
+0x90, 0x70, 0x90, 0x38, 0xa4, 0x08, 0x10, 0x31, 0xa2, 0xa4, 0x08, 0x20,
+0x31, 0xa4, 0x10, 0x10, 0xa4, 0x08, 0x18, 0x31, 0xa3, 0x90, 0xb8, 0x90,
+0x70, 0x90, 0x38, 0xa4, 0x09, 0x30, 0x31, 0xc6, 0xa4, 0x09, 0x40, 0x31,
+0xc8, 0x10, 0x10, 0xa4, 0x09, 0x38, 0x31, 0xc7, 0x90, 0x70, 0x90, 0x38,
+0xa4, 0x08, 0xa0, 0x31, 0xb4, 0xa4, 0x08, 0xb0, 0x31, 0xb6, 0x10, 0x10,
+0xa4, 0x08, 0xa8, 0x31, 0xb5, 0x10, 0x10, 0x91, 0x40, 0x90, 0xa0, 0x90,
+0x50, 0x90, 0x28, 0x80, 0x30, 0xcb, 0x80, 0x30, 0xca, 0x90, 0x28, 0x80,
+0x30, 0xc9, 0x80, 0x30, 0xc8, 0x90, 0x50, 0x90, 0x28, 0x80, 0x30, 0xc4,
+0x80, 0x30, 0xc7, 0x90, 0x28, 0x80, 0x30, 0xc6, 0x80, 0x30, 0xc5, 0x90,
+0xa0, 0x90, 0x50, 0x90, 0x28, 0x80, 0x30, 0xbc, 0x80, 0x30, 0xc3, 0x90,
+0x28, 0x80, 0x30, 0xc2, 0x80, 0x30, 0xc1, 0x90, 0x50, 0x90, 0x28, 0x80,
+0x30, 0xbd, 0x80, 0x30, 0xc0, 0x90, 0x28, 0x80, 0x30, 0xbf, 0x80, 0x30,
+0xbe, 0x91, 0x88, 0x80, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x28, 0x81, 0x31,
+0x3b, 0x10, 0x10, 0x80, 0x31, 0x3a, 0x90, 0x28, 0x81, 0x31, 0x3d, 0x10,
+0x10, 0x80, 0x31, 0x3c, 0x90, 0x60, 0x90, 0x28, 0x81, 0x31, 0x41, 0x10,
+0x10, 0x80, 0x31, 0x40, 0x90, 0x28, 0x81, 0x31, 0x3f, 0x10, 0x10, 0x80,
+0x31, 0x3e, 0x80, 0x10, 0x10, 0x10, 0x10, 0x90, 0x28, 0x81, 0x31, 0x38,
+0x10, 0x10, 0x80, 0x31, 0x39, 0xa0, 0x0b, 0x90, 0xa0, 0x0a, 0xc8, 0x95,
+0x60, 0x92, 0xb0, 0x91, 0x40, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80,
+0x31, 0x56, 0x80, 0x31, 0x55, 0x10, 0x10, 0x80, 0x31, 0x54, 0x90, 0x70,
+0x90, 0x38, 0xa4, 0x06, 0xe8, 0x31, 0x68, 0xa4, 0x06, 0xe0, 0x31, 0x67,
+0x10, 0x10, 0xa4, 0x06, 0xd8, 0x31, 0x66, 0x90, 0xb8, 0x90, 0x70, 0x90,
+0x38, 0xa4, 0x08, 0x08, 0x31, 0x8c, 0xa4, 0x08, 0x00, 0x31, 0x8b, 0x10,
+0x10, 0xa4, 0x07, 0xf8, 0x31, 0x8a, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x07,
+0x78, 0x31, 0x7a, 0xa4, 0x07, 0x70, 0x31, 0x79, 0x10, 0x10, 0xa4, 0x07,
+0x68, 0x31, 0x78, 0x91, 0x40, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80,
+0x31, 0x51, 0x80, 0x31, 0x53, 0x10, 0x10, 0x80, 0x31, 0x52, 0x90, 0x70,
+0x90, 0x38, 0xa4, 0x06, 0xc0, 0x31, 0x63, 0xa4, 0x06, 0xd0, 0x31, 0x65,
+0x10, 0x10, 0xa4, 0x06, 0xc8, 0x31, 0x64, 0x90, 0xb8, 0x90, 0x70, 0x90,
+0x38, 0xa4, 0x07, 0xe0, 0x31, 0x87, 0xa4, 0x07, 0xf0, 0x31, 0x89, 0x10,
+0x10, 0xa4, 0x07, 0xe8, 0x31, 0x88, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x07,
+0x50, 0x31, 0x75, 0xa4, 0x07, 0x60, 0x31, 0x77, 0x10, 0x10, 0xa4, 0x07,
+0x58, 0x31, 0x76, 0x92, 0xb0, 0x91, 0x40, 0x90, 0x88, 0x90, 0x50, 0x90,
+0x28, 0x80, 0x31, 0x4e, 0x80, 0x31, 0x50, 0x10, 0x10, 0x80, 0x31, 0x4f,
+0x90, 0x70, 0x90, 0x38, 0xa4, 0x06, 0xa8, 0x31, 0x60, 0xa4, 0x06, 0xb8,
+0x31, 0x62, 0x10, 0x10, 0xa4, 0x06, 0xb0, 0x31, 0x61, 0x90, 0xb8, 0x90,
+0x70, 0x90, 0x38, 0xa4, 0x07, 0xc8, 0x31, 0x84, 0xa4, 0x07, 0xd8, 0x31,
+0x86, 0x10, 0x10, 0xa4, 0x07, 0xd0, 0x31, 0x85, 0x90, 0x70, 0x90, 0x38,
+0xa4, 0x07, 0x38, 0x31, 0x72, 0xa4, 0x07, 0x48, 0x31, 0x74, 0x10, 0x10,
+0xa4, 0x07, 0x40, 0x31, 0x73, 0x91, 0x40, 0x90, 0x88, 0x90, 0x50, 0x90,
+0x28, 0x80, 0x31, 0x4b, 0x80, 0x31, 0x4d, 0x10, 0x10, 0x80, 0x31, 0x4c,
+0x90, 0x70, 0x90, 0x38, 0xa4, 0x06, 0x90, 0x31, 0x5d, 0xa4, 0x06, 0xa0,
+0x31, 0x5f, 0x10, 0x10, 0xa4, 0x06, 0x98, 0x31, 0x5e, 0x90, 0xb8, 0x90,
+0x70, 0x90, 0x38, 0xa4, 0x07, 0xb0, 0x31, 0x81, 0xa4, 0x07, 0xc0, 0x31,
+0x83, 0x10, 0x10, 0xa4, 0x07, 0xb8, 0x31, 0x82, 0x90, 0x70, 0x90, 0x38,
+0xa4, 0x07, 0x20, 0x31, 0x6f, 0xa4, 0x07, 0x30, 0x31, 0x71, 0x10, 0x10,
+0xa4, 0x07, 0x28, 0x31, 0x70, 0x10, 0x10, 0x80, 0x10, 0x10, 0x10, 0x10,
+0x90, 0x50, 0x90, 0x28, 0x80, 0x31, 0x42, 0x80, 0x31, 0x44, 0x10, 0x10,
+0x80, 0x31, 0x43, 0x80, 0x95, 0x60, 0x92, 0xb0, 0x91, 0x40, 0x90, 0x88,
+0x90, 0x50, 0x90, 0x28, 0x80, 0x31, 0x48, 0x80, 0x31, 0x4a, 0x10, 0x10,
+0x80, 0x31, 0x49, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x06, 0x78, 0x31, 0x5a,
+0xa4, 0x06, 0x88, 0x31, 0x5c, 0x10, 0x10, 0xa4, 0x06, 0x80, 0x31, 0x5b,
+0x90, 0xb8, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x07, 0x98, 0x31, 0x7e, 0xa4,
+0x07, 0xa8, 0x31, 0x80, 0x10, 0x10, 0xa4, 0x07, 0xa0, 0x31, 0x7f, 0x90,
+0x70, 0x90, 0x38, 0xa4, 0x07, 0x08, 0x31, 0x6c, 0xa4, 0x07, 0x18, 0x31,
+0x6e, 0x10, 0x10, 0xa4, 0x07, 0x10, 0x31, 0x6d, 0x91, 0x40, 0x90, 0x88,
+0x90, 0x50, 0x90, 0x28, 0x80, 0x31, 0x45, 0x80, 0x31, 0x47, 0x10, 0x10,
+0x80, 0x31, 0x46, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x06, 0x60, 0x31, 0x57,
+0xa4, 0x06, 0x70, 0x31, 0x59, 0x10, 0x10, 0xa4, 0x06, 0x68, 0x31, 0x58,
+0x90, 0xb8, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x07, 0x80, 0x31, 0x7b, 0xa4,
+0x07, 0x90, 0x31, 0x7d, 0x10, 0x10, 0xa4, 0x07, 0x88, 0x31, 0x7c, 0x90,
+0x70, 0x90, 0x38, 0xa4, 0x06, 0xf0, 0x31, 0x69, 0xa4, 0x07, 0x00, 0x31,
+0x6b, 0x10, 0x10, 0xa4, 0x06, 0xf8, 0x31, 0x6a, 0x10, 0x10, 0x91, 0x40,
+0x90, 0xa0, 0x90, 0x50, 0x90, 0x28, 0x80, 0x30, 0xbb, 0x80, 0x30, 0xba,
+0x90, 0x28, 0x80, 0x30, 0xb9, 0x80, 0x30, 0xb8, 0x90, 0x50, 0x90, 0x28,
+0x80, 0x30, 0xb4, 0x80, 0x30, 0xb7, 0x90, 0x28, 0x80, 0x30, 0xb6, 0x80,
+0x30, 0xb5, 0x90, 0xa0, 0x90, 0x50, 0x90, 0x28, 0x80, 0x30, 0xac, 0x80,
+0x30, 0xb3, 0x90, 0x28, 0x80, 0x30, 0xb2, 0x80, 0x30, 0xb1, 0x90, 0x50,
+0x90, 0x28, 0x80, 0x30, 0xad, 0x80, 0x30, 0xb0, 0x90, 0x28, 0x80, 0x30,
+0xaf, 0x80, 0x30, 0xae, 0xc3, 0xc0, 0x30, 0x42, 0x9c, 0xe8, 0x07, 0x60,
+0x91, 0x90, 0x90, 0xf0, 0x10, 0x10, 0x80, 0x88, 0x00, 0x80, 0x90, 0x50,
+0x90, 0x28, 0x80, 0x33, 0xf8, 0x80, 0x33, 0xf9, 0x81, 0x33, 0xef, 0xd0,
+0x41, 0x80, 0x24, 0x20, 0x90, 0x24, 0x20, 0x98, 0x10, 0x10, 0x80, 0x90,
+0x58, 0x80, 0x90, 0x28, 0x24, 0x1f, 0x90, 0x24, 0x1f, 0x98, 0x81, 0x24,
+0x1f, 0x50, 0x92, 0x68, 0x91, 0x00, 0x80, 0x90, 0x90, 0x90, 0x30, 0x80,
+0x24, 0x20, 0x00, 0x90, 0x38, 0xa4, 0x1f, 0xf8, 0x34, 0x06, 0x80, 0x34,
+0x05, 0x80, 0x90, 0x28, 0x80, 0x34, 0x0f, 0xa4, 0x1f, 0xe0, 0x34, 0x0e,
+0x80, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x28, 0x80, 0x34, 0x09, 0xa4, 0x1f,
+0xf0, 0x34, 0x08, 0x90, 0x28, 0x80, 0x34, 0x04, 0xa4, 0x1f, 0xe8, 0x34,
+0x03, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0x0d, 0x80, 0x34, 0x0c, 0x90,
+0x28, 0x24, 0x20, 0x88, 0x24, 0x20, 0x80, 0x90, 0x58, 0x80, 0x10, 0x10,
+0x80, 0x10, 0x10, 0x80, 0x33, 0xfb, 0x80, 0x90, 0x40, 0x10, 0x10, 0x80,
+0x24, 0x1f, 0x60, 0x80, 0x10, 0x10, 0x80, 0x33, 0xfa, 0x91, 0x58, 0x91,
+0x00, 0x90, 0x80, 0x81, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0xf6, 0x80,
+0x33, 0xf7, 0x81, 0x33, 0xee, 0x81, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33,
+0xf4, 0x80, 0x33, 0xf5, 0x81, 0x33, 0xed, 0x83, 0x90, 0x28, 0x24, 0x1f,
+0x80, 0x24, 0x1f, 0x88, 0x90, 0xe8, 0x81, 0x90, 0x88, 0x90, 0x38, 0x10,
+0x10, 0x80, 0x34, 0x07, 0x90, 0x28, 0x80, 0x34, 0x02, 0x80, 0x34, 0x01,
+0x80, 0x90, 0x28, 0x80, 0x34, 0x0b, 0x80, 0x34, 0x0a, 0x82, 0x10, 0x10,
+0x80, 0x24, 0x1f, 0x58, 0x97, 0x10, 0x9e, 0x10, 0x06, 0x98, 0x93, 0x00,
+0x91, 0x80, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x03, 0x80, 0x30,
+0x71, 0x24, 0x03, 0x78, 0x90, 0x38, 0xa4, 0x04, 0x10, 0x30, 0x83, 0x24,
+0x04, 0x08, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x05, 0x30, 0x30, 0xa7, 0x24,
+0x05, 0x28, 0x90, 0x38, 0xa4, 0x04, 0xa0, 0x30, 0x95, 0x24, 0x04, 0x98,
+0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x03, 0x70, 0x30, 0x6c, 0x24,
+0x03, 0x68, 0x90, 0x38, 0xa4, 0x04, 0x00, 0x30, 0x7e, 0x24, 0x03, 0xf8,
+0x90, 0x60, 0x90, 0x38, 0xa4, 0x05, 0x20, 0x30, 0xa2, 0x24, 0x05, 0x18,
+0x90, 0x38, 0xa4, 0x04, 0x90, 0x30, 0x90, 0x24, 0x04, 0x88, 0x91, 0x80,
+0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x03, 0x58, 0x30, 0x69, 0x24,
+0x03, 0x50, 0x90, 0x38, 0xa4, 0x03, 0xe8, 0x30, 0x7b, 0x24, 0x03, 0xe0,
+0x90, 0x60, 0x90, 0x38, 0xa4, 0x05, 0x08, 0x30, 0x9f, 0x24, 0x05, 0x00,
+0x90, 0x38, 0xa4, 0x04, 0x78, 0x30, 0x8d, 0x24, 0x04, 0x70, 0x90, 0xc0,
+0x90, 0x60, 0x90, 0x38, 0xa4, 0x03, 0x40, 0x30, 0x66, 0x24, 0x03, 0x38,
+0x90, 0x38, 0xa4, 0x03, 0xd0, 0x30, 0x78, 0x24, 0x03, 0xc8, 0x90, 0x60,
+0x90, 0x38, 0xa4, 0x04, 0xf0, 0x30, 0x9c, 0x24, 0x04, 0xe8, 0x90, 0x38,
+0xa4, 0x04, 0x60, 0x30, 0x8a, 0x24, 0x04, 0x58, 0x10, 0x10, 0x80, 0x10,
+0x10, 0x10, 0x10, 0x90, 0x38, 0xa4, 0x02, 0xf8, 0x30, 0x5d, 0x24, 0x02,
+0xf0, 0xd7, 0x42, 0x00, 0xa4, 0x38, 0x58, 0x37, 0x0d, 0xa4, 0x38, 0x38,
+0x37, 0x09, 0x9c, 0xe0, 0x06, 0x90, 0x93, 0x00, 0x91, 0x80, 0x90, 0xc0,
+0x90, 0x60, 0x90, 0x38, 0xa4, 0x03, 0x28, 0x30, 0x63, 0x24, 0x03, 0x20,
+0x90, 0x38, 0xa4, 0x03, 0xb8, 0x30, 0x75, 0x24, 0x03, 0xb0, 0x90, 0x60,
+0x90, 0x38, 0xa4, 0x04, 0xd8, 0x30, 0x99, 0x24, 0x04, 0xd0, 0x90, 0x38,
+0xa4, 0x04, 0x48, 0x30, 0x87, 0x24, 0x04, 0x40, 0x90, 0xc0, 0x90, 0x60,
+0x90, 0x38, 0xa4, 0x03, 0x10, 0x30, 0x60, 0x24, 0x03, 0x08, 0x90, 0x38,
+0xa4, 0x03, 0xa0, 0x30, 0x72, 0x24, 0x03, 0x98, 0x90, 0x60, 0x90, 0x38,
+0xa4, 0x04, 0xc0, 0x30, 0x96, 0x24, 0x04, 0xb8, 0x90, 0x38, 0xa4, 0x04,
+0x30, 0x30, 0x84, 0x24, 0x04, 0x28, 0x10, 0x10, 0x90, 0xe0, 0x90, 0x70,
+0x90, 0x38, 0xa4, 0x02, 0x88, 0x30, 0x52, 0xa4, 0x02, 0x78, 0x30, 0x50,
+0x90, 0x38, 0xa4, 0x02, 0x70, 0x30, 0x4b, 0xa4, 0x02, 0x60, 0x30, 0x4d,
+0x90, 0x70, 0x90, 0x38, 0xa4, 0x02, 0x50, 0x30, 0x43, 0xa4, 0x02, 0x40,
+0x30, 0x49, 0x90, 0x38, 0xa4, 0x02, 0x38, 0x30, 0x44, 0xa4, 0x02, 0x28,
+0x30, 0x46, 0x91, 0x48, 0x80, 0x90, 0xa0, 0x90, 0x50, 0x90, 0x28, 0x80,
+0x30, 0x56, 0x24, 0x02, 0xa8, 0x90, 0x28, 0x80, 0x30, 0x58, 0x24, 0x02,
+0xb8, 0x90, 0x50, 0x90, 0x28, 0x80, 0x30, 0x5c, 0x24, 0x02, 0xd8, 0x90,
+0x28, 0x80, 0x30, 0x5a, 0x24, 0x02, 0xc8, 0x80, 0x10, 0x10, 0x10, 0x10,
+0x90, 0x28, 0x80, 0x30, 0x53, 0x24, 0x02, 0xa0, 0xd7, 0x42, 0x00, 0xa4,
+0x38, 0x60, 0x37, 0x0e, 0xa4, 0x38, 0x40, 0x37, 0x0a, 0xa0, 0x14, 0x68,
+0xa0, 0x10, 0x90, 0xa0, 0x0c, 0x60, 0x9e, 0x88, 0x09, 0xd0, 0x94, 0xf0,
+0x90, 0xb0, 0x88, 0x00, 0x68, 0x84, 0x10, 0x10, 0xc9, 0xe1, 0x44, 0x40,
+0x85, 0x35, 0x2d, 0xcb, 0x61, 0x3d, 0x00, 0x85, 0x35, 0x03, 0x9a, 0x00,
+0x03, 0xf8, 0x91, 0x98, 0x80, 0x91, 0x10, 0x90, 0xa0, 0x90, 0x68, 0x90,
+0x20, 0x3a, 0x53, 0xc9, 0xe2, 0x94, 0x40, 0x85, 0x35, 0x2b, 0xa4, 0x52,
+0x78, 0x3a, 0x50, 0x90, 0x38, 0xa4, 0x52, 0x40, 0x3a, 0x49, 0xa4, 0x52,
+0x30, 0x3a, 0x47, 0x90, 0x48, 0x10, 0x10, 0xa4, 0x51, 0xf8, 0x3a, 0x40,
+0x10, 0x10, 0x80, 0x3a, 0x3c, 0x81, 0x10, 0x10, 0x80, 0xa4, 0x51, 0xc8,
+0x3a, 0x3a, 0x91, 0xb0, 0x91, 0x60, 0x90, 0xe0, 0x90, 0x70, 0x90, 0x38,
+0xa4, 0x52, 0x68, 0x3a, 0x4e, 0xa4, 0x52, 0x58, 0x3a, 0x4c, 0x90, 0x38,
+0xa4, 0x52, 0x20, 0x3a, 0x45, 0xa4, 0x52, 0x10, 0x3a, 0x43, 0x90, 0x48,
+0x10, 0x10, 0xa4, 0x51, 0xe8, 0x3a, 0x3e, 0x10, 0x10, 0x80, 0x3a, 0x3b,
+0x90, 0x28, 0x80, 0x3a, 0x34, 0x80, 0x3a, 0x33, 0x81, 0x10, 0x10, 0x80,
+0xa4, 0x51, 0xb8, 0x3a, 0x38, 0xcb, 0x61, 0x3c, 0xc0, 0x85, 0x35, 0x02,
+0x90, 0xd8, 0x88, 0x00, 0x90, 0x84, 0x90, 0x38, 0xc1, 0xc0, 0x85, 0x3a,
+0x56, 0xc9, 0xe1, 0x44, 0x00, 0x85, 0x35, 0x29, 0xcb, 0x61, 0x3c, 0x80,
+0x85, 0x35, 0x01, 0x88, 0x00, 0x68, 0x84, 0x10, 0x10, 0xc9, 0xe1, 0x43,
+0xc0, 0x85, 0x35, 0x27, 0xcb, 0x61, 0x3c, 0x40, 0x85, 0x35, 0x00, 0x91,
+0xf8, 0x90, 0xb0, 0x88, 0x00, 0x68, 0x84, 0x10, 0x10, 0xc9, 0xe1, 0x43,
+0x40, 0x85, 0x35, 0x23, 0xcb, 0x61, 0x3b, 0xc0, 0x85, 0x34, 0xfe, 0x88,
+0x01, 0x00, 0x90, 0xa0, 0x81, 0x90, 0x70, 0x80, 0x90, 0x20, 0x3a, 0x4a,
+0xc9, 0xe1, 0x43, 0x00, 0x85, 0x35, 0x21, 0x81, 0x3a, 0x41, 0x81, 0x10,
+0x10, 0x80, 0xa4, 0x51, 0xa8, 0x3a, 0x36, 0xcb, 0x61, 0x3b, 0x80, 0x85,
+0x34, 0xfd, 0x90, 0xb0, 0x88, 0x00, 0x68, 0x84, 0x10, 0x10, 0xc9, 0xe1,
+0x42, 0xc0, 0x85, 0x35, 0x1f, 0xcb, 0x61, 0x3b, 0x40, 0x85, 0x34, 0xfc,
+0x88, 0x00, 0x68, 0x84, 0x10, 0x10, 0xc9, 0xe1, 0x42, 0x80, 0x85, 0x35,
+0x1d, 0xcb, 0x61, 0x3b, 0x00, 0x85, 0x34, 0xfb, 0x92, 0x38, 0x81, 0x91,
+0x68, 0x91, 0x18, 0x90, 0x80, 0x90, 0x40, 0x80, 0xa4, 0x53, 0x28, 0x3a,
+0x66, 0x80, 0xa4, 0x53, 0x20, 0x3a, 0x63, 0x90, 0x28, 0x81, 0x3a, 0x62,
+0x90, 0x38, 0xa4, 0x53, 0x00, 0x3a, 0x61, 0xa4, 0x52, 0xf0, 0x3a, 0x5f,
+0x90, 0x28, 0x80, 0x3a, 0x5d, 0x80, 0x3a, 0x5c, 0x80, 0x90, 0x40, 0x10,
+0x10, 0x80, 0x24, 0x52, 0xd8, 0x10, 0x10, 0x90, 0x38, 0xa4, 0x52, 0xc8,
+0x3a, 0x5a, 0xa4, 0x52, 0xb8, 0x3a, 0x58, 0x90, 0x28, 0x80, 0x3a, 0x55,
+0x80, 0x3a, 0x54, 0x9a, 0xd0, 0x03, 0xe0, 0x91, 0x60, 0x90, 0xb0, 0x88,
+0x00, 0x68, 0x84, 0x10, 0x10, 0xc9, 0xe1, 0x42, 0x00, 0x85, 0x35, 0x19,
+0xcb, 0x61, 0x3a, 0x80, 0x85, 0x34, 0xf9, 0x88, 0x00, 0x68, 0x84, 0x10,
+0x10, 0xc9, 0xe1, 0x41, 0xc0, 0x85, 0x35, 0x17, 0xcb, 0x61, 0x3a, 0x40,
+0x85, 0x34, 0xf8, 0x90, 0xb0, 0x88, 0x00, 0x68, 0x84, 0x10, 0x10, 0xc9,
+0xe1, 0x41, 0x80, 0x85, 0x35, 0x15, 0xcb, 0x61, 0x3a, 0x00, 0x85, 0x34,
+0xf7, 0x88, 0x00, 0x68, 0x84, 0x10, 0x10, 0xc9, 0xe1, 0x41, 0x40, 0x85,
+0x35, 0x13, 0xcb, 0x61, 0x39, 0xc0, 0x85, 0x34, 0xf6, 0x90, 0x90, 0x90,
+0x48, 0xcb, 0xa1, 0x38, 0x00, 0x85, 0x34, 0xe5, 0xcb, 0xa1, 0x37, 0xc0,
+0x85, 0x34, 0xe4, 0x90, 0x48, 0xcb, 0xa1, 0x37, 0x80, 0x85, 0x34, 0xe3,
+0xcb, 0xa1, 0x37, 0x40, 0x85, 0x34, 0xe2, 0xcb, 0xa2, 0x8c, 0x40, 0x80,
+0x3a, 0x32, 0x92, 0x40, 0x91, 0x20, 0x90, 0x90, 0x90, 0x48, 0x8c, 0x26,
+0x60, 0x84, 0x24, 0x26, 0xd8, 0x8c, 0x26, 0x58, 0x84, 0x24, 0x26, 0xd0,
+0x90, 0x48, 0x8c, 0x26, 0x50, 0x84, 0x24, 0x26, 0xc8, 0x8c, 0x26, 0x48,
+0x84, 0x24, 0x26, 0xc0, 0x90, 0x90, 0x90, 0x48, 0x8c, 0x26, 0x38, 0x84,
+0x24, 0x26, 0xb0, 0x8c, 0x26, 0x30, 0x84, 0x24, 0x26, 0xa8, 0x90, 0x48,
+0x8c, 0x26, 0x28, 0x84, 0x24, 0x26, 0xa0, 0x8c, 0x26, 0x20, 0x84, 0x24,
+0x26, 0x98, 0x91, 0x20, 0x90, 0x90, 0x90, 0x48, 0x8c, 0x26, 0x10, 0x84,
+0x24, 0x26, 0x88, 0x8c, 0x26, 0x08, 0x84, 0x24, 0x26, 0x80, 0x90, 0x48,
+0x8c, 0x26, 0x00, 0x84, 0x24, 0x26, 0x78, 0x8c, 0x25, 0xf8, 0x84, 0x24,
+0x26, 0x70, 0x90, 0x38, 0xa4, 0x25, 0xe0, 0x34, 0xbd, 0xa4, 0x25, 0xd0,
+0x34, 0xbb, 0xa0, 0x0f, 0x50, 0xa0, 0x09, 0x08, 0x9a, 0x30, 0x04, 0x40,
+0x91, 0x90, 0x90, 0xc8, 0x98, 0x50, 0x00, 0x80, 0xe5, 0x22, 0x8a, 0x40,
+0x3a, 0x21, 0xe5, 0x22, 0x82, 0x40, 0x3a, 0x1d, 0xcb, 0x61, 0x2a, 0x40,
+0x85, 0x34, 0xb8, 0x98, 0x50, 0x00, 0x80, 0xe5, 0x22, 0x7a, 0x40, 0x39,
+0xe1, 0xe5, 0x22, 0x72, 0x40, 0x39, 0xdd, 0xcb, 0x61, 0x2a, 0x00, 0x85,
+0x34, 0xb7, 0x90, 0x48, 0xcb, 0xa1, 0x29, 0xc0, 0x85, 0x34, 0xb6, 0xcb,
+0xa1, 0x29, 0x80, 0x85, 0x34, 0xb5, 0x91, 0x90, 0x90, 0xc8, 0x98, 0x50,
+0x00, 0x80, 0xe5, 0x22, 0x64, 0x40, 0x39, 0xa9, 0xe5, 0x22, 0x58, 0x40,
+0x39, 0x79, 0xcb, 0x61, 0x29, 0x00, 0x85, 0x34, 0xb3, 0x98, 0x50, 0x00,
+0x80, 0xe5, 0x22, 0x4c, 0x40, 0x39, 0x49, 0xe5, 0x22, 0x40, 0x40, 0x39,
+0x19, 0xcb, 0x61, 0x28, 0xc0, 0x85, 0x34, 0xb2, 0x90, 0x48, 0xcb, 0xa1,
+0x28, 0x80, 0x85, 0x34, 0xb1, 0xcb, 0xa1, 0x28, 0x40, 0x85, 0x34, 0xb0,
+0x92, 0x20, 0x91, 0x30, 0x90, 0xb8, 0xd5, 0x03, 0x00, 0xc0, 0xc0, 0x81,
+0x8c, 0x01, 0xa0, 0x84, 0x30, 0x3e, 0xc0, 0xc0, 0x81, 0x8c, 0x01, 0x80,
+0x84, 0x30, 0x3c, 0xd5, 0x02, 0x00, 0xc0, 0xc0, 0x81, 0x30, 0x28, 0xc0,
+0xc0, 0x81, 0x30, 0x24, 0x90, 0x78, 0xd5, 0x02, 0x00, 0xc0, 0xc0, 0x81,
+0x30, 0x1c, 0xc0, 0xc0, 0x81, 0x30, 0x18, 0xd5, 0x02, 0x00, 0xc0, 0xc0,
+0x81, 0x30, 0x10, 0xc0, 0xc0, 0x81, 0x30, 0x0c, 0x91, 0x70, 0x90, 0xd8,
+0xd5, 0x03, 0x80, 0xc8, 0xe2, 0x38, 0x40, 0x81, 0x8c, 0x01, 0xc0, 0x84,
+0x30, 0x40, 0xc8, 0xe2, 0x3a, 0x40, 0x81, 0x8c, 0x01, 0x90, 0x84, 0x30,
+0x3d, 0xd5, 0x02, 0x80, 0xc8, 0xe2, 0x37, 0x40, 0x81, 0x30, 0x2c, 0xc8,
+0xe2, 0x31, 0xc0, 0x81, 0x30, 0x26, 0x90, 0x98, 0xd5, 0x02, 0x80, 0xc8,
+0xe2, 0x26, 0xc0, 0x81, 0x30, 0x20, 0xc8, 0xe2, 0x28, 0xc0, 0x81, 0x30,
+0x1a, 0xd5, 0x02, 0x80, 0xc8, 0xe2, 0x25, 0xc0, 0x81, 0x30, 0x14, 0xc8,
+0xe2, 0x20, 0x40, 0x81, 0x30, 0x0e, 0x9a, 0x30, 0x04, 0x40, 0x91, 0x90,
+0x90, 0xc8, 0x98, 0x50, 0x00, 0x80, 0xe5, 0x22, 0x7e, 0x40, 0x39, 0xf1,
+0xe5, 0x22, 0x80, 0x40, 0x3a, 0x15, 0xcb, 0x61, 0x27, 0xc0, 0x85, 0x34,
+0xae, 0x98, 0x50, 0x00, 0x80, 0xe5, 0x22, 0x6e, 0x40, 0x39, 0xb1, 0xe5,
+0x22, 0x70, 0x40, 0x39, 0xd5, 0xcb, 0x61, 0x27, 0x80, 0x85, 0x34, 0xad,
+0x90, 0x48, 0xcb, 0xa1, 0x27, 0x40, 0x85, 0x34, 0xac, 0xcb, 0xa1, 0x27,
+0x00, 0x85, 0x34, 0xab, 0x91, 0x90, 0x90, 0xc8, 0x98, 0x50, 0x00, 0x80,
+0xe5, 0x22, 0x60, 0x40, 0x39, 0x99, 0xe5, 0x22, 0x54, 0x40, 0x39, 0x69,
+0xcb, 0x61, 0x25, 0x40, 0x85, 0x34, 0x9a, 0x98, 0x50, 0x00, 0x80, 0xe5,
+0x22, 0x48, 0x40, 0x39, 0x39, 0xe5, 0x22, 0x3c, 0x40, 0x39, 0x09, 0xcb,
+0x61, 0x25, 0x00, 0x85, 0x34, 0x99, 0x90, 0x48, 0xcb, 0xa1, 0x24, 0xc0,
+0x85, 0x34, 0x98, 0xcb, 0xa1, 0x24, 0x80, 0x85, 0x34, 0x97, 0x91, 0x00,
+0x90, 0x80, 0x90, 0x40, 0xe5, 0x20, 0x02, 0x40, 0x30, 0x0a, 0xe5, 0x20,
+0x01, 0x80, 0x30, 0x07, 0x90, 0x40, 0xe5, 0x20, 0x00, 0xc0, 0x30, 0x04,
+0xe5, 0x20, 0x00, 0x00, 0x30, 0x01, 0x90, 0x80, 0x90, 0x40, 0xe5, 0x22,
+0x2d, 0x40, 0x38, 0xab, 0xe5, 0x22, 0x2f, 0x80, 0x38, 0xd3, 0x90, 0x40,
+0xe5, 0x22, 0x1b, 0xc0, 0x38, 0x65, 0xe5, 0x22, 0x1e, 0x00, 0x38, 0x8d,
+0x80, 0x99, 0x28, 0x02, 0xf0, 0x8c, 0x24, 0x48, 0x90, 0x80, 0x90, 0x40,
+0xe5, 0x22, 0x84, 0x40, 0x3a, 0x0d, 0xe5, 0x22, 0x81, 0x40, 0x3a, 0x19,
+0x90, 0x40, 0xe5, 0x22, 0x74, 0x40, 0x39, 0xcd, 0xe5, 0x22, 0x71, 0x40,
+0x39, 0xd9, 0x91, 0x48, 0x90, 0xc8, 0x98, 0x50, 0x00, 0x80, 0xe5, 0x22,
+0x62, 0x40, 0x39, 0xa1, 0xe5, 0x22, 0x56, 0x40, 0x39, 0x71, 0xcb, 0x61,
+0x23, 0x00, 0x85, 0x34, 0x90, 0x90, 0x40, 0xe5, 0x22, 0x4a, 0x40, 0x39,
+0x41, 0xe5, 0x22, 0x3e, 0x40, 0x39, 0x11, 0x90, 0x48, 0xcb, 0xa1, 0x22,
+0x80, 0x85, 0x34, 0x8e, 0xcb, 0xa1, 0x22, 0xc0, 0x85, 0x34, 0x8f, 0x10,
+0x10, 0x90, 0x80, 0x90, 0x40, 0xe5, 0x22, 0x33, 0xc0, 0x38, 0xcb, 0xe5,
+0x22, 0x30, 0xc0, 0x38, 0xd9, 0x90, 0x40, 0xe5, 0x22, 0x22, 0x40, 0x38,
+0x85, 0xe5, 0x22, 0x1f, 0x40, 0x38, 0x93,
+};
+
+static const struct ia64_dis_names ia64_dis_names[] = {
+{ 0x51, 41, 0, 10 },
+{ 0x31, 41, 1, 20 },
+{ 0x11, 42, 0, 19 },
+{ 0x29, 41, 0, 12 },
+{ 0x19, 41, 1, 24 },
+{ 0x9, 42, 0, 23 },
+{ 0x15, 41, 0, 14 },
+{ 0xd, 41, 1, 28 },
+{ 0x5, 42, 0, 27 },
+{ 0xb, 41, 0, 16 },
+{ 0x7, 41, 1, 32 },
+{ 0x3, 42, 0, 31 },
+{ 0x51, 39, 1, 58 },
+{ 0x50, 39, 0, 34 },
+{ 0xd1, 39, 1, 57 },
+{ 0xd0, 39, 0, 33 },
+{ 0x31, 39, 1, 68 },
+{ 0x30, 39, 1, 44 },
+{ 0x11, 40, 1, 67 },
+{ 0x10, 40, 0, 43 },
+{ 0x71, 39, 1, 66 },
+{ 0x70, 39, 1, 42 },
+{ 0x31, 40, 1, 65 },
+{ 0x30, 40, 0, 41 },
+{ 0x29, 39, 1, 60 },
+{ 0x28, 39, 0, 36 },
+{ 0x69, 39, 1, 59 },
+{ 0x68, 39, 0, 35 },
+{ 0x19, 39, 1, 72 },
+{ 0x18, 39, 1, 48 },
+{ 0x9, 40, 1, 71 },
+{ 0x8, 40, 0, 47 },
+{ 0x39, 39, 1, 70 },
+{ 0x38, 39, 1, 46 },
+{ 0x19, 40, 1, 69 },
+{ 0x18, 40, 0, 45 },
+{ 0x15, 39, 1, 62 },
+{ 0x14, 39, 0, 38 },
+{ 0x35, 39, 1, 61 },
+{ 0x34, 39, 0, 37 },
+{ 0xd, 39, 1, 76 },
+{ 0xc, 39, 1, 52 },
+{ 0x5, 40, 1, 75 },
+{ 0x4, 40, 0, 51 },
+{ 0x1d, 39, 1, 74 },
+{ 0x1c, 39, 1, 50 },
+{ 0xd, 40, 1, 73 },
+{ 0xc, 40, 0, 49 },
+{ 0xb, 39, 1, 64 },
+{ 0xa, 39, 0, 40 },
+{ 0x1b, 39, 1, 63 },
+{ 0x1a, 39, 0, 39 },
+{ 0x7, 39, 1, 80 },
+{ 0x6, 39, 1, 56 },
+{ 0x3, 40, 1, 79 },
+{ 0x2, 40, 0, 55 },
+{ 0xf, 39, 1, 78 },
+{ 0xe, 39, 1, 54 },
+{ 0x7, 40, 1, 77 },
+{ 0x6, 40, 0, 53 },
+{ 0x8, 38, 0, 82 },
+{ 0x18, 38, 0, 81 },
+{ 0x1, 38, 1, 86 },
+{ 0x2, 38, 0, 85 },
+{ 0x3, 38, 1, 84 },
+{ 0x4, 38, 0, 83 },
+{ 0x1, 336, 0, 87 },
+{ 0x20, 289, 0, 98 },
+{ 0x220, 289, 0, 94 },
+{ 0x1220, 289, 0, 91 },
+{ 0xa20, 289, 0, 92 },
+{ 0x620, 289, 0, 93 },
+{ 0x120, 289, 0, 95 },
+{ 0xa0, 289, 0, 96 },
+{ 0x60, 289, 0, 97 },
+{ 0x10, 289, 0, 102 },
+{ 0x90, 289, 0, 99 },
+{ 0x50, 289, 0, 100 },
+{ 0x30, 289, 0, 101 },
+{ 0x8, 289, 0, 103 },
+{ 0x4, 289, 0, 104 },
+{ 0x2, 289, 0, 105 },
+{ 0x1, 289, 0, 106 },
+{ 0x1, 411, 0, 108 },
+{ 0x3, 411, 0, 107 },
+{ 0x2, 417, 0, 109 },
+{ 0x1, 417, 0, 110 },
+{ 0x2, 413, 0, 111 },
+{ 0x1, 413, 0, 112 },
+{ 0x2, 415, 0, 113 },
+{ 0x1, 415, 0, 114 },
+{ 0x2, 419, 0, 115 },
+{ 0x1, 419, 0, 116 },
+{ 0x1, 268, 0, 143 },
+{ 0x5, 268, 0, 141 },
+{ 0x3, 268, 0, 142 },
+{ 0x140, 277, 0, 119 },
+{ 0x540, 277, 0, 117 },
+{ 0x340, 277, 0, 118 },
+{ 0xc0, 277, 0, 131 },
+{ 0x2c0, 277, 0, 129 },
+{ 0x1c0, 277, 0, 130 },
+{ 0x20, 277, 0, 146 },
+{ 0xa0, 277, 0, 144 },
+{ 0x60, 277, 0, 145 },
+{ 0x10, 277, 0, 158 },
+{ 0x50, 277, 0, 156 },
+{ 0x30, 277, 0, 157 },
+{ 0x8, 277, 0, 170 },
+{ 0x28, 277, 0, 168 },
+{ 0x18, 277, 0, 169 },
+{ 0x4, 277, 0, 180 },
+{ 0x2, 277, 0, 181 },
+{ 0x1, 277, 0, 182 },
+{ 0x140, 271, 0, 122 },
+{ 0x540, 271, 0, 120 },
+{ 0x340, 271, 0, 121 },
+{ 0xc0, 271, 0, 134 },
+{ 0x2c0, 271, 0, 132 },
+{ 0x1c0, 271, 0, 133 },
+{ 0x20, 271, 0, 149 },
+{ 0xa0, 271, 0, 147 },
+{ 0x60, 271, 0, 148 },
+{ 0x10, 271, 0, 161 },
+{ 0x50, 271, 0, 159 },
+{ 0x30, 271, 0, 160 },
+{ 0x8, 271, 0, 173 },
+{ 0x28, 271, 0, 171 },
+{ 0x18, 271, 0, 172 },
+{ 0x4, 271, 0, 183 },
+{ 0x2, 271, 0, 184 },
+{ 0x1, 271, 0, 185 },
+{ 0x140, 274, 0, 125 },
+{ 0x540, 274, 0, 123 },
+{ 0x340, 274, 0, 124 },
+{ 0xc0, 274, 0, 137 },
+{ 0x2c0, 274, 0, 135 },
+{ 0x1c0, 274, 0, 136 },
+{ 0x20, 274, 0, 152 },
+{ 0xa0, 274, 0, 150 },
+{ 0x60, 274, 0, 151 },
+{ 0x10, 274, 0, 164 },
+{ 0x50, 274, 0, 162 },
+{ 0x30, 274, 0, 163 },
+{ 0x8, 274, 0, 176 },
+{ 0x28, 274, 0, 174 },
+{ 0x18, 274, 0, 175 },
+{ 0x4, 274, 0, 186 },
+{ 0x2, 274, 0, 187 },
+{ 0x1, 274, 0, 188 },
+{ 0x140, 286, 0, 128 },
+{ 0x540, 286, 0, 126 },
+{ 0x340, 286, 0, 127 },
+{ 0xc0, 286, 0, 140 },
+{ 0x2c0, 286, 0, 138 },
+{ 0x1c0, 286, 0, 139 },
+{ 0x20, 286, 0, 155 },
+{ 0xa0, 286, 0, 153 },
+{ 0x60, 286, 0, 154 },
+{ 0x10, 286, 0, 167 },
+{ 0x50, 286, 0, 165 },
+{ 0x30, 286, 0, 166 },
+{ 0x8, 286, 0, 179 },
+{ 0x28, 286, 0, 177 },
+{ 0x18, 286, 0, 178 },
+{ 0x4, 286, 0, 189 },
+{ 0x2, 286, 0, 190 },
+{ 0x1, 286, 0, 191 },
+{ 0x8, 390, 0, 192 },
+{ 0x4, 390, 0, 193 },
+{ 0x2, 390, 0, 194 },
+{ 0x1, 390, 0, 195 },
+{ 0x20, 288, 0, 203 },
+{ 0x220, 288, 0, 199 },
+{ 0x1220, 288, 0, 196 },
+{ 0xa20, 288, 0, 197 },
+{ 0x620, 288, 0, 198 },
+{ 0x120, 288, 0, 200 },
+{ 0xa0, 288, 0, 201 },
+{ 0x60, 288, 0, 202 },
+{ 0x10, 288, 0, 207 },
+{ 0x90, 288, 0, 204 },
+{ 0x50, 288, 0, 205 },
+{ 0x30, 288, 0, 206 },
+{ 0x8, 288, 0, 208 },
+{ 0x4, 288, 0, 209 },
+{ 0x2, 288, 0, 210 },
+{ 0x1, 288, 0, 211 },
+{ 0x20, 287, 0, 219 },
+{ 0x220, 287, 0, 215 },
+{ 0x1220, 287, 0, 212 },
+{ 0xa20, 287, 0, 213 },
+{ 0x620, 287, 0, 214 },
+{ 0x120, 287, 0, 216 },
+{ 0xa0, 287, 0, 217 },
+{ 0x60, 287, 0, 218 },
+{ 0x10, 287, 0, 223 },
+{ 0x90, 287, 0, 220 },
+{ 0x50, 287, 0, 221 },
+{ 0x30, 287, 0, 222 },
+{ 0x8, 287, 0, 224 },
+{ 0x4, 287, 0, 225 },
+{ 0x2, 287, 0, 226 },
+{ 0x1, 287, 0, 227 },
+{ 0x140, 279, 0, 230 },
+{ 0x540, 279, 0, 228 },
+{ 0x340, 279, 0, 229 },
+{ 0xc0, 279, 0, 239 },
+{ 0x2c0, 279, 0, 237 },
+{ 0x1c0, 279, 0, 238 },
+{ 0x20, 279, 0, 248 },
+{ 0xa0, 279, 0, 246 },
+{ 0x60, 279, 0, 247 },
+{ 0x10, 279, 0, 257 },
+{ 0x50, 279, 0, 255 },
+{ 0x30, 279, 0, 256 },
+{ 0x8, 279, 0, 266 },
+{ 0x28, 279, 0, 264 },
+{ 0x18, 279, 0, 265 },
+{ 0x4, 279, 0, 273 },
+{ 0x2, 279, 0, 274 },
+{ 0x1, 279, 0, 275 },
+{ 0x140, 281, 0, 233 },
+{ 0x540, 281, 0, 231 },
+{ 0x340, 281, 0, 232 },
+{ 0xc0, 281, 0, 242 },
+{ 0x2c0, 281, 0, 240 },
+{ 0x1c0, 281, 0, 241 },
+{ 0x20, 281, 0, 251 },
+{ 0xa0, 281, 0, 249 },
+{ 0x60, 281, 0, 250 },
+{ 0x10, 281, 0, 260 },
+{ 0x50, 281, 0, 258 },
+{ 0x30, 281, 0, 259 },
+{ 0x8, 281, 0, 269 },
+{ 0x28, 281, 0, 267 },
+{ 0x18, 281, 0, 268 },
+{ 0x4, 281, 0, 276 },
+{ 0x2, 281, 0, 277 },
+{ 0x1, 281, 0, 278 },
+{ 0x140, 283, 0, 236 },
+{ 0x540, 283, 0, 234 },
+{ 0x340, 283, 0, 235 },
+{ 0xc0, 283, 0, 245 },
+{ 0x2c0, 283, 0, 243 },
+{ 0x1c0, 283, 0, 244 },
+{ 0x20, 283, 0, 254 },
+{ 0xa0, 283, 0, 252 },
+{ 0x60, 283, 0, 253 },
+{ 0x10, 283, 0, 263 },
+{ 0x50, 283, 0, 261 },
+{ 0x30, 283, 0, 262 },
+{ 0x8, 283, 0, 272 },
+{ 0x28, 283, 0, 270 },
+{ 0x18, 283, 0, 271 },
+{ 0x4, 283, 0, 279 },
+{ 0x2, 283, 0, 280 },
+{ 0x1, 283, 0, 281 },
+{ 0x140, 278, 0, 284 },
+{ 0x540, 278, 0, 282 },
+{ 0x340, 278, 0, 283 },
+{ 0xc0, 278, 0, 293 },
+{ 0x2c0, 278, 0, 291 },
+{ 0x1c0, 278, 0, 292 },
+{ 0x20, 278, 0, 302 },
+{ 0xa0, 278, 0, 300 },
+{ 0x60, 278, 0, 301 },
+{ 0x10, 278, 0, 311 },
+{ 0x50, 278, 0, 309 },
+{ 0x30, 278, 0, 310 },
+{ 0x8, 278, 0, 320 },
+{ 0x28, 278, 0, 318 },
+{ 0x18, 278, 0, 319 },
+{ 0x4, 278, 0, 327 },
+{ 0x2, 278, 0, 328 },
+{ 0x1, 278, 0, 329 },
+{ 0x140, 280, 0, 287 },
+{ 0x540, 280, 0, 285 },
+{ 0x340, 280, 0, 286 },
+{ 0xc0, 280, 0, 296 },
+{ 0x2c0, 280, 0, 294 },
+{ 0x1c0, 280, 0, 295 },
+{ 0x20, 280, 0, 305 },
+{ 0xa0, 280, 0, 303 },
+{ 0x60, 280, 0, 304 },
+{ 0x10, 280, 0, 314 },
+{ 0x50, 280, 0, 312 },
+{ 0x30, 280, 0, 313 },
+{ 0x8, 280, 0, 323 },
+{ 0x28, 280, 0, 321 },
+{ 0x18, 280, 0, 322 },
+{ 0x4, 280, 0, 330 },
+{ 0x2, 280, 0, 331 },
+{ 0x1, 280, 0, 332 },
+{ 0x140, 282, 0, 290 },
+{ 0x540, 282, 0, 288 },
+{ 0x340, 282, 0, 289 },
+{ 0xc0, 282, 0, 299 },
+{ 0x2c0, 282, 0, 297 },
+{ 0x1c0, 282, 0, 298 },
+{ 0x20, 282, 0, 308 },
+{ 0xa0, 282, 0, 306 },
+{ 0x60, 282, 0, 307 },
+{ 0x10, 282, 0, 317 },
+{ 0x50, 282, 0, 315 },
+{ 0x30, 282, 0, 316 },
+{ 0x8, 282, 0, 326 },
+{ 0x28, 282, 0, 324 },
+{ 0x18, 282, 0, 325 },
+{ 0x4, 282, 0, 333 },
+{ 0x2, 282, 0, 334 },
+{ 0x1, 282, 0, 335 },
+{ 0x1, 410, 0, 337 },
+{ 0x3, 410, 0, 336 },
+{ 0x2, 416, 0, 338 },
+{ 0x1, 416, 0, 339 },
+{ 0x2, 412, 0, 340 },
+{ 0x1, 412, 0, 341 },
+{ 0x2, 414, 0, 342 },
+{ 0x1, 414, 0, 343 },
+{ 0x2, 418, 0, 344 },
+{ 0x1, 418, 0, 345 },
+{ 0x1, 267, 0, 372 },
+{ 0x5, 267, 0, 370 },
+{ 0x3, 267, 0, 371 },
+{ 0x140, 276, 0, 348 },
+{ 0x540, 276, 0, 346 },
+{ 0x340, 276, 0, 347 },
+{ 0xc0, 276, 0, 360 },
+{ 0x2c0, 276, 0, 358 },
+{ 0x1c0, 276, 0, 359 },
+{ 0x20, 276, 0, 375 },
+{ 0xa0, 276, 0, 373 },
+{ 0x60, 276, 0, 374 },
+{ 0x10, 276, 0, 387 },
+{ 0x50, 276, 0, 385 },
+{ 0x30, 276, 0, 386 },
+{ 0x8, 276, 0, 399 },
+{ 0x28, 276, 0, 397 },
+{ 0x18, 276, 0, 398 },
+{ 0x4, 276, 0, 409 },
+{ 0x2, 276, 0, 410 },
+{ 0x1, 276, 0, 411 },
+{ 0x140, 270, 0, 351 },
+{ 0x540, 270, 0, 349 },
+{ 0x340, 270, 0, 350 },
+{ 0xc0, 270, 0, 363 },
+{ 0x2c0, 270, 0, 361 },
+{ 0x1c0, 270, 0, 362 },
+{ 0x20, 270, 0, 378 },
+{ 0xa0, 270, 0, 376 },
+{ 0x60, 270, 0, 377 },
+{ 0x10, 270, 0, 390 },
+{ 0x50, 270, 0, 388 },
+{ 0x30, 270, 0, 389 },
+{ 0x8, 270, 0, 402 },
+{ 0x28, 270, 0, 400 },
+{ 0x18, 270, 0, 401 },
+{ 0x4, 270, 0, 412 },
+{ 0x2, 270, 0, 413 },
+{ 0x1, 270, 0, 414 },
+{ 0x140, 273, 0, 354 },
+{ 0x540, 273, 0, 352 },
+{ 0x340, 273, 0, 353 },
+{ 0xc0, 273, 0, 366 },
+{ 0x2c0, 273, 0, 364 },
+{ 0x1c0, 273, 0, 365 },
+{ 0x20, 273, 0, 381 },
+{ 0xa0, 273, 0, 379 },
+{ 0x60, 273, 0, 380 },
+{ 0x10, 273, 0, 393 },
+{ 0x50, 273, 0, 391 },
+{ 0x30, 273, 0, 392 },
+{ 0x8, 273, 0, 405 },
+{ 0x28, 273, 0, 403 },
+{ 0x18, 273, 0, 404 },
+{ 0x4, 273, 0, 415 },
+{ 0x2, 273, 0, 416 },
+{ 0x1, 273, 0, 417 },
+{ 0x140, 285, 0, 357 },
+{ 0x540, 285, 0, 355 },
+{ 0x340, 285, 0, 356 },
+{ 0xc0, 285, 0, 369 },
+{ 0x2c0, 285, 0, 367 },
+{ 0x1c0, 285, 0, 368 },
+{ 0x20, 285, 0, 384 },
+{ 0xa0, 285, 0, 382 },
+{ 0x60, 285, 0, 383 },
+{ 0x10, 285, 0, 396 },
+{ 0x50, 285, 0, 394 },
+{ 0x30, 285, 0, 395 },
+{ 0x8, 285, 0, 408 },
+{ 0x28, 285, 0, 406 },
+{ 0x18, 285, 0, 407 },
+{ 0x4, 285, 0, 418 },
+{ 0x2, 285, 0, 419 },
+{ 0x1, 285, 0, 420 },
+{ 0x1, 266, 0, 447 },
+{ 0x5, 266, 0, 445 },
+{ 0x3, 266, 0, 446 },
+{ 0x140, 275, 0, 423 },
+{ 0x540, 275, 0, 421 },
+{ 0x340, 275, 0, 422 },
+{ 0xc0, 275, 0, 435 },
+{ 0x2c0, 275, 0, 433 },
+{ 0x1c0, 275, 0, 434 },
+{ 0x20, 275, 0, 450 },
+{ 0xa0, 275, 0, 448 },
+{ 0x60, 275, 0, 449 },
+{ 0x10, 275, 0, 462 },
+{ 0x50, 275, 0, 460 },
+{ 0x30, 275, 0, 461 },
+{ 0x8, 275, 0, 474 },
+{ 0x28, 275, 0, 472 },
+{ 0x18, 275, 0, 473 },
+{ 0x4, 275, 0, 484 },
+{ 0x2, 275, 0, 485 },
+{ 0x1, 275, 0, 486 },
+{ 0x140, 269, 0, 426 },
+{ 0x540, 269, 0, 424 },
+{ 0x340, 269, 0, 425 },
+{ 0xc0, 269, 0, 438 },
+{ 0x2c0, 269, 0, 436 },
+{ 0x1c0, 269, 0, 437 },
+{ 0x20, 269, 0, 453 },
+{ 0xa0, 269, 0, 451 },
+{ 0x60, 269, 0, 452 },
+{ 0x10, 269, 0, 465 },
+{ 0x50, 269, 0, 463 },
+{ 0x30, 269, 0, 464 },
+{ 0x8, 269, 0, 477 },
+{ 0x28, 269, 0, 475 },
+{ 0x18, 269, 0, 476 },
+{ 0x4, 269, 0, 487 },
+{ 0x2, 269, 0, 488 },
+{ 0x1, 269, 0, 489 },
+{ 0x140, 272, 0, 429 },
+{ 0x540, 272, 0, 427 },
+{ 0x340, 272, 0, 428 },
+{ 0xc0, 272, 0, 441 },
+{ 0x2c0, 272, 0, 439 },
+{ 0x1c0, 272, 0, 440 },
+{ 0x20, 272, 0, 456 },
+{ 0xa0, 272, 0, 454 },
+{ 0x60, 272, 0, 455 },
+{ 0x10, 272, 0, 468 },
+{ 0x50, 272, 0, 466 },
+{ 0x30, 272, 0, 467 },
+{ 0x8, 272, 0, 480 },
+{ 0x28, 272, 0, 478 },
+{ 0x18, 272, 0, 479 },
+{ 0x4, 272, 0, 490 },
+{ 0x2, 272, 0, 491 },
+{ 0x1, 272, 0, 492 },
+{ 0x140, 284, 0, 432 },
+{ 0x540, 284, 0, 430 },
+{ 0x340, 284, 0, 431 },
+{ 0xc0, 284, 0, 444 },
+{ 0x2c0, 284, 0, 442 },
+{ 0x1c0, 284, 0, 443 },
+{ 0x20, 284, 0, 459 },
+{ 0xa0, 284, 0, 457 },
+{ 0x60, 284, 0, 458 },
+{ 0x10, 284, 0, 471 },
+{ 0x50, 284, 0, 469 },
+{ 0x30, 284, 0, 470 },
+{ 0x8, 284, 0, 483 },
+{ 0x28, 284, 0, 481 },
+{ 0x18, 284, 0, 482 },
+{ 0x4, 284, 0, 493 },
+{ 0x2, 284, 0, 494 },
+{ 0x1, 284, 0, 495 },
+{ 0x8, 409, 0, 497 },
+{ 0x18, 409, 0, 496 },
+{ 0x4, 409, 0, 499 },
+{ 0xc, 409, 0, 498 },
+{ 0x2, 409, 0, 506 },
+{ 0x1, 409, 0, 507 },
+{ 0x4, 407, 0, 501 },
+{ 0xc, 407, 0, 500 },
+{ 0x2, 407, 0, 508 },
+{ 0x1, 407, 0, 509 },
+{ 0x4, 405, 0, 503 },
+{ 0xc, 405, 0, 502 },
+{ 0x2, 405, 0, 510 },
+{ 0x1, 405, 0, 511 },
+{ 0x4, 401, 0, 505 },
+{ 0xc, 401, 0, 504 },
+{ 0x2, 401, 0, 512 },
+{ 0x1, 401, 0, 513 },
+{ 0xa00, 265, 0, 528 },
+{ 0x2a00, 265, 0, 526 },
+{ 0x1a00, 265, 0, 527 },
+{ 0x600, 265, 0, 540 },
+{ 0x2600, 265, 0, 516 },
+{ 0xa600, 265, 0, 514 },
+{ 0x6600, 265, 0, 515 },
+{ 0x1600, 265, 0, 538 },
+{ 0xe00, 265, 0, 539 },
+{ 0x100, 265, 0, 552 },
+{ 0x500, 265, 0, 550 },
+{ 0x300, 265, 0, 551 },
+{ 0x80, 265, 0, 555 },
+{ 0x280, 265, 0, 553 },
+{ 0x180, 265, 0, 554 },
+{ 0x40, 265, 0, 567 },
+{ 0x140, 265, 0, 565 },
+{ 0xc0, 265, 0, 566 },
+{ 0x20, 265, 0, 579 },
+{ 0xa0, 265, 0, 577 },
+{ 0x60, 265, 0, 578 },
+{ 0x10, 265, 0, 591 },
+{ 0x50, 265, 0, 589 },
+{ 0x30, 265, 0, 590 },
+{ 0x8, 265, 0, 603 },
+{ 0x28, 265, 0, 601 },
+{ 0x18, 265, 0, 602 },
+{ 0x4, 265, 0, 613 },
+{ 0x2, 265, 0, 614 },
+{ 0x1, 265, 0, 615 },
+{ 0x500, 261, 0, 531 },
+{ 0x1500, 261, 0, 529 },
+{ 0xd00, 261, 0, 530 },
+{ 0x300, 261, 0, 543 },
+{ 0x1300, 261, 0, 519 },
+{ 0x5300, 261, 0, 517 },
+{ 0x3300, 261, 0, 518 },
+{ 0xb00, 261, 0, 541 },
+{ 0x700, 261, 0, 542 },
+{ 0x80, 261, 0, 558 },
+{ 0x280, 261, 0, 556 },
+{ 0x180, 261, 0, 557 },
+{ 0x40, 261, 0, 570 },
+{ 0x140, 261, 0, 568 },
+{ 0xc0, 261, 0, 569 },
+{ 0x20, 261, 0, 582 },
+{ 0xa0, 261, 0, 580 },
+{ 0x60, 261, 0, 581 },
+{ 0x10, 261, 0, 594 },
+{ 0x50, 261, 0, 592 },
+{ 0x30, 261, 0, 593 },
+{ 0x8, 261, 0, 606 },
+{ 0x28, 261, 0, 604 },
+{ 0x18, 261, 0, 605 },
+{ 0x4, 261, 0, 616 },
+{ 0x2, 261, 0, 617 },
+{ 0x1, 261, 0, 618 },
+{ 0x500, 258, 0, 534 },
+{ 0x1500, 258, 0, 532 },
+{ 0xd00, 258, 0, 533 },
+{ 0x300, 258, 0, 546 },
+{ 0x1300, 258, 0, 522 },
+{ 0x5300, 258, 0, 520 },
+{ 0x3300, 258, 0, 521 },
+{ 0xb00, 258, 0, 544 },
+{ 0x700, 258, 0, 545 },
+{ 0x80, 258, 0, 561 },
+{ 0x280, 258, 0, 559 },
+{ 0x180, 258, 0, 560 },
+{ 0x40, 258, 0, 573 },
+{ 0x140, 258, 0, 571 },
+{ 0xc0, 258, 0, 572 },
+{ 0x20, 258, 0, 585 },
+{ 0xa0, 258, 0, 583 },
+{ 0x60, 258, 0, 584 },
+{ 0x10, 258, 0, 597 },
+{ 0x50, 258, 0, 595 },
+{ 0x30, 258, 0, 596 },
+{ 0x8, 258, 0, 609 },
+{ 0x28, 258, 0, 607 },
+{ 0x18, 258, 0, 608 },
+{ 0x4, 258, 0, 619 },
+{ 0x2, 258, 0, 620 },
+{ 0x1, 258, 0, 621 },
+{ 0x500, 253, 0, 537 },
+{ 0x1500, 253, 0, 535 },
+{ 0xd00, 253, 0, 536 },
+{ 0x300, 253, 0, 549 },
+{ 0x1300, 253, 0, 525 },
+{ 0x5300, 253, 0, 523 },
+{ 0x3300, 253, 0, 524 },
+{ 0xb00, 253, 0, 547 },
+{ 0x700, 253, 0, 548 },
+{ 0x80, 253, 0, 564 },
+{ 0x280, 253, 0, 562 },
+{ 0x180, 253, 0, 563 },
+{ 0x40, 253, 0, 576 },
+{ 0x140, 253, 0, 574 },
+{ 0xc0, 253, 0, 575 },
+{ 0x20, 253, 0, 588 },
+{ 0xa0, 253, 0, 586 },
+{ 0x60, 253, 0, 587 },
+{ 0x10, 253, 0, 600 },
+{ 0x50, 253, 0, 598 },
+{ 0x30, 253, 0, 599 },
+{ 0x8, 253, 0, 612 },
+{ 0x28, 253, 0, 610 },
+{ 0x18, 253, 0, 611 },
+{ 0x4, 253, 0, 622 },
+{ 0x2, 253, 0, 623 },
+{ 0x1, 253, 0, 624 },
+{ 0x8, 238, 0, 625 },
+{ 0x4, 238, 0, 626 },
+{ 0x2, 238, 0, 627 },
+{ 0x1, 238, 0, 628 },
+{ 0x2, 176, 0, 631 },
+{ 0xa, 176, 0, 629 },
+{ 0x6, 176, 0, 630 },
+{ 0x1, 176, 0, 637 },
+{ 0x5, 176, 0, 635 },
+{ 0x3, 176, 0, 636 },
+{ 0x2, 175, 0, 634 },
+{ 0xa, 175, 0, 632 },
+{ 0x6, 175, 0, 633 },
+{ 0x1, 175, 0, 640 },
+{ 0x5, 175, 0, 638 },
+{ 0x3, 175, 0, 639 },
+{ 0x4, 446, 0, 641 },
+{ 0x2, 446, 0, 642 },
+{ 0x1, 446, 0, 643 },
+{ 0x4, 445, 0, 644 },
+{ 0x2, 445, 0, 645 },
+{ 0x1, 445, 0, 646 },
+{ 0x4, 444, 0, 647 },
+{ 0x2, 444, 0, 648 },
+{ 0x1, 444, 0, 649 },
+{ 0x4, 443, 0, 650 },
+{ 0x2, 443, 0, 651 },
+{ 0x1, 443, 0, 652 },
+{ 0x2, 123, 1, 658 },
+{ 0x2, 124, 0, 657 },
+{ 0xa, 123, 1, 654 },
+{ 0xa, 124, 0, 653 },
+{ 0x6, 123, 1, 656 },
+{ 0x6, 124, 0, 655 },
+{ 0x1, 123, 1, 688 },
+{ 0x1, 124, 0, 687 },
+{ 0x5, 123, 1, 684 },
+{ 0x5, 124, 0, 683 },
+{ 0x3, 123, 1, 686 },
+{ 0x3, 124, 0, 685 },
+{ 0x2, 131, 1, 664 },
+{ 0x2, 132, 0, 663 },
+{ 0xa, 131, 1, 660 },
+{ 0xa, 132, 0, 659 },
+{ 0x6, 131, 1, 662 },
+{ 0x6, 132, 0, 661 },
+{ 0x1, 131, 1, 694 },
+{ 0x1, 132, 0, 693 },
+{ 0x5, 131, 1, 690 },
+{ 0x5, 132, 0, 689 },
+{ 0x3, 131, 1, 692 },
+{ 0x3, 132, 0, 691 },
+{ 0x2, 129, 1, 670 },
+{ 0x2, 130, 0, 669 },
+{ 0xa, 129, 1, 666 },
+{ 0xa, 130, 0, 665 },
+{ 0x6, 129, 1, 668 },
+{ 0x6, 130, 0, 667 },
+{ 0x1, 129, 1, 700 },
+{ 0x1, 130, 0, 699 },
+{ 0x5, 129, 1, 696 },
+{ 0x5, 130, 0, 695 },
+{ 0x3, 129, 1, 698 },
+{ 0x3, 130, 0, 697 },
+{ 0x2, 127, 1, 676 },
+{ 0x2, 128, 0, 675 },
+{ 0xa, 127, 1, 672 },
+{ 0xa, 128, 0, 671 },
+{ 0x6, 127, 1, 674 },
+{ 0x6, 128, 0, 673 },
+{ 0x1, 127, 1, 706 },
+{ 0x1, 128, 0, 705 },
+{ 0x5, 127, 1, 702 },
+{ 0x5, 128, 0, 701 },
+{ 0x3, 127, 1, 704 },
+{ 0x3, 128, 0, 703 },
+{ 0x2, 125, 1, 682 },
+{ 0x2, 126, 0, 681 },
+{ 0xa, 125, 1, 678 },
+{ 0xa, 126, 0, 677 },
+{ 0x6, 125, 1, 680 },
+{ 0x6, 126, 0, 679 },
+{ 0x1, 125, 1, 712 },
+{ 0x1, 126, 0, 711 },
+{ 0x5, 125, 1, 708 },
+{ 0x5, 126, 0, 707 },
+{ 0x3, 125, 1, 710 },
+{ 0x3, 126, 0, 709 },
+{ 0x4, 402, 1, 718 },
+{ 0x4, 403, 0, 717 },
+{ 0xc, 402, 1, 716 },
+{ 0xc, 403, 0, 715 },
+{ 0x2, 402, 1, 728 },
+{ 0x2, 403, 0, 727 },
+{ 0x1, 402, 1, 730 },
+{ 0x1, 403, 0, 729 },
+{ 0x8, 408, 0, 714 },
+{ 0x18, 408, 0, 713 },
+{ 0x4, 408, 0, 720 },
+{ 0xc, 408, 0, 719 },
+{ 0x2, 408, 0, 731 },
+{ 0x1, 408, 0, 732 },
+{ 0x4, 406, 0, 722 },
+{ 0xc, 406, 0, 721 },
+{ 0x2, 406, 0, 733 },
+{ 0x1, 406, 0, 734 },
+{ 0x4, 404, 0, 724 },
+{ 0xc, 404, 0, 723 },
+{ 0x2, 404, 0, 735 },
+{ 0x1, 404, 0, 736 },
+{ 0x4, 400, 0, 726 },
+{ 0xc, 400, 0, 725 },
+{ 0x2, 400, 0, 737 },
+{ 0x1, 400, 0, 738 },
+{ 0xa00, 264, 0, 753 },
+{ 0x2a00, 264, 0, 751 },
+{ 0x1a00, 264, 0, 752 },
+{ 0x600, 264, 0, 765 },
+{ 0x2600, 264, 0, 741 },
+{ 0xa600, 264, 0, 739 },
+{ 0x6600, 264, 0, 740 },
+{ 0x1600, 264, 0, 763 },
+{ 0xe00, 264, 0, 764 },
+{ 0x100, 264, 0, 777 },
+{ 0x500, 264, 0, 775 },
+{ 0x300, 264, 0, 776 },
+{ 0x80, 264, 0, 780 },
+{ 0x280, 264, 0, 778 },
+{ 0x180, 264, 0, 779 },
+{ 0x40, 264, 0, 792 },
+{ 0x140, 264, 0, 790 },
+{ 0xc0, 264, 0, 791 },
+{ 0x20, 264, 0, 804 },
+{ 0xa0, 264, 0, 802 },
+{ 0x60, 264, 0, 803 },
+{ 0x10, 264, 0, 816 },
+{ 0x50, 264, 0, 814 },
+{ 0x30, 264, 0, 815 },
+{ 0x8, 264, 0, 828 },
+{ 0x28, 264, 0, 826 },
+{ 0x18, 264, 0, 827 },
+{ 0x4, 264, 0, 838 },
+{ 0x2, 264, 0, 839 },
+{ 0x1, 264, 0, 840 },
+{ 0x500, 260, 0, 756 },
+{ 0x1500, 260, 0, 754 },
+{ 0xd00, 260, 0, 755 },
+{ 0x300, 260, 0, 768 },
+{ 0x1300, 260, 0, 744 },
+{ 0x5300, 260, 0, 742 },
+{ 0x3300, 260, 0, 743 },
+{ 0xb00, 260, 0, 766 },
+{ 0x700, 260, 0, 767 },
+{ 0x80, 260, 0, 783 },
+{ 0x280, 260, 0, 781 },
+{ 0x180, 260, 0, 782 },
+{ 0x40, 260, 0, 795 },
+{ 0x140, 260, 0, 793 },
+{ 0xc0, 260, 0, 794 },
+{ 0x20, 260, 0, 807 },
+{ 0xa0, 260, 0, 805 },
+{ 0x60, 260, 0, 806 },
+{ 0x10, 260, 0, 819 },
+{ 0x50, 260, 0, 817 },
+{ 0x30, 260, 0, 818 },
+{ 0x8, 260, 0, 831 },
+{ 0x28, 260, 0, 829 },
+{ 0x18, 260, 0, 830 },
+{ 0x4, 260, 0, 841 },
+{ 0x2, 260, 0, 842 },
+{ 0x1, 260, 0, 843 },
+{ 0x500, 257, 0, 759 },
+{ 0x1500, 257, 0, 757 },
+{ 0xd00, 257, 0, 758 },
+{ 0x300, 257, 0, 771 },
+{ 0x1300, 257, 0, 747 },
+{ 0x5300, 257, 0, 745 },
+{ 0x3300, 257, 0, 746 },
+{ 0xb00, 257, 0, 769 },
+{ 0x700, 257, 0, 770 },
+{ 0x80, 257, 0, 786 },
+{ 0x280, 257, 0, 784 },
+{ 0x180, 257, 0, 785 },
+{ 0x40, 257, 0, 798 },
+{ 0x140, 257, 0, 796 },
+{ 0xc0, 257, 0, 797 },
+{ 0x20, 257, 0, 810 },
+{ 0xa0, 257, 0, 808 },
+{ 0x60, 257, 0, 809 },
+{ 0x10, 257, 0, 822 },
+{ 0x50, 257, 0, 820 },
+{ 0x30, 257, 0, 821 },
+{ 0x8, 257, 0, 834 },
+{ 0x28, 257, 0, 832 },
+{ 0x18, 257, 0, 833 },
+{ 0x4, 257, 0, 844 },
+{ 0x2, 257, 0, 845 },
+{ 0x1, 257, 0, 846 },
+{ 0x500, 252, 0, 762 },
+{ 0x1500, 252, 0, 760 },
+{ 0xd00, 252, 0, 761 },
+{ 0x300, 252, 0, 774 },
+{ 0x1300, 252, 0, 750 },
+{ 0x5300, 252, 0, 748 },
+{ 0x3300, 252, 0, 749 },
+{ 0xb00, 252, 0, 772 },
+{ 0x700, 252, 0, 773 },
+{ 0x80, 252, 0, 789 },
+{ 0x280, 252, 0, 787 },
+{ 0x180, 252, 0, 788 },
+{ 0x40, 252, 0, 801 },
+{ 0x140, 252, 0, 799 },
+{ 0xc0, 252, 0, 800 },
+{ 0x20, 252, 0, 813 },
+{ 0xa0, 252, 0, 811 },
+{ 0x60, 252, 0, 812 },
+{ 0x10, 252, 0, 825 },
+{ 0x50, 252, 0, 823 },
+{ 0x30, 252, 0, 824 },
+{ 0x8, 252, 0, 837 },
+{ 0x28, 252, 0, 835 },
+{ 0x18, 252, 0, 836 },
+{ 0x4, 252, 0, 847 },
+{ 0x2, 252, 0, 848 },
+{ 0x1, 252, 0, 849 },
+{ 0x8, 254, 1, 895 },
+{ 0x8, 255, 0, 894 },
+{ 0x28, 254, 1, 891 },
+{ 0x28, 255, 0, 890 },
+{ 0x18, 254, 1, 893 },
+{ 0x18, 255, 0, 892 },
+{ 0x4, 254, 1, 957 },
+{ 0x4, 255, 0, 956 },
+{ 0x2, 254, 1, 959 },
+{ 0x2, 255, 0, 958 },
+{ 0x1, 254, 1, 961 },
+{ 0x1, 255, 0, 960 },
+{ 0xa00, 262, 0, 865 },
+{ 0x2a00, 262, 0, 863 },
+{ 0x1a00, 262, 0, 864 },
+{ 0x600, 262, 0, 877 },
+{ 0x2600, 262, 0, 853 },
+{ 0xa600, 262, 0, 851 },
+{ 0x6600, 262, 0, 852 },
+{ 0x1600, 262, 0, 875 },
+{ 0xe00, 262, 0, 876 },
+{ 0x100, 262, 0, 889 },
+{ 0x500, 262, 0, 887 },
+{ 0x300, 262, 0, 888 },
+{ 0x80, 262, 0, 898 },
+{ 0x280, 262, 0, 896 },
+{ 0x180, 262, 0, 897 },
+{ 0x40, 262, 0, 910 },
+{ 0x140, 262, 0, 908 },
+{ 0xc0, 262, 0, 909 },
+{ 0x20, 262, 0, 922 },
+{ 0xa0, 262, 0, 920 },
+{ 0x60, 262, 0, 921 },
+{ 0x10, 262, 0, 934 },
+{ 0x50, 262, 0, 932 },
+{ 0x30, 262, 0, 933 },
+{ 0x8, 262, 0, 946 },
+{ 0x28, 262, 0, 944 },
+{ 0x18, 262, 0, 945 },
+{ 0x4, 262, 0, 962 },
+{ 0x2, 262, 0, 963 },
+{ 0x1, 262, 1, 964 },
+{ 0x1, 263, 0, 850 },
+{ 0x500, 259, 0, 868 },
+{ 0x1500, 259, 0, 866 },
+{ 0xd00, 259, 0, 867 },
+{ 0x300, 259, 0, 880 },
+{ 0x1300, 259, 0, 856 },
+{ 0x5300, 259, 0, 854 },
+{ 0x3300, 259, 0, 855 },
+{ 0xb00, 259, 0, 878 },
+{ 0x700, 259, 0, 879 },
+{ 0x80, 259, 0, 901 },
+{ 0x280, 259, 0, 899 },
+{ 0x180, 259, 0, 900 },
+{ 0x40, 259, 0, 913 },
+{ 0x140, 259, 0, 911 },
+{ 0xc0, 259, 0, 912 },
+{ 0x20, 259, 0, 925 },
+{ 0xa0, 259, 0, 923 },
+{ 0x60, 259, 0, 924 },
+{ 0x10, 259, 0, 937 },
+{ 0x50, 259, 0, 935 },
+{ 0x30, 259, 0, 936 },
+{ 0x8, 259, 0, 949 },
+{ 0x28, 259, 0, 947 },
+{ 0x18, 259, 0, 948 },
+{ 0x4, 259, 0, 965 },
+{ 0x2, 259, 0, 966 },
+{ 0x1, 259, 0, 967 },
+{ 0x500, 256, 0, 871 },
+{ 0x1500, 256, 0, 869 },
+{ 0xd00, 256, 0, 870 },
+{ 0x300, 256, 0, 883 },
+{ 0x1300, 256, 0, 859 },
+{ 0x5300, 256, 0, 857 },
+{ 0x3300, 256, 0, 858 },
+{ 0xb00, 256, 0, 881 },
+{ 0x700, 256, 0, 882 },
+{ 0x80, 256, 0, 904 },
+{ 0x280, 256, 0, 902 },
+{ 0x180, 256, 0, 903 },
+{ 0x40, 256, 0, 916 },
+{ 0x140, 256, 0, 914 },
+{ 0xc0, 256, 0, 915 },
+{ 0x20, 256, 0, 928 },
+{ 0xa0, 256, 0, 926 },
+{ 0x60, 256, 0, 927 },
+{ 0x10, 256, 0, 940 },
+{ 0x50, 256, 0, 938 },
+{ 0x30, 256, 0, 939 },
+{ 0x8, 256, 0, 952 },
+{ 0x28, 256, 0, 950 },
+{ 0x18, 256, 0, 951 },
+{ 0x4, 256, 0, 968 },
+{ 0x2, 256, 0, 969 },
+{ 0x1, 256, 0, 970 },
+{ 0x500, 251, 0, 874 },
+{ 0x1500, 251, 0, 872 },
+{ 0xd00, 251, 0, 873 },
+{ 0x300, 251, 0, 886 },
+{ 0x1300, 251, 0, 862 },
+{ 0x5300, 251, 0, 860 },
+{ 0x3300, 251, 0, 861 },
+{ 0xb00, 251, 0, 884 },
+{ 0x700, 251, 0, 885 },
+{ 0x80, 251, 0, 907 },
+{ 0x280, 251, 0, 905 },
+{ 0x180, 251, 0, 906 },
+{ 0x40, 251, 0, 919 },
+{ 0x140, 251, 0, 917 },
+{ 0xc0, 251, 0, 918 },
+{ 0x20, 251, 0, 931 },
+{ 0xa0, 251, 0, 929 },
+{ 0x60, 251, 0, 930 },
+{ 0x10, 251, 0, 943 },
+{ 0x50, 251, 0, 941 },
+{ 0x30, 251, 0, 942 },
+{ 0x8, 251, 0, 955 },
+{ 0x28, 251, 0, 953 },
+{ 0x18, 251, 0, 954 },
+{ 0x4, 251, 0, 971 },
+{ 0x2, 251, 0, 972 },
+{ 0x1, 251, 0, 973 },
+{ 0x2, 150, 0, 975 },
+{ 0x1, 150, 0, 976 },
+{ 0x1, 50, 0, 977 },
+{ 0x3, 49, 0, 978 },
+{ 0x1, 428, 0, 979 },
+{ 0x1, 438, 0, 980 },
+{ 0x2, 386, 0, 983 },
+{ 0x1, 386, 0, 984 },
+{ 0x2, 384, 0, 985 },
+{ 0x1, 384, 0, 986 },
+{ 0x1, 383, 0, 987 },
+{ 0x1, 328, 0, 992 },
+{ 0x1, 327, 0, 993 },
+{ 0x1, 326, 0, 994 },
+{ 0x1, 325, 0, 995 },
+{ 0x1, 250, 0, 996 },
+{ 0x1, 249, 0, 997 },
+{ 0x1, 324, 0, 998 },
+{ 0x1, 323, 0, 999 },
+{ 0x1, 322, 0, 1000 },
+{ 0x1, 321, 0, 1001 },
+{ 0x1, 320, 0, 1002 },
+{ 0x1, 319, 0, 1003 },
+{ 0x1, 318, 0, 1004 },
+{ 0x2, 248, 0, 1005 },
+{ 0x1, 248, 0, 1006 },
+{ 0x2, 366, 0, 1012 },
+{ 0x1, 366, 0, 1013 },
+{ 0x1, 317, 0, 1014 },
+{ 0x1, 316, 0, 1015 },
+{ 0x1, 315, 0, 1016 },
+{ 0x1, 314, 0, 1017 },
+{ 0x1, 8, 1, 1019 },
+{ 0x1, 9, 0, 1018 },
+{ 0x1, 313, 0, 1020 },
+{ 0x1, 312, 0, 1021 },
+{ 0x1, 311, 0, 1022 },
+{ 0x1, 310, 0, 1023 },
+{ 0x1, 388, 0, 1024 },
+{ 0x1, 399, 0, 1025 },
+{ 0x1, 389, 0, 1026 },
+{ 0x1, 423, 0, 1027 },
+{ 0x1, 309, 0, 1031 },
+{ 0x1, 247, 0, 1032 },
+{ 0x1, 177, 0, 1035 },
+{ 0x2, 291, 0, 1039 },
+{ 0x1, 291, 0, 1040 },
+{ 0x1, 236, 0, 1041 },
+{ 0x5, 48, 0, 1043 },
+{ 0x3, 48, 0, 1044 },
+{ 0x5, 47, 0, 1045 },
+{ 0x3, 47, 0, 1046 },
+{ 0x1, 365, 0, 1047 },
+{ 0x1, 373, 0, 1048 },
+{ 0x1, 371, 0, 1049 },
+{ 0x1, 392, 0, 1050 },
+{ 0x1, 372, 0, 1051 },
+{ 0x1, 370, 0, 1052 },
+{ 0x2, 378, 0, 1053 },
+{ 0x1, 378, 0, 1055 },
+{ 0x2, 376, 0, 1054 },
+{ 0x1, 376, 0, 1056 },
+{ 0x2, 396, 0, 1057 },
+{ 0x1, 396, 0, 1060 },
+{ 0x2, 377, 0, 1058 },
+{ 0x1, 377, 0, 1061 },
+{ 0x2, 375, 0, 1059 },
+{ 0x1, 375, 0, 1062 },
+{ 0x1, 338, 0, 1063 },
+{ 0x1, 337, 0, 1064 },
+{ 0x1, 369, 0, 1065 },
+{ 0x1, 360, 0, 1066 },
+{ 0x1, 362, 0, 1067 },
+{ 0x1, 359, 0, 1068 },
+{ 0x1, 361, 0, 1069 },
+{ 0x2, 442, 0, 1070 },
+{ 0x1, 442, 0, 1073 },
+{ 0x2, 441, 0, 1071 },
+{ 0x1, 441, 0, 1074 },
+{ 0x2, 440, 0, 1072 },
+{ 0x1, 440, 0, 1075 },
+{ 0x1, 348, 0, 1076 },
+{ 0x2, 347, 0, 1077 },
+{ 0x1, 347, 0, 1078 },
+{ 0x2, 294, 0, 1079 },
+{ 0x1, 294, 0, 1082 },
+{ 0x2, 293, 0, 1080 },
+{ 0x1, 293, 0, 1083 },
+{ 0x2, 292, 0, 1081 },
+{ 0x1, 292, 0, 1084 },
+{ 0x2, 363, 0, 1085 },
+{ 0x1, 363, 0, 1086 },
+{ 0x2, 364, 0, 1087 },
+{ 0x1, 364, 0, 1088 },
+{ 0xa, 434, 1, 1100 },
+{ 0xa, 435, 1, 1099 },
+{ 0xa, 436, 1, 1098 },
+{ 0xa, 437, 0, 1097 },
+{ 0x1a, 434, 1, 1092 },
+{ 0x1a, 435, 1, 1091 },
+{ 0x32, 436, 1, 1090 },
+{ 0x32, 437, 0, 1089 },
+{ 0x6, 434, 1, 1108 },
+{ 0x6, 435, 1, 1107 },
+{ 0x6, 436, 1, 1106 },
+{ 0x6, 437, 0, 1105 },
+{ 0x1, 434, 1, 1120 },
+{ 0x1, 435, 1, 1119 },
+{ 0x1, 436, 1, 1118 },
+{ 0x1, 437, 0, 1117 },
+{ 0x9, 434, 1, 1104 },
+{ 0x9, 435, 1, 1103 },
+{ 0x9, 436, 1, 1102 },
+{ 0x9, 437, 0, 1101 },
+{ 0x19, 434, 1, 1096 },
+{ 0x19, 435, 1, 1095 },
+{ 0x31, 436, 1, 1094 },
+{ 0x31, 437, 0, 1093 },
+{ 0x5, 434, 1, 1112 },
+{ 0x5, 435, 1, 1111 },
+{ 0x5, 436, 1, 1110 },
+{ 0x5, 437, 0, 1109 },
+{ 0x3, 434, 1, 1116 },
+{ 0x3, 435, 1, 1115 },
+{ 0x3, 436, 1, 1114 },
+{ 0x3, 437, 0, 1113 },
+{ 0xa, 429, 1, 1132 },
+{ 0xa, 430, 1, 1131 },
+{ 0xa, 431, 1, 1130 },
+{ 0xa, 432, 0, 1129 },
+{ 0x1a, 429, 1, 1124 },
+{ 0x1a, 430, 1, 1123 },
+{ 0x32, 431, 1, 1122 },
+{ 0x32, 432, 0, 1121 },
+{ 0x6, 429, 1, 1140 },
+{ 0x6, 430, 1, 1139 },
+{ 0x6, 431, 1, 1138 },
+{ 0x6, 432, 0, 1137 },
+{ 0x1, 429, 1, 1152 },
+{ 0x1, 430, 1, 1151 },
+{ 0x1, 431, 1, 1150 },
+{ 0x1, 432, 0, 1149 },
+{ 0x9, 429, 1, 1136 },
+{ 0x9, 430, 1, 1135 },
+{ 0x9, 431, 1, 1134 },
+{ 0x9, 432, 0, 1133 },
+{ 0x19, 429, 1, 1128 },
+{ 0x19, 430, 1, 1127 },
+{ 0x31, 431, 1, 1126 },
+{ 0x31, 432, 0, 1125 },
+{ 0x5, 429, 1, 1144 },
+{ 0x5, 430, 1, 1143 },
+{ 0x5, 431, 1, 1142 },
+{ 0x5, 432, 0, 1141 },
+{ 0x3, 429, 1, 1148 },
+{ 0x3, 430, 1, 1147 },
+{ 0x3, 431, 1, 1146 },
+{ 0x3, 432, 0, 1145 },
+{ 0x1, 139, 0, 1153 },
+{ 0x1, 138, 0, 1154 },
+{ 0x1, 391, 1, 1156 },
+{ 0x1, 137, 0, 1155 },
+{ 0x2, 395, 1, 1158 },
+{ 0x2, 141, 0, 1157 },
+{ 0x1, 395, 1, 1160 },
+{ 0x1, 141, 0, 1159 },
+{ 0x1, 397, 0, 1161 },
+{ 0x1, 136, 0, 1162 },
+{ 0x2, 135, 0, 1163 },
+{ 0x2, 134, 0, 1164 },
+{ 0x1, 454, 1, 1170 },
+{ 0x1, 246, 0, 1033 },
+{ 0x1, 453, 0, 1171 },
+{ 0x1, 452, 1, 1172 },
+{ 0x1, 245, 0, 1042 },
+{ 0x1, 308, 0, 1173 },
+{ 0x1, 307, 1, 1174 },
+{ 0x1, 290, 0, 1034 },
+{ 0x1, 306, 0, 1175 },
+{ 0x1, 305, 1, 1176 },
+{ 0x1, 427, 0, 1036 },
+{ 0x1, 304, 1, 1177 },
+{ 0x1, 398, 0, 1038 },
+{ 0x1, 303, 0, 1178 },
+{ 0x1, 302, 0, 1179 },
+{ 0x1, 301, 0, 1180 },
+{ 0x1, 300, 1, 1181 },
+{ 0x2, 398, 0, 1037 },
+{ 0x10, 299, 0, 1185 },
+{ 0x90, 299, 0, 1183 },
+{ 0x190, 299, 0, 1182 },
+{ 0x50, 299, 0, 1184 },
+{ 0x30, 299, 0, 1187 },
+{ 0x70, 299, 0, 1186 },
+{ 0x8, 299, 0, 1189 },
+{ 0x18, 299, 0, 1188 },
+{ 0x4, 299, 0, 1190 },
+{ 0x1, 299, 0, 1193 },
+{ 0x3, 299, 0, 1192 },
+{ 0x1, 298, 1, 1194 },
+{ 0x2, 299, 0, 1191 },
+{ 0x3, 46, 0, 1195 },
+{ 0x1, 241, 1, 1196 },
+{ 0x1, 242, 1, 1028 },
+{ 0x1, 243, 0, 88 },
+{ 0x1, 341, 1, 1197 },
+{ 0x1, 342, 1, 1029 },
+{ 0x1, 343, 0, 89 },
+{ 0x1, 34, 1, 1198 },
+{ 0x1, 35, 1, 1030 },
+{ 0x1, 36, 0, 90 },
+{ 0x1, 230, 0, 1199 },
+{ 0x4, 447, 0, 1200 },
+{ 0x2, 447, 0, 1201 },
+{ 0x1, 447, 1, 1203 },
+{ 0x1, 448, 0, 1202 },
+{ 0x8, 449, 0, 1204 },
+{ 0x4, 449, 0, 1205 },
+{ 0x1, 449, 1, 1207 },
+{ 0x2, 449, 0, 1206 },
+{ 0x8, 219, 0, 1208 },
+{ 0x4, 219, 0, 1209 },
+{ 0x2, 219, 0, 1210 },
+{ 0x1, 219, 1, 1212 },
+{ 0x1, 220, 0, 1211 },
+{ 0x10, 221, 0, 1213 },
+{ 0x8, 221, 0, 1214 },
+{ 0x4, 221, 0, 1215 },
+{ 0x1, 221, 1, 1217 },
+{ 0x2, 221, 0, 1216 },
+{ 0x220, 191, 0, 1218 },
+{ 0x120, 191, 0, 1219 },
+{ 0xa0, 191, 0, 1220 },
+{ 0x60, 191, 1, 1222 },
+{ 0x4, 192, 0, 1221 },
+{ 0x110, 191, 0, 1228 },
+{ 0x90, 191, 0, 1229 },
+{ 0x50, 191, 0, 1230 },
+{ 0x30, 191, 1, 1232 },
+{ 0x2, 192, 0, 1231 },
+{ 0x8, 191, 0, 1233 },
+{ 0x4, 191, 0, 1234 },
+{ 0x2, 191, 0, 1235 },
+{ 0x1, 191, 1, 1237 },
+{ 0x1, 192, 0, 1236 },
+{ 0x440, 193, 0, 1223 },
+{ 0x240, 193, 0, 1224 },
+{ 0x140, 193, 0, 1225 },
+{ 0xc0, 193, 1, 1227 },
+{ 0x40, 193, 0, 1226 },
+{ 0x220, 193, 0, 1238 },
+{ 0x120, 193, 0, 1239 },
+{ 0xa0, 193, 0, 1240 },
+{ 0x60, 193, 1, 1242 },
+{ 0x20, 193, 0, 1241 },
+{ 0x10, 193, 0, 1243 },
+{ 0x8, 193, 0, 1244 },
+{ 0x4, 193, 0, 1245 },
+{ 0x1, 193, 1, 1247 },
+{ 0x2, 193, 0, 1246 },
+{ 0x8, 215, 0, 1248 },
+{ 0x4, 215, 0, 1249 },
+{ 0x2, 215, 0, 1250 },
+{ 0x1, 215, 1, 1252 },
+{ 0x1, 216, 0, 1251 },
+{ 0x220, 187, 0, 1253 },
+{ 0x120, 187, 0, 1254 },
+{ 0xa0, 187, 0, 1255 },
+{ 0x60, 187, 1, 1257 },
+{ 0x4, 188, 0, 1256 },
+{ 0x110, 187, 0, 1263 },
+{ 0x90, 187, 0, 1264 },
+{ 0x50, 187, 0, 1265 },
+{ 0x30, 187, 1, 1267 },
+{ 0x2, 188, 0, 1266 },
+{ 0x8, 187, 0, 1268 },
+{ 0x4, 187, 0, 1269 },
+{ 0x2, 187, 0, 1270 },
+{ 0x1, 187, 1, 1272 },
+{ 0x1, 188, 0, 1271 },
+{ 0x440, 233, 0, 1258 },
+{ 0x240, 233, 0, 1259 },
+{ 0x140, 233, 0, 1260 },
+{ 0xc0, 233, 1, 1262 },
+{ 0x40, 233, 0, 1261 },
+{ 0x220, 233, 0, 1273 },
+{ 0x120, 233, 0, 1274 },
+{ 0xa0, 233, 0, 1275 },
+{ 0x60, 233, 1, 1277 },
+{ 0x20, 233, 0, 1276 },
+{ 0x10, 233, 0, 1278 },
+{ 0x8, 233, 0, 1279 },
+{ 0x4, 233, 0, 1280 },
+{ 0x1, 233, 1, 1282 },
+{ 0x2, 233, 0, 1281 },
+{ 0x8, 207, 0, 1283 },
+{ 0x4, 207, 0, 1284 },
+{ 0x2, 207, 0, 1285 },
+{ 0x1, 207, 1, 1287 },
+{ 0x1, 208, 0, 1286 },
+{ 0x10, 214, 0, 1288 },
+{ 0x8, 214, 0, 1289 },
+{ 0x4, 214, 0, 1290 },
+{ 0x1, 214, 1, 1292 },
+{ 0x2, 214, 0, 1291 },
+{ 0x220, 178, 0, 1293 },
+{ 0x120, 178, 0, 1294 },
+{ 0xa0, 178, 0, 1295 },
+{ 0x60, 178, 1, 1297 },
+{ 0x4, 179, 0, 1296 },
+{ 0x110, 178, 0, 1318 },
+{ 0x90, 178, 0, 1319 },
+{ 0x50, 178, 0, 1320 },
+{ 0x30, 178, 1, 1322 },
+{ 0x2, 179, 0, 1321 },
+{ 0x8, 178, 0, 1323 },
+{ 0x4, 178, 0, 1324 },
+{ 0x2, 178, 0, 1325 },
+{ 0x1, 178, 1, 1327 },
+{ 0x1, 179, 0, 1326 },
+{ 0x440, 186, 0, 1298 },
+{ 0x240, 186, 0, 1299 },
+{ 0x140, 186, 0, 1300 },
+{ 0xc0, 186, 1, 1302 },
+{ 0x40, 186, 0, 1301 },
+{ 0x220, 186, 0, 1328 },
+{ 0x120, 186, 0, 1329 },
+{ 0xa0, 186, 0, 1330 },
+{ 0x60, 186, 1, 1332 },
+{ 0x20, 186, 0, 1331 },
+{ 0x10, 186, 0, 1333 },
+{ 0x8, 186, 0, 1334 },
+{ 0x4, 186, 0, 1335 },
+{ 0x1, 186, 1, 1337 },
+{ 0x2, 186, 0, 1336 },
+{ 0x440, 143, 0, 1303 },
+{ 0x240, 143, 0, 1304 },
+{ 0x140, 143, 0, 1305 },
+{ 0xc0, 143, 1, 1307 },
+{ 0x40, 143, 0, 1306 },
+{ 0x220, 143, 0, 1338 },
+{ 0x120, 143, 0, 1339 },
+{ 0xa0, 143, 0, 1340 },
+{ 0x60, 143, 1, 1342 },
+{ 0x20, 143, 0, 1341 },
+{ 0x10, 143, 0, 1343 },
+{ 0x8, 143, 0, 1344 },
+{ 0x1, 143, 1, 1347 },
+{ 0x2, 143, 0, 1346 },
+{ 0x440, 194, 1, 1313 },
+{ 0x441, 174, 0, 1308 },
+{ 0x240, 194, 1, 1314 },
+{ 0x241, 174, 0, 1309 },
+{ 0x140, 194, 1, 1315 },
+{ 0x141, 174, 0, 1310 },
+{ 0xc0, 194, 1, 1317 },
+{ 0x40, 194, 1, 1316 },
+{ 0xc1, 174, 1, 1312 },
+{ 0x41, 174, 0, 1311 },
+{ 0x220, 194, 1, 1358 },
+{ 0x221, 174, 0, 1348 },
+{ 0x120, 194, 1, 1359 },
+{ 0x121, 174, 0, 1349 },
+{ 0xa0, 194, 1, 1360 },
+{ 0xa1, 174, 0, 1350 },
+{ 0x60, 194, 1, 1362 },
+{ 0x20, 194, 1, 1361 },
+{ 0x61, 174, 1, 1352 },
+{ 0x21, 174, 0, 1351 },
+{ 0x10, 194, 1, 1363 },
+{ 0x11, 174, 0, 1353 },
+{ 0x8, 194, 1, 1364 },
+{ 0x9, 174, 0, 1354 },
+{ 0x4, 194, 1, 1365 },
+{ 0x5, 174, 0, 1355 },
+{ 0x1, 194, 1, 1367 },
+{ 0x2, 194, 1, 1366 },
+{ 0x3, 174, 1, 1357 },
+{ 0x1, 174, 0, 1356 },
+{ 0x1, 153, 1, 1375 },
+{ 0x1, 154, 1, 1374 },
+{ 0x1, 155, 1, 1373 },
+{ 0x1, 156, 0, 1372 },
+{ 0x3, 153, 1, 1371 },
+{ 0x3, 154, 1, 1370 },
+{ 0x3, 155, 1, 1369 },
+{ 0x3, 156, 0, 1368 },
+{ 0x1108, 159, 1, 1537 },
+{ 0x1108, 160, 1, 1536 },
+{ 0x1108, 165, 1, 1377 },
+{ 0x1108, 166, 0, 1376 },
+{ 0x908, 159, 1, 1539 },
+{ 0x908, 160, 1, 1538 },
+{ 0x908, 165, 1, 1379 },
+{ 0x908, 166, 0, 1378 },
+{ 0x508, 159, 1, 1541 },
+{ 0x508, 160, 1, 1540 },
+{ 0x508, 165, 1, 1381 },
+{ 0x508, 166, 0, 1380 },
+{ 0x308, 159, 1, 1545 },
+{ 0x308, 160, 1, 1544 },
+{ 0x108, 160, 1, 1542 },
+{ 0x18, 161, 1, 1543 },
+{ 0x308, 165, 1, 1385 },
+{ 0x308, 166, 1, 1384 },
+{ 0x108, 166, 1, 1382 },
+{ 0x18, 167, 0, 1383 },
+{ 0x88, 159, 1, 1577 },
+{ 0x88, 160, 1, 1576 },
+{ 0x88, 165, 1, 1457 },
+{ 0x88, 166, 0, 1456 },
+{ 0x48, 159, 1, 1579 },
+{ 0x48, 160, 1, 1578 },
+{ 0x48, 165, 1, 1459 },
+{ 0x48, 166, 0, 1458 },
+{ 0x28, 159, 1, 1581 },
+{ 0x28, 160, 1, 1580 },
+{ 0x28, 165, 1, 1461 },
+{ 0x28, 166, 0, 1460 },
+{ 0x18, 159, 1, 1585 },
+{ 0x18, 160, 1, 1584 },
+{ 0x8, 160, 1, 1582 },
+{ 0x8, 161, 1, 1583 },
+{ 0x18, 165, 1, 1465 },
+{ 0x18, 166, 1, 1464 },
+{ 0x8, 166, 1, 1462 },
+{ 0x8, 167, 0, 1463 },
+{ 0x884, 159, 1, 1547 },
+{ 0x884, 160, 1, 1546 },
+{ 0x442, 162, 1, 1437 },
+{ 0x442, 163, 1, 1436 },
+{ 0x884, 165, 1, 1407 },
+{ 0x884, 166, 1, 1406 },
+{ 0x442, 168, 1, 1387 },
+{ 0x442, 169, 0, 1386 },
+{ 0x484, 159, 1, 1549 },
+{ 0x484, 160, 1, 1548 },
+{ 0x242, 162, 1, 1439 },
+{ 0x242, 163, 1, 1438 },
+{ 0x484, 165, 1, 1409 },
+{ 0x484, 166, 1, 1408 },
+{ 0x242, 168, 1, 1389 },
+{ 0x242, 169, 0, 1388 },
+{ 0x284, 159, 1, 1551 },
+{ 0x284, 160, 1, 1550 },
+{ 0x142, 162, 1, 1441 },
+{ 0x142, 163, 1, 1440 },
+{ 0x284, 165, 1, 1411 },
+{ 0x284, 166, 1, 1410 },
+{ 0x142, 168, 1, 1391 },
+{ 0x142, 169, 0, 1390 },
+{ 0x184, 159, 1, 1555 },
+{ 0x184, 160, 1, 1554 },
+{ 0x84, 160, 1, 1552 },
+{ 0xc, 161, 1, 1553 },
+{ 0xc2, 162, 1, 1445 },
+{ 0xc2, 163, 1, 1444 },
+{ 0x42, 163, 1, 1442 },
+{ 0x6, 164, 1, 1443 },
+{ 0x184, 165, 1, 1415 },
+{ 0x184, 166, 1, 1414 },
+{ 0x84, 166, 1, 1412 },
+{ 0xc, 167, 1, 1413 },
+{ 0xc2, 168, 1, 1395 },
+{ 0xc2, 169, 1, 1394 },
+{ 0x42, 169, 1, 1392 },
+{ 0x6, 170, 0, 1393 },
+{ 0x44, 159, 1, 1587 },
+{ 0x44, 160, 1, 1586 },
+{ 0x22, 162, 1, 1517 },
+{ 0x22, 163, 1, 1516 },
+{ 0x44, 165, 1, 1487 },
+{ 0x44, 166, 1, 1486 },
+{ 0x22, 168, 1, 1467 },
+{ 0x22, 169, 0, 1466 },
+{ 0x24, 159, 1, 1589 },
+{ 0x24, 160, 1, 1588 },
+{ 0x12, 162, 1, 1519 },
+{ 0x12, 163, 1, 1518 },
+{ 0x24, 165, 1, 1489 },
+{ 0x24, 166, 1, 1488 },
+{ 0x12, 168, 1, 1469 },
+{ 0x12, 169, 0, 1468 },
+{ 0x14, 159, 1, 1591 },
+{ 0x14, 160, 1, 1590 },
+{ 0xa, 162, 1, 1521 },
+{ 0xa, 163, 1, 1520 },
+{ 0x14, 165, 1, 1491 },
+{ 0x14, 166, 1, 1490 },
+{ 0xa, 168, 1, 1471 },
+{ 0xa, 169, 0, 1470 },
+{ 0xc, 159, 1, 1595 },
+{ 0xc, 160, 1, 1594 },
+{ 0x4, 160, 1, 1592 },
+{ 0x4, 161, 1, 1593 },
+{ 0x6, 162, 1, 1525 },
+{ 0x6, 163, 1, 1524 },
+{ 0x2, 163, 1, 1522 },
+{ 0x2, 164, 1, 1523 },
+{ 0xc, 165, 1, 1495 },
+{ 0xc, 166, 1, 1494 },
+{ 0x4, 166, 1, 1492 },
+{ 0x4, 167, 1, 1493 },
+{ 0x6, 168, 1, 1475 },
+{ 0x6, 169, 1, 1474 },
+{ 0x2, 169, 1, 1472 },
+{ 0x2, 170, 0, 1473 },
+{ 0x442, 159, 1, 1557 },
+{ 0x442, 160, 1, 1556 },
+{ 0x221, 162, 1, 1447 },
+{ 0x221, 163, 1, 1446 },
+{ 0x442, 165, 1, 1417 },
+{ 0x442, 166, 1, 1416 },
+{ 0x221, 168, 1, 1397 },
+{ 0x221, 169, 0, 1396 },
+{ 0x242, 159, 1, 1559 },
+{ 0x242, 160, 1, 1558 },
+{ 0x121, 162, 1, 1449 },
+{ 0x121, 163, 1, 1448 },
+{ 0x242, 165, 1, 1419 },
+{ 0x242, 166, 1, 1418 },
+{ 0x121, 168, 1, 1399 },
+{ 0x121, 169, 0, 1398 },
+{ 0x142, 159, 1, 1561 },
+{ 0x142, 160, 1, 1560 },
+{ 0xa1, 162, 1, 1451 },
+{ 0xa1, 163, 1, 1450 },
+{ 0x142, 165, 1, 1421 },
+{ 0x142, 166, 1, 1420 },
+{ 0xa1, 168, 1, 1401 },
+{ 0xa1, 169, 0, 1400 },
+{ 0xc2, 159, 1, 1565 },
+{ 0xc2, 160, 1, 1564 },
+{ 0x42, 160, 1, 1562 },
+{ 0x6, 161, 1, 1563 },
+{ 0x61, 162, 1, 1455 },
+{ 0x61, 163, 1, 1454 },
+{ 0x21, 163, 1, 1452 },
+{ 0x3, 164, 1, 1453 },
+{ 0xc2, 165, 1, 1425 },
+{ 0xc2, 166, 1, 1424 },
+{ 0x42, 166, 1, 1422 },
+{ 0x6, 167, 1, 1423 },
+{ 0x61, 168, 1, 1405 },
+{ 0x61, 169, 1, 1404 },
+{ 0x21, 169, 1, 1402 },
+{ 0x3, 170, 0, 1403 },
+{ 0x22, 159, 1, 1597 },
+{ 0x22, 160, 1, 1596 },
+{ 0x11, 162, 1, 1527 },
+{ 0x11, 163, 1, 1526 },
+{ 0x22, 165, 1, 1497 },
+{ 0x22, 166, 1, 1496 },
+{ 0x11, 168, 1, 1477 },
+{ 0x11, 169, 0, 1476 },
+{ 0x12, 159, 1, 1599 },
+{ 0x12, 160, 1, 1598 },
+{ 0x9, 162, 1, 1529 },
+{ 0x9, 163, 1, 1528 },
+{ 0x12, 165, 1, 1499 },
+{ 0x12, 166, 1, 1498 },
+{ 0x9, 168, 1, 1479 },
+{ 0x9, 169, 0, 1478 },
+{ 0xa, 159, 1, 1601 },
+{ 0xa, 160, 1, 1600 },
+{ 0x5, 162, 1, 1531 },
+{ 0x5, 163, 1, 1530 },
+{ 0xa, 165, 1, 1501 },
+{ 0xa, 166, 1, 1500 },
+{ 0x5, 168, 1, 1481 },
+{ 0x5, 169, 0, 1480 },
+{ 0x6, 159, 1, 1605 },
+{ 0x6, 160, 1, 1604 },
+{ 0x2, 160, 1, 1602 },
+{ 0x2, 161, 1, 1603 },
+{ 0x3, 162, 1, 1535 },
+{ 0x3, 163, 1, 1534 },
+{ 0x1, 163, 1, 1532 },
+{ 0x1, 164, 1, 1533 },
+{ 0x6, 165, 1, 1505 },
+{ 0x6, 166, 1, 1504 },
+{ 0x2, 166, 1, 1502 },
+{ 0x2, 167, 1, 1503 },
+{ 0x3, 168, 1, 1485 },
+{ 0x3, 169, 1, 1484 },
+{ 0x1, 169, 1, 1482 },
+{ 0x1, 170, 0, 1483 },
+{ 0x221, 159, 1, 1567 },
+{ 0x221, 160, 1, 1566 },
+{ 0x221, 165, 1, 1427 },
+{ 0x221, 166, 0, 1426 },
+{ 0x121, 159, 1, 1569 },
+{ 0x121, 160, 1, 1568 },
+{ 0x121, 165, 1, 1429 },
+{ 0x121, 166, 0, 1428 },
+{ 0xa1, 159, 1, 1571 },
+{ 0xa1, 160, 1, 1570 },
+{ 0xa1, 165, 1, 1431 },
+{ 0xa1, 166, 0, 1430 },
+{ 0x61, 159, 1, 1575 },
+{ 0x61, 160, 1, 1574 },
+{ 0x21, 160, 1, 1572 },
+{ 0x3, 161, 1, 1573 },
+{ 0x61, 165, 1, 1435 },
+{ 0x61, 166, 1, 1434 },
+{ 0x21, 166, 1, 1432 },
+{ 0x3, 167, 0, 1433 },
+{ 0x11, 159, 1, 1607 },
+{ 0x11, 160, 1, 1606 },
+{ 0x11, 165, 1, 1507 },
+{ 0x11, 166, 0, 1506 },
+{ 0x9, 159, 1, 1609 },
+{ 0x9, 160, 1, 1608 },
+{ 0x9, 165, 1, 1509 },
+{ 0x9, 166, 0, 1508 },
+{ 0x5, 159, 1, 1611 },
+{ 0x5, 160, 1, 1610 },
+{ 0x5, 165, 1, 1511 },
+{ 0x5, 166, 0, 1510 },
+{ 0x3, 159, 1, 1615 },
+{ 0x3, 160, 1, 1614 },
+{ 0x1, 160, 1, 1612 },
+{ 0x1, 161, 1, 1613 },
+{ 0x3, 165, 1, 1515 },
+{ 0x3, 166, 1, 1514 },
+{ 0x1, 166, 1, 1512 },
+{ 0x1, 167, 0, 1513 },
+{ 0x442, 205, 0, 1616 },
+{ 0x242, 205, 0, 1617 },
+{ 0x142, 205, 0, 1618 },
+{ 0xc2, 205, 1, 1620 },
+{ 0x6, 206, 1, 1619 },
+{ 0x1, 439, 0, 981 },
+{ 0x22, 205, 0, 1626 },
+{ 0x12, 205, 0, 1627 },
+{ 0xa, 205, 0, 1628 },
+{ 0x6, 205, 1, 1630 },
+{ 0x2, 206, 1, 1629 },
+{ 0x2, 367, 0, 1010 },
+{ 0x221, 205, 0, 1621 },
+{ 0x121, 205, 0, 1622 },
+{ 0xa1, 205, 0, 1623 },
+{ 0x61, 205, 1, 1625 },
+{ 0x3, 206, 1, 1624 },
+{ 0x1, 433, 0, 982 },
+{ 0x11, 205, 0, 1631 },
+{ 0x9, 205, 0, 1632 },
+{ 0x5, 205, 0, 1633 },
+{ 0x3, 205, 1, 1635 },
+{ 0x1, 206, 1, 1634 },
+{ 0x1, 367, 0, 1011 },
+{ 0x4, 211, 0, 1636 },
+{ 0x1, 211, 0, 1638 },
+{ 0x1, 218, 0, 1639 },
+{ 0x1, 217, 1, 1640 },
+{ 0x2, 211, 0, 1637 },
+{ 0x1, 196, 0, 1641 },
+{ 0x880, 202, 0, 1642 },
+{ 0x480, 202, 0, 1643 },
+{ 0x280, 202, 0, 1644 },
+{ 0x180, 202, 1, 1646 },
+{ 0x80, 203, 0, 1645 },
+{ 0x440, 202, 1, 1657 },
+{ 0x88, 204, 0, 1647 },
+{ 0x240, 202, 1, 1658 },
+{ 0x48, 204, 0, 1648 },
+{ 0x140, 202, 1, 1659 },
+{ 0x28, 204, 0, 1649 },
+{ 0xc0, 202, 1, 1661 },
+{ 0x40, 203, 1, 1660 },
+{ 0x18, 204, 1, 1651 },
+{ 0x8, 204, 0, 1650 },
+{ 0x220, 202, 1, 1662 },
+{ 0x44, 204, 0, 1652 },
+{ 0x120, 202, 1, 1663 },
+{ 0x24, 204, 0, 1653 },
+{ 0xa0, 202, 1, 1664 },
+{ 0x14, 204, 0, 1654 },
+{ 0x60, 202, 1, 1666 },
+{ 0x20, 203, 1, 1665 },
+{ 0xc, 204, 1, 1656 },
+{ 0x4, 204, 0, 1655 },
+{ 0x110, 202, 0, 1667 },
+{ 0x90, 202, 0, 1668 },
+{ 0x50, 202, 0, 1669 },
+{ 0x30, 202, 1, 1671 },
+{ 0x10, 203, 1, 1670 },
+{ 0x1, 385, 0, 974 },
+{ 0x88, 202, 0, 1672 },
+{ 0x48, 202, 0, 1673 },
+{ 0x28, 202, 0, 1674 },
+{ 0x18, 202, 1, 1676 },
+{ 0x8, 203, 1, 1675 },
+{ 0xc, 368, 0, 1007 },
+{ 0x44, 202, 1, 1687 },
+{ 0x22, 204, 0, 1677 },
+{ 0x24, 202, 1, 1688 },
+{ 0x12, 204, 0, 1678 },
+{ 0x14, 202, 1, 1689 },
+{ 0xa, 204, 0, 1679 },
+{ 0xc, 202, 1, 1691 },
+{ 0x4, 203, 1, 1690 },
+{ 0x6, 204, 1, 1681 },
+{ 0x2, 204, 1, 1680 },
+{ 0x6, 368, 0, 1008 },
+{ 0x22, 202, 1, 1692 },
+{ 0x11, 204, 0, 1682 },
+{ 0x12, 202, 1, 1693 },
+{ 0x9, 204, 0, 1683 },
+{ 0xa, 202, 1, 1694 },
+{ 0x5, 204, 0, 1684 },
+{ 0x6, 202, 1, 1696 },
+{ 0x2, 203, 1, 1695 },
+{ 0x3, 204, 1, 1686 },
+{ 0x1, 204, 1, 1685 },
+{ 0x3, 368, 0, 1009 },
+{ 0x11, 202, 0, 1697 },
+{ 0x9, 202, 0, 1698 },
+{ 0x5, 202, 0, 1699 },
+{ 0x3, 202, 1, 1701 },
+{ 0x1, 203, 0, 1700 },
+{ 0x8, 198, 0, 1702 },
+{ 0x4, 198, 0, 1703 },
+{ 0x2, 198, 0, 1704 },
+{ 0x1, 198, 1, 1706 },
+{ 0x1, 199, 1, 1705 },
+{ 0x1, 332, 0, 988 },
+{ 0x8, 200, 0, 1707 },
+{ 0x4, 200, 0, 1708 },
+{ 0x2, 200, 0, 1709 },
+{ 0x1, 200, 1, 1711 },
+{ 0x1, 201, 1, 1710 },
+{ 0x1, 331, 0, 989 },
+{ 0x8, 209, 0, 1712 },
+{ 0x4, 209, 0, 1713 },
+{ 0x2, 209, 0, 1714 },
+{ 0x1, 209, 1, 1716 },
+{ 0x1, 210, 1, 1715 },
+{ 0x1, 330, 0, 990 },
+{ 0x8, 212, 0, 1717 },
+{ 0x4, 212, 0, 1718 },
+{ 0x2, 212, 0, 1719 },
+{ 0x1, 212, 1, 1721 },
+{ 0x1, 213, 1, 1720 },
+{ 0x1, 329, 0, 991 },
+{ 0x8, 224, 0, 1722 },
+{ 0x4, 224, 0, 1723 },
+{ 0x2, 224, 0, 1724 },
+{ 0x1, 224, 1, 1726 },
+{ 0x1, 225, 0, 1725 },
+{ 0x8, 222, 0, 1727 },
+{ 0x4, 222, 0, 1728 },
+{ 0x2, 222, 0, 1729 },
+{ 0x1, 222, 1, 1731 },
+{ 0x1, 223, 0, 1730 },
+{ 0x1, 240, 0, 1732 },
+{ 0x1, 340, 0, 1733 },
+{ 0x1, 33, 0, 1734 },
+{ 0x8, 151, 0, 1735 },
+{ 0x4, 151, 0, 1736 },
+{ 0x2, 151, 0, 1737 },
+{ 0x1, 151, 1, 1739 },
+{ 0x1, 152, 0, 1738 },
+{ 0x8, 157, 0, 1740 },
+{ 0x4, 157, 0, 1741 },
+{ 0x2, 157, 0, 1742 },
+{ 0x1, 157, 1, 1744 },
+{ 0x1, 158, 0, 1743 },
+{ 0x8, 231, 0, 1745 },
+{ 0x4, 231, 0, 1746 },
+{ 0x2, 231, 0, 1747 },
+{ 0x1, 231, 1, 1749 },
+{ 0x1, 232, 0, 1748 },
+{ 0x1, 173, 0, 1750 },
+{ 0x442, 171, 0, 1751 },
+{ 0x242, 171, 0, 1752 },
+{ 0x142, 171, 0, 1753 },
+{ 0xc2, 171, 1, 1755 },
+{ 0x6, 172, 0, 1754 },
+{ 0x22, 171, 0, 1761 },
+{ 0x12, 171, 0, 1762 },
+{ 0xa, 171, 0, 1763 },
+{ 0x6, 171, 1, 1765 },
+{ 0x2, 172, 1, 1764 },
+{ 0x1, 135, 0, 1165 },
+{ 0x221, 171, 0, 1756 },
+{ 0x121, 171, 0, 1757 },
+{ 0xa1, 171, 0, 1758 },
+{ 0x61, 171, 1, 1760 },
+{ 0x3, 172, 0, 1759 },
+{ 0x11, 171, 0, 1766 },
+{ 0x9, 171, 0, 1767 },
+{ 0x5, 171, 0, 1768 },
+{ 0x3, 171, 1, 1770 },
+{ 0x1, 172, 1, 1769 },
+{ 0x1, 134, 0, 1166 },
+{ 0x1, 237, 0, 1771 },
+{ 0x1, 195, 0, 1772 },
+{ 0x1, 149, 0, 1773 },
+{ 0x1, 148, 0, 1774 },
+{ 0x4, 234, 0, 1775 },
+{ 0x2, 234, 0, 1776 },
+{ 0x1, 234, 0, 1777 },
+{ 0x1, 197, 0, 1778 },
+{ 0x2, 235, 0, 1779 },
+{ 0x1, 235, 0, 1780 },
+{ 0x4, 185, 0, 1781 },
+{ 0x2, 185, 0, 1782 },
+{ 0x1, 185, 0, 1783 },
+{ 0x4, 182, 0, 1784 },
+{ 0x1, 190, 0, 1787 },
+{ 0x1, 189, 1, 1788 },
+{ 0x2, 182, 0, 1785 },
+{ 0x1, 142, 0, 1789 },
+{ 0x1, 297, 1, 1790 },
+{ 0x1, 182, 0, 1786 },
+{ 0x8, 144, 0, 1791 },
+{ 0x4, 144, 0, 1792 },
+{ 0x2, 144, 0, 1793 },
+{ 0x1, 144, 1, 1795 },
+{ 0x1, 145, 0, 1794 },
+{ 0x8, 146, 0, 1796 },
+{ 0x4, 146, 0, 1797 },
+{ 0x2, 146, 0, 1798 },
+{ 0x1, 146, 1, 1800 },
+{ 0x1, 147, 1, 1799 },
+{ 0x1, 426, 0, 1167 },
+{ 0x8, 180, 0, 1801 },
+{ 0x4, 180, 0, 1802 },
+{ 0x2, 180, 0, 1803 },
+{ 0x1, 180, 1, 1805 },
+{ 0x1, 181, 1, 1804 },
+{ 0x1, 425, 0, 1168 },
+{ 0x8, 183, 0, 1806 },
+{ 0x4, 183, 0, 1807 },
+{ 0x2, 183, 0, 1808 },
+{ 0x1, 183, 1, 1810 },
+{ 0x1, 184, 1, 1809 },
+{ 0x1, 424, 0, 1169 },
+{ 0x8, 228, 0, 1811 },
+{ 0x4, 228, 0, 1812 },
+{ 0x2, 228, 0, 1813 },
+{ 0x1, 228, 1, 1815 },
+{ 0x1, 229, 0, 1814 },
+{ 0x8, 226, 0, 1816 },
+{ 0x4, 226, 0, 1817 },
+{ 0x2, 226, 0, 1818 },
+{ 0x1, 226, 1, 1820 },
+{ 0x1, 227, 0, 1819 },
+{ 0x8, 44, 0, 1825 },
+{ 0x18, 44, 0, 1821 },
+{ 0x4, 44, 0, 1826 },
+{ 0xc, 44, 0, 1822 },
+{ 0x2, 44, 0, 1827 },
+{ 0x6, 44, 0, 1823 },
+{ 0x1, 44, 0, 1828 },
+{ 0x3, 44, 0, 1824 },
+{ 0x51, 30, 0, 1830 },
+{ 0xd1, 30, 0, 1829 },
+{ 0x31, 30, 1, 1840 },
+{ 0x11, 31, 0, 1839 },
+{ 0x71, 30, 1, 1838 },
+{ 0x31, 31, 0, 1837 },
+{ 0x29, 30, 0, 1832 },
+{ 0x69, 30, 0, 1831 },
+{ 0x19, 30, 1, 1844 },
+{ 0x9, 31, 0, 1843 },
+{ 0x39, 30, 1, 1842 },
+{ 0x19, 31, 0, 1841 },
+{ 0x15, 30, 0, 1834 },
+{ 0x35, 30, 0, 1833 },
+{ 0xd, 30, 1, 1848 },
+{ 0x5, 31, 0, 1847 },
+{ 0x1d, 30, 1, 1846 },
+{ 0xd, 31, 0, 1845 },
+{ 0xb, 30, 0, 1836 },
+{ 0x1b, 30, 0, 1835 },
+{ 0x7, 30, 1, 1852 },
+{ 0x3, 31, 0, 1851 },
+{ 0xf, 30, 1, 1850 },
+{ 0x7, 31, 0, 1849 },
+{ 0xa2, 28, 0, 1854 },
+{ 0x1a2, 28, 0, 1853 },
+{ 0x62, 28, 1, 1864 },
+{ 0x22, 29, 0, 1863 },
+{ 0xe2, 28, 1, 1862 },
+{ 0x62, 29, 0, 1861 },
+{ 0x52, 28, 0, 1856 },
+{ 0xd2, 28, 0, 1855 },
+{ 0x32, 28, 1, 1868 },
+{ 0x12, 29, 0, 1867 },
+{ 0x72, 28, 1, 1866 },
+{ 0x32, 29, 0, 1865 },
+{ 0x2a, 28, 0, 1858 },
+{ 0x6a, 28, 0, 1857 },
+{ 0x1a, 28, 1, 1872 },
+{ 0xa, 29, 0, 1871 },
+{ 0x3a, 28, 1, 1870 },
+{ 0x1a, 29, 0, 1869 },
+{ 0x16, 28, 0, 1860 },
+{ 0x36, 28, 0, 1859 },
+{ 0xe, 28, 1, 1876 },
+{ 0x6, 29, 0, 1875 },
+{ 0x1e, 28, 1, 1874 },
+{ 0xe, 29, 0, 1873 },
+{ 0x51, 28, 0, 1878 },
+{ 0xd1, 28, 0, 1877 },
+{ 0x31, 28, 1, 1888 },
+{ 0x11, 29, 0, 1887 },
+{ 0x71, 28, 1, 1886 },
+{ 0x31, 29, 0, 1885 },
+{ 0x29, 28, 0, 1880 },
+{ 0x69, 28, 0, 1879 },
+{ 0x19, 28, 1, 1892 },
+{ 0x9, 29, 0, 1891 },
+{ 0x39, 28, 1, 1890 },
+{ 0x19, 29, 0, 1889 },
+{ 0x15, 28, 0, 1882 },
+{ 0x35, 28, 0, 1881 },
+{ 0xd, 28, 1, 1896 },
+{ 0x5, 29, 0, 1895 },
+{ 0x1d, 28, 1, 1894 },
+{ 0xd, 29, 0, 1893 },
+{ 0xb, 28, 0, 1884 },
+{ 0x1b, 28, 0, 1883 },
+{ 0x7, 28, 1, 1900 },
+{ 0x3, 29, 0, 1899 },
+{ 0xf, 28, 1, 1898 },
+{ 0x7, 29, 0, 1897 },
+{ 0x51, 26, 0, 1902 },
+{ 0xd1, 26, 0, 1901 },
+{ 0x31, 26, 1, 1912 },
+{ 0x11, 27, 0, 1911 },
+{ 0x71, 26, 1, 1910 },
+{ 0x31, 27, 0, 1909 },
+{ 0x29, 26, 0, 1904 },
+{ 0x69, 26, 0, 1903 },
+{ 0x19, 26, 1, 1916 },
+{ 0x9, 27, 0, 1915 },
+{ 0x39, 26, 1, 1914 },
+{ 0x19, 27, 0, 1913 },
+{ 0x15, 26, 0, 1906 },
+{ 0x35, 26, 0, 1905 },
+{ 0xd, 26, 1, 1920 },
+{ 0x5, 27, 0, 1919 },
+{ 0x1d, 26, 1, 1918 },
+{ 0xd, 27, 0, 1917 },
+{ 0xb, 26, 0, 1908 },
+{ 0x1b, 26, 0, 1907 },
+{ 0x7, 26, 1, 1924 },
+{ 0x3, 27, 0, 1923 },
+{ 0xf, 26, 1, 1922 },
+{ 0x7, 27, 0, 1921 },
+{ 0xa2, 24, 0, 1926 },
+{ 0x1a2, 24, 0, 1925 },
+{ 0x62, 24, 1, 1936 },
+{ 0x22, 25, 0, 1935 },
+{ 0xe2, 24, 1, 1934 },
+{ 0x62, 25, 0, 1933 },
+{ 0x52, 24, 0, 1928 },
+{ 0xd2, 24, 0, 1927 },
+{ 0x32, 24, 1, 1940 },
+{ 0x12, 25, 0, 1939 },
+{ 0x72, 24, 1, 1938 },
+{ 0x32, 25, 0, 1937 },
+{ 0x2a, 24, 0, 1930 },
+{ 0x6a, 24, 0, 1929 },
+{ 0x1a, 24, 1, 1944 },
+{ 0xa, 25, 0, 1943 },
+{ 0x3a, 24, 1, 1942 },
+{ 0x1a, 25, 0, 1941 },
+{ 0x16, 24, 0, 1932 },
+{ 0x36, 24, 0, 1931 },
+{ 0xe, 24, 1, 1948 },
+{ 0x6, 25, 0, 1947 },
+{ 0x1e, 24, 1, 1946 },
+{ 0xe, 25, 0, 1945 },
+{ 0x51, 24, 0, 1950 },
+{ 0xd1, 24, 0, 1949 },
+{ 0x31, 24, 1, 1960 },
+{ 0x11, 25, 0, 1959 },
+{ 0x71, 24, 1, 1958 },
+{ 0x31, 25, 0, 1957 },
+{ 0x29, 24, 0, 1952 },
+{ 0x69, 24, 0, 1951 },
+{ 0x19, 24, 1, 1964 },
+{ 0x9, 25, 0, 1963 },
+{ 0x39, 24, 1, 1962 },
+{ 0x19, 25, 0, 1961 },
+{ 0x15, 24, 0, 1954 },
+{ 0x35, 24, 0, 1953 },
+{ 0xd, 24, 1, 1968 },
+{ 0x5, 25, 0, 1967 },
+{ 0x1d, 24, 1, 1966 },
+{ 0xd, 25, 0, 1965 },
+{ 0xb, 24, 0, 1956 },
+{ 0x1b, 24, 0, 1955 },
+{ 0x7, 24, 1, 1972 },
+{ 0x3, 25, 0, 1971 },
+{ 0xf, 24, 1, 1970 },
+{ 0x7, 25, 0, 1969 },
+{ 0x51, 22, 1, 1998 },
+{ 0x50, 22, 0, 1974 },
+{ 0xd1, 22, 1, 1997 },
+{ 0xd0, 22, 0, 1973 },
+{ 0x31, 22, 1, 2008 },
+{ 0x30, 22, 1, 1984 },
+{ 0x11, 23, 1, 2007 },
+{ 0x10, 23, 0, 1983 },
+{ 0x71, 22, 1, 2006 },
+{ 0x70, 22, 1, 1982 },
+{ 0x31, 23, 1, 2005 },
+{ 0x30, 23, 0, 1981 },
+{ 0x29, 22, 1, 2000 },
+{ 0x28, 22, 0, 1976 },
+{ 0x69, 22, 1, 1999 },
+{ 0x68, 22, 0, 1975 },
+{ 0x19, 22, 1, 2012 },
+{ 0x18, 22, 1, 1988 },
+{ 0x9, 23, 1, 2011 },
+{ 0x8, 23, 0, 1987 },
+{ 0x39, 22, 1, 2010 },
+{ 0x38, 22, 1, 1986 },
+{ 0x19, 23, 1, 2009 },
+{ 0x18, 23, 0, 1985 },
+{ 0x15, 22, 1, 2002 },
+{ 0x14, 22, 0, 1978 },
+{ 0x35, 22, 1, 2001 },
+{ 0x34, 22, 0, 1977 },
+{ 0xd, 22, 1, 2016 },
+{ 0xc, 22, 1, 1992 },
+{ 0x5, 23, 1, 2015 },
+{ 0x4, 23, 0, 1991 },
+{ 0x1d, 22, 1, 2014 },
+{ 0x1c, 22, 1, 1990 },
+{ 0xd, 23, 1, 2013 },
+{ 0xc, 23, 0, 1989 },
+{ 0xb, 22, 1, 2004 },
+{ 0xa, 22, 0, 1980 },
+{ 0x1b, 22, 1, 2003 },
+{ 0x1a, 22, 0, 1979 },
+{ 0x7, 22, 1, 2020 },
+{ 0x6, 22, 1, 1996 },
+{ 0x3, 23, 1, 2019 },
+{ 0x2, 23, 0, 1995 },
+{ 0xf, 22, 1, 2018 },
+{ 0xe, 22, 1, 1994 },
+{ 0x7, 23, 1, 2017 },
+{ 0x6, 23, 0, 1993 },
+{ 0x8, 21, 0, 2022 },
+{ 0x18, 21, 0, 2021 },
+{ 0x1, 21, 1, 2026 },
+{ 0x2, 21, 0, 2025 },
+{ 0x3, 21, 1, 2024 },
+{ 0x4, 21, 0, 2023 },
+{ 0x1, 239, 0, 2027 },
+{ 0x1, 339, 0, 2028 },
+{ 0x14, 43, 0, 2031 },
+{ 0x34, 43, 0, 2029 },
+{ 0xc, 43, 0, 2032 },
+{ 0x1c, 43, 0, 2030 },
+{ 0x2, 43, 0, 2035 },
+{ 0x6, 43, 0, 2033 },
+{ 0x1, 43, 0, 2036 },
+{ 0x3, 43, 0, 2034 },
+{ 0x51, 19, 0, 2038 },
+{ 0xd1, 19, 0, 2037 },
+{ 0x31, 19, 1, 2048 },
+{ 0x11, 20, 0, 2047 },
+{ 0x71, 19, 1, 2046 },
+{ 0x31, 20, 0, 2045 },
+{ 0x29, 19, 0, 2040 },
+{ 0x69, 19, 0, 2039 },
+{ 0x19, 19, 1, 2052 },
+{ 0x9, 20, 0, 2051 },
+{ 0x39, 19, 1, 2050 },
+{ 0x19, 20, 0, 2049 },
+{ 0x15, 19, 0, 2042 },
+{ 0x35, 19, 0, 2041 },
+{ 0xd, 19, 1, 2056 },
+{ 0x5, 20, 0, 2055 },
+{ 0x1d, 19, 1, 2054 },
+{ 0xd, 20, 0, 2053 },
+{ 0xb, 19, 0, 2044 },
+{ 0x1b, 19, 0, 2043 },
+{ 0x7, 19, 1, 2060 },
+{ 0x3, 20, 0, 2059 },
+{ 0xf, 19, 1, 2058 },
+{ 0x7, 20, 0, 2057 },
+{ 0x1, 32, 0, 2061 },
+{ 0x1, 140, 0, 2062 },
+{ 0x2, 45, 0, 2063 },
+{ 0x1, 45, 0, 2064 },
+{ 0x1, 387, 0, 2065 },
+{ 0x2, 52, 0, 2066 },
+{ 0x1, 52, 0, 2067 },
+{ 0x1, 133, 0, 2068 },
+{ 0x51, 17, 0, 2070 },
+{ 0xd1, 17, 0, 2069 },
+{ 0x31, 17, 1, 2080 },
+{ 0x11, 18, 0, 2079 },
+{ 0x71, 17, 1, 2078 },
+{ 0x31, 18, 0, 2077 },
+{ 0x29, 17, 0, 2072 },
+{ 0x69, 17, 0, 2071 },
+{ 0x19, 17, 1, 2084 },
+{ 0x9, 18, 0, 2083 },
+{ 0x39, 17, 1, 2082 },
+{ 0x19, 18, 0, 2081 },
+{ 0x15, 17, 0, 2074 },
+{ 0x35, 17, 0, 2073 },
+{ 0xd, 17, 1, 2088 },
+{ 0x5, 18, 0, 2087 },
+{ 0x1d, 17, 1, 2086 },
+{ 0xd, 18, 0, 2085 },
+{ 0xb, 17, 0, 2076 },
+{ 0x1b, 17, 0, 2075 },
+{ 0x7, 17, 1, 2092 },
+{ 0x3, 18, 0, 2091 },
+{ 0xf, 17, 1, 2090 },
+{ 0x7, 18, 0, 2089 },
+{ 0xa20, 15, 0, 2094 },
+{ 0x1a20, 15, 0, 2093 },
+{ 0x620, 15, 1, 2104 },
+{ 0x220, 16, 0, 2103 },
+{ 0xe20, 15, 1, 2102 },
+{ 0x620, 16, 0, 2101 },
+{ 0x520, 15, 0, 2096 },
+{ 0xd20, 15, 0, 2095 },
+{ 0x320, 15, 1, 2108 },
+{ 0x120, 16, 0, 2107 },
+{ 0x720, 15, 1, 2106 },
+{ 0x320, 16, 0, 2105 },
+{ 0x2a0, 15, 0, 2098 },
+{ 0x6a0, 15, 0, 2097 },
+{ 0x1a0, 15, 1, 2112 },
+{ 0xa0, 16, 0, 2111 },
+{ 0x3a0, 15, 1, 2110 },
+{ 0x1a0, 16, 0, 2109 },
+{ 0x160, 15, 0, 2100 },
+{ 0x360, 15, 0, 2099 },
+{ 0xe0, 15, 1, 2116 },
+{ 0x60, 16, 0, 2115 },
+{ 0x1e0, 15, 1, 2114 },
+{ 0xe0, 16, 0, 2113 },
+{ 0x51, 15, 1, 2142 },
+{ 0x50, 15, 0, 2118 },
+{ 0xd1, 15, 1, 2141 },
+{ 0xd0, 15, 0, 2117 },
+{ 0x31, 15, 1, 2152 },
+{ 0x30, 15, 1, 2128 },
+{ 0x11, 16, 1, 2151 },
+{ 0x10, 16, 0, 2127 },
+{ 0x71, 15, 1, 2150 },
+{ 0x70, 15, 1, 2126 },
+{ 0x31, 16, 1, 2149 },
+{ 0x30, 16, 0, 2125 },
+{ 0x29, 15, 1, 2144 },
+{ 0x28, 15, 0, 2120 },
+{ 0x69, 15, 1, 2143 },
+{ 0x68, 15, 0, 2119 },
+{ 0x19, 15, 1, 2156 },
+{ 0x18, 15, 1, 2132 },
+{ 0x9, 16, 1, 2155 },
+{ 0x8, 16, 0, 2131 },
+{ 0x39, 15, 1, 2154 },
+{ 0x38, 15, 1, 2130 },
+{ 0x19, 16, 1, 2153 },
+{ 0x18, 16, 0, 2129 },
+{ 0x15, 15, 1, 2146 },
+{ 0x14, 15, 0, 2122 },
+{ 0x35, 15, 1, 2145 },
+{ 0x34, 15, 0, 2121 },
+{ 0xd, 15, 1, 2160 },
+{ 0xc, 15, 1, 2136 },
+{ 0x5, 16, 1, 2159 },
+{ 0x4, 16, 0, 2135 },
+{ 0x1d, 15, 1, 2158 },
+{ 0x1c, 15, 1, 2134 },
+{ 0xd, 16, 1, 2157 },
+{ 0xc, 16, 0, 2133 },
+{ 0xb, 15, 1, 2148 },
+{ 0xa, 15, 0, 2124 },
+{ 0x1b, 15, 1, 2147 },
+{ 0x1a, 15, 0, 2123 },
+{ 0x7, 15, 1, 2164 },
+{ 0x6, 15, 1, 2140 },
+{ 0x3, 16, 1, 2163 },
+{ 0x2, 16, 0, 2139 },
+{ 0xf, 15, 1, 2162 },
+{ 0xe, 15, 1, 2138 },
+{ 0x7, 16, 1, 2161 },
+{ 0x6, 16, 0, 2137 },
+{ 0x8, 14, 0, 2166 },
+{ 0x18, 14, 0, 2165 },
+{ 0x1, 14, 1, 2170 },
+{ 0x2, 14, 0, 2169 },
+{ 0x3, 14, 1, 2168 },
+{ 0x4, 14, 0, 2167 },
+{ 0x1, 109, 1, 2322 },
+{ 0x1, 110, 1, 2321 },
+{ 0x1, 111, 1, 2320 },
+{ 0x1, 112, 1, 2319 },
+{ 0x1, 113, 1, 2318 },
+{ 0x1, 114, 1, 2317 },
+{ 0x1, 115, 1, 2316 },
+{ 0x1, 116, 1, 2315 },
+{ 0x39, 41, 1, 22 },
+{ 0x19, 42, 0, 21 },
+{ 0x3, 109, 1, 2314 },
+{ 0x3, 110, 1, 2313 },
+{ 0x3, 111, 1, 2312 },
+{ 0x3, 112, 1, 2311 },
+{ 0x3, 113, 1, 2310 },
+{ 0x3, 114, 1, 2309 },
+{ 0x3, 115, 1, 2308 },
+{ 0x3, 116, 1, 2307 },
+{ 0x69, 41, 0, 11 },
+{ 0x14, 100, 1, 2302 },
+{ 0x22, 101, 1, 2299 },
+{ 0x44, 101, 1, 2301 },
+{ 0xa, 108, 1, 2300 },
+{ 0xd1, 41, 0, 9 },
+{ 0x34, 100, 1, 2174 },
+{ 0xc4, 101, 1, 2173 },
+{ 0x1c, 107, 1, 2171 },
+{ 0xe, 122, 0, 2172 },
+{ 0xc, 100, 1, 2462 },
+{ 0xa, 101, 1, 2459 },
+{ 0x14, 101, 1, 2461 },
+{ 0x6, 108, 0, 2460 },
+{ 0x2, 100, 1, 2186 },
+{ 0x2, 101, 1, 2185 },
+{ 0x2, 106, 1, 2184 },
+{ 0x2, 107, 0, 2183 },
+{ 0x12, 100, 1, 2182 },
+{ 0x42, 101, 1, 2181 },
+{ 0x6, 106, 1, 2180 },
+{ 0x6, 107, 0, 2179 },
+{ 0xa, 100, 1, 2306 },
+{ 0x12, 101, 1, 2305 },
+{ 0x24, 101, 1, 2303 },
+{ 0x5, 108, 1, 2304 },
+{ 0x71, 41, 1, 18 },
+{ 0x31, 42, 0, 17 },
+{ 0x1a, 100, 1, 2178 },
+{ 0x32, 101, 1, 2177 },
+{ 0x1a, 107, 1, 2175 },
+{ 0x7, 122, 0, 2176 },
+{ 0x6, 100, 1, 2466 },
+{ 0x6, 101, 1, 2465 },
+{ 0xc, 101, 1, 2463 },
+{ 0x3, 108, 0, 2464 },
+{ 0x1, 100, 1, 2482 },
+{ 0x1, 101, 1, 2481 },
+{ 0x1, 102, 1, 2480 },
+{ 0x1, 103, 1, 2479 },
+{ 0x1, 104, 1, 2478 },
+{ 0x1, 105, 1, 2477 },
+{ 0x1, 106, 1, 2476 },
+{ 0x1, 107, 0, 2475 },
+{ 0x3, 100, 1, 2474 },
+{ 0x3, 101, 1, 2473 },
+{ 0x3, 102, 1, 2472 },
+{ 0x3, 103, 1, 2471 },
+{ 0x3, 104, 1, 2470 },
+{ 0x3, 105, 1, 2469 },
+{ 0x3, 106, 1, 2468 },
+{ 0x3, 107, 0, 2467 },
+{ 0x8, 67, 1, 2346 },
+{ 0x8, 68, 1, 2345 },
+{ 0x2, 73, 1, 2340 },
+{ 0x2, 74, 1, 2339 },
+{ 0x1, 76, 1, 2344 },
+{ 0x1, 77, 1, 2343 },
+{ 0x1, 78, 1, 2342 },
+{ 0x1, 79, 1, 2341 },
+{ 0xf, 41, 1, 30 },
+{ 0x7, 42, 0, 29 },
+{ 0x18, 67, 1, 2338 },
+{ 0x18, 68, 1, 2337 },
+{ 0x6, 73, 1, 2332 },
+{ 0x6, 74, 1, 2331 },
+{ 0x3, 76, 1, 2336 },
+{ 0x3, 77, 1, 2335 },
+{ 0x3, 78, 1, 2334 },
+{ 0x3, 79, 1, 2333 },
+{ 0x1b, 41, 0, 15 },
+{ 0x14, 67, 1, 2326 },
+{ 0x22, 68, 1, 2323 },
+{ 0x44, 68, 1, 2325 },
+{ 0xa, 75, 1, 2324 },
+{ 0x35, 41, 0, 13 },
+{ 0x34, 67, 1, 2190 },
+{ 0xc4, 68, 1, 2189 },
+{ 0x38, 74, 1, 2187 },
+{ 0xe, 85, 0, 2188 },
+{ 0xc, 67, 1, 2486 },
+{ 0xa, 68, 1, 2483 },
+{ 0x14, 68, 1, 2485 },
+{ 0x6, 75, 0, 2484 },
+{ 0x2, 67, 1, 2202 },
+{ 0x2, 68, 1, 2201 },
+{ 0x4, 73, 1, 2200 },
+{ 0x4, 74, 0, 2199 },
+{ 0x12, 67, 1, 2198 },
+{ 0x42, 68, 1, 2197 },
+{ 0xc, 73, 1, 2196 },
+{ 0xc, 74, 0, 2195 },
+{ 0xa, 67, 1, 2330 },
+{ 0x12, 68, 1, 2329 },
+{ 0x24, 68, 1, 2327 },
+{ 0x5, 75, 1, 2328 },
+{ 0x1d, 41, 1, 26 },
+{ 0xd, 42, 0, 25 },
+{ 0x1a, 67, 1, 2194 },
+{ 0x32, 68, 1, 2193 },
+{ 0x34, 74, 1, 2191 },
+{ 0x7, 85, 0, 2192 },
+{ 0x6, 67, 1, 2490 },
+{ 0x6, 68, 1, 2489 },
+{ 0xc, 68, 1, 2487 },
+{ 0x3, 75, 0, 2488 },
+{ 0x1, 67, 1, 2506 },
+{ 0x1, 68, 1, 2505 },
+{ 0x1, 69, 1, 2504 },
+{ 0x1, 70, 1, 2503 },
+{ 0x1, 71, 1, 2502 },
+{ 0x1, 72, 1, 2501 },
+{ 0x1, 73, 1, 2500 },
+{ 0x1, 74, 0, 2499 },
+{ 0x3, 67, 1, 2498 },
+{ 0x3, 68, 1, 2497 },
+{ 0x3, 69, 1, 2496 },
+{ 0x3, 70, 1, 2495 },
+{ 0x3, 71, 1, 2494 },
+{ 0x3, 72, 1, 2493 },
+{ 0x3, 73, 1, 2492 },
+{ 0x3, 74, 0, 2491 },
+{ 0x28, 95, 1, 2354 },
+{ 0x44, 96, 1, 2349 },
+{ 0x88, 96, 1, 2353 },
+{ 0x44, 97, 1, 2348 },
+{ 0x88, 97, 1, 2352 },
+{ 0x44, 98, 1, 2347 },
+{ 0x88, 98, 1, 2351 },
+{ 0x28, 99, 0, 2350 },
+{ 0x68, 95, 1, 2210 },
+{ 0x188, 96, 1, 2209 },
+{ 0x188, 97, 1, 2208 },
+{ 0x188, 98, 1, 2207 },
+{ 0x38, 118, 1, 2206 },
+{ 0x38, 119, 1, 2205 },
+{ 0x38, 120, 1, 2204 },
+{ 0x38, 121, 0, 2203 },
+{ 0x18, 95, 1, 2514 },
+{ 0x14, 96, 1, 2509 },
+{ 0x28, 96, 1, 2513 },
+{ 0x14, 97, 1, 2508 },
+{ 0x28, 97, 1, 2512 },
+{ 0x14, 98, 1, 2507 },
+{ 0x28, 98, 1, 2511 },
+{ 0x18, 99, 0, 2510 },
+{ 0x14, 95, 1, 2362 },
+{ 0x24, 96, 1, 2361 },
+{ 0x48, 96, 1, 2357 },
+{ 0x24, 97, 1, 2360 },
+{ 0x48, 97, 1, 2356 },
+{ 0x24, 98, 1, 2359 },
+{ 0x48, 98, 1, 2355 },
+{ 0x14, 99, 0, 2358 },
+{ 0x34, 95, 1, 2218 },
+{ 0x64, 96, 1, 2217 },
+{ 0x64, 97, 1, 2216 },
+{ 0x64, 98, 1, 2215 },
+{ 0x1c, 118, 1, 2214 },
+{ 0x1c, 119, 1, 2213 },
+{ 0x1c, 120, 1, 2212 },
+{ 0x1c, 121, 0, 2211 },
+{ 0xc, 95, 1, 2522 },
+{ 0xc, 96, 1, 2521 },
+{ 0x18, 96, 1, 2517 },
+{ 0xc, 97, 1, 2520 },
+{ 0x18, 97, 1, 2516 },
+{ 0xc, 98, 1, 2519 },
+{ 0x18, 98, 1, 2515 },
+{ 0xc, 99, 0, 2518 },
+{ 0xa, 95, 1, 2370 },
+{ 0x11, 96, 1, 2365 },
+{ 0x22, 96, 1, 2369 },
+{ 0x11, 97, 1, 2364 },
+{ 0x22, 97, 1, 2368 },
+{ 0x11, 98, 1, 2363 },
+{ 0x22, 98, 1, 2367 },
+{ 0xa, 99, 0, 2366 },
+{ 0x1a, 95, 1, 2226 },
+{ 0x62, 96, 1, 2225 },
+{ 0x62, 97, 1, 2224 },
+{ 0x62, 98, 1, 2223 },
+{ 0xe, 118, 1, 2222 },
+{ 0xe, 119, 1, 2221 },
+{ 0xe, 120, 1, 2220 },
+{ 0xe, 121, 0, 2219 },
+{ 0x6, 95, 1, 2530 },
+{ 0x5, 96, 1, 2525 },
+{ 0xa, 96, 1, 2529 },
+{ 0x5, 97, 1, 2524 },
+{ 0xa, 97, 1, 2528 },
+{ 0x5, 98, 1, 2523 },
+{ 0xa, 98, 1, 2527 },
+{ 0x6, 99, 0, 2526 },
+{ 0x5, 95, 1, 2378 },
+{ 0x9, 96, 1, 2377 },
+{ 0x12, 96, 1, 2373 },
+{ 0x9, 97, 1, 2376 },
+{ 0x12, 97, 1, 2372 },
+{ 0x9, 98, 1, 2375 },
+{ 0x12, 98, 1, 2371 },
+{ 0x5, 99, 0, 2374 },
+{ 0xd, 95, 1, 2234 },
+{ 0x19, 96, 1, 2233 },
+{ 0x19, 97, 1, 2232 },
+{ 0x19, 98, 1, 2231 },
+{ 0x7, 118, 1, 2230 },
+{ 0x7, 119, 1, 2229 },
+{ 0x7, 120, 1, 2228 },
+{ 0x7, 121, 0, 2227 },
+{ 0x3, 95, 1, 2538 },
+{ 0x3, 96, 1, 2537 },
+{ 0x6, 96, 1, 2533 },
+{ 0x3, 97, 1, 2536 },
+{ 0x6, 97, 1, 2532 },
+{ 0x3, 98, 1, 2535 },
+{ 0x6, 98, 1, 2531 },
+{ 0x3, 99, 0, 2534 },
+{ 0x28, 62, 1, 2386 },
+{ 0x44, 63, 1, 2381 },
+{ 0x88, 63, 1, 2385 },
+{ 0x44, 64, 1, 2380 },
+{ 0x88, 64, 1, 2384 },
+{ 0x44, 65, 1, 2379 },
+{ 0x88, 65, 1, 2383 },
+{ 0x28, 66, 0, 2382 },
+{ 0x68, 62, 1, 2242 },
+{ 0x188, 63, 1, 2241 },
+{ 0x188, 64, 1, 2240 },
+{ 0x188, 65, 1, 2239 },
+{ 0x38, 81, 1, 2238 },
+{ 0x38, 82, 1, 2237 },
+{ 0x38, 83, 1, 2236 },
+{ 0x38, 84, 0, 2235 },
+{ 0x18, 62, 1, 2546 },
+{ 0x14, 63, 1, 2541 },
+{ 0x28, 63, 1, 2545 },
+{ 0x14, 64, 1, 2540 },
+{ 0x28, 64, 1, 2544 },
+{ 0x14, 65, 1, 2539 },
+{ 0x28, 65, 1, 2543 },
+{ 0x18, 66, 0, 2542 },
+{ 0x14, 62, 1, 2394 },
+{ 0x24, 63, 1, 2393 },
+{ 0x48, 63, 1, 2389 },
+{ 0x24, 64, 1, 2392 },
+{ 0x48, 64, 1, 2388 },
+{ 0x24, 65, 1, 2391 },
+{ 0x48, 65, 1, 2387 },
+{ 0x14, 66, 0, 2390 },
+{ 0x34, 62, 1, 2250 },
+{ 0x64, 63, 1, 2249 },
+{ 0x64, 64, 1, 2248 },
+{ 0x64, 65, 1, 2247 },
+{ 0x1c, 81, 1, 2246 },
+{ 0x1c, 82, 1, 2245 },
+{ 0x1c, 83, 1, 2244 },
+{ 0x1c, 84, 0, 2243 },
+{ 0xc, 62, 1, 2554 },
+{ 0xc, 63, 1, 2553 },
+{ 0x18, 63, 1, 2549 },
+{ 0xc, 64, 1, 2552 },
+{ 0x18, 64, 1, 2548 },
+{ 0xc, 65, 1, 2551 },
+{ 0x18, 65, 1, 2547 },
+{ 0xc, 66, 0, 2550 },
+{ 0xa, 62, 1, 2402 },
+{ 0x11, 63, 1, 2397 },
+{ 0x22, 63, 1, 2401 },
+{ 0x11, 64, 1, 2396 },
+{ 0x22, 64, 1, 2400 },
+{ 0x11, 65, 1, 2395 },
+{ 0x22, 65, 1, 2399 },
+{ 0xa, 66, 0, 2398 },
+{ 0x1a, 62, 1, 2258 },
+{ 0x62, 63, 1, 2257 },
+{ 0x62, 64, 1, 2256 },
+{ 0x62, 65, 1, 2255 },
+{ 0xe, 81, 1, 2254 },
+{ 0xe, 82, 1, 2253 },
+{ 0xe, 83, 1, 2252 },
+{ 0xe, 84, 0, 2251 },
+{ 0x6, 62, 1, 2562 },
+{ 0x5, 63, 1, 2557 },
+{ 0xa, 63, 1, 2561 },
+{ 0x5, 64, 1, 2556 },
+{ 0xa, 64, 1, 2560 },
+{ 0x5, 65, 1, 2555 },
+{ 0xa, 65, 1, 2559 },
+{ 0x6, 66, 0, 2558 },
+{ 0x5, 62, 1, 2410 },
+{ 0x9, 63, 1, 2409 },
+{ 0x12, 63, 1, 2405 },
+{ 0x9, 64, 1, 2408 },
+{ 0x12, 64, 1, 2404 },
+{ 0x9, 65, 1, 2407 },
+{ 0x12, 65, 1, 2403 },
+{ 0x5, 66, 0, 2406 },
+{ 0xd, 62, 1, 2266 },
+{ 0x19, 63, 1, 2265 },
+{ 0x19, 64, 1, 2264 },
+{ 0x19, 65, 1, 2263 },
+{ 0x7, 81, 1, 2262 },
+{ 0x7, 82, 1, 2261 },
+{ 0x7, 83, 1, 2260 },
+{ 0x7, 84, 0, 2259 },
+{ 0x3, 62, 1, 2570 },
+{ 0x3, 63, 1, 2569 },
+{ 0x6, 63, 1, 2565 },
+{ 0x3, 64, 1, 2568 },
+{ 0x6, 64, 1, 2564 },
+{ 0x3, 65, 1, 2567 },
+{ 0x6, 65, 1, 2563 },
+{ 0x3, 66, 0, 2566 },
+{ 0x8, 86, 1, 2434 },
+{ 0x8, 87, 1, 2433 },
+{ 0x2, 88, 1, 2432 },
+{ 0x2, 89, 1, 2431 },
+{ 0x2, 90, 1, 2430 },
+{ 0x2, 91, 1, 2429 },
+{ 0x2, 92, 1, 2428 },
+{ 0x2, 93, 0, 2427 },
+{ 0x18, 86, 1, 2426 },
+{ 0x18, 87, 1, 2425 },
+{ 0x6, 88, 1, 2424 },
+{ 0x6, 89, 1, 2423 },
+{ 0x6, 90, 1, 2422 },
+{ 0x6, 91, 1, 2421 },
+{ 0x6, 92, 1, 2420 },
+{ 0x6, 93, 0, 2419 },
+{ 0x14, 86, 1, 2414 },
+{ 0x22, 87, 1, 2411 },
+{ 0x44, 87, 1, 2413 },
+{ 0xa, 94, 0, 2412 },
+{ 0x34, 86, 1, 2270 },
+{ 0xc4, 87, 1, 2269 },
+{ 0x38, 93, 1, 2267 },
+{ 0xe, 117, 0, 2268 },
+{ 0xc, 86, 1, 2574 },
+{ 0xa, 87, 1, 2571 },
+{ 0x14, 87, 1, 2573 },
+{ 0x6, 94, 0, 2572 },
+{ 0x2, 86, 1, 2282 },
+{ 0x2, 87, 1, 2281 },
+{ 0x4, 92, 1, 2280 },
+{ 0x4, 93, 0, 2279 },
+{ 0x12, 86, 1, 2278 },
+{ 0x42, 87, 1, 2277 },
+{ 0xc, 92, 1, 2276 },
+{ 0xc, 93, 0, 2275 },
+{ 0xa, 86, 1, 2418 },
+{ 0x12, 87, 1, 2417 },
+{ 0x24, 87, 1, 2415 },
+{ 0x5, 94, 0, 2416 },
+{ 0x1a, 86, 1, 2274 },
+{ 0x32, 87, 1, 2273 },
+{ 0x34, 93, 1, 2271 },
+{ 0x7, 117, 0, 2272 },
+{ 0x6, 86, 1, 2578 },
+{ 0x6, 87, 1, 2577 },
+{ 0xc, 87, 1, 2575 },
+{ 0x3, 94, 0, 2576 },
+{ 0x1, 86, 1, 2594 },
+{ 0x1, 87, 1, 2593 },
+{ 0x1, 88, 1, 2592 },
+{ 0x1, 89, 1, 2591 },
+{ 0x1, 90, 1, 2590 },
+{ 0x1, 91, 1, 2589 },
+{ 0x1, 92, 1, 2588 },
+{ 0x1, 93, 0, 2587 },
+{ 0x3, 86, 1, 2586 },
+{ 0x3, 87, 1, 2585 },
+{ 0x3, 88, 1, 2584 },
+{ 0x3, 89, 1, 2583 },
+{ 0x3, 90, 1, 2582 },
+{ 0x3, 91, 1, 2581 },
+{ 0x3, 92, 1, 2580 },
+{ 0x3, 93, 0, 2579 },
+{ 0x8, 53, 1, 2458 },
+{ 0x8, 54, 1, 2457 },
+{ 0x2, 55, 1, 2456 },
+{ 0x2, 56, 1, 2455 },
+{ 0x2, 57, 1, 2454 },
+{ 0x2, 58, 1, 2453 },
+{ 0x2, 59, 1, 2452 },
+{ 0x2, 60, 0, 2451 },
+{ 0x18, 53, 1, 2450 },
+{ 0x18, 54, 1, 2449 },
+{ 0x6, 55, 1, 2448 },
+{ 0x6, 56, 1, 2447 },
+{ 0x6, 57, 1, 2446 },
+{ 0x6, 58, 1, 2445 },
+{ 0x6, 59, 1, 2444 },
+{ 0x6, 60, 0, 2443 },
+{ 0x14, 53, 1, 2438 },
+{ 0x22, 54, 1, 2435 },
+{ 0x44, 54, 1, 2437 },
+{ 0xa, 61, 0, 2436 },
+{ 0x34, 53, 1, 2286 },
+{ 0xc4, 54, 1, 2285 },
+{ 0x38, 60, 1, 2283 },
+{ 0xe, 80, 0, 2284 },
+{ 0xc, 53, 1, 2598 },
+{ 0xa, 54, 1, 2595 },
+{ 0x14, 54, 1, 2597 },
+{ 0x6, 61, 0, 2596 },
+{ 0x2, 53, 1, 2298 },
+{ 0x2, 54, 1, 2297 },
+{ 0x4, 59, 1, 2296 },
+{ 0x4, 60, 0, 2295 },
+{ 0x12, 53, 1, 2294 },
+{ 0x42, 54, 1, 2293 },
+{ 0xc, 59, 1, 2292 },
+{ 0xc, 60, 0, 2291 },
+{ 0xa, 53, 1, 2442 },
+{ 0x12, 54, 1, 2441 },
+{ 0x24, 54, 1, 2439 },
+{ 0x5, 61, 0, 2440 },
+{ 0x1a, 53, 1, 2290 },
+{ 0x32, 54, 1, 2289 },
+{ 0x34, 60, 1, 2287 },
+{ 0x7, 80, 0, 2288 },
+{ 0x6, 53, 1, 2602 },
+{ 0x6, 54, 1, 2601 },
+{ 0xc, 54, 1, 2599 },
+{ 0x3, 61, 0, 2600 },
+{ 0x1, 53, 1, 2618 },
+{ 0x1, 54, 1, 2617 },
+{ 0x1, 55, 1, 2616 },
+{ 0x1, 56, 1, 2615 },
+{ 0x1, 57, 1, 2614 },
+{ 0x1, 58, 1, 2613 },
+{ 0x1, 59, 1, 2612 },
+{ 0x1, 60, 0, 2611 },
+{ 0x3, 53, 1, 2610 },
+{ 0x3, 54, 1, 2609 },
+{ 0x3, 55, 1, 2608 },
+{ 0x3, 56, 1, 2607 },
+{ 0x3, 57, 1, 2606 },
+{ 0x3, 58, 1, 2605 },
+{ 0x3, 59, 1, 2604 },
+{ 0x3, 60, 0, 2603 },
+{ 0x1, 4, 0, 2619 },
+{ 0x1, 296, 0, 2620 },
+{ 0x1, 379, 0, 2621 },
+{ 0x1, 374, 0, 2622 },
+{ 0x2, 358, 0, 2623 },
+{ 0x1, 358, 0, 2626 },
+{ 0x2, 357, 0, 2624 },
+{ 0x1, 357, 0, 2627 },
+{ 0x2, 356, 0, 2625 },
+{ 0x1, 356, 0, 2628 },
+{ 0x1, 355, 0, 2629 },
+{ 0x1, 354, 0, 2630 },
+{ 0x2, 353, 0, 2631 },
+{ 0x1, 353, 0, 2633 },
+{ 0x2, 352, 0, 2632 },
+{ 0x1, 352, 0, 2634 },
+{ 0x1, 382, 0, 2641 },
+{ 0x8, 381, 0, 2635 },
+{ 0x4, 381, 0, 2637 },
+{ 0x2, 381, 0, 2639 },
+{ 0x1, 381, 0, 2642 },
+{ 0x8, 380, 0, 2636 },
+{ 0x4, 380, 0, 2638 },
+{ 0x2, 380, 0, 2640 },
+{ 0x1, 380, 0, 2643 },
+{ 0x1, 351, 0, 2650 },
+{ 0x8, 350, 0, 2644 },
+{ 0x4, 350, 0, 2646 },
+{ 0x2, 350, 0, 2648 },
+{ 0x1, 350, 0, 2651 },
+{ 0x8, 349, 0, 2645 },
+{ 0x4, 349, 0, 2647 },
+{ 0x2, 349, 1, 2649 },
+{ 0x4, 143, 0, 1345 },
+{ 0x1, 349, 0, 2652 },
+{ 0x1, 6, 0, 2653 },
+{ 0x1, 7, 0, 2654 },
+{ 0x1, 295, 0, 2655 },
+{ 0x1, 451, 0, 2656 },
+{ 0x1, 346, 0, 2657 },
+{ 0x1, 13, 0, 2658 },
+{ 0x1, 11, 0, 2659 },
+{ 0x1, 422, 0, 2660 },
+{ 0x1, 394, 0, 2661 },
+{ 0x1, 393, 0, 2662 },
+{ 0x1, 450, 0, 2663 },
+{ 0x1, 345, 0, 2664 },
+{ 0x1, 12, 0, 2665 },
+{ 0x1, 10, 0, 2666 },
+{ 0x1, 5, 0, 2667 },
+{ 0x1, 421, 0, 2668 },
+{ 0x1, 420, 0, 2669 },
+{ 0x1, 1, 0, 2670 },
+{ 0x1, 0, 0, 2671 },
+};
+
--- /dev/null
+++ b/arch/ia64/kdb/ia64-asmtab.h
@@ -0,0 +1,158 @@
+/* ia64-asmtab.h -- Header for compacted IA-64 opcode tables.
+   Copyright 1999, 2000 Free Software Foundation, Inc.
+   Contributed by Bob Manson of Cygnus Support <manson@cygnus.com>
+
+   This file is part of GDB, GAS, and the GNU binutils.
+
+   GDB, GAS, and the GNU binutils are free software; you can redistribute
+   them and/or modify them under the terms of the GNU General Public
+   License as published by the Free Software Foundation; either version
+   2, or (at your option) any later version.
+
+   GDB, GAS, and the GNU binutils are distributed in the hope that they
+   will be useful, but WITHOUT ANY WARRANTY; without even the implied
+   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+   the GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this file; see the file COPYING.  If not, write to the
+   Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+/* Extracted from binutils 2.16.91.0.2 (OpenSUSE 10.0) and modified for kdb use.
+ * Any trailing whitespace was removed and #ifdef/ifndef __KERNEL__ added as
+ * required.
+ * Keith Owens <kaos@sgi.com> 15 May 2006
+ */
+
+#ifndef IA64_ASMTAB_H
+#define IA64_ASMTAB_H
+
+#ifdef __KERNEL__
+#include "ia64.h"
+#else	/* __KERNEL__ */
+#include "opcode/ia64.h"
+#endif	/* __KERNEL__ */
+
+/* The primary opcode table is made up of the following: */
+struct ia64_main_table
+{
+  /* The entry in the string table that corresponds to the name of this
+     opcode. */
+  unsigned short name_index;
+
+  /* The type of opcode; corresponds to the TYPE field in
+     struct ia64_opcode. */
+  unsigned char opcode_type;
+
+  /* The number of outputs for this opcode. */
+  unsigned char num_outputs;
+
+  /* The base insn value for this opcode.  It may be modified by completers. */
+  ia64_insn opcode;
+
+  /* The mask of valid bits in OPCODE. Zeros indicate operand fields. */
+  ia64_insn mask;
+
+  /* The operands of this instruction.  Corresponds to the OPERANDS field
+     in struct ia64_opcode. */
+  unsigned char operands[5];
+
+  /* The flags for this instruction.  Corresponds to the FLAGS field in
+     struct ia64_opcode. */
+  short flags;
+
+  /* The tree of completers for this instruction; this is an offset into
+     completer_table. */
+  short completers;
+};
+
+/* Each instruction has a set of possible "completers", or additional
+   suffixes that can alter the instruction's behavior, and which has
+   potentially different dependencies.
+
+   The completer entries modify certain bits in the instruction opcode.
+   Which bits are to be modified are marked by the BITS, MASK and
+   OFFSET fields.  The completer entry may also note dependencies for the
+   opcode.
+
+   These completers are arranged in a DAG; the pointers are indexes
+   into the completer_table array.  The completer DAG is searched by
+   find_completer () and ia64_find_matching_opcode ().
+
+   Note that each completer needs to be applied in turn, so that if we
+   have the instruction
+   	cmp.lt.unc
+   the completer entries for both "lt" and "unc" would need to be applied
+   to the opcode's value.
+
+   Some instructions do not require any completers; these contain an
+   empty completer entry.  Instructions that require a completer do
+   not contain an empty entry.
+
+   Terminal completers (those completers that validly complete an
+   instruction) are marked by having the TERMINAL_COMPLETER flag set.
+
+   Only dependencies listed in the terminal completer for an opcode are
+   considered to apply to that opcode instance. */
+
+struct ia64_completer_table
+{
+  /* The bit value that this completer sets. */
+  unsigned int bits;
+
+  /* And its mask. 1s are bits that are to be modified in the
+     instruction. */
+  unsigned int mask;
+
+  /* The entry in the string table that corresponds to the name of this
+     completer. */
+  unsigned short name_index;
+
+  /* An alternative completer, or -1 if this is the end of the chain. */
+  short alternative;
+
+  /* A pointer to the DAG of completers that can potentially follow
+     this one, or -1. */
+  short subentries;
+
+  /* The bit offset in the instruction where BITS and MASK should be
+     applied. */
+  unsigned char offset : 7;
+
+  unsigned char terminal_completer : 1;
+
+  /* Index into the dependency list table */
+  short dependencies;
+};
+
+/* This contains sufficient information for the disassembler to resolve
+   the complete name of the original instruction.  */
+struct ia64_dis_names
+{
+  /* COMPLETER_INDEX represents the tree of completers that make up
+     the instruction.  The LSB represents the top of the tree for the
+     specified instruction.
+
+     A 0 bit indicates to go to the next alternate completer via the
+     alternative field; a 1 bit indicates that the current completer
+     is part of the instruction, and to go down the subentries index.
+     We know we've reached the final completer when we run out of 1
+     bits.
+
+     There is always at least one 1 bit. */
+  unsigned int completer_index : 20;
+
+  /* The index in the main_table[] array for the instruction. */
+  unsigned short insn_index : 11;
+
+  /* If set, the next entry in this table is an alternate possibility
+     for this instruction encoding.  Which one to use is determined by
+     the instruction type and other factors (see opcode_verify ()).  */
+  unsigned int next_flag : 1;
+
+  /* The disassembly priority of this entry among instructions. */
+  unsigned short priority;
+};
+
+#endif
--- /dev/null
+++ b/arch/ia64/kdb/ia64-dis.c
@@ -0,0 +1,312 @@
+/* ia64-dis.c -- Disassemble ia64 instructions
+   Copyright 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   This file is part of GDB, GAS, and the GNU binutils.
+
+   GDB, GAS, and the GNU binutils are free software; you can redistribute
+   them and/or modify them under the terms of the GNU General Public
+   License as published by the Free Software Foundation; either version
+   2, or (at your option) any later version.
+
+   GDB, GAS, and the GNU binutils are distributed in the hope that they
+   will be useful, but WITHOUT ANY WARRANTY; without even the implied
+   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+   the GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this file; see the file COPYING.  If not, write to the
+   Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+/* Extracted from binutils 2.16.91.0.2 (OpenSUSE 10.0) and modified for kdb use.
+ * Any trailing whitespace was removed and #ifdef/ifndef __KERNEL__ added as
+ * required.
+ * Keith Owens <kaos@sgi.com> 15 May 2006
+ */
+
+#ifdef __KERNEL__
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/dis-asm.h>
+#include "ia64.h"
+
+/* imported from bfd/libbfd.c for kernel */
+bfd_uint64_t
+bfd_getl64 (const void *p ATTRIBUTE_UNUSED)
+{
+#ifdef BFD_HOST_64_BIT
+  const bfd_byte *addr = p;
+  bfd_uint64_t v;
+
+  v  = addr[7]; v <<= 8;
+  v |= addr[6]; v <<= 8;
+  v |= addr[5]; v <<= 8;
+  v |= addr[4]; v <<= 8;
+  v |= addr[3]; v <<= 8;
+  v |= addr[2]; v <<= 8;
+  v |= addr[1]; v <<= 8;
+  v |= addr[0];
+
+  return v;
+#else
+  BFD_FAIL();
+  return 0;
+#endif
+
+}
+
+#else	/* __KERNEL__ */
+#include <assert.h>
+#include <string.h>
+
+#include "dis-asm.h"
+#include "opcode/ia64.h"
+#endif	/* __KERNEL__ */
+
+#define NELEMS(a)	((int) (sizeof (a) / sizeof (a[0])))
+
+/* Disassemble ia64 instruction.  */
+
+/* Return the instruction type for OPCODE found in unit UNIT. */
+
+static enum ia64_insn_type
+unit_to_type (ia64_insn opcode, enum ia64_unit unit)
+{
+  enum ia64_insn_type type;
+  int op;
+
+  op = IA64_OP (opcode);
+
+  if (op >= 8 && (unit == IA64_UNIT_I || unit == IA64_UNIT_M))
+    {
+      type = IA64_TYPE_A;
+    }
+  else
+    {
+      switch (unit)
+	{
+	case IA64_UNIT_I:
+	  type = IA64_TYPE_I; break;
+	case IA64_UNIT_M:
+	  type = IA64_TYPE_M; break;
+	case IA64_UNIT_B:
+	  type = IA64_TYPE_B; break;
+	case IA64_UNIT_F:
+	  type = IA64_TYPE_F; break;
+        case IA64_UNIT_L:
+	case IA64_UNIT_X:
+	  type = IA64_TYPE_X; break;
+	default:
+	  type = -1;
+	}
+    }
+  return type;
+}
+
+int
+print_insn_ia64 (bfd_vma memaddr, struct disassemble_info *info)
+{
+  ia64_insn t0, t1, slot[3], template, s_bit, insn;
+  int slotnum, j, status, need_comma, retval, slot_multiplier;
+  const struct ia64_operand *odesc;
+  const struct ia64_opcode *idesc;
+  const char *err, *str, *tname;
+  BFD_HOST_U_64_BIT value;
+  bfd_byte bundle[16];
+  enum ia64_unit unit;
+  char regname[16];
+
+  if (info->bytes_per_line == 0)
+    info->bytes_per_line = 6;
+  info->display_endian = info->endian;
+
+  slot_multiplier = info->bytes_per_line;
+  retval = slot_multiplier;
+
+  slotnum = (((long) memaddr) & 0xf) / slot_multiplier;
+  if (slotnum > 2)
+    return -1;
+
+  memaddr -= (memaddr & 0xf);
+  status = (*info->read_memory_func) (memaddr, bundle, sizeof (bundle), info);
+  if (status != 0)
+    {
+      (*info->memory_error_func) (status, memaddr, info);
+      return -1;
+    }
+  /* bundles are always in little-endian byte order */
+  t0 = bfd_getl64 (bundle);
+  t1 = bfd_getl64 (bundle + 8);
+  s_bit = t0 & 1;
+  template = (t0 >> 1) & 0xf;
+  slot[0] = (t0 >>  5) & 0x1ffffffffffLL;
+  slot[1] = ((t0 >> 46) & 0x3ffff) | ((t1 & 0x7fffff) << 18);
+  slot[2] = (t1 >> 23) & 0x1ffffffffffLL;
+
+  tname = ia64_templ_desc[template].name;
+  if (slotnum == 0)
+    (*info->fprintf_func) (info->stream, "[%s] ", tname);
+  else
+    (*info->fprintf_func) (info->stream, "      ");
+
+  unit = ia64_templ_desc[template].exec_unit[slotnum];
+
+  if (template == 2 && slotnum == 1)
+    {
+      /* skip L slot in MLI template: */
+      slotnum = 2;
+      retval += slot_multiplier;
+    }
+
+  insn = slot[slotnum];
+
+  if (unit == IA64_UNIT_NIL)
+    goto decoding_failed;
+
+  idesc = ia64_dis_opcode (insn, unit_to_type (insn, unit));
+  if (idesc == NULL)
+    goto decoding_failed;
+
+  /* print predicate, if any: */
+
+  if ((idesc->flags & IA64_OPCODE_NO_PRED)
+      || (insn & 0x3f) == 0)
+    (*info->fprintf_func) (info->stream, "      ");
+  else
+    (*info->fprintf_func) (info->stream, "(p%02d) ", (int)(insn & 0x3f));
+
+  /* now the actual instruction: */
+
+  (*info->fprintf_func) (info->stream, "%s", idesc->name);
+  if (idesc->operands[0])
+    (*info->fprintf_func) (info->stream, " ");
+
+  need_comma = 0;
+  for (j = 0; j < NELEMS (idesc->operands) && idesc->operands[j]; ++j)
+    {
+      odesc = elf64_ia64_operands + idesc->operands[j];
+
+      if (need_comma)
+	(*info->fprintf_func) (info->stream, ",");
+
+      if (odesc - elf64_ia64_operands == IA64_OPND_IMMU64)
+	{
+	  /* special case of 64 bit immediate load: */
+	  value = ((insn >> 13) & 0x7f) | (((insn >> 27) & 0x1ff) << 7)
+	    | (((insn >> 22) & 0x1f) << 16) | (((insn >> 21) & 0x1) << 21)
+	    | (slot[1] << 22) | (((insn >> 36) & 0x1) << 63);
+	}
+      else if (odesc - elf64_ia64_operands == IA64_OPND_IMMU62)
+        {
+          /* 62-bit immediate for nop.x/break.x */
+          value = ((slot[1] & 0x1ffffffffffLL) << 21)
+            | (((insn >> 36) & 0x1) << 20)
+            | ((insn >> 6) & 0xfffff);
+        }
+      else if (odesc - elf64_ia64_operands == IA64_OPND_TGT64)
+	{
+	  /* 60-bit immediate for long branches. */
+	  value = (((insn >> 13) & 0xfffff)
+		   | (((insn >> 36) & 1) << 59)
+		   | (((slot[1] >> 2) & 0x7fffffffffLL) << 20)) << 4;
+	}
+      else
+	{
+	  err = (*odesc->extract) (odesc, insn, &value);
+	  if (err)
+	    {
+	      (*info->fprintf_func) (info->stream, "%s", err);
+	      goto done;
+	    }
+	}
+
+	switch (odesc->class)
+	  {
+	  case IA64_OPND_CLASS_CST:
+	    (*info->fprintf_func) (info->stream, "%s", odesc->str);
+	    break;
+
+	  case IA64_OPND_CLASS_REG:
+	    if (odesc->str[0] == 'a' && odesc->str[1] == 'r')
+	      {
+		switch (value)
+		  {
+		  case 0: case 1: case 2: case 3:
+		  case 4: case 5: case 6: case 7:
+		    sprintf (regname, "ar.k%u", (unsigned int) value);
+		    break;
+		  case 16:	strcpy (regname, "ar.rsc"); break;
+		  case 17:	strcpy (regname, "ar.bsp"); break;
+		  case 18:	strcpy (regname, "ar.bspstore"); break;
+		  case 19:	strcpy (regname, "ar.rnat"); break;
+		  case 32:	strcpy (regname, "ar.ccv"); break;
+		  case 36:	strcpy (regname, "ar.unat"); break;
+		  case 40:	strcpy (regname, "ar.fpsr"); break;
+		  case 44:	strcpy (regname, "ar.itc"); break;
+		  case 64:	strcpy (regname, "ar.pfs"); break;
+		  case 65:	strcpy (regname, "ar.lc"); break;
+		  case 66:	strcpy (regname, "ar.ec"); break;
+		  default:
+		    sprintf (regname, "ar%u", (unsigned int) value);
+		    break;
+		  }
+		(*info->fprintf_func) (info->stream, "%s", regname);
+	      }
+	    else
+	      (*info->fprintf_func) (info->stream, "%s%d", odesc->str, (int)value);
+	    break;
+
+	  case IA64_OPND_CLASS_IND:
+	    (*info->fprintf_func) (info->stream, "%s[r%d]", odesc->str, (int)value);
+	    break;
+
+	  case IA64_OPND_CLASS_ABS:
+	    str = 0;
+	    if (odesc - elf64_ia64_operands == IA64_OPND_MBTYPE4)
+	      switch (value)
+		{
+		case 0x0: str = "@brcst"; break;
+		case 0x8: str = "@mix"; break;
+		case 0x9: str = "@shuf"; break;
+		case 0xa: str = "@alt"; break;
+		case 0xb: str = "@rev"; break;
+		}
+
+	    if (str)
+	      (*info->fprintf_func) (info->stream, "%s", str);
+	    else if (odesc->flags & IA64_OPND_FLAG_DECIMAL_SIGNED)
+	      (*info->fprintf_func) (info->stream, "%lld", (long long) value);
+	    else if (odesc->flags & IA64_OPND_FLAG_DECIMAL_UNSIGNED)
+	      (*info->fprintf_func) (info->stream, "%llu", (long long) value);
+	    else
+	      (*info->fprintf_func) (info->stream, "0x%llx", (long long) value);
+	    break;
+
+	  case IA64_OPND_CLASS_REL:
+	    (*info->print_address_func) (memaddr + value, info);
+	    break;
+	  }
+
+      need_comma = 1;
+      if (j + 1 == idesc->num_outputs)
+	{
+	  (*info->fprintf_func) (info->stream, "=");
+	  need_comma = 0;
+	}
+    }
+  if (slotnum + 1 == ia64_templ_desc[template].group_boundary
+      || ((slotnum == 2) && s_bit))
+    (*info->fprintf_func) (info->stream, ";;");
+
+ done:
+  ia64_free_opcode ((struct ia64_opcode *)idesc);
+ failed:
+  if (slotnum == 2)
+    retval += 16 - 3*slot_multiplier;
+  return retval;
+
+ decoding_failed:
+  (*info->fprintf_func) (info->stream, "      data8 %#011llx", (long long) insn);
+  goto failed;
+}
--- /dev/null
+++ b/arch/ia64/kdb/ia64-opc.c
@@ -0,0 +1,749 @@
+/* ia64-opc.c -- Functions to access the compacted opcode table
+   Copyright 1999, 2000, 2001, 2003, 2005 Free Software Foundation, Inc.
+   Written by Bob Manson of Cygnus Solutions, <manson@cygnus.com>
+
+   This file is part of GDB, GAS, and the GNU binutils.
+
+   GDB, GAS, and the GNU binutils are free software; you can redistribute
+   them and/or modify them under the terms of the GNU General Public
+   License as published by the Free Software Foundation; either version
+   2, or (at your option) any later version.
+
+   GDB, GAS, and the GNU binutils are distributed in the hope that they
+   will be useful, but WITHOUT ANY WARRANTY; without even the implied
+   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+   the GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this file; see the file COPYING.  If not, write to the
+   Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+/* Extracted from binutils 2.16.91.0.2 (OpenSUSE 10.0) and modified for kdb use.
+ * Any trailing whitespace was removed and #ifdef/ifndef __KERNEL__ added as
+ * required.
+ * Keith Owens <kaos@sgi.com> 15 May 2006
+ */
+
+#ifdef __KERNEL__
+#include <linux/kernel.h>
+#include <linux/kdb.h>
+#include <linux/kdbprivate.h>
+#include <asm/ansidecl.h>
+
+#define xstrdup(string) ({ char *res = kdb_strdup(string, GFP_ATOMIC); if (!res) BUG(); res; })
+#define xmalloc(size) ({ void *res = debug_kmalloc(size, GFP_ATOMIC); if (!res) BUG(); res; })
+#define free(address) debug_kfree(address)
+#define abort() BUG()
+
+#else	/* __KERNEL__ */
+#include "ansidecl.h"
+#include "sysdep.h"
+#include "libiberty.h"
+#endif	/* __KERNEL__ */
+#include "ia64-asmtab.h"
+#include "ia64-asmtab.c"
+
+static void get_opc_prefix (const char **, char *);
+static short int find_string_ent (const char *);
+static short int find_main_ent (short int);
+static short int find_completer (short int, short int, const char *);
+static ia64_insn apply_completer (ia64_insn, int);
+static int extract_op_bits (int, int, int);
+static int extract_op (int, int *, unsigned int *);
+static int opcode_verify (ia64_insn, int, enum ia64_insn_type);
+static int locate_opcode_ent (ia64_insn, enum ia64_insn_type);
+static struct ia64_opcode *make_ia64_opcode
+  (ia64_insn, const char *, int, int);
+static struct ia64_opcode *ia64_find_matching_opcode
+  (const char *, short int);
+
+const struct ia64_templ_desc ia64_templ_desc[16] =
+  {
+    { 0, { IA64_UNIT_M, IA64_UNIT_I, IA64_UNIT_I }, "MII" },	/* 0 */
+    { 2, { IA64_UNIT_M, IA64_UNIT_I, IA64_UNIT_I }, "MII" },
+    { 0, { IA64_UNIT_M, IA64_UNIT_L, IA64_UNIT_X }, "MLX" },
+    { 0, { 0, },				    "-3-" },
+    { 0, { IA64_UNIT_M, IA64_UNIT_M, IA64_UNIT_I }, "MMI" },	/* 4 */
+    { 1, { IA64_UNIT_M, IA64_UNIT_M, IA64_UNIT_I }, "MMI" },
+    { 0, { IA64_UNIT_M, IA64_UNIT_F, IA64_UNIT_I }, "MFI" },
+    { 0, { IA64_UNIT_M, IA64_UNIT_M, IA64_UNIT_F }, "MMF" },
+    { 0, { IA64_UNIT_M, IA64_UNIT_I, IA64_UNIT_B }, "MIB" },	/* 8 */
+    { 0, { IA64_UNIT_M, IA64_UNIT_B, IA64_UNIT_B }, "MBB" },
+    { 0, { 0, },				    "-a-" },
+    { 0, { IA64_UNIT_B, IA64_UNIT_B, IA64_UNIT_B }, "BBB" },
+    { 0, { IA64_UNIT_M, IA64_UNIT_M, IA64_UNIT_B }, "MMB" },	/* c */
+    { 0, { 0, },				    "-d-" },
+    { 0, { IA64_UNIT_M, IA64_UNIT_F, IA64_UNIT_B }, "MFB" },
+    { 0, { 0, },				    "-f-" },
+  };
+
+
+/* Copy the prefix contained in *PTR (up to a '.' or a NUL) to DEST.
+   PTR will be adjusted to point to the start of the next portion
+   of the opcode, or at the NUL character. */
+
+static void
+get_opc_prefix (const char **ptr, char *dest)
+{
+  char *c = strchr (*ptr, '.');
+  if (c != NULL)
+    {
+      memcpy (dest, *ptr, c - *ptr);
+      dest[c - *ptr] = '\0';
+      *ptr = c + 1;
+    }
+  else
+    {
+      int l = strlen (*ptr);
+      memcpy (dest, *ptr, l);
+      dest[l] = '\0';
+      *ptr += l;
+    }
+}
+
+/* Find the index of the entry in the string table corresponding to
+   STR; return -1 if one does not exist. */
+
+static short
+find_string_ent (const char *str)
+{
+  short start = 0;
+  short end = sizeof (ia64_strings) / sizeof (const char *);
+  short i = (start + end) / 2;
+
+  if (strcmp (str, ia64_strings[end - 1]) > 0)
+    {
+      return -1;
+    }
+  while (start <= end)
+    {
+      int c = strcmp (str, ia64_strings[i]);
+      if (c < 0)
+	{
+	  end = i - 1;
+	}
+      else if (c == 0)
+	{
+	  return i;
+	}
+      else
+	{
+	  start = i + 1;
+	}
+      i = (start + end) / 2;
+    }
+  return -1;
+}
+
+/* Find the opcode in the main opcode table whose name is STRINGINDEX, or
+   return -1 if one does not exist. */
+
+static short
+find_main_ent (short nameindex)
+{
+  short start = 0;
+  short end = sizeof (main_table) / sizeof (struct ia64_main_table);
+  short i = (start + end) / 2;
+
+  if (nameindex < main_table[0].name_index
+      || nameindex > main_table[end - 1].name_index)
+    {
+      return -1;
+    }
+  while (start <= end)
+    {
+      if (nameindex < main_table[i].name_index)
+	{
+	  end = i - 1;
+	}
+      else if (nameindex == main_table[i].name_index)
+	{
+	  while (i > 0 && main_table[i - 1].name_index == nameindex)
+	    {
+	      i--;
+	    }
+	  return i;
+	}
+      else
+	{
+	  start = i + 1;
+	}
+      i = (start + end) / 2;
+    }
+  return -1;
+}
+
+/* Find the index of the entry in the completer table that is part of
+   MAIN_ENT (starting from PREV_COMPLETER) that matches NAME, or
+   return -1 if one does not exist. */
+
+static short
+find_completer (short main_ent, short prev_completer, const char *name)
+{
+  short name_index = find_string_ent (name);
+
+  if (name_index < 0)
+    {
+      return -1;
+    }
+
+  if (prev_completer == -1)
+    {
+      prev_completer = main_table[main_ent].completers;
+    }
+  else
+    {
+      prev_completer = completer_table[prev_completer].subentries;
+    }
+
+  while (prev_completer != -1)
+    {
+      if (completer_table[prev_completer].name_index == name_index)
+	{
+	  return prev_completer;
+	}
+      prev_completer = completer_table[prev_completer].alternative;
+    }
+  return -1;
+}
+
+/* Apply the completer referred to by COMPLETER_INDEX to OPCODE, and
+   return the result. */
+
+static ia64_insn
+apply_completer (ia64_insn opcode, int completer_index)
+{
+  ia64_insn mask = completer_table[completer_index].mask;
+  ia64_insn bits = completer_table[completer_index].bits;
+  int shiftamt = (completer_table[completer_index].offset & 63);
+
+  mask = mask << shiftamt;
+  bits = bits << shiftamt;
+  opcode = (opcode & ~mask) | bits;
+  return opcode;
+}
+
+/* Extract BITS number of bits starting from OP_POINTER + BITOFFSET in
+   the dis_table array, and return its value.  (BITOFFSET is numbered
+   starting from MSB to LSB, so a BITOFFSET of 0 indicates the MSB of the
+   first byte in OP_POINTER.) */
+
+static int
+extract_op_bits (int op_pointer, int bitoffset, int bits)
+{
+  int res = 0;
+
+  op_pointer += (bitoffset / 8);
+
+  if (bitoffset % 8)
+    {
+      unsigned int op = dis_table[op_pointer++];
+      int numb = 8 - (bitoffset % 8);
+      int mask = (1 << numb) - 1;
+      int bata = (bits < numb) ? bits : numb;
+      int delta = numb - bata;
+
+      res = (res << bata) | ((op & mask) >> delta);
+      bitoffset += bata;
+      bits -= bata;
+    }
+  while (bits >= 8)
+    {
+      res = (res << 8) | (dis_table[op_pointer++] & 255);
+      bits -= 8;
+    }
+  if (bits > 0)
+    {
+      unsigned int op = (dis_table[op_pointer++] & 255);
+      res = (res << bits) | (op >> (8 - bits));
+    }
+  return res;
+}
+
+/* Examine the state machine entry at OP_POINTER in the dis_table
+   array, and extract its values into OPVAL and OP.  The length of the
+   state entry in bits is returned. */
+
+static int
+extract_op (int op_pointer, int *opval, unsigned int *op)
+{
+  int oplen = 5;
+
+  *op = dis_table[op_pointer];
+
+  if ((*op) & 0x40)
+    {
+      opval[0] = extract_op_bits (op_pointer, oplen, 5);
+      oplen += 5;
+    }
+  switch ((*op) & 0x30)
+    {
+    case 0x10:
+      {
+	opval[1] = extract_op_bits (op_pointer, oplen, 8);
+	oplen += 8;
+	opval[1] += op_pointer;
+	break;
+      }
+    case 0x20:
+      {
+	opval[1] = extract_op_bits (op_pointer, oplen, 16);
+	if (! (opval[1] & 32768))
+	  {
+	    opval[1] += op_pointer;
+	  }
+	oplen += 16;
+	break;
+      }
+    case 0x30:
+      {
+	oplen--;
+	opval[2] = extract_op_bits (op_pointer, oplen, 12);
+	oplen += 12;
+	opval[2] |= 32768;
+	break;
+      }
+    }
+  if (((*op) & 0x08) && (((*op) & 0x30) != 0x30))
+    {
+      opval[2] = extract_op_bits (op_pointer, oplen, 16);
+      oplen += 16;
+      if (! (opval[2] & 32768))
+	{
+	  opval[2] += op_pointer;
+	}
+    }
+  return oplen;
+}
+
+/* Returns a non-zero value if the opcode in the main_table list at
+   PLACE matches OPCODE and is of type TYPE. */
+
+static int
+opcode_verify (ia64_insn opcode, int place, enum ia64_insn_type type)
+{
+  if (main_table[place].opcode_type != type)
+    {
+      return 0;
+    }
+  if (main_table[place].flags
+      & (IA64_OPCODE_F2_EQ_F3 | IA64_OPCODE_LEN_EQ_64MCNT))
+    {
+      const struct ia64_operand *o1, *o2;
+      ia64_insn f2, f3;
+
+      if (main_table[place].flags & IA64_OPCODE_F2_EQ_F3)
+	{
+	  o1 = elf64_ia64_operands + IA64_OPND_F2;
+	  o2 = elf64_ia64_operands + IA64_OPND_F3;
+	  (*o1->extract) (o1, opcode, &f2);
+	  (*o2->extract) (o2, opcode, &f3);
+	  if (f2 != f3)
+	    return 0;
+	}
+      else
+	{
+	  ia64_insn len, count;
+
+	  /* length must equal 64-count: */
+	  o1 = elf64_ia64_operands + IA64_OPND_LEN6;
+	  o2 = elf64_ia64_operands + main_table[place].operands[2];
+	  (*o1->extract) (o1, opcode, &len);
+	  (*o2->extract) (o2, opcode, &count);
+	  if (len != 64 - count)
+	    return 0;
+	}
+    }
+  return 1;
+}
+
+/* Find an instruction entry in the ia64_dis_names array that matches
+   opcode OPCODE and is of type TYPE.  Returns either a positive index
+   into the array, or a negative value if an entry for OPCODE could
+   not be found.  Checks all matches and returns the one with the highest
+   priority. */
+
+static int
+locate_opcode_ent (ia64_insn opcode, enum ia64_insn_type type)
+{
+  int currtest[41];
+  int bitpos[41];
+  int op_ptr[41];
+  int currstatenum = 0;
+  short found_disent = -1;
+  short found_priority = -1;
+
+  currtest[currstatenum] = 0;
+  op_ptr[currstatenum] = 0;
+  bitpos[currstatenum] = 40;
+
+  while (1)
+    {
+      int op_pointer = op_ptr[currstatenum];
+      unsigned int op;
+      int currbitnum = bitpos[currstatenum];
+      int oplen;
+      int opval[3] = {0};
+      int next_op;
+      int currbit;
+
+      oplen = extract_op (op_pointer, opval, &op);
+
+      bitpos[currstatenum] = currbitnum;
+
+      /* Skip opval[0] bits in the instruction. */
+      if (op & 0x40)
+	{
+	  currbitnum -= opval[0];
+	}
+
+      /* The value of the current bit being tested. */
+      currbit = opcode & (((ia64_insn) 1) << currbitnum) ? 1 : 0;
+      next_op = -1;
+
+      /* We always perform the tests specified in the current state in
+	 a particular order, falling through to the next test if the
+	 previous one failed. */
+      switch (currtest[currstatenum])
+	{
+	case 0:
+	  currtest[currstatenum]++;
+	  if (currbit == 0 && (op & 0x80))
+	    {
+	      /* Check for a zero bit.  If this test solely checks for
+		 a zero bit, we can check for up to 8 consecutive zero
+		 bits (the number to check is specified by the lower 3
+		 bits in the state code.)
+
+		 If the state instruction matches, we go to the very
+		 next state instruction; otherwise, try the next test. */
+
+	      if ((op & 0xf8) == 0x80)
+		{
+		  int count = op & 0x7;
+		  int x;
+
+		  for (x = 0; x <= count; x++)
+		    {
+		      int i =
+			opcode & (((ia64_insn) 1) << (currbitnum - x)) ? 1 : 0;
+		      if (i)
+			{
+			  break;
+			}
+		    }
+		  if (x > count)
+		    {
+		      next_op = op_pointer + ((oplen + 7) / 8);
+		      currbitnum -= count;
+		      break;
+		    }
+		}
+	      else if (! currbit)
+		{
+		  next_op = op_pointer + ((oplen + 7) / 8);
+		  break;
+		}
+	    }
+	  /* FALLTHROUGH */
+	case 1:
+	  /* If the bit in the instruction is one, go to the state
+	     instruction specified by opval[1]. */
+	  currtest[currstatenum]++;
+	  if (currbit && (op & 0x30) != 0 && ((op & 0x30) != 0x30))
+	    {
+	      next_op = opval[1];
+	      break;
+	    }
+	  /* FALLTHROUGH */
+	case 2:
+	  /* Don't care.  Skip the current bit and go to the state
+	     instruction specified by opval[2].
+
+	     An encoding of 0x30 is special; this means that a 12-bit
+	     offset into the ia64_dis_names[] array is specified.  */
+	  currtest[currstatenum]++;
+	  if ((op & 0x08) || ((op & 0x30) == 0x30))
+	    {
+	      next_op = opval[2];
+	      break;
+	    }
+	}
+
+      /* If bit 15 is set in the address of the next state, an offset
+	 in the ia64_dis_names array was specified instead.  We then
+	 check to see if an entry in the list of opcodes matches the
+	 opcode we were given; if so, we have succeeded.  */
+
+      if ((next_op >= 0) && (next_op & 32768))
+	{
+	  short disent = next_op & 32767;
+          short priority = -1;
+
+	  if (next_op > 65535)
+	    {
+	      abort ();
+	    }
+
+	  /* Run through the list of opcodes to check, trying to find
+	     one that matches.  */
+	  while (disent >= 0)
+	    {
+	      int place = ia64_dis_names[disent].insn_index;
+
+              priority = ia64_dis_names[disent].priority;
+
+	      if (opcode_verify (opcode, place, type)
+                  && priority > found_priority)
+		{
+		  break;
+		}
+	      if (ia64_dis_names[disent].next_flag)
+		{
+		  disent++;
+		}
+	      else
+		{
+		  disent = -1;
+		}
+	    }
+
+	  if (disent >= 0)
+	    {
+              found_disent = disent;
+              found_priority = priority;
+	    }
+          /* Try the next test in this state, regardless of whether a match
+             was found. */
+          next_op = -2;
+	}
+
+      /* next_op == -1 is "back up to the previous state".
+	 next_op == -2 is "stay in this state and try the next test".
+	 Otherwise, transition to the state indicated by next_op. */
+
+      if (next_op == -1)
+	{
+	  currstatenum--;
+	  if (currstatenum < 0)
+	    {
+              return found_disent;
+	    }
+	}
+      else if (next_op >= 0)
+	{
+	  currstatenum++;
+	  bitpos[currstatenum] = currbitnum - 1;
+	  op_ptr[currstatenum] = next_op;
+	  currtest[currstatenum] = 0;
+	}
+    }
+}
+
+/* Construct an ia64_opcode entry based on OPCODE, NAME and PLACE. */
+
+static struct ia64_opcode *
+make_ia64_opcode (ia64_insn opcode, const char *name, int place, int depind)
+{
+  struct ia64_opcode *res =
+    (struct ia64_opcode *) xmalloc (sizeof (struct ia64_opcode));
+  res->name = xstrdup (name);
+  res->type = main_table[place].opcode_type;
+  res->num_outputs = main_table[place].num_outputs;
+  res->opcode = opcode;
+  res->mask = main_table[place].mask;
+  res->operands[0] = main_table[place].operands[0];
+  res->operands[1] = main_table[place].operands[1];
+  res->operands[2] = main_table[place].operands[2];
+  res->operands[3] = main_table[place].operands[3];
+  res->operands[4] = main_table[place].operands[4];
+  res->flags = main_table[place].flags;
+  res->ent_index = place;
+  res->dependencies = &op_dependencies[depind];
+  return res;
+}
+
+/* Determine the ia64_opcode entry for the opcode specified by INSN
+   and TYPE.  If a valid entry is not found, return NULL. */
+struct ia64_opcode *
+ia64_dis_opcode (ia64_insn insn, enum ia64_insn_type type)
+{
+  int disent = locate_opcode_ent (insn, type);
+
+  if (disent < 0)
+    {
+      return NULL;
+    }
+  else
+    {
+      unsigned int cb = ia64_dis_names[disent].completer_index;
+      static char name[128];
+      int place = ia64_dis_names[disent].insn_index;
+      int ci = main_table[place].completers;
+      ia64_insn tinsn = main_table[place].opcode;
+
+      strcpy (name, ia64_strings [main_table[place].name_index]);
+
+      while (cb)
+	{
+	  if (cb & 1)
+	    {
+	      int cname = completer_table[ci].name_index;
+
+	      tinsn = apply_completer (tinsn, ci);
+
+	      if (ia64_strings[cname][0] != '\0')
+		{
+		  strcat (name, ".");
+		  strcat (name, ia64_strings[cname]);
+		}
+	      if (cb != 1)
+		{
+		  ci = completer_table[ci].subentries;
+		}
+	    }
+	  else
+	    {
+	      ci = completer_table[ci].alternative;
+	    }
+	  if (ci < 0)
+	    {
+	      abort ();
+	    }
+	  cb = cb >> 1;
+	}
+      if (tinsn != (insn & main_table[place].mask))
+	{
+	  abort ();
+	}
+      return make_ia64_opcode (insn, name, place,
+                               completer_table[ci].dependencies);
+    }
+}
+
+/* Search the main_opcode table starting from PLACE for an opcode that
+   matches NAME.  Return NULL if one is not found. */
+
+static struct ia64_opcode *
+ia64_find_matching_opcode (const char *name, short place)
+{
+  char op[129];
+  const char *suffix;
+  short name_index;
+
+  if (strlen (name) > 128)
+    {
+      return NULL;
+    }
+  suffix = name;
+  get_opc_prefix (&suffix, op);
+  name_index = find_string_ent (op);
+  if (name_index < 0)
+    {
+      return NULL;
+    }
+
+  while (main_table[place].name_index == name_index)
+    {
+      const char *curr_suffix = suffix;
+      ia64_insn curr_insn = main_table[place].opcode;
+      short completer = -1;
+
+      do {
+	if (suffix[0] == '\0')
+	  {
+	    completer = find_completer (place, completer, suffix);
+	  }
+	else
+	  {
+	    get_opc_prefix (&curr_suffix, op);
+	    completer = find_completer (place, completer, op);
+	  }
+	if (completer != -1)
+	  {
+	    curr_insn = apply_completer (curr_insn, completer);
+	  }
+      } while (completer != -1 && curr_suffix[0] != '\0');
+
+      if (completer != -1 && curr_suffix[0] == '\0'
+	  && completer_table[completer].terminal_completer)
+	{
+          int depind = completer_table[completer].dependencies;
+	  return make_ia64_opcode (curr_insn, name, place, depind);
+	}
+      else
+	{
+	  place++;
+	}
+    }
+  return NULL;
+}
+
+/* Find the next opcode after PREV_ENT that matches PREV_ENT, or return NULL
+   if one does not exist.
+
+   It is the caller's responsibility to invoke ia64_free_opcode () to
+   release any resources used by the returned entry. */
+
+struct ia64_opcode *
+ia64_find_next_opcode (struct ia64_opcode *prev_ent)
+{
+  return ia64_find_matching_opcode (prev_ent->name,
+				    prev_ent->ent_index + 1);
+}
+
+/* Find the first opcode that matches NAME, or return NULL if it does
+   not exist.
+
+   It is the caller's responsibility to invoke ia64_free_opcode () to
+   release any resources used by the returned entry. */
+
+struct ia64_opcode *
+ia64_find_opcode (const char *name)
+{
+  char op[129];
+  const char *suffix;
+  short place;
+  short name_index;
+
+  if (strlen (name) > 128)
+    {
+      return NULL;
+    }
+  suffix = name;
+  get_opc_prefix (&suffix, op);
+  name_index = find_string_ent (op);
+  if (name_index < 0)
+    {
+      return NULL;
+    }
+
+  place = find_main_ent (name_index);
+
+  if (place < 0)
+    {
+      return NULL;
+    }
+  return ia64_find_matching_opcode (name, place);
+}
+
+/* Free any resources used by ENT. */
+void
+ia64_free_opcode (struct ia64_opcode *ent)
+{
+  free ((void *)ent->name);
+  free (ent);
+}
+
+const struct ia64_dependency *
+ia64_find_dependency (int index)
+{
+  index = DEP(index);
+
+  if (index < 0
+      || index >= (int)(sizeof(dependencies) / sizeof(dependencies[0])))
+    return NULL;
+
+  return &dependencies[index];
+}
--- /dev/null
+++ b/arch/ia64/kdb/ia64-opc.h
@@ -0,0 +1,141 @@
+/* ia64-opc.h -- IA-64 opcode table.
+   Copyright 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   This file is part of GDB, GAS, and the GNU binutils.
+
+   GDB, GAS, and the GNU binutils are free software; you can redistribute
+   them and/or modify them under the terms of the GNU General Public
+   License as published by the Free Software Foundation; either version
+   2, or (at your option) any later version.
+
+   GDB, GAS, and the GNU binutils are distributed in the hope that they
+   will be useful, but WITHOUT ANY WARRANTY; without even the implied
+   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+   the GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this file; see the file COPYING.  If not, write to the
+   Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+/* Extracted from binutils 2.16.91.0.2 (OpenSUSE 10.0) and modified for kdb use.
+ * Any trailing whitespace was removed and #ifdef/ifndef __KERNEL__ added as
+ * required.
+ * Keith Owens <kaos@sgi.com> 15 May 2006
+ */
+
+#ifndef IA64_OPC_H
+#define IA64_OPC_H
+
+#ifdef __KERNEL__
+#include "ia64.h"
+#else	/* __KERNEL__ */
+#include "opcode/ia64.h"
+#endif	/* __KERNEL__ */
+
+/* define a couple of abbreviations: */
+
+#define bOp(x)	(((ia64_insn) ((x) & 0xf)) << 37)
+#define mOp	bOp (-1)
+#define Op(x)	bOp (x), mOp
+
+#define FIRST		IA64_OPCODE_FIRST
+#define X_IN_MLX	IA64_OPCODE_X_IN_MLX
+#define LAST		IA64_OPCODE_LAST
+#define PRIV		IA64_OPCODE_PRIV
+#define NO_PRED		IA64_OPCODE_NO_PRED
+#define SLOT2		IA64_OPCODE_SLOT2
+#define PSEUDO		IA64_OPCODE_PSEUDO
+#define F2_EQ_F3	IA64_OPCODE_F2_EQ_F3
+#define LEN_EQ_64MCNT	IA64_OPCODE_LEN_EQ_64MCNT
+#define MOD_RRBS        IA64_OPCODE_MOD_RRBS
+#define POSTINC		IA64_OPCODE_POSTINC
+
+#define AR_CCV	IA64_OPND_AR_CCV
+#define AR_PFS	IA64_OPND_AR_PFS
+#define AR_CSD	IA64_OPND_AR_CSD
+#define C1	IA64_OPND_C1
+#define C8	IA64_OPND_C8
+#define C16	IA64_OPND_C16
+#define GR0	IA64_OPND_GR0
+#define IP	IA64_OPND_IP
+#define PR	IA64_OPND_PR
+#define PR_ROT	IA64_OPND_PR_ROT
+#define PSR	IA64_OPND_PSR
+#define PSR_L	IA64_OPND_PSR_L
+#define PSR_UM	IA64_OPND_PSR_UM
+
+#define AR3	IA64_OPND_AR3
+#define B1	IA64_OPND_B1
+#define B2	IA64_OPND_B2
+#define CR3	IA64_OPND_CR3
+#define F1	IA64_OPND_F1
+#define F2	IA64_OPND_F2
+#define F3	IA64_OPND_F3
+#define F4	IA64_OPND_F4
+#define P1	IA64_OPND_P1
+#define P2	IA64_OPND_P2
+#define R1	IA64_OPND_R1
+#define R2	IA64_OPND_R2
+#define R3	IA64_OPND_R3
+#define R3_2	IA64_OPND_R3_2
+
+#define CPUID_R3 IA64_OPND_CPUID_R3
+#define DBR_R3	IA64_OPND_DBR_R3
+#define DTR_R3	IA64_OPND_DTR_R3
+#define ITR_R3	IA64_OPND_ITR_R3
+#define IBR_R3	IA64_OPND_IBR_R3
+#define MR3	IA64_OPND_MR3
+#define MSR_R3	IA64_OPND_MSR_R3
+#define PKR_R3	IA64_OPND_PKR_R3
+#define PMC_R3	IA64_OPND_PMC_R3
+#define PMD_R3	IA64_OPND_PMD_R3
+#define RR_R3	IA64_OPND_RR_R3
+
+#define CCNT5	IA64_OPND_CCNT5
+#define CNT2a	IA64_OPND_CNT2a
+#define CNT2b	IA64_OPND_CNT2b
+#define CNT2c	IA64_OPND_CNT2c
+#define CNT5	IA64_OPND_CNT5
+#define CNT6	IA64_OPND_CNT6
+#define CPOS6a	IA64_OPND_CPOS6a
+#define CPOS6b	IA64_OPND_CPOS6b
+#define CPOS6c	IA64_OPND_CPOS6c
+#define IMM1	IA64_OPND_IMM1
+#define IMM14	IA64_OPND_IMM14
+#define IMM17	IA64_OPND_IMM17
+#define IMM22	IA64_OPND_IMM22
+#define IMM44	IA64_OPND_IMM44
+#define SOF	IA64_OPND_SOF
+#define SOL	IA64_OPND_SOL
+#define SOR	IA64_OPND_SOR
+#define IMM8	IA64_OPND_IMM8
+#define IMM8U4	IA64_OPND_IMM8U4
+#define IMM8M1	IA64_OPND_IMM8M1
+#define IMM8M1U4 IA64_OPND_IMM8M1U4
+#define IMM8M1U8 IA64_OPND_IMM8M1U8
+#define IMM9a	IA64_OPND_IMM9a
+#define IMM9b	IA64_OPND_IMM9b
+#define IMMU2	IA64_OPND_IMMU2
+#define IMMU21	IA64_OPND_IMMU21
+#define IMMU24	IA64_OPND_IMMU24
+#define IMMU62	IA64_OPND_IMMU62
+#define IMMU64	IA64_OPND_IMMU64
+#define IMMU7a	IA64_OPND_IMMU7a
+#define IMMU7b	IA64_OPND_IMMU7b
+#define IMMU9	IA64_OPND_IMMU9
+#define INC3	IA64_OPND_INC3
+#define LEN4	IA64_OPND_LEN4
+#define LEN6	IA64_OPND_LEN6
+#define MBTYPE4	IA64_OPND_MBTYPE4
+#define MHTYPE8	IA64_OPND_MHTYPE8
+#define POS6	IA64_OPND_POS6
+#define TAG13	IA64_OPND_TAG13
+#define TAG13b	IA64_OPND_TAG13b
+#define TGT25	IA64_OPND_TGT25
+#define TGT25b	IA64_OPND_TGT25b
+#define TGT25c	IA64_OPND_TGT25c
+#define TGT64   IA64_OPND_TGT64
+
+#endif
--- /dev/null
+++ b/arch/ia64/kdb/ia64.h
@@ -0,0 +1,402 @@
+/* ia64.h -- Header file for ia64 opcode table
+   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+	Contributed by David Mosberger-Tang <davidm@hpl.hp.com> */
+
+/* Extracted from binutils 2.16.91.0.2 (OpenSUSE 10.0) and modified for kdb use.
+ * Any trailing whitespace was removed and #ifdef/ifndef __KERNEL__ added as
+ * required.
+ * Keith Owens <kaos@sgi.com> 15 May 2006
+ */
+
+#ifndef opcode_ia64_h
+#define opcode_ia64_h
+
+#ifdef __KERNEL__
+#include <asm/bfd.h>
+#else	/* __KERNEL__ */
+#include <sys/types.h>
+
+#include "bfd.h"
+#endif	/* __KERNEL__ */
+
+
+typedef BFD_HOST_U_64_BIT ia64_insn;
+
+enum ia64_insn_type
+  {
+    IA64_TYPE_NIL = 0,	/* illegal type */
+    IA64_TYPE_A,	/* integer alu (I- or M-unit) */
+    IA64_TYPE_I,	/* non-alu integer (I-unit) */
+    IA64_TYPE_M,	/* memory (M-unit) */
+    IA64_TYPE_B,	/* branch (B-unit) */
+    IA64_TYPE_F,	/* floating-point (F-unit) */
+    IA64_TYPE_X,	/* long encoding (X-unit) */
+    IA64_TYPE_DYN,	/* Dynamic opcode */
+    IA64_NUM_TYPES
+  };
+
+enum ia64_unit
+  {
+    IA64_UNIT_NIL = 0,	/* illegal unit */
+    IA64_UNIT_I,	/* integer unit */
+    IA64_UNIT_M,	/* memory unit */
+    IA64_UNIT_B,	/* branching unit */
+    IA64_UNIT_F,	/* floating-point unit */
+    IA64_UNIT_L,	/* long "unit" */
+    IA64_UNIT_X,	/* may be integer or branch unit */
+    IA64_NUM_UNITS
+  };
+
+/* Changes to this enumeration must be propagated to the operand table in
+   bfd/cpu-ia64-opc.c
+ */
+enum ia64_opnd
+  {
+    IA64_OPND_NIL,	/* no operand---MUST BE FIRST!*/
+
+    /* constants */
+    IA64_OPND_AR_CSD,	/* application register csd (ar.csd) */
+    IA64_OPND_AR_CCV,	/* application register ccv (ar.ccv) */
+    IA64_OPND_AR_PFS,	/* application register pfs (ar.pfs) */
+    IA64_OPND_C1,	/* the constant 1 */
+    IA64_OPND_C8,	/* the constant 8 */
+    IA64_OPND_C16,	/* the constant 16 */
+    IA64_OPND_GR0,	/* gr0 */
+    IA64_OPND_IP,	/* instruction pointer (ip) */
+    IA64_OPND_PR,	/* predicate register (pr) */
+    IA64_OPND_PR_ROT,	/* rotating predicate register (pr.rot) */
+    IA64_OPND_PSR,	/* processor status register (psr) */
+    IA64_OPND_PSR_L,	/* processor status register L (psr.l) */
+    IA64_OPND_PSR_UM,	/* processor status register UM (psr.um) */
+
+    /* register operands: */
+    IA64_OPND_AR3,	/* third application register # (bits 20-26) */
+    IA64_OPND_B1,	/* branch register # (bits 6-8) */
+    IA64_OPND_B2,	/* branch register # (bits 13-15) */
+    IA64_OPND_CR3,	/* third control register # (bits 20-26) */
+    IA64_OPND_F1,	/* first floating-point register # */
+    IA64_OPND_F2,	/* second floating-point register # */
+    IA64_OPND_F3,	/* third floating-point register # */
+    IA64_OPND_F4,	/* fourth floating-point register # */
+    IA64_OPND_P1,	/* first predicate # */
+    IA64_OPND_P2,	/* second predicate # */
+    IA64_OPND_R1,	/* first register # */
+    IA64_OPND_R2,	/* second register # */
+    IA64_OPND_R3,	/* third register # */
+    IA64_OPND_R3_2,	/* third register # (limited to gr0-gr3) */
+
+    /* indirect operands: */
+    IA64_OPND_CPUID_R3,	/* cpuid[reg] */
+    IA64_OPND_DBR_R3,	/* dbr[reg] */
+    IA64_OPND_DTR_R3,	/* dtr[reg] */
+    IA64_OPND_ITR_R3,	/* itr[reg] */
+    IA64_OPND_IBR_R3,	/* ibr[reg] */
+    IA64_OPND_MR3,	/* memory at addr of third register # */
+    IA64_OPND_MSR_R3,	/* msr[reg] */
+    IA64_OPND_PKR_R3,	/* pkr[reg] */
+    IA64_OPND_PMC_R3,	/* pmc[reg] */
+    IA64_OPND_PMD_R3,	/* pmd[reg] */
+    IA64_OPND_RR_R3,	/* rr[reg] */
+
+    /* immediate operands: */
+    IA64_OPND_CCNT5,	/* 5-bit count (31 - bits 20-24) */
+    IA64_OPND_CNT2a,	/* 2-bit count (1 + bits 27-28) */
+    IA64_OPND_CNT2b,	/* 2-bit count (bits 27-28): 1, 2, 3 */
+    IA64_OPND_CNT2c,	/* 2-bit count (bits 30-31): 0, 7, 15, or 16 */
+    IA64_OPND_CNT5,	/* 5-bit count (bits 14-18) */
+    IA64_OPND_CNT6,	/* 6-bit count (bits 27-32) */
+    IA64_OPND_CPOS6a,	/* 6-bit count (63 - bits 20-25) */
+    IA64_OPND_CPOS6b,	/* 6-bit count (63 - bits 14-19) */
+    IA64_OPND_CPOS6c,	/* 6-bit count (63 - bits 31-36) */
+    IA64_OPND_IMM1,	/* signed 1-bit immediate (bit 36) */
+    IA64_OPND_IMMU2,	/* unsigned 2-bit immediate (bits 13-14) */
+    IA64_OPND_IMMU7a,	/* unsigned 7-bit immediate (bits 13-19) */
+    IA64_OPND_IMMU7b,	/* unsigned 7-bit immediate (bits 20-26) */
+    IA64_OPND_SOF,	/* 8-bit stack frame size */
+    IA64_OPND_SOL,	/* 8-bit size of locals */
+    IA64_OPND_SOR,	/* 6-bit number of rotating registers (scaled by 8) */
+    IA64_OPND_IMM8,	/* signed 8-bit immediate (bits 13-19 & 36) */
+    IA64_OPND_IMM8U4,	/* cmp4*u signed 8-bit immediate (bits 13-19 & 36) */
+    IA64_OPND_IMM8M1,	/* signed 8-bit immediate -1 (bits 13-19 & 36) */
+    IA64_OPND_IMM8M1U4,	/* cmp4*u signed 8-bit immediate -1 (bits 13-19 & 36)*/
+    IA64_OPND_IMM8M1U8,	/* cmp*u signed 8-bit immediate -1 (bits 13-19 & 36) */
+    IA64_OPND_IMMU9,	/* unsigned 9-bit immediate (bits 33-34, 20-26) */
+    IA64_OPND_IMM9a,	/* signed 9-bit immediate (bits 6-12, 27, 36) */
+    IA64_OPND_IMM9b,	/* signed 9-bit immediate (bits 13-19, 27, 36) */
+    IA64_OPND_IMM14,	/* signed 14-bit immediate (bits 13-19, 27-32, 36) */
+    IA64_OPND_IMM17,	/* signed 17-bit immediate (2*bits 6-12, 24-31, 36) */
+    IA64_OPND_IMMU21,	/* unsigned 21-bit immediate (bits 6-25, 36) */
+    IA64_OPND_IMM22,	/* signed 22-bit immediate (bits 13-19, 22-36) */
+    IA64_OPND_IMMU24,	/* unsigned 24-bit immediate (bits 6-26, 31-32, 36) */
+    IA64_OPND_IMM44,	/* signed 44-bit immediate (2^16*bits 6-32, 36) */
+    IA64_OPND_IMMU62,	/* unsigned 62-bit immediate */
+    IA64_OPND_IMMU64,	/* unsigned 64-bit immediate (lotsa bits...) */
+    IA64_OPND_INC3,	/* signed 3-bit (bits 13-15): +/-1, 4, 8, 16 */
+    IA64_OPND_LEN4,	/* 4-bit count (bits 27-30 + 1) */
+    IA64_OPND_LEN6,	/* 6-bit count (bits 27-32 + 1) */
+    IA64_OPND_MBTYPE4,	/* 4-bit mux type (bits 20-23) */
+    IA64_OPND_MHTYPE8,	/* 8-bit mux type (bits 20-27) */
+    IA64_OPND_POS6,	/* 6-bit count (bits 14-19) */
+    IA64_OPND_TAG13,	/* signed 13-bit tag (ip + 16*bits 6-12, 33-34) */
+    IA64_OPND_TAG13b,	/* signed 13-bit tag (ip + 16*bits 24-32) */
+    IA64_OPND_TGT25,	/* signed 25-bit (ip + 16*bits 6-25, 36) */
+    IA64_OPND_TGT25b,	/* signed 25-bit (ip + 16*bits 6-12, 20-32, 36) */
+    IA64_OPND_TGT25c,	/* signed 25-bit (ip + 16*bits 13-32, 36) */
+    IA64_OPND_TGT64,    /* 64-bit (ip + 16*bits 13-32, 36, 2-40(L)) */
+    IA64_OPND_LDXMOV,	/* any symbol, generates R_IA64_LDXMOV.  */
+
+    IA64_OPND_COUNT	/* # of operand types (MUST BE LAST!) */
+  };
+
+enum ia64_dependency_mode
+{
+  IA64_DV_RAW,
+  IA64_DV_WAW,
+  IA64_DV_WAR,
+};
+
+enum ia64_dependency_semantics
+{
+  IA64_DVS_NONE,
+  IA64_DVS_IMPLIED,
+  IA64_DVS_IMPLIEDF,
+  IA64_DVS_DATA,
+  IA64_DVS_INSTR,
+  IA64_DVS_SPECIFIC,
+  IA64_DVS_STOP,
+  IA64_DVS_OTHER,
+};
+
+enum ia64_resource_specifier
+{
+  IA64_RS_ANY,
+  IA64_RS_AR_K,
+  IA64_RS_AR_UNAT,
+  IA64_RS_AR, /* 8-15, 20, 22-23, 31, 33-35, 37-39, 41-43, 45-47, 67-111 */
+  IA64_RS_ARb, /* 48-63, 112-127 */
+  IA64_RS_BR,
+  IA64_RS_CFM,
+  IA64_RS_CPUID,
+  IA64_RS_CR_IRR,
+  IA64_RS_CR_LRR,
+  IA64_RS_CR, /* 3-7,10-15,18,26-63,75-79,82-127 */
+  IA64_RS_DBR,
+  IA64_RS_FR,
+  IA64_RS_FRb,
+  IA64_RS_GR0,
+  IA64_RS_GR,
+  IA64_RS_IBR,
+  IA64_RS_INSERVICE, /* CR[EOI] or CR[IVR] */
+  IA64_RS_MSR,
+  IA64_RS_PKR,
+  IA64_RS_PMC,
+  IA64_RS_PMD,
+  IA64_RS_PR,  /* non-rotating, 1-15 */
+  IA64_RS_PRr, /* rotating, 16-62 */
+  IA64_RS_PR63,
+  IA64_RS_RR,
+
+  IA64_RS_ARX, /* ARs not in RS_AR or RS_ARb */
+  IA64_RS_CRX, /* CRs not in RS_CR */
+  IA64_RS_PSR, /* PSR bits */
+  IA64_RS_RSE, /* implementation-specific RSE resources */
+  IA64_RS_AR_FPSR,
+};
+
+enum ia64_rse_resource
+{
+  IA64_RSE_N_STACKED_PHYS,
+  IA64_RSE_BOF,
+  IA64_RSE_STORE_REG,
+  IA64_RSE_LOAD_REG,
+  IA64_RSE_BSPLOAD,
+  IA64_RSE_RNATBITINDEX,
+  IA64_RSE_CFLE,
+  IA64_RSE_NDIRTY,
+};
+
+/* Information about a given resource dependency */
+struct ia64_dependency
+{
+  /* Name of the resource */
+  const char *name;
+  /* Does this dependency need further specification? */
+  enum ia64_resource_specifier specifier;
+  /* Mode of dependency */
+  enum ia64_dependency_mode mode;
+  /* Dependency semantics */
+  enum ia64_dependency_semantics semantics;
+  /* Register index, if applicable (distinguishes AR, CR, and PSR deps) */
+#define REG_NONE (-1)
+  int regindex;
+  /* Special info on semantics */
+  const char *info;
+};
+
+/* Two arrays of indexes into the ia64_dependency table.
+   chks are dependencies to check for conflicts when an opcode is
+   encountered; regs are dependencies to register (mark as used) when an
+   opcode is used.  chks correspond to readers (RAW) or writers (WAW or
+   WAR) of a resource, while regs correspond to writers (RAW or WAW) and
+   readers (WAR) of a resource.  */
+struct ia64_opcode_dependency
+{
+  int nchks;
+  const unsigned short *chks;
+  int nregs;
+  const unsigned short *regs;
+};
+
+/* encode/extract the note/index for a dependency */
+#define RDEP(N,X) (((N)<<11)|(X))
+#define NOTE(X) (((X)>>11)&0x1F)
+#define DEP(X) ((X)&0x7FF)
+
+/* A template descriptor describes the execution units that are active
+   for each of the three slots.  It also specifies the location of
+   instruction group boundaries that may be present between two slots.  */
+struct ia64_templ_desc
+  {
+    int group_boundary;	/* 0=no boundary, 1=between slot 0 & 1, etc. */
+    enum ia64_unit exec_unit[3];
+    const char *name;
+  };
+
+/* The opcode table is an array of struct ia64_opcode.  */
+
+struct ia64_opcode
+  {
+    /* The opcode name.  */
+    const char *name;
+
+    /* The type of the instruction: */
+    enum ia64_insn_type type;
+
+    /* Number of output operands: */
+    int num_outputs;
+
+    /* The opcode itself.  Those bits which will be filled in with
+       operands are zeroes.  */
+    ia64_insn opcode;
+
+    /* The opcode mask.  This is used by the disassembler.  This is a
+       mask containing ones indicating those bits which must match the
+       opcode field, and zeroes indicating those bits which need not
+       match (and are presumably filled in by operands).  */
+    ia64_insn mask;
+
+    /* An array of operand codes.  Each code is an index into the
+       operand table.  They appear in the order which the operands must
+       appear in assembly code, and are terminated by a zero.  */
+    enum ia64_opnd operands[5];
+
+    /* One bit flags for the opcode.  These are primarily used to
+       indicate specific processors and environments support the
+       instructions.  The defined values are listed below. */
+    unsigned int flags;
+
+    /* Used by ia64_find_next_opcode (). */
+    short ent_index;
+
+    /* Opcode dependencies. */
+    const struct ia64_opcode_dependency *dependencies;
+  };
+
+/* Values defined for the flags field of a struct ia64_opcode.  */
+
+#define IA64_OPCODE_FIRST	(1<<0)	/* must be first in an insn group */
+#define IA64_OPCODE_X_IN_MLX	(1<<1)	/* insn is allowed in X slot of MLX */
+#define IA64_OPCODE_LAST	(1<<2)	/* must be last in an insn group */
+#define IA64_OPCODE_PRIV	(1<<3)	/* privileged instruct */
+#define IA64_OPCODE_SLOT2	(1<<4)	/* insn allowed in slot 2 only */
+#define IA64_OPCODE_NO_PRED	(1<<5)	/* insn cannot be predicated */
+#define IA64_OPCODE_PSEUDO	(1<<6)	/* insn is a pseudo-op */
+#define IA64_OPCODE_F2_EQ_F3	(1<<7)	/* constraint: F2 == F3 */
+#define IA64_OPCODE_LEN_EQ_64MCNT	(1<<8)	/* constraint: LEN == 64-CNT */
+#define IA64_OPCODE_MOD_RRBS    (1<<9)	/* modifies all rrbs in CFM */
+#define IA64_OPCODE_POSTINC	(1<<10)	/* postincrement MR3 operand */
+
+/* A macro to extract the major opcode from an instruction.  */
+#define IA64_OP(i)	(((i) >> 37) & 0xf)
+
+enum ia64_operand_class
+  {
+    IA64_OPND_CLASS_CST,	/* constant */
+    IA64_OPND_CLASS_REG,	/* register */
+    IA64_OPND_CLASS_IND,	/* indirect register */
+    IA64_OPND_CLASS_ABS,	/* absolute value */
+    IA64_OPND_CLASS_REL,	/* IP-relative value */
+  };
+
+/* The operands table is an array of struct ia64_operand.  */
+
+struct ia64_operand
+{
+  enum ia64_operand_class class;
+
+  /* Set VALUE as the operand bits for the operand of type SELF in the
+     instruction pointed to by CODE.  If an error occurs, *CODE is not
+     modified and the returned string describes the cause of the
+     error.  If no error occurs, NULL is returned.  */
+  const char *(*insert) (const struct ia64_operand *self, ia64_insn value,
+			 ia64_insn *code);
+
+  /* Extract the operand bits for an operand of type SELF from
+     instruction CODE store them in *VALUE.  If an error occurs, the
+     cause of the error is described by the string returned.  If no
+     error occurs, NULL is returned.  */
+  const char *(*extract) (const struct ia64_operand *self, ia64_insn code,
+			  ia64_insn *value);
+
+  /* A string whose meaning depends on the operand class.  */
+
+  const char *str;
+
+  struct bit_field
+    {
+      /* The number of bits in the operand.  */
+      int bits;
+
+      /* How far the operand is left shifted in the instruction.  */
+      int shift;
+    }
+  field[4];		/* no operand has more than this many bit-fields */
+
+  unsigned int flags;
+
+  const char *desc;	/* brief description */
+};
+
+/* Values defined for the flags field of a struct ia64_operand.  */
+
+/* Disassemble as signed decimal (instead of hex): */
+#define IA64_OPND_FLAG_DECIMAL_SIGNED	(1<<0)
+/* Disassemble as unsigned decimal (instead of hex): */
+#define IA64_OPND_FLAG_DECIMAL_UNSIGNED	(1<<1)
+
+extern const struct ia64_templ_desc ia64_templ_desc[16];
+
+/* The tables are sorted by major opcode number and are otherwise in
+   the order in which the disassembler should consider instructions.  */
+extern struct ia64_opcode ia64_opcodes_a[];
+extern struct ia64_opcode ia64_opcodes_i[];
+extern struct ia64_opcode ia64_opcodes_m[];
+extern struct ia64_opcode ia64_opcodes_b[];
+extern struct ia64_opcode ia64_opcodes_f[];
+extern struct ia64_opcode ia64_opcodes_d[];
+
+
+extern struct ia64_opcode *ia64_find_opcode (const char *name);
+extern struct ia64_opcode *ia64_find_next_opcode (struct ia64_opcode *ent);
+
+extern struct ia64_opcode *ia64_dis_opcode (ia64_insn insn,
+					    enum ia64_insn_type type);
+
+extern void ia64_free_opcode (struct ia64_opcode *ent);
+extern const struct ia64_dependency *ia64_find_dependency (int index);
+
+/* To avoid circular library dependencies, this array is implemented
+   in bfd/cpu-ia64-opc.c: */
+extern const struct ia64_operand elf64_ia64_operands[IA64_OPND_COUNT];
+
+#endif /* opcode_ia64_h */
--- /dev/null
+++ b/arch/ia64/kdb/kdb_cmds
@@ -0,0 +1,17 @@
+# Standard architecture specific commands for kdb.
+# These commands are appended to those in kdb/kdb_cmds, see that file for
+# restrictions.
+
+# Standard debugging information for first level support, invoked from archkdb*
+# commands that are defined in kdb/kdb_cmds.
+
+defcmd archkdbcommon "" "Common arch debugging"
+  set LINES 2000000
+  set BTAPROMPT 0
+  -summary
+  -id %ip-0x40
+  -cpu
+  -ps
+  -dmesg 600
+  -bt
+endefcmd
--- /dev/null
+++ b/arch/ia64/kdb/kdba_bp.c
@@ -0,0 +1,841 @@
+/*
+ * Kernel Debugger Architecture Dependent Breakpoint Handling
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (c) 1999-2004 Silicon Graphics, Inc.  All Rights Reserved.
+ */
+
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/smp.h>
+#include <linux/ptrace.h>
+#include <linux/kdb.h>
+#include <linux/kdbprivate.h>
+#include <asm/pgalloc.h>
+
+
+static char *kdba_rwtypes[] = { "Instruction(Register)", "Data Write",
+			"I/O", "Data Access"};
+
+/*
+ * Table describing processor architecture hardware
+ * breakpoint registers.
+ */
+
+static kdbhard_bp_t kdb_hardbreaks[KDB_MAXHARDBPT];
+
+#ifdef CONFIG_KDB_HARDWARE_BREAKPOINTS
+/*
+ * Counters for number of debug registers used on each CPU.
+ * Used to detect when to enable and disable debug traps.
+ */
+static unsigned char kdb_dbrs_used[NR_CPUS];
+#endif /* CONFIG_KDB_HARDWARE_BREAKPOINTS */
+
+/*
+ * kdba_db_trap
+ *
+ *	Perform breakpoint processing upon entry to the
+ *	processor debugger fault.   Determine and print
+ *	the active breakpoint.
+ *
+ * Parameters:
+ *	regs	Exception frame containing machine register state
+ *	error	Error number passed to kdb.
+ * Outputs:
+ *	None.
+ * Returns:
+ *	KDB_DB_BPT	Standard instruction or data breakpoint encountered
+ *	KDB_DB_SS	Single Step fault ('ss' command or end of 'ssb' command)
+ *	KDB_DB_SSB	Single Step fault, caller should continue ('ssb' command)
+ *	KDB_DB_SSBPT	Single step over breakpoint
+ *	KDB_DB_NOBPT	No existing kdb breakpoint matches this debug exception
+ * Locking:
+ *	None.
+ * Remarks:
+ *	Yup, there be goto's here.
+ *
+ *	If multiple processors receive debug exceptions simultaneously,
+ *	one may be waiting at the kdb fence in kdb() while the user
+ *	issues a 'bc' command to clear the breakpoint the processor
+ *	which is waiting has already encountered.  If this is the case,
+ *	the debug registers will no longer match any entry in the
+ *	breakpoint table, and we'll return the value KDB_DB_NOBPT.
+ *	This can cause a panic in die_if_kernel().  It is safer to
+ *	disable the breakpoint (bd), go until all processors are past
+ *	the breakpoint then clear the breakpoint (bc).  This code
+ *	recognises a breakpoint even when disabled but not when it has
+ *	been cleared.
+ *
+ *	WARNING: This routine clears the debug state.  It should be called
+ *		 once per debug and the result cached.
+ */
+
+kdb_dbtrap_t
+kdba_db_trap(struct pt_regs *regs, int error)
+{
+	int i;
+	kdb_dbtrap_t rv = KDB_DB_BPT;
+	kdb_bp_t *bp;
+
+	if (KDB_NULL_REGS(regs))
+		return KDB_DB_NOBPT;
+
+	if (KDB_DEBUG(BP))
+		kdb_printf("kdba_db_trap: error %d\n", error);
+
+	if (error == 36) {
+		/* Single step */
+		if (KDB_STATE(SSBPT)) {
+			if (KDB_DEBUG(BP))
+				kdb_printf("ssbpt\n");
+			KDB_STATE_CLEAR(SSBPT);
+			for(i=0,bp=kdb_breakpoints;
+			    i < KDB_MAXBPT;
+			    i++, bp++) {
+				if (KDB_DEBUG(BP))
+					kdb_printf("bp 0x%p enabled %d delayed %d global %d cpu %d\n",
+						   bp, bp->bp_enabled, bp->bp_delayed, bp->bp_global, bp->bp_cpu);
+				if (!bp->bp_enabled)
+					continue;
+				if (!bp->bp_global && bp->bp_cpu != smp_processor_id())
+					continue;
+				if (KDB_DEBUG(BP))
+					kdb_printf("bp for this cpu\n");
+				if (bp->bp_delayed) {
+					bp->bp_delayed = 0;
+					if (KDB_DEBUG(BP))
+						kdb_printf("kdba_installbp\n");
+					kdba_installbp(regs, bp);
+					if (!KDB_STATE(DOING_SS)) {
+						kdba_clearsinglestep(regs);
+						return(KDB_DB_SSBPT);
+					}
+					break;
+				}
+			}
+			if (i == KDB_MAXBPT) {
+				kdb_printf("kdb: Unable to find delayed breakpoint\n");
+			}
+			if (!KDB_STATE(DOING_SS)) {
+				kdba_clearsinglestep(regs);
+				return(KDB_DB_NOBPT);
+			}
+			/* FALLTHROUGH */
+		}
+
+		/*
+		 * KDB_STATE_DOING_SS is set when the kernel debugger is using
+		 * the processor trap flag to single-step a processor.  If a
+		 * single step trap occurs and this flag is clear, the SS trap
+		 * will be ignored by KDB and the kernel will be allowed to deal
+		 * with it as necessary (e.g. for ptrace).
+		 */
+		if (!KDB_STATE(DOING_SS))
+			return(KDB_DB_NOBPT);
+
+		/* single step */
+		rv = KDB_DB_SS;		/* Indicate single step */
+		if (KDB_STATE(DOING_SSB))		/* No ia64 ssb support yet */
+			KDB_STATE_CLEAR(DOING_SSB);	/* No ia64 ssb support yet */
+		if (KDB_STATE(DOING_SSB)) {
+			/* No IA64 ssb support yet */
+		} else {
+			/*
+			 * Print current insn
+			 */
+			kdb_machreg_t pc = regs->cr_iip + ia64_psr(regs)->ri * 6;
+			kdb_printf("SS trap at ");
+			kdb_symbol_print(pc, NULL, KDB_SP_DEFAULT|KDB_SP_NEWLINE);
+			kdb_id1(pc);
+			KDB_STATE_CLEAR(DOING_SS);
+		}
+
+		if (rv != KDB_DB_SSB)
+			kdba_clearsinglestep(regs);
+	}
+
+	return(rv);
+}
+
+/*
+ * kdba_bp_trap
+ *
+ *	Perform breakpoint processing upon entry to the
+ *	processor breakpoint instruction fault.   Determine and print
+ *	the active breakpoint.
+ *
+ * Parameters:
+ *	regs	Exception frame containing machine register state
+ *	error	Error number passed to kdb.
+ * Outputs:
+ *	None.
+ * Returns:
+ *	0	Standard instruction or data breakpoint encountered
+ *	1	Single Step fault ('ss' command)
+ *	2	Single Step fault, caller should continue ('ssb' command)
+ *	3	No existing kdb breakpoint matches this debug exception
+ * Locking:
+ *	None.
+ * Remarks:
+ *
+ *	If multiple processors receive debug exceptions simultaneously,
+ *	one may be waiting at the kdb fence in kdb() while the user
+ *	issues a 'bc' command to clear the breakpoint the processor which
+ *	is waiting has already encountered.   If this is the case, the
+ *	debug registers will no longer match any entry in the breakpoint
+ *	table, and we'll return the value '3'.  This can cause a panic
+ *	in die_if_kernel().  It is safer to disable the breakpoint (bd),
+ *	'go' until all processors are past the breakpoint then clear the
+ *	breakpoint (bc).  This code recognises a breakpoint even when
+ *	disabled but not when it has been cleared.
+ *
+ *	WARNING: This routine resets the ip.  It should be called
+ *		 once per breakpoint and the result cached.
+ */
+
+kdb_dbtrap_t
+kdba_bp_trap(struct pt_regs *regs, int error)
+{
+	int i;
+	kdb_dbtrap_t rv;
+	kdb_bp_t *bp;
+
+	if (KDB_NULL_REGS(regs))
+		return KDB_DB_NOBPT;
+
+	/*
+	 * Determine which breakpoint was encountered.
+	 */
+	if (KDB_DEBUG(BP))
+		kdb_printf("kdba_bp_trap: ip=0x%lx "
+			   "regs=0x%p sp=0x%lx\n",
+			   regs->cr_iip, regs, regs->r12);
+
+	rv = KDB_DB_NOBPT;	/* Cause kdb() to return */
+
+	for(i=0, bp=kdb_breakpoints; i<KDB_MAXBPT; i++, bp++) {
+		if (bp->bp_free)
+			continue;
+		if (!bp->bp_global && bp->bp_cpu != smp_processor_id())
+			continue;
+		 if (bp->bp_addr == regs->cr_iip) {
+			/* Hit this breakpoint.  */
+			kdb_printf("Instruction(i) breakpoint #%d at 0x%lx\n",
+				  i, regs->cr_iip);
+			kdb_id1(regs->cr_iip);
+			rv = KDB_DB_BPT;
+			bp->bp_delay = 1;
+			/* SSBPT is set when the kernel debugger must single
+			 * step a task in order to re-establish an instruction
+			 * breakpoint which uses the instruction replacement
+			 * mechanism.  It is cleared by any action that removes
+			 * the need to single-step the breakpoint.
+			 */
+			KDB_STATE_SET(SSBPT);
+			break;
+		}
+	}
+
+	return rv;
+}
+
+/*
+ * kdba_handle_bp
+ *
+ *	Handle an instruction-breakpoint trap.  Called when re-installing
+ *	an enabled breakpoint which has has the bp_delay bit set.
+ *
+ * Parameters:
+ * Returns:
+ * Locking:
+ * Remarks:
+ *
+ * Ok, we really need to:
+ *	1) Restore the original instruction byte(s)
+ *	2) Single Step
+ *	3) Restore breakpoint instruction
+ *	4) Continue.
+ *
+ *
+ */
+
+static void
+kdba_handle_bp(struct pt_regs *regs, kdb_bp_t *bp)
+{
+	if (KDB_NULL_REGS(regs))
+		return;
+
+	if (KDB_DEBUG(BP))
+		kdb_printf("regs->cr_iip = 0x%lx\n", regs->cr_iip);
+
+	/*
+	 * Setup single step
+	 */
+	kdba_setsinglestep(regs);
+
+	/*
+	 * Reset delay attribute
+	 */
+	bp->bp_delay = 0;
+	bp->bp_delayed = 1;
+}
+
+
+/*
+ * kdba_bptype
+ *
+ *	Return a string describing type of breakpoint.
+ *
+ * Parameters:
+ *	bph	Pointer to hardware breakpoint description
+ * Outputs:
+ *	None.
+ * Returns:
+ *	Character string.
+ * Locking:
+ *	None.
+ * Remarks:
+ */
+
+char *
+kdba_bptype(kdbhard_bp_t *bph)
+{
+	char *mode;
+
+	mode = kdba_rwtypes[bph->bph_mode];
+
+	return mode;
+}
+
+/*
+ * kdba_printbpreg
+ *
+ *	Print register name assigned to breakpoint
+ *
+ * Parameters:
+ *	bph	Pointer hardware breakpoint structure
+ * Outputs:
+ *	None.
+ * Returns:
+ *	None.
+ * Locking:
+ *	None.
+ * Remarks:
+ */
+
+static void
+kdba_printbpreg(kdbhard_bp_t *bph)
+{
+	kdb_printf(" in dr%ld", bph->bph_reg);
+}
+
+/*
+ * kdba_printbp
+ *
+ *	Print string describing hardware breakpoint.
+ *
+ * Parameters:
+ *	bph	Pointer to hardware breakpoint description
+ * Outputs:
+ *	None.
+ * Returns:
+ *	None.
+ * Locking:
+ *	None.
+ * Remarks:
+ */
+
+void
+kdba_printbp(kdb_bp_t *bp)
+{
+	kdb_printf("\n    is enabled");
+	if (bp->bp_hardtype) {
+ 		/* Note that bp->bp_hard[NR_CPU] is for x86.
+		 * The ia64 uses bp->bp_hard[0] only.
+		 */
+		kdba_printbpreg(bp->bp_hard[0]);
+		if (bp->bp_hard[0]->bph_mode != 0) {
+			kdb_printf(" for %d bytes",
+				   bp->bp_hard[0]->bph_length+1);
+		}
+	}
+}
+
+/*
+ * kdba_parsebp
+ *
+ *	Parse architecture dependent portion of the
+ *	breakpoint command.
+ *
+ * Parameters:
+ *	None.
+ * Outputs:
+ *	None.
+ * Returns:
+ *	Zero for success, a kdb diagnostic for failure
+ * Locking:
+ *	None.
+ * Remarks:
+ *	for IA64 architure, data access, data write and
+ *	I/O breakpoints are supported in addition to instruction
+ *	breakpoints.
+ *
+ *	{datar|dataw|io|inst} [length]
+ */
+
+int
+kdba_parsebp(int argc, const char **argv, int *nextargp, kdb_bp_t *bp)
+{
+	int nextarg = *nextargp;
+	int diag;
+	kdbhard_bp_t *bph = &bp->bp_template;
+
+	bph->bph_mode = 0;		/* Default to instruction breakpoint */
+	bph->bph_length = 0;		/* Length must be zero for insn bp */
+	if ((argc + 1) != nextarg) {
+		if (strnicmp(argv[nextarg], "datar", sizeof("datar")) == 0) {
+			bph->bph_mode = 3;
+		} else if (strnicmp(argv[nextarg], "dataw", sizeof("dataw")) == 0) {
+			bph->bph_mode = 1;
+		} else if (strnicmp(argv[nextarg], "io", sizeof("io")) == 0) {
+			bph->bph_mode = 2;
+		} else if (strnicmp(argv[nextarg], "inst", sizeof("inst")) == 0) {
+			bph->bph_mode = 0;
+		} else {
+			return KDB_ARGCOUNT;
+		}
+
+		if (bph->bph_mode == 0)
+			kdba_check_pc(&bp->bp_addr);
+
+		bph->bph_length = 3;	/* Default to 4 byte */
+
+		nextarg++;
+
+		if ((argc + 1) != nextarg) {
+			unsigned long len;
+
+			diag = kdbgetularg((char *)argv[nextarg],
+					   &len);
+			if (diag)
+				return diag;
+
+
+			if ((len > 4) || (len == 3))
+				return KDB_BADLENGTH;
+
+			bph->bph_length = len;
+			bph->bph_length--; /* Normalize for debug register */
+			nextarg++;
+		}
+
+		if ((argc + 1) != nextarg)
+			return KDB_ARGCOUNT;
+
+		/*
+		 * Indicate to architecture independent level that
+		 * a hardware register assignment is required to enable
+		 * this breakpoint.
+		 */
+
+		bph->bph_free = 0;
+	} else {
+		if (KDB_DEBUG(BP))
+			kdb_printf("kdba_bp: no args, forcehw is %d\n", bp->bp_forcehw);
+		if (bp->bp_forcehw) {
+			/*
+			 * We are forced to use a hardware register for this
+			 * breakpoint because either the bph or bpha
+			 * commands were used to establish this breakpoint.
+			 */
+			bph->bph_free = 0;
+		} else {
+			/*
+			 * Indicate to architecture dependent level that
+			 * the instruction replacement breakpoint technique
+			 * should be used for this breakpoint.
+			 */
+			bph->bph_free = 1;
+			bp->bp_adjust = 0;	/* software, break is fault, not trap */
+		}
+	}
+
+	if (bph->bph_mode == 0 && kdba_verify_rw(bp->bp_addr, bph->bph_length+1)) {
+		kdb_printf("Invalid address for breakpoint, ignoring bp command\n");
+		return KDB_BADADDR;
+	}
+
+	*nextargp = nextarg;
+#ifndef CONFIG_KDB_HARDWARE_BREAKPOINTS
+	if (!bph->bph_free) {
+		kdb_printf("kdba_parsebp hardware breakpoints are not supported yet\n");
+		return KDB_NOTIMP;
+	}
+#endif /* CONFIG_KDB_HARDWARE_BREAKPOINTS */
+	return 0;
+}
+
+/*
+ * kdba_allocbp
+ *
+ *	Associate a hardware register with a breakpoint.
+ *
+ * Parameters:
+ *	None.
+ * Outputs:
+ *	None.
+ * Returns:
+ *	A pointer to the allocated register kdbhard_bp_t structure for
+ *	success, Null and a non-zero diagnostic for failure.
+ * Locking:
+ *	None.
+ * Remarks:
+ */
+
+static kdbhard_bp_t *
+kdba_allocbp(kdbhard_bp_t *bph, int *diagp)
+{
+	int i;
+	kdbhard_bp_t *newbph;
+
+	for(i=0,newbph=kdb_hardbreaks; i < KDB_MAXHARDBPT; i++, newbph++) {
+		if (newbph->bph_free) {
+			break;
+		}
+	}
+
+	if (i == KDB_MAXHARDBPT) {
+		*diagp = KDB_TOOMANYDBREGS;
+		return NULL;
+	}
+
+	*diagp = 0;
+
+	/*
+	 * Copy data from template.  Can't just copy the entire template
+	 * here because the register number in kdb_hardbreaks must be
+	 * preserved.
+	 */
+	newbph->bph_data = bph->bph_data;
+	newbph->bph_write = bph->bph_write;
+	newbph->bph_mode = bph->bph_mode;
+	newbph->bph_length = bph->bph_length;
+
+	/*
+	 * Mark entry allocated.
+	 */
+	newbph->bph_free = 0;
+
+	return newbph;
+}
+
+/*
+ * kdba_alloc_hwbp
+ *
+ *	Associate a hardware registers with a breakpoint.
+ *	If hw bp is global hw registers descriptor will be allocated
+ *	on every CPU.
+ *
+ * Parameters:
+ *	bp - hardware bp
+ *	diagp - pointer to variable that will store error when
+ *	function complete
+ * Outputs:
+ *	None.
+ * Returns:
+ *	None
+ * Locking:
+ *	None.
+ * Remarks:
+ *	Should be called with correct bp->bp_template.
+ */
+
+void
+kdba_alloc_hwbp(kdb_bp_t *bp, int *diagp)
+{
+ 	/* Note that bp->bp_hard[NR_CPU] is for x86.
+	 * The ia64 uses bp->bp_hard[0] only.
+	 */
+	bp->bp_hard[0] = kdba_allocbp(&bp->bp_template, diagp);
+	bp->bp_hardtype = 1;
+}
+
+
+
+/*
+ * kdba_freebp
+ *
+ *	Deallocate a hardware breakpoint
+ *
+ * Parameters:
+ *	None.
+ * Outputs:
+ *	None.
+ * Returns:
+ *	Zero for success, a kdb diagnostic for failure
+ * Locking:
+ *	None.
+ * Remarks:
+ */
+
+static void
+kdba_freebp(kdbhard_bp_t *bph)
+{
+	bph->bph_free = 1;
+}
+
+/*
+ * kdba_free_hwbp
+ *
+ *     Frees allocated hw registers descriptors for bp.
+ *     If hw bp is global, hw registers descriptors will be freed
+ *     on every CPU.
+ *
+ * Parameters:
+ *     bp - hardware bp
+ * Outputs:
+ *     None.
+ * Returns:
+ *     None
+ * Locking:
+ *     None.
+ * Remarks:
+ *     Should be called with correct bp->bp_template
+ */
+
+void
+kdba_free_hwbp(kdb_bp_t *bp)
+{
+	/* When kernel enters KDB, first, all local bps
+	 * are removed, so here we don't need to clear
+	 * debug registers.
+	 */
+
+	kdba_freebp(bp->bp_hard[0]);
+	bp->bp_hard[0] = NULL;
+	bp->bp_hardtype = 0;
+}
+
+
+/*
+ * kdba_initbp
+ *
+ *	Initialize the breakpoint table for the hardware breakpoint
+ *	register.
+ *
+ * Parameters:
+ *	None.
+ * Outputs:
+ *	None.
+ * Returns:
+ *	Zero for success, a kdb diagnostic for failure
+ * Locking:
+ *	None.
+ * Remarks:
+ *
+ *	There is one entry per register.  On the ia64 architecture
+ *	all the registers are interchangeable, so no special allocation
+ *	criteria are required.
+ */
+
+void
+kdba_initbp(void)
+{
+	int i;
+	kdbhard_bp_t *bph;
+
+	/*
+	 * Clear the hardware breakpoint table
+	 */
+
+	memset(kdb_hardbreaks, '\0', sizeof(kdb_hardbreaks));
+
+	for(i=0,bph=kdb_hardbreaks; i<KDB_MAXHARDBPT; i++, bph++) {
+		bph->bph_reg = i;
+		bph->bph_free = 1;
+	}
+}
+
+#ifdef CONFIG_KDB_HARDWARE_BREAKPOINTS
+/*
+ * Enable Instruction Debug & Data Debug faults on this CPU now.
+ */
+static inline void kdba_enable_debug_faults(void)
+{
+	unsigned long tmp;
+
+	tmp = ia64_getreg(_IA64_REG_PSR);
+	ia64_stop();
+	tmp |= IA64_PSR_DB;
+	ia64_stop();
+	ia64_setreg(_IA64_REG_PSR_L, tmp);
+	ia64_srlz_i();
+	if (KDB_DEBUG(BP))
+		kdb_printf("enabling debug faults: [%d]PSR.L=%08x\n",
+			   smp_processor_id(), (unsigned int)tmp);
+}
+
+/*
+ * Disable Instruction Debug & Data Debug faults on this CPU now.
+ */
+static inline void kdba_disable_debug_faults(void)
+{
+	unsigned long tmp;
+
+	tmp = ia64_getreg(_IA64_REG_PSR);
+	ia64_stop();
+	tmp &= ~IA64_PSR_DB;
+	ia64_stop();
+	ia64_setreg(_IA64_REG_PSR_L, tmp);
+	ia64_srlz_i();
+	if (KDB_DEBUG(BP))
+		kdb_printf("disabling debug faults: [%d]PSR.L=%08x\n",
+			   smp_processor_id(), (unsigned int)tmp);
+}
+#endif /* CONFIG_KDB_HARDWARE_BREAKPOINTS */
+
+/*
+ * kdba_installbp
+ *
+ *	Install a breakpoint
+ *
+ * Parameters:
+ *	regs	Exception frame
+ *	bp	Breakpoint structure for the breakpoint to be installed
+ * Outputs:
+ *	None.
+ * Returns:
+ *	0 if breakpoint set, otherwise error.
+ * Locking:
+ *	None.
+ * Remarks:
+ *	For hardware breakpoints, a debug register is allocated
+ *	and assigned to the breakpoint.  If no debug register is
+ *	available, a warning message is printed and the breakpoint
+ *	is disabled.
+ *
+ *	For instruction replacement breakpoints, we must single-step
+ *	over the replaced instruction at this point so we can re-install
+ *	the breakpoint instruction after the single-step.  SSBPT is set
+ *	when the breakpoint is initially hit and is cleared by any action
+ *	that removes the need for single-step over the breakpoint.
+ */
+
+int
+kdba_installbp(struct pt_regs *regs, kdb_bp_t *bp)
+{
+	/*
+	 * Install the breakpoint, if it is not already installed.
+	 */
+
+	if (KDB_DEBUG(BP)) {
+		kdb_printf("kdba_installbp bp_installed %d\n", bp->bp_installed);
+	}
+	if (!KDB_STATE(SSBPT))
+		bp->bp_delay = 0;
+
+	if (bp->bp_hardtype) {
+#ifdef CONFIG_KDB_HARDWARE_BREAKPOINTS
+		/*
+		 * Hardware breakpoints are always local for the
+		 * purposes of installation (i.e. they use per-cpu
+		 * registers), so we don't need to check bp_installed
+		 */
+		kdba_installdbreg(bp);
+		if (++kdb_dbrs_used[smp_processor_id()] == 1)
+			kdba_enable_debug_faults();
+		bp->bp_installed = 1;
+		if (KDB_DEBUG(BP)) {
+			kdb_printf("kdba_installbp hardware reg %ld at " kdb_bfd_vma_fmt0 "\n",
+				   bp->bp_hard[0]->bph_reg, bp->bp_addr);
+		}
+#endif /* CONFIG_KDB_HARDWARE_BREAKPOINTS */
+
+	} else if (bp->bp_delay) {
+		if (!bp->bp_installed) {
+			if (KDB_DEBUG(BP))
+				kdb_printf("kdba_installbp delayed bp\n");
+			kdba_handle_bp(regs, bp);
+		}
+	} else {
+		if (!bp->bp_installed) {
+			/* Software breakpoints always use slot 0 in the 128 bit
+			 * bundle.  The template type does not matter, slot 0
+			 * can only be M or B and the encodings for break.m and
+			 * break.b are the same.
+			 */
+			unsigned long break_inst;
+			if (kdb_getarea_size(bp->bp_inst.inst, bp->bp_addr, sizeof(bp->bp_inst.inst))) {
+				kdb_printf("kdba_installbp failed to read software breakpoint at 0x%lx\n", bp->bp_addr);
+				return(1);
+			}
+			break_inst = (bp->bp_inst.inst[0] & ~INST_SLOT0_MASK) | BREAK_INSTR;
+			if (kdb_putarea_size(bp->bp_addr, &break_inst, sizeof(break_inst))) {
+				kdb_printf("kdba_installbp failed to set software breakpoint at 0x%lx\n", bp->bp_addr);
+				return(1);
+			}
+			if (KDB_DEBUG(BP))
+				kdb_printf("kdba_installbp instruction 0x%lx at " kdb_bfd_vma_fmt0 "\n",
+					   BREAK_INSTR, bp->bp_addr);
+			bp->bp_installed = 1;
+			flush_icache_range(bp->bp_addr, bp->bp_addr+16);
+		}
+	}
+	return(0);
+}
+
+/*
+ * kdba_removebp
+ *
+ *	Make a breakpoint ineffective.
+ *
+ * Parameters:
+ *	None.
+ * Outputs:
+ *	None.
+ * Returns:
+ *	0 if breakpoint removed, otherwise error.
+ * Locking:
+ *	None.
+ * Remarks:
+ */
+
+int
+kdba_removebp(kdb_bp_t *bp)
+{
+	/*
+	 * For hardware breakpoints, remove it from the active register,
+	 * for software breakpoints, restore the instruction stream.
+	 */
+	if (KDB_DEBUG(BP)) {
+		kdb_printf("kdba_removebp bp_installed %d\n", bp->bp_installed);
+	}
+
+	if (bp->bp_hardtype) {
+#ifdef CONFIG_KDB_HARDWARE_BREAKPOINTS
+		if (KDB_DEBUG(BP)) {
+			kdb_printf("kdb: removing hardware reg %ld at " kdb_bfd_vma_fmt0 "\n",
+				   bp->bp_hard[0]->bph_reg, bp->bp_addr);
+		}
+		if (--kdb_dbrs_used[smp_processor_id()] == 0)
+			kdba_disable_debug_faults();
+		kdba_removedbreg(bp);
+#endif /* CONFIG_KDB_HARDWARE_BREAKPOINTS */
+	} else {
+		if (bp->bp_installed) {
+			if (KDB_DEBUG(BP))
+				kdb_printf("kdb: restoring instruction 0x%016lx%016lx at " kdb_bfd_vma_fmt0 "\n",
+					   bp->bp_inst.inst[0], bp->bp_inst.inst[1], bp->bp_addr);
+			if (kdba_putarea_size(bp->bp_addr, bp->bp_inst.inst, sizeof(bp->bp_inst.inst)))
+				return(1);
+		}
+		bp->bp_installed = 0;
+		flush_icache_range(bp->bp_addr, bp->bp_addr+16);
+	}
+	return(0);
+}
--- /dev/null
+++ b/arch/ia64/kdb/kdba_bt.c
@@ -0,0 +1,285 @@
+/*
+ * Kernel Debugger Architecture Dependent Stack Traceback
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (c) 1999-2004 Silicon Graphics, Inc.  All Rights Reserved.
+ */
+
+#include <linux/ctype.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/kallsyms.h>
+#include <linux/kdb.h>
+#include <linux/kdbprivate.h>
+#include <asm/system.h>
+#include <asm/sections.h>
+
+/*
+ * bt_print_one
+ *
+ *	Print one back trace entry.
+ *
+ * Inputs:
+ *	ip	Current program counter.
+ *	symtab	Information about symbol that ip falls within.
+ *	argcount Maximum number of arguments to print.
+ * Outputs:
+ *	None.
+ * Returns:
+ *	None.
+ * Locking:
+ *	None.
+ * Remarks:
+ *	None.
+ */
+
+static void
+bt_print_one(kdb_machreg_t ip,
+	     const kdb_symtab_t *symtab, int argcount,
+	     struct unw_frame_info *info)
+{
+	int btsymarg = 0;		/* Convert arguments to symbols */
+	int btsp = 0;			/* Print stack and backing store pointers */
+	int nosect = 0;			/* Suppress section data */
+	int args;
+	kdb_machreg_t sp, bsp, cfm;
+
+	kdbgetintenv("BTSYMARG", &btsymarg);
+	kdbgetintenv("BTSP", &btsp);
+	kdbgetintenv("NOSECT", &nosect);
+
+	unw_get_sp(info, &sp);
+	unw_get_bsp(info, &bsp);
+	unw_get_cfm(info, &cfm);
+	kdb_symbol_print(ip, symtab, KDB_SP_VALUE|KDB_SP_NEWLINE);
+	args = (cfm >> 7) & 0x7f;	/* sol */
+	if (!args)
+		args = cfm & 0x7f;	/* no in/local, use sof instead */
+	if (argcount && args) {
+		int i, argc = args;
+
+		kdb_printf("        args (");
+		if (argc > argcount)
+			argc = argcount;
+
+		for(i = 0; i < argc; i++){
+			kdb_machreg_t arg;
+			char nat;
+			if (unw_access_gr(info, i+32, &arg, &nat, 0))
+				arg = 0;
+
+			if (i)
+				kdb_printf(", ");
+			kdb_printf("0x%lx", arg);
+		}
+		kdb_printf(")\n");
+		if (btsymarg) {
+			kdb_symtab_t	arg_symtab;
+			kdb_machreg_t	arg;
+			for(i = 0; i < argc; i++){
+				char nat;
+				if (unw_access_gr(info, i+32, &arg, &nat, 0))
+					arg = 0;
+				if (kdbnearsym(arg, &arg_symtab)) {
+					kdb_printf("        arg %d ", i);
+					kdb_symbol_print(arg, &arg_symtab, KDB_SP_DEFAULT|KDB_SP_NEWLINE);
+				}
+			}
+		}
+	}
+	if (symtab->sym_name) {
+		if (!nosect) {
+			kdb_printf("        %s", symtab->mod_name);
+			if (symtab->sec_name)
+				kdb_printf(" %s 0x%lx", symtab->sec_name, symtab->sec_start);
+			kdb_printf(" 0x%lx", symtab->sym_start);
+			if (symtab->sym_end)
+				kdb_printf(" 0x%lx", symtab->sym_end);
+			kdb_printf("\n");
+		}
+		if (strncmp(symtab->sym_name, "ia64_spinlock_contention", 24) == 0) {
+			kdb_machreg_t r31;
+			char nat;
+			kdb_printf("        r31 (spinlock address) ");
+			if (unw_access_gr(info, 31, &r31, &nat, 0))
+				r31 = 0;
+			kdb_symbol_print(r31, NULL, KDB_SP_VALUE|KDB_SP_NEWLINE);
+		}
+	}
+	if (btsp)
+		kdb_printf("        sp 0x%016lx bsp 0x%016lx cfm 0x%016lx info->pfs_loc 0x%016lx 0x%016lx\n",
+				sp, bsp, cfm, (u64) info->pfs_loc, info->pfs_loc ? *(info->pfs_loc) : 0);
+}
+
+/*
+ * kdba_bt_stack
+ *
+ *	Unwind the ia64 backtrace for a specified process.
+ *
+ * Inputs:
+ *	argcount
+ *	p	Pointer to task structure to unwind.
+ * Outputs:
+ *	None.
+ * Returns:
+ *	zero for success, a kdb diagnostic if error
+ * Locking:
+ *	none.
+ * Remarks:
+ *	none.
+ */
+
+static int
+kdba_bt_stack(int argcount, const struct task_struct *p)
+{
+	kdb_symtab_t symtab;
+	struct unw_frame_info info;
+	struct switch_stack *sw;
+	struct pt_regs *regs = NULL;
+	int count = 0;
+	int btsp = 0;			/* Backtrace the kdb code as well */
+	u64 *prev_pfs_loc = NULL;
+	extern char __attribute__ ((weak)) ia64_spinlock_contention_pre3_4[];
+	extern char __attribute__ ((weak)) ia64_spinlock_contention_pre3_4_end[];
+
+	/*
+	 * Upon entering kdb_main_loop, the stack frame looks like this:
+	 *
+	 *	+---------------------+
+	 *	|   struct pt_regs    |
+	 *	+---------------------+
+	 *	|		      |
+	 *	|   kernel stack      |
+	 *	|		      |
+	 *	+=====================+ <--- top of stack upon entering kdb
+	 *	|   struct pt_regs    |
+	 *	+---------------------+
+	 *	|		      |
+	 *	|   kdb stack         |
+	 *	|		      |
+	 *	+---------------------+
+	 *	| struct switch_stack |
+	 *	+=====================+ <--- kdb_running_process[cpu].arch.sw from do_kdba_main_loop
+	 *
+	 * When looking at another process, we do not have the address of the
+	 * current pt_regs, it is NULL.  If the process has saved its state, use
+	 * that pt_regs instead.
+	 */
+
+	kdbgetintenv("BTSP", &btsp);
+
+	if (kdb_task_has_cpu(p)) {
+		struct kdb_running_process *krp = kdb_running_process + kdb_process_cpu(p);
+		if (krp->seqno) {
+			sw = krp->arch.sw;
+			regs = krp->regs;
+		}
+		else
+			sw = NULL;
+	}
+	else {
+		/* Not running, assume blocked */
+		sw = (struct switch_stack *) (p->thread.ksp + 16);
+	}
+	if (!sw) {
+		kdb_printf("Process does not have a switch_stack, cannot backtrace\n");
+		kdb_ps1(p);
+		return 0;
+	}
+
+	unw_init_frame_info(&info, (struct task_struct *)p, sw);
+
+	/* If we have the address of pt_regs, suppress backtrace on the frames below
+	 * pt_regs.  No point in displaying kdb itself, unless the user is debugging
+	 * the unwinder using set BTSP=1.
+	 */
+	if (regs && !btsp) {
+		kdb_machreg_t sp;
+		if (user_mode(regs)) {
+			kdb_printf("Process was interrupted in user mode, no backtrace available\n");
+			return 0;
+		}
+		do {
+			unw_get_sp(&info, &sp);
+			if (sp >= (kdb_machreg_t)regs)
+				break;
+		} while (unw_unwind(&info) >= 0 && count++ < 200);
+	}
+
+	do {
+		kdb_machreg_t ip;
+
+		/* Avoid unsightly console message from unw_unwind() when attempting
+		 * to unwind through the Interrupt Vector Table which has no unwind
+		 * information.  dispatch_illegal_op_fault() is an exception, it sits
+		 * in the 0x3c00 slot.
+		 */
+		if (info.ip >= (u64)__start_ivt_text && info.ip < (u64)__end_ivt_text) {
+			if (info.ip < (u64)__start_ivt_text + 0x3c00 ||
+			    info.ip >= (u64)__start_ivt_text + 0x4000)
+				return 0;
+		}
+
+		/* WAR for spinlock contention from leaf functions.  ia64_spinlock_contention_pre3_4
+		 * has ar.pfs == r0.  Leaf functions do not modify ar.pfs so ar.pfs remains
+		 * as 0, stopping the backtrace.  Record the previous ar.pfs when the current
+		 * IP is in ia64_spinlock_contention_pre3_4 then unwind, if pfs_loc has not changed
+		 * after unwind then use pt_regs.ar_pfs which is where the real ar.pfs is for
+		 * leaf functions.
+		 */
+		if (prev_pfs_loc && regs && info.pfs_loc == prev_pfs_loc)
+			info.pfs_loc = &regs->ar_pfs;
+		prev_pfs_loc = (info.ip >= (u64)ia64_spinlock_contention_pre3_4 &&
+				info.ip < (u64)ia64_spinlock_contention_pre3_4_end) ?
+			       info.pfs_loc : NULL;
+
+		unw_get_ip(&info, &ip);
+		if (ip == 0)
+			break;
+
+		kdbnearsym(ip, &symtab);
+		if (!symtab.sym_name) {
+			kdb_printf("0x%0*lx - No name.  May be an area that has no unwind data\n",
+				(int)(2*sizeof(ip)), ip);
+			return 0;
+		}
+		bt_print_one(ip, &symtab, argcount, &info);
+	} while (unw_unwind(&info) >= 0 && count++ < 200);
+	if (count >= 200)
+		kdb_printf("bt truncated, count limit reached\n");
+
+	return 0;
+}
+
+int
+kdba_bt_address(kdb_machreg_t addr, int argcount)
+{
+	kdb_printf("Backtrace from a stack address is not supported on ia64\n");
+	return KDB_NOTIMP;
+}
+
+/*
+ * kdba_bt_process
+ *
+ *	Do a backtrace for a specified process.
+ *
+ * Inputs:
+ *	p	Struct task pointer extracted by 'bt' command.
+ *	argcount
+ * Outputs:
+ *	None.
+ * Returns:
+ *	zero for success, a kdb diagnostic if error
+ * Locking:
+ *	none.
+ */
+
+int
+kdba_bt_process(const struct task_struct *p, int argcount)
+{
+	return kdba_bt_stack(argcount, p);
+}
--- /dev/null
+++ b/arch/ia64/kdb/kdba_fru.c
@@ -0,0 +1,65 @@
+/*
+ * Kernel Debugger Architecture Dependent FRU functions.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (c) 1999-2004 Silicon Graphics, Inc.  All Rights Reserved.
+ */
+
+#include <linux/types.h>
+#include <linux/kdb.h>
+#include <linux/kdbprivate.h>
+#include <linux/module.h>
+#include <asm/sal.h>
+#include <asm/sn/sn_sal.h>
+
+MODULE_AUTHOR("Jesse Barnes");
+MODULE_DESCRIPTION("Capture FRU data");
+MODULE_LICENSE("GPL");
+
+/**
+ * kdba_fru - capture FRU data
+ * @argc: arg count
+ * @argv: arg values
+ *
+ * Tell the system contollers to capture FRU data
+ */
+static int
+kdba_fru(int argc, const char **argv)
+{
+	u64 ret;
+
+	kdb_printf("Capturing FRU data...");
+	ret = ia64_sn_fru_capture();
+	kdb_printf("done.\n");
+	return ret;
+}
+
+/**
+ * kdba_fru_init - register 'fru' command with kdb
+ *
+ * Register the 'fru' command with kdb at load time.
+ */
+static int __init
+kdba_fru_init(void)
+{
+	kdb_register("fru", kdba_fru, 0, "Capture FRU data", 0);
+
+	return 0;
+}
+
+/**
+ * kdba_fru_exit - unregister the 'fru' command
+ *
+ * Tell kdb that the 'fru' command is no longer available.
+ */
+static void __exit
+kdba_fru_exit(void)
+{
+	kdb_unregister("fru");
+}
+
+module_init(kdba_fru_init)
+module_exit(kdba_fru_exit)
--- /dev/null
+++ b/arch/ia64/kdb/kdba_id.c
@@ -0,0 +1,529 @@
+/*
+ * Kernel Debugger Architecture Dependent Instruction Disassembly
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (c) 1999-2004 Silicon Graphics, Inc.  All Rights Reserved.
+ */
+
+#include <stdarg.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/string.h>
+#include <linux/kdb.h>
+#include <linux/kdbprivate.h>
+#include <asm/patch.h>
+
+#define KDBA_PRINTBUF_LEN	64	/* buffer len to print a single instr */
+#define KDBA_READBUFFER_LEN	256	/* buffer for BFD disassembler */
+
+#define BUNDLE_MULTIPLIER	3	/* how many instr/bundle */
+#define BUNDLE_SIZE		16	/* how many bytes/bundle */
+#define KDBA_DEFAULT_IDLEN	3	/* default number of bundles to disassemble */
+
+/*
+ * kdba_dis_getsym
+ *
+ *	Get a symbol for the disassembler.
+ *
+ * Parameters:
+ *	addr	Address for which to get symbol
+ *	dip	Pointer to disassemble_info
+ * Returns:
+ *	0
+ * Locking:
+ * Remarks:
+ *	Not used for kdb.
+ */
+
+/* ARGSUSED */
+static int
+kdba_dis_getsym(bfd_vma addr, disassemble_info *dip)
+{
+
+	return 0;
+}
+
+/*
+ * kdba_printaddress
+ *
+ *	Print (symbolically) an address.
+ *
+ * Parameters:
+ *	addr	Address for which to get symbol
+ *	dip	Pointer to disassemble_info
+ *	flag	True if a ":<tab>" sequence should follow the address
+ * Returns:
+ *	0
+ * Locking:
+ * Remarks:
+ *
+ */
+
+/* ARGSUSED */
+static void
+kdba_printaddress(kdb_machreg_t addr, disassemble_info *dip, int flag)
+{
+	kdb_symtab_t symtab;
+	int spaces = 5;
+	unsigned int offset;
+	int slot;
+
+	/* Some code prints slot number, some prints "byte" offset
+	 * from start of bundle.  Standardise on "byte" offset.
+	 */
+	slot = addr & 0x0f;
+	if (slot < 3)
+		slot *= 6;
+	addr = (addr & ~0x0f) + slot;
+
+	/*
+	 * Print a symbol name or address as necessary.
+	 */
+	dip->fprintf_func(dip->stream, "0x%0*lx ", (int)(2*sizeof(addr)), addr);
+	kdbnearsym(addr, &symtab);
+	if (symtab.sym_name) {
+		/* Do not use kdb_symbol_print here, it always does
+		 * kdb_printf but we want dip->fprintf_func.
+		 */
+		dip->fprintf_func(dip->stream, "%s", symtab.sym_name);
+		if ((offset = addr - symtab.sym_start) == 0) {
+			spaces += 4;
+		}
+		else {
+			unsigned int o = offset;
+			while (o >>= 4)
+				--spaces;
+			dip->fprintf_func(dip->stream, "+0x%x", offset);
+		}
+	}
+
+	if (flag) {
+		if (spaces < 1) {
+			spaces = 1;
+		}
+		dip->fprintf_func(dip->stream, ":%*s", spaces, " ");
+	}
+}
+
+/* Calls outside the current kernel module use a PLT */
+
+static int addr_maybe_plt;
+
+/* The templates below were extracted from arch/ia64/kernel/module.c.  The
+ * masks were generated by this quick and dirty program:
+ */
+
+#if 0	/* mask program */
+#include <stdio.h>
+
+#define u64 unsigned long
+
+/* routines copied from arch/ia64/kernel/patch.c */
+
+static void
+ia64_patch (u64 insn_addr, u64 mask, u64 val)
+{
+	u64 m0, m1, v0, v1, b0, b1, *b = (u64 *) (insn_addr & -16);
+#	define insn_mask ((1UL << 41) - 1)
+	unsigned long shift;
+
+	b0 = b[0]; b1 = b[1];
+	shift = 5 + 41 * (insn_addr % 16); /* 5 bits of template, then 3 x 41-bit instructions */
+	if (shift >= 64) {
+		m1 = mask << (shift - 64);
+		v1 = val << (shift - 64);
+	} else {
+		m0 = mask << shift; m1 = mask >> (64 - shift);
+		v0 = val  << shift; v1 = val >> (64 - shift);
+		b[0] = (b0 & ~m0) | (v0 & m0);
+	}
+	b[1] = (b1 & ~m1) | (v1 & m1);
+}
+
+static void
+ia64_patch_imm64 (u64 insn_addr, u64 val)
+{
+	/* The assembler may generate offset pointing to either slot 1
+	   or slot 2 for a long (2-slot) instruction, occupying slots 1
+	   and 2.  */
+  	insn_addr &= -16UL;
+	ia64_patch(insn_addr + 2,
+		   0x01fffefe000UL, (  ((val & 0x8000000000000000UL) >> 27) /* bit 63 -> 36 */
+				     | ((val & 0x0000000000200000UL) <<  0) /* bit 21 -> 21 */
+				     | ((val & 0x00000000001f0000UL) <<  6) /* bit 16 -> 22 */
+				     | ((val & 0x000000000000ff80UL) << 20) /* bit  7 -> 27 */
+				     | ((val & 0x000000000000007fUL) << 13) /* bit  0 -> 13 */));
+	ia64_patch(insn_addr + 1, 0x1ffffffffffUL, val >> 22);
+}
+
+static void
+ia64_patch_imm60 (u64 insn_addr, u64 val)
+{
+	/* The assembler may generate offset pointing to either slot 1
+	   or slot 2 for a long (2-slot) instruction, occupying slots 1
+	   and 2.  */
+  	insn_addr &= -16UL;
+	ia64_patch(insn_addr + 2,
+		   0x011ffffe000UL, (  ((val & 0x0800000000000000UL) >> 23) /* bit 59 -> 36 */
+				     | ((val & 0x00000000000fffffUL) << 13) /* bit  0 -> 13 */));
+	ia64_patch(insn_addr + 1, 0x1fffffffffcUL, val >> 18);
+}
+
+struct plt_entry {
+	unsigned char bundle[3][16];
+};
+static struct plt_entry ia64_plt_mask;
+
+int main(void)
+{
+	int i, j;
+	printf("2 bundle\n");
+	for (i = 0; i < 2; ++i)
+		for (j = 0; j < 16; ++j)
+			ia64_plt_mask.bundle[i][j] = 0xff;
+	ia64_patch_imm64((u64) (ia64_plt_mask.bundle + 0), 0);
+	ia64_patch_imm60((u64) (ia64_plt_mask.bundle + 1), 0);
+	for (i = 0; i < 2; ++i) {
+		for (j = 0; j < 16; ++j) {
+			printf("0x%02x", ia64_plt_mask.bundle[i][j]);
+			if (j != 15)
+				printf(", ");
+			if (j % 6 == 5 || j == 15)
+				printf("\n");
+		}
+	}
+	printf("\n3 bundle\n");
+	for (i = 0; i < 3; ++i)
+		for (j = 0; j < 16; ++j)
+			ia64_plt_mask.bundle[i][j] = 0xff;
+	ia64_patch_imm64((u64) (ia64_plt_mask.bundle + 0), 0);
+	ia64_patch_imm64((u64) (ia64_plt_mask.bundle + 1), 0);
+	for (i = 0; i < 3; ++i) {
+		for (j = 0; j < 16; ++j) {
+			printf("0x%02x", ia64_plt_mask.bundle[i][j]);
+			if (j != 15)
+				printf(", ");
+			if (j % 6 == 5 || j == 15)
+				printf("\n");
+		}
+	}
+	return 0;
+}
+#endif	/* mask program */
+
+#ifdef CONFIG_IA64_BRL_EMU
+#define PLT_BUNDLES 3
+struct plt_entry {
+	unsigned char bundle[PLT_BUNDLES][16];
+};
+static const struct plt_entry ia64_plt_template = {
+	{
+		{
+			0x05, 0x00, 0x00, 0x00, 0x01, 0x00, /* [MLX] nop.m 0 */
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /*	     movl r16=TARGET_IP */
+			0x02, 0x00, 0x00, 0x60
+		},
+		{
+			0x04, 0x00, 0x00, 0x00, 0x01, 0x00, /* [MLX] nop.m 0 */
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x20, /*	     movl gp=TARGET_GP */
+			0x00, 0x00, 0x00, 0x60
+		},
+		{
+			0x11, 0x00, 0x00, 0x00, 0x01, 0x00, /* [MIB] nop.m 0 */
+			0x60, 0x80, 0x04, 0x80, 0x03, 0x00, /*	     mov b6=r16 */
+			0x60, 0x00, 0x80, 0x00		    /*	     br.few b6 */
+		}
+	}
+};
+static const struct plt_entry ia64_plt_mask = {
+	{
+		{
+			0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, /* [MLX] nop.m 0 */
+			0x00, 0x00, 0x00, 0x00, 0x80, 0xff, /*       movl r16=TARGET_IP */
+			0x0f, 0x08, 0x00, 0xf0
+		},
+		{
+			0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, /* [MLX] nop.m 0 */
+			0x00, 0x00, 0x00, 0x00, 0x80, 0xff, /*       movl gp=TARGET_GP */
+			0x0f, 0x08, 0x00, 0xf0
+		},
+		{
+			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, /* [MIB] nop.m 0 */
+			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, /*       mov b6=r16 */
+			0xff, 0xff, 0xff, 0xff              /*       br.few b6 */
+		}
+};
+
+#else /* !CONFIG_IA64_BRL_EMU */
+
+#define PLT_BUNDLES 2
+struct plt_entry {
+	unsigned char bundle[PLT_BUNDLES][16];
+};
+static const struct plt_entry ia64_plt_template = {
+	{
+		{
+			0x04, 0x00, 0x00, 0x00, 0x01, 0x00, /* [MLX] nop.m 0 */
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x20, /*	     movl gp=TARGET_GP */
+			0x00, 0x00, 0x00, 0x60
+		},
+		{
+			0x05, 0x00, 0x00, 0x00, 0x01, 0x00, /* [MLX] nop.m 0 */
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /*	     brl.many TARGET_IP */
+			0x08, 0x00, 0x00, 0xc0
+		}
+	}
+};
+static const struct plt_entry ia64_plt_mask = {
+	{
+		{
+			0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, /* [MLX] nop.m 0 */
+			0x00, 0x00, 0x00, 0x00, 0x80, 0xff, /*       movl gp=TARGET_GP */
+			0x0f, 0x08, 0x00, 0xf0
+		},
+		{
+			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, /* [MLX] nop.m 0 */
+			0x00, 0x00, 0x00, 0x00, 0x80, 0xff, /*       brl.many TARGET_IP */
+			0x0f, 0x00, 0x00, 0xf7
+		}
+	}
+};
+#endif /* CONFIG_IA64_BRL_EMU */
+
+static inline u64
+get_slot(u64 bundle, int slot)
+{
+	switch (slot) {
+	case 0:
+		return (((u64 *)bundle)[0] >> 5) & 0x1ffffffffffLL;
+	case 1:
+		return ((((u64 *)bundle)[0] >> 46) & 0x3ffff) |
+		       ((((u64 *)bundle)[1] & 0x7fffff) << 18);
+	default:
+		return (((u64 *)bundle)[1] >> 23) & 0x1ffffffffffLL;
+	}
+}
+
+static inline u64
+get_movl (u64 addr)
+{
+	/* X2 format */
+	u64 slot1 = get_slot(addr, 1), slot2 = get_slot(addr, 2);
+	u64 i, imm9d, imm5c, ic, imm7b, imm41;
+	i = (slot2 >> 36) & 0x1UL;
+	imm9d = (slot2 >> 27) & 0xfffUL;
+	imm5c = (slot2 >> 22) & 0x1fUL;
+	ic = (slot2 >> 21) & 0x1UL;
+	imm7b = (slot2 >> 13) & 0x7fUL;
+	imm41 = slot1;
+	return (i << 63) | (imm41 << 22) | (ic << 21) | (imm5c << 16) |
+	       (imm9d << 7) | imm7b;
+}
+
+static inline u64
+get_brl (u64 addr)
+{
+	/* X3 format */
+	u64 slot1 = get_slot(addr, 1), slot2 = get_slot(addr, 2);
+	u64 i, imm20b, imm39;
+	i = (slot2 >> 36) & 0x1UL;
+	imm20b = (slot2 >> 13) & 0xfffffUL;
+	imm39 = slot1 >> 2;
+	return ((i << 59) | (imm39 << 20) | imm20b) << 4;
+}
+
+static bfd_vma
+is_plt(bfd_vma addr) {
+	int i, j;
+	u64 target;
+	struct plt_entry plt;
+	if (kdb_getarea_size(&plt, addr, sizeof(plt)))
+		return 0;
+	for (i = 0; i < PLT_BUNDLES; ++i) {
+		for (j = 0; j < 16; ++j) {
+			if ((plt.bundle[i][j] & ia64_plt_mask.bundle[i][j]) !=
+			    ia64_plt_template.bundle[i][j])
+				return 0;
+		}
+	}
+	if (PLT_BUNDLES == 2) {
+		/* brl is IP relative, in second bundle */
+		target = get_brl(addr + 16) + addr + 16;
+	} else {
+		/* movl is absolute, in first bundle */
+		target = get_movl(addr);
+	}
+	return target;
+}
+
+/*
+ * kdba_dis_printaddr
+ *
+ *	Print (symbolically) an address.  Called by GNU disassembly
+ *	code via disassemble_info structure.
+ *
+ * Parameters:
+ *	addr	Address for which to get symbol
+ *	dip	Pointer to disassemble_info
+ * Returns:
+ *	0
+ * Locking:
+ * Remarks:
+ *	This function will never append ":<tab>" to the printed
+ *	symbolic address.  If the address may be a PLT entry then try to decode
+ *	the PLT information.
+ */
+
+static void
+kdba_dis_printaddr(bfd_vma addr, disassemble_info *dip)
+{
+	bfd_vma target;
+	kdba_printaddress(addr, dip, 0);
+	if (!addr_maybe_plt)
+		return;
+	if (!(target = is_plt(addr)))
+		return;
+	kdb_printf(" PLT --> ");
+	kdba_printaddress(target, dip, 0);
+}
+
+/*
+ * kdba_dis_getmem
+ *
+ *	Fetch 'length' bytes from 'addr' into 'buf'.
+ *
+ * Parameters:
+ *	addr	Address for which to get symbol
+ *	buf	Address of buffer to fill with bytes from 'addr'
+ *	length	Number of bytes to fetch
+ *	dip	Pointer to disassemble_info
+ * Returns:
+ *	0
+ * Locking:
+ * Remarks:
+ *
+ */
+
+/* ARGSUSED */
+static int
+kdba_dis_getmem(bfd_vma addr, bfd_byte *buf, unsigned int length, disassemble_info *dip)
+{
+	return kdb_getarea_size(buf, addr, length);
+}
+
+/*
+ * kdba_id_parsemode
+ *
+ * 	Parse IDMODE environment variable string and
+ *	set appropriate value into "disassemble_info" structure.
+ *
+ * Parameters:
+ *	mode	Mode string
+ *	dip	Disassemble_info structure pointer
+ * Returns:
+ * Locking:
+ * Remarks:
+ *	No mode supported yet.
+ */
+
+int
+kdba_id_parsemode(const char *mode, disassemble_info *dip)
+{
+	if (mode && strcmp(mode, "ia64"))
+		return KDB_BADMODE;
+	return 0;
+}
+
+/*
+ * kdba_check_pc
+ *
+ * 	Check that the pc is satisfactory.
+ *
+ * Parameters:
+ *	pc	Program Counter Value.
+ * Returns:
+ *	None
+ * Locking:
+ *	None.
+ * Remarks:
+ *	Can change pc.
+ */
+
+void
+kdba_check_pc(kdb_machreg_t *pc)
+{
+	(*pc) &= ~0xf;	/* pc must be 16 byte aligned */
+}
+
+/*
+ * kdba_id_printinsn
+ *
+ * 	Format and print a single bundle at 'pc'. Return the
+ *	length of the bundle.
+ *
+ * Parameters:
+ *	pc	Program Counter Value.
+ *	dip	Disassemble_info structure pointer
+ * Returns:
+ *	Length of instruction, -1 for error.
+ * Locking:
+ *	None.
+ * Remarks:
+ *	None.
+ */
+
+int
+kdba_id_printinsn(kdb_machreg_t pc, disassemble_info *dip)
+{
+	int ret;
+	int byte = 0;
+
+	kdba_check_pc(&pc);
+	while (byte < 16) {
+		kdba_dis_printaddr(pc+byte, dip);
+		addr_maybe_plt = 1;
+		ret = print_insn_ia64((kdb_machreg_t)(pc+byte), dip);
+		addr_maybe_plt = 0;
+		dip->fprintf_func(dip->stream, "\n");
+		if (ret < 0)
+			break;
+		byte += ret;
+	}
+	return(byte);
+}
+
+/*
+ * kdba_id_init
+ *
+ * 	Initialize the architecture dependent elements of
+ *	the disassembly information structure
+ *	for the GNU disassembler.
+ *
+ * Parameters:
+ *	None.
+ * Outputs:
+ *	None.
+ * Returns:
+ *	None.
+ * Locking:
+ *	None.
+ * Remarks:
+ */
+
+void
+kdba_id_init(disassemble_info *dip)
+{
+	dip->read_memory_func       = kdba_dis_getmem;
+	dip->print_address_func     = kdba_dis_printaddr;
+	dip->symbol_at_address_func = kdba_dis_getsym;
+
+	dip->flavour                = bfd_target_elf_flavour;
+	dip->arch		    = bfd_arch_ia64;
+	dip->endian	    	    = BFD_ENDIAN_LITTLE;
+
+	dip->display_endian         = BFD_ENDIAN_LITTLE;
+}
--- /dev/null
+++ b/arch/ia64/kdb/kdba_io.c
@@ -0,0 +1,661 @@
+/*
+ * Kernel Debugger Architecture Dependent Console I/O handler
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (c) 1999-2006 Silicon Graphics, Inc.  All Rights Reserved.
+ */
+
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <linux/console.h>
+#include <linux/ctype.h>
+#include <linux/keyboard.h>
+#include <linux/serial.h>
+#include <linux/serial_reg.h>
+
+#include <linux/kdb.h>
+#include <linux/kdbprivate.h>
+
+#if defined(CONFIG_SERIAL_8250_CONSOLE) || defined(CONFIG_SERIAL_SGI_L1_CONSOLE)
+#define HAVE_KDBA_SERIAL_CONSOLE
+#endif
+
+/* from include/linux/pc_keyb.h on 2.4 */
+#define KBD_STATUS_REG		0x64	/* Status register (R) */
+#define KBD_DATA_REG		0x60	/* Keyboard data register (R/W) */
+#define KBD_CMD_SET_LEDS	0xED	/* Set keyboard leds */
+#define KBD_STAT_OBF 		0x01	/* Keyboard output buffer full */
+#define KBD_STAT_IBF 		0x02	/* Keyboard input buffer full */
+#define KBD_STAT_MOUSE_OBF	0x20	/* Mouse output buffer full */
+
+#ifdef	CONFIG_VT_CONSOLE
+#define KDB_BLINK_LED 1
+#else
+#undef	KDB_BLINK_LED
+#endif
+
+#ifdef CONFIG_KDB_USB
+
+/* support up to 8 USB keyboards (probably excessive, but...) */
+#define KDB_USB_NUM_KEYBOARDS	8
+struct kdb_usb_kbd_info kdb_usb_kbds[KDB_USB_NUM_KEYBOARDS];
+
+extern int kdb_no_usb;
+
+static unsigned char kdb_usb_keycode[256] = {
+	  0,  0,  0,  0, 30, 48, 46, 32, 18, 33, 34, 35, 23, 36, 37, 38,
+	 50, 49, 24, 25, 16, 19, 31, 20, 22, 47, 17, 45, 21, 44,  2,  3,
+	  4,  5,  6,  7,  8,  9, 10, 11, 28,  1, 14, 15, 57, 12, 13, 26,
+	 27, 43, 84, 39, 40, 41, 51, 52, 53, 58, 59, 60, 61, 62, 63, 64,
+	 65, 66, 67, 68, 87, 88, 99, 70,119,110,102,104,111,107,109,106,
+	105,108,103, 69, 98, 55, 74, 78, 96, 79, 80, 81, 75, 76, 77, 71,
+	 72, 73, 82, 83, 86,127,116,117, 85, 89, 90, 91, 92, 93, 94, 95,
+	120,121,122,123,134,138,130,132,128,129,131,137,133,135,136,113,
+	115,114,  0,  0,  0,124,  0,181,182,183,184,185,186,187,188,189,
+	190,191,192,193,194,195,196,197,198,  0,  0,  0,  0,  0,  0,  0,
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	 29, 42, 56,125, 97, 54,100,126,164,166,165,163,161,115,114,113,
+	150,158,159,128,136,177,178,176,142,152,173,140
+};
+
+/*
+ * kdb_usb_keyboard_attach()
+ * Attach a USB keyboard to kdb.
+ */
+int
+kdb_usb_keyboard_attach(struct urb *urb, unsigned char *buffer, void *poll_func)
+{
+	int	i;
+	int	rc = -1;
+
+	if (kdb_no_usb)
+		return 0;
+
+	/*
+	 * Search through the array of KDB USB keyboards (kdb_usb_kbds)
+	 * looking for a free index. If found, assign the keyboard to
+	 * the array index.
+	 */
+
+	for (i = 0; i < KDB_USB_NUM_KEYBOARDS; i++) {
+		if (kdb_usb_kbds[i].urb) /* index is already assigned */
+			continue;
+
+		/* found a free array index */
+		kdb_usb_kbds[i].urb = urb;
+		kdb_usb_kbds[i].buffer = buffer;
+		kdb_usb_kbds[i].poll_func = poll_func;
+
+		rc = 0;	/* success */
+
+		break;
+	}
+
+	return rc;
+}
+EXPORT_SYMBOL_GPL (kdb_usb_keyboard_attach);
+
+/*
+ * kdb_usb_keyboard_detach()
+ * Detach a USB keyboard from kdb.
+ */
+int
+kdb_usb_keyboard_detach(struct urb *urb)
+{
+	int	i;
+	int	rc = -1;
+
+	if (kdb_no_usb)
+		return 0;
+
+	/*
+	 * Search through the array of KDB USB keyboards (kdb_usb_kbds)
+	 * looking for the index with the matching URB. If found,
+	 * clear the array index.
+	 */
+
+	for (i = 0; i < KDB_USB_NUM_KEYBOARDS; i++) {
+		if (kdb_usb_kbds[i].urb != urb)
+			continue;
+
+		/* found it, clear the index */
+		kdb_usb_kbds[i].urb = NULL;
+		kdb_usb_kbds[i].buffer = NULL;
+		kdb_usb_kbds[i].poll_func = NULL;
+		kdb_usb_kbds[i].caps_lock = 0;
+
+		rc = 0;	/* success */
+
+		break;
+	}
+
+	return rc;
+}
+EXPORT_SYMBOL_GPL (kdb_usb_keyboard_detach);
+
+/*
+ * get_usb_char
+ * This function drives the USB attached keyboards.
+ * Fetch the USB scancode and decode it.
+ */
+static int
+get_usb_char(void)
+{
+	int	i;
+	int	ret;
+	unsigned char keycode, spec;
+	extern u_short plain_map[], shift_map[], ctrl_map[];
+
+	if (kdb_no_usb)
+		return -1;
+
+	/*
+	 * Loop through all the USB keyboard(s) and return
+	 * the first character obtained from them.
+	 */
+
+	for (i = 0; i < KDB_USB_NUM_KEYBOARDS; i++) {
+		/* skip uninitialized keyboard array entries */
+		if (!kdb_usb_kbds[i].urb || !kdb_usb_kbds[i].buffer ||
+		    !kdb_usb_kbds[i].poll_func)
+			continue;
+
+		/* Transfer char */
+		ret = (*kdb_usb_kbds[i].poll_func)(kdb_usb_kbds[i].urb);
+
+		if (ret == -EBUSY && kdb_usb_kbds[i].poll_ret != -EBUSY)
+			kdb_printf("NOTICE: USB HC driver BUSY. "
+			    "USB keyboard has been disabled.\n");
+
+		kdb_usb_kbds[i].poll_ret = ret;
+
+		if (ret < 0) /* error or no characters, try the next kbd */
+			continue;
+
+		spec = kdb_usb_kbds[i].buffer[0];
+		keycode = kdb_usb_kbds[i].buffer[2];
+		kdb_usb_kbds[i].buffer[0] = (char)0;
+		kdb_usb_kbds[i].buffer[2] = (char)0;
+
+		if(kdb_usb_kbds[i].buffer[3]) {
+			kdb_usb_kbds[i].buffer[3] = (char)0;
+			continue;
+		}
+
+		/* A normal key is pressed, decode it */
+		if(keycode)
+			keycode = kdb_usb_keycode[keycode];
+
+		/* 2 Keys pressed at one time ? */
+		if (spec && keycode) {
+			switch(spec)
+			{
+			case 0x2:
+			case 0x20: /* Shift */
+				return shift_map[keycode];
+			case 0x1:
+			case 0x10: /* Ctrl */
+				return ctrl_map[keycode];
+			case 0x4:
+			case 0x40: /* Alt */
+				break;
+			}
+		} else if (keycode) { /* If only one key pressed */
+			switch(keycode)
+			{
+			case 0x1C: /* Enter */
+				return 13;
+
+			case 0x3A: /* Capslock */
+				kdb_usb_kbds[i].caps_lock = !(kdb_usb_kbds[i].caps_lock);
+				break;
+			case 0x0E: /* Backspace */
+				return 8;
+			case 0x0F: /* TAB */
+				return 9;
+			case 0x77: /* Pause */
+				break ;
+			default:
+				if(!kdb_usb_kbds[i].caps_lock) {
+					return plain_map[keycode];
+				}
+				else {
+					return shift_map[keycode];
+				}
+			}
+		}
+	}
+
+	/* no chars were returned from any of the USB keyboards */
+
+	return -1;
+}
+#endif	/* CONFIG_KDB_USB */
+
+/*
+ * This module contains code to read characters from the keyboard or a serial
+ * port.
+ *
+ * It is used by the kernel debugger, and is polled, not interrupt driven.
+ *
+ */
+
+#ifdef	KDB_BLINK_LED
+/*
+ * send:  Send a byte to the keyboard controller.  Used primarily to
+ * 	  alter LED settings.
+ */
+
+static void
+kdb_kbdsend(unsigned char byte)
+{
+	int timeout;
+	for (timeout = 200 * 1000; timeout && (inb(KBD_STATUS_REG) & KBD_STAT_IBF); timeout--);
+	outb(byte, KBD_DATA_REG);
+	udelay(40);
+	for (timeout = 200 * 1000; timeout && (~inb(KBD_STATUS_REG) & KBD_STAT_OBF); timeout--);
+	inb(KBD_DATA_REG);
+	udelay(40);
+}
+
+static void
+kdb_toggleled(int led)
+{
+	static int leds;
+
+	leds ^= led;
+
+	kdb_kbdsend(KBD_CMD_SET_LEDS);
+	kdb_kbdsend((unsigned char)leds);
+}
+#endif	/* KDB_BLINK_LED */
+
+#ifdef	HAVE_KDBA_SERIAL_CONSOLE
+
+struct kdb_serial kdb_serial;
+enum kdba_serial_console kdba_serial_console;
+static int get_serial_char(void);
+
+/* There must be a serial_inp_xxx() and get_serial_char_xxx() for each type
+ * of console.  See enum kdba_serial_console in include/asm-$(ARCH)/kdbprivate.h.
+ */
+
+#ifdef	CONFIG_SERIAL_8250_CONSOLE
+
+static unsigned int
+serial_inp_standard(const struct kdb_serial *kdb_serial, int offset)
+{
+	offset <<= kdb_serial->ioreg_shift;
+
+	switch (kdb_serial->io_type) {
+	case SERIAL_IO_MEM:
+		return readb((void __iomem *)(kdb_serial->iobase + offset));
+		break;
+	default:
+		return inb(kdb_serial->iobase + offset);
+		break;
+	}
+}
+
+/* Check if there is a byte ready at the serial port */
+static int
+get_serial_char_standard(void)
+{
+	unsigned char ch;
+	static unsigned long fifon;
+	if (fifon == 0) {
+		/* try to set the FIFO */
+		fifon = kdb_serial.iobase +
+			(UART_FCR << kdb_serial.ioreg_shift);
+		switch (kdb_serial.io_type) {
+		case SERIAL_IO_MEM:
+			writeb((UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_RCVR |
+				UART_FCR_CLEAR_XMIT), (void __iomem *)fifon);
+			break;
+		default:
+			outb((UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_RCVR |
+				UART_FCR_CLEAR_XMIT), fifon);
+			break;
+		}
+	}
+
+	if (kdb_serial.iobase == 0)
+		return -1;
+
+	if (serial_inp_standard(&kdb_serial, UART_LSR) & UART_LSR_DR) {
+		ch = serial_inp_standard(&kdb_serial, UART_RX);
+		if (ch == 0x7f)
+			ch = 8;
+		return ch;
+	}
+	return -1;
+}
+
+#else	/* !CONFIG_SERIAL_8250_CONSOLE */
+
+#define get_serial_char_standard() -1
+
+#endif	/* CONFIG_SERIAL_8250_CONSOLE */
+
+#ifdef CONFIG_SERIAL_SGI_L1_CONSOLE
+
+extern u64 master_node_bedrock_address;
+
+/* UART registers on the Bedrock start at 0x80 */
+
+extern int l1_serial_in_polled(void);
+extern int l1_control_in_polled(int);
+
+/* Read a byte from the L1 port.  kdb_serial is ignored */
+static unsigned int
+serial_inp_sgi_l1(const struct kdb_serial *kdb_serial, int offset)
+{
+	if (offset & 0x80) {
+		int counter = 10000;
+		unsigned int value;
+		while ( counter-- ) {
+			value = l1_serial_in_polled();
+			/* Gobble up the 0's */
+			if ( value )
+				return(value);
+		}
+		return(0);
+	}
+	else {
+		return l1_control_in_polled(offset);
+	}
+}
+
+/* Check if there is a byte ready at the L1 port. */
+static int
+get_serial_char_sgi_l1(void)
+{
+	unsigned char ch;
+	int status;
+
+	if ((status = serial_inp_sgi_l1(&kdb_serial, UART_LSR)) & UART_LSR_DR) {
+		ch = serial_inp_sgi_l1(&kdb_serial, UART_RX | 0x80);	/* bedrock offset */
+		if (ch == 0x7f)
+			ch = 8;
+		return ch;
+	}
+	return -1;
+}
+
+#else	/* !CONFIG_SERIAL_SGI_L1_CONSOLE */
+
+#define get_serial_char_sgi_l1() -1
+
+#endif	/* CONFIG_SERIAL_SGI_L1_CONSOLE */
+
+/* Select the serial console input at run time, to handle generic kernels */
+
+static int
+get_serial_char(void)
+{
+	switch (kdba_serial_console) {
+	case KDBA_SC_NONE:
+		return -1;
+	case KDBA_SC_STANDARD:
+		return get_serial_char_standard();
+	case KDBA_SC_SGI_L1:
+		return get_serial_char_sgi_l1();
+	}
+	/* gcc is not smart enough to realize that all paths return before here :( */
+	return -1;
+}
+
+#endif /* HAVE_KDBA_SERIAL_CONSOLE */
+
+#ifdef	CONFIG_VT_CONSOLE
+
+static int kbd_exists;
+
+/*
+ * Check if the keyboard controller has a keypress for us.
+ * Some parts (Enter Release, LED change) are still blocking polled here,
+ * but hopefully they are all short.
+ */
+static int get_kbd_char(void)
+{
+	int scancode, scanstatus;
+	static int shift_lock;	/* CAPS LOCK state (0-off, 1-on) */
+	static int shift_key;	/* Shift next keypress */
+	static int ctrl_key;
+	u_short keychar;
+	extern u_short plain_map[], shift_map[], ctrl_map[];
+
+	if (KDB_FLAG(NO_I8042) || KDB_FLAG(NO_VT_CONSOLE) ||
+	    (inb(KBD_STATUS_REG) == 0xff && inb(KBD_DATA_REG) == 0xff)) {
+		kbd_exists = 0;
+		return -1;
+	}
+	kbd_exists = 1;
+
+	if ((inb(KBD_STATUS_REG) & KBD_STAT_OBF) == 0)
+		return -1;
+
+	/*
+	 * Fetch the scancode
+	 */
+	scancode = inb(KBD_DATA_REG);
+	scanstatus = inb(KBD_STATUS_REG);
+
+	/*
+	 * Ignore mouse events.
+	 */
+	if (scanstatus & KBD_STAT_MOUSE_OBF)
+		return -1;
+
+	/*
+	 * Ignore release, trigger on make
+	 * (except for shift keys, where we want to
+	 *  keep the shift state so long as the key is
+	 *  held down).
+	 */
+
+	if (((scancode&0x7f) == 0x2a) || ((scancode&0x7f) == 0x36)) {
+		/*
+		 * Next key may use shift table
+		 */
+		if ((scancode & 0x80) == 0) {
+			shift_key=1;
+		} else {
+			shift_key=0;
+		}
+		return -1;
+	}
+
+	if ((scancode&0x7f) == 0x1d) {
+		/*
+		 * Left ctrl key
+		 */
+		if ((scancode & 0x80) == 0) {
+			ctrl_key = 1;
+		} else {
+			ctrl_key = 0;
+		}
+		return -1;
+	}
+
+	if ((scancode & 0x80) != 0)
+		return -1;
+
+	scancode &= 0x7f;
+
+	/*
+	 * Translate scancode
+	 */
+
+	if (scancode == 0x3a) {
+		/*
+		 * Toggle caps lock
+		 */
+		shift_lock ^= 1;
+
+#ifdef	KDB_BLINK_LED
+		kdb_toggleled(0x4);
+#endif
+		return -1;
+	}
+
+	if (scancode == 0x0e) {
+		/*
+		 * Backspace
+		 */
+		return 8;
+	}
+
+	/* Special Key */
+	switch (scancode) {
+	case 0xF: /* Tab */
+		return 9;
+	case 0x53: /* Del */
+		return 4;
+	case 0x47: /* Home */
+		return 1;
+	case 0x4F: /* End */
+		return 5;
+	case 0x4B: /* Left */
+		return 2;
+	case 0x48: /* Up */
+		return 16;
+	case 0x50: /* Down */
+		return 14;
+	case 0x4D: /* Right */
+		return 6;
+	}
+
+	if (scancode == 0xe0) {
+		return -1;
+	}
+
+	/*
+	 * For Japanese 86/106 keyboards
+	 * 	See comment in drivers/char/pc_keyb.c.
+	 * 	- Masahiro Adegawa
+	 */
+	if (scancode == 0x73) {
+		scancode = 0x59;
+	} else if (scancode == 0x7d) {
+		scancode = 0x7c;
+	}
+
+	if (!shift_lock && !shift_key && !ctrl_key) {
+		keychar = plain_map[scancode];
+	} else if (shift_lock || shift_key) {
+		keychar = shift_map[scancode];
+	} else if (ctrl_key) {
+		keychar = ctrl_map[scancode];
+	} else {
+		keychar = 0x0020;
+		kdb_printf("Unknown state/scancode (%d)\n", scancode);
+	}
+	keychar &= 0x0fff;
+	switch (KTYP(keychar)) {
+	case KT_LETTER:
+	case KT_LATIN:
+		if (isprint(keychar))
+			break;		/* printable characters */
+		/* drop through */
+	case KT_SPEC:
+		if (keychar == K_ENTER)
+			break;
+		/* drop through */
+	default:
+		return(-1);	/* ignore unprintables */
+	}
+
+	if ((scancode & 0x7f) == 0x1c) {
+		/*
+		 * enter key.  All done.  Absorb the release scancode.
+		 */
+		while ((inb(KBD_STATUS_REG) & KBD_STAT_OBF) == 0)
+			;
+
+		/*
+		 * Fetch the scancode
+		 */
+		scancode = inb(KBD_DATA_REG);
+		scanstatus = inb(KBD_STATUS_REG);
+
+		while (scanstatus & KBD_STAT_MOUSE_OBF) {
+			scancode = inb(KBD_DATA_REG);
+			scanstatus = inb(KBD_STATUS_REG);
+		}
+
+		if (scancode != 0x9c) {
+			/*
+			 * Wasn't an enter-release,  why not?
+			 */
+			kdb_printf("kdb: expected enter got 0x%x status 0x%x\n",
+			       scancode, scanstatus);
+		}
+
+		kdb_printf("\n");
+		return 13;
+	}
+
+	return keychar & 0xff;
+}
+#endif	/* CONFIG_VT_CONSOLE */
+
+#ifdef KDB_BLINK_LED
+
+/* Leave numlock alone, setting it messes up laptop keyboards with the keypad
+ * mapped over normal keys.
+ */
+static int kdba_blink_mask = 0x1 | 0x4;
+
+#ifdef CONFIG_SMP
+#define BOGOMIPS (local_cpu_data->loops_per_jiffy/(500000/HZ))
+#else
+#define BOGOMIPS (loops_per_jiffy/(500000/HZ))
+#endif
+static int blink_led(void)
+{
+	static long delay;
+
+	if (kbd_exists == 0)
+		return -1;
+
+	if (--delay < 0) {
+		if (BOGOMIPS == 0)	/* early kdb */
+			delay = 150000000/1000;     /* arbitrary bogomips */
+		else
+			delay = 150000000/BOGOMIPS; /* Roughly 1 second when polling */
+		kdb_toggleled(kdba_blink_mask);
+	}
+	return -1;
+}
+#endif
+
+get_char_func poll_funcs[] = {
+#if defined(CONFIG_VT_CONSOLE)
+	get_kbd_char,
+#endif
+#ifdef	HAVE_KDBA_SERIAL_CONSOLE
+	get_serial_char,
+#endif
+#ifdef KDB_BLINK_LED
+	blink_led,
+#endif
+#ifdef CONFIG_KDB_USB
+	get_usb_char,
+#endif
+	NULL
+};
+
+/* Dummy versions of kdba_local_arch_setup, kdba_local_arch_cleanup.
+ * FIXME: ia64 with legacy keyboard might need the same code as i386.
+ */
+
+void kdba_local_arch_setup(void) {}
+void kdba_local_arch_cleanup(void) {}
--- /dev/null
+++ b/arch/ia64/kdb/kdba_jmp.S
@@ -0,0 +1,394 @@
+/*
+ * Kernel Debugger Architecture Dependent Longjump Support.
+ */
+
+/* setjmp() and longjmp() assembler support for kdb on ia64.
+
+   This code was copied from glibc CVS as of 2001-06-27 and modified where
+   necessary to fit the kernel.  No glibc lines were changed or deleted, all
+   adjustments are wrapped in #ifdef __KERNEL__, except for the added
+   .mem.offset lines, they work in or out of the kenrel.  The original code is
+   in sysdeps/unix/sysv/linux/ia64/{setjmp.S,__longjmp.S}.
+
+   glibc has setjmp (save signals) and _setjmp (do not save signals).  Kernel
+   code does not have signals, only kdba_setjmp_asm() is used.
+
+   Keith Owens <kaos@melbourne.sgi.com> 2001-06-27
+ */
+
+/* Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.
+   Contributed by David Mosberger-Tang <davidm@hpl.hp.com>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If
+   not, write to the Free Software Foundation, Inc.,
+   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+   The layout of the jmp_buf is as follows.  This is subject to change
+   and user-code should never depend on the particular layout of
+   jmp_buf!
+
+
+  	offset:	description:
+	-------	------------
+  	0x000	stack pointer (r12)	; unchangeable (see _JMPBUF_UNWINDS)
+  	0x008	r1 (gp)
+	0x010	caller's unat
+	0x018	fpsr
+  	0x020	r4
+  	0x028	r5
+  	0x030	r6
+  	0x038	r7
+  	0x040	rp (b0)
+  	0x048	b1
+  	0x050	b2
+  	0x058	b3
+  	0x060	b4
+  	0x068	b5
+  	0x070	ar.pfs
+  	0x078	ar.lc
+  	0x080	pr
+  	0x088	ar.bsp			; unchangeable (see __longjmp.S)
+  	0x090	ar.unat
+	0x098	&__jmp_buf	; address of the jmpbuf (needed to locate NaT bits in unat)
+	0x0a0	 f2
+	0x0b0	 f3
+	0x0c0	 f4
+	0x0d0	 f5
+	0x0e0	f16
+  	0x0f0	f17
+  	0x100	f18
+  	0x110	f19
+  	0x120	f20
+  	0x130	f21
+  	0x130	f22
+  	0x140	f23
+  	0x150	f24
+  	0x160	f25
+  	0x170	f26
+  	0x180	f27
+  	0x190	f28
+  	0x1a0	f29
+  	0x1b0	f30
+  	0x1c0	f31 */
+
+#ifndef __KERNEL__
+
+#include <sysdep.h>
+#include <features.h>
+
+	/* The following two entry points are the traditional entry points: */
+
+LEAF(setjmp)
+	alloc r8=ar.pfs,2,0,0,0
+	mov in1=1
+	br.cond.sptk.many __sigsetjmp
+END(setjmp)
+
+LEAF(_setjmp)
+	alloc r8=ar.pfs,2,0,0,0
+	mov in1=0
+	br.cond.sptk.many __sigsetjmp
+END(_setjmp)
+
+	/* __sigsetjmp(__jmp_buf buf, int savemask) */
+
+ENTRY(__sigsetjmp)
+
+#else	/* __KERNEL __ */
+#include <asm/asmmacro.h>
+#define ret br.ret.sptk.few rp
+GLOBAL_ENTRY(kdba_setjmp)
+#endif	/* !__KERNEL__ */
+
+	.prologue ASM_UNW_PRLG_RP|ASM_UNW_PRLG_PFS, ASM_UNW_PRLG_GRSAVE(2)
+	alloc loc1=ar.pfs,2,2,2,0
+	mov r16=ar.unat
+	;;
+	mov r17=ar.fpsr
+	mov r2=in0
+	add r3=8,in0
+	;;
+.mem.offset 0,0;
+	st8.spill.nta [r2]=sp,16	// r12 (sp)
+.mem.offset 8,0;
+	st8.spill.nta [r3]=gp,16	// r1 (gp)
+	;;
+	st8.nta [r2]=r16,16		// save caller's unat
+	st8.nta [r3]=r17,16		// save fpsr
+	add r8=0xa0,in0
+	;;
+.mem.offset 160,0;
+	st8.spill.nta [r2]=r4,16	// r4
+.mem.offset 168,0;
+	st8.spill.nta [r3]=r5,16	// r5
+	add r9=0xb0,in0
+	;;
+	stf.spill.nta [r8]=f2,32
+	stf.spill.nta [r9]=f3,32
+	mov loc0=rp
+	.body
+	;;
+	stf.spill.nta [r8]=f4,32
+	stf.spill.nta [r9]=f5,32
+	mov r17=b1
+	;;
+	stf.spill.nta [r8]=f16,32
+	stf.spill.nta [r9]=f17,32
+	mov r18=b2
+	;;
+	stf.spill.nta [r8]=f18,32
+	stf.spill.nta [r9]=f19,32
+	mov r19=b3
+	;;
+	stf.spill.nta [r8]=f20,32
+	stf.spill.nta [r9]=f21,32
+	mov r20=b4
+	;;
+	stf.spill.nta [r8]=f22,32
+	stf.spill.nta [r9]=f23,32
+	mov r21=b5
+	;;
+	stf.spill.nta [r8]=f24,32
+	stf.spill.nta [r9]=f25,32
+	mov r22=ar.lc
+	;;
+	stf.spill.nta [r8]=f26,32
+	stf.spill.nta [r9]=f27,32
+	mov r24=pr
+	;;
+	stf.spill.nta [r8]=f28,32
+	stf.spill.nta [r9]=f29,32
+	;;
+	stf.spill.nta [r8]=f30
+	stf.spill.nta [r9]=f31
+
+.mem.offset 0,0;
+	st8.spill.nta [r2]=r6,16	// r6
+.mem.offset 8,0;
+	st8.spill.nta [r3]=r7,16	// r7
+	;;
+	mov r23=ar.bsp
+	mov r25=ar.unat
+#ifndef __KERNEL__
+	mov out0=in0
+#endif	/* !__KERNEL__ */
+
+	st8.nta [r2]=loc0,16		// b0
+	st8.nta [r3]=r17,16		// b1
+#ifndef __KERNEL__
+	mov out1=in1
+#endif	/* !__KERNEL__ */
+	;;
+	st8.nta [r2]=r18,16		// b2
+	st8.nta [r3]=r19,16		// b3
+	;;
+	st8.nta [r2]=r20,16		// b4
+	st8.nta [r3]=r21,16		// b5
+	;;
+	st8.nta [r2]=loc1,16		// ar.pfs
+	st8.nta [r3]=r22,16		// ar.lc
+	;;
+	st8.nta [r2]=r24,16		// pr
+	st8.nta [r3]=r23,16		// ar.bsp
+	;;
+	st8.nta [r2]=r25		// ar.unat
+	st8.nta [r3]=in0		// &__jmp_buf
+#ifndef __KERNEL__
+	br.call.dpnt.few rp=__sigjmp_save
+.ret0:					// force a new bundle ::q
+#endif	/* !_KERNEL__ */
+	mov r8=0
+	mov rp=loc0
+	mov ar.pfs=loc1
+	ret
+#ifndef __KERNEL__
+END(__sigsetjmp)
+
+weak_extern(_setjmp)
+weak_extern(setjmp)
+
+#else	/* __KERNEL__ */
+END(kdba_setjmp)
+#endif	/* !_KERNEL__ */
+
+/* Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.
+   Contributed by David Mosberger-Tang <davidm@hpl.hp.com>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If
+   not, write to the Free Software Foundation, Inc.,
+   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+   Note that __sigsetjmp() did NOT flush the register stack.  Instead,
+   we do it here since __longjmp() is usually much less frequently
+   invoked than __sigsetjmp(). The only difficulty is that __sigsetjmp()
+   didn't (and wouldn't be able to) save ar.rnat either.  This is a problem
+   because if we're not careful, we could end up loading random NaT bits.
+   There are two cases:
+
+	(i)  ar.bsp < ia64_rse_rnat_addr(jmpbuf.ar_bsp)
+		ar.rnat contains the desired bits---preserve ar.rnat
+		across loadrs and write to ar.bspstore
+
+	(ii) ar.bsp >= ia64_rse_rnat_addr(jmpbuf.ar_bsp)
+		The desired ar.rnat is stored in
+		ia64_rse_rnat_addr(jmpbuf.ar_bsp).  Load those
+		bits into ar.rnat after setting ar.bspstore. */
+
+#ifndef __KERNEL__
+#include <sysdep.h>
+#include <features.h>
+#endif	/* !__KERNEL__ */
+
+#	define	pPos	p6	/* is rotate count positive? */
+#	define	pNeg	p7	/* is rotate count negative? */
+
+
+	/* __longjmp(__jmp_buf buf, int val) */
+
+#ifndef __KERNEL__
+LEAF(__longjmp)
+#else	/* __KERNEL__ */
+GLOBAL_ENTRY(kdba_longjmp)
+#endif	/* !__KERNEL__ */
+	alloc r8=ar.pfs,2,1,0,0
+	mov r27=ar.rsc
+	add r2=0x98,in0		// r2 <- &jmpbuf.orig_jmp_buf_addr
+	;;
+	ld8 r8=[r2],-16		// r8 <- orig_jmp_buf_addr
+	mov r10=ar.bsp
+	and r11=~0x3,r27	// clear ar.rsc.mode
+	;;
+	flushrs			// flush dirty regs to backing store (must be first in insn grp)
+	ld8 r23=[r2],8		// r23 <- jmpbuf.ar_bsp
+	sub r8=r8,in0		// r8 <- &orig_jmpbuf - &jmpbuf
+	;;
+	ld8 r25=[r2]		// r25 <- jmpbuf.ar_unat
+	extr.u r8=r8,3,6	// r8 <- (&orig_jmpbuf - &jmpbuf)/8 & 0x3f
+	;;
+	cmp.lt pNeg,pPos=r8,r0
+	mov r2=in0
+	;;
+(pPos)	mov r16=r8
+(pNeg)	add r16=64,r8
+(pPos)	sub r17=64,r8
+(pNeg)	sub r17=r0,r8
+	;;
+	mov ar.rsc=r11		// put RSE in enforced lazy mode
+	shr.u r8=r25,r16
+	add r3=8,in0		// r3 <- &jmpbuf.r1
+	shl r9=r25,r17
+	;;
+	or r25=r8,r9
+	;;
+	mov r26=ar.rnat
+	mov ar.unat=r25		// setup ar.unat (NaT bits for r1, r4-r7, and r12)
+	;;
+	ld8.fill.nta sp=[r2],16	// r12 (sp)
+	ld8.fill.nta gp=[r3],16		// r1 (gp)
+	dep r11=-1,r23,3,6	// r11 <- ia64_rse_rnat_addr(jmpbuf.ar_bsp)
+	;;
+	ld8.nta r16=[r2],16		// caller's unat
+	ld8.nta r17=[r3],16		// fpsr
+	;;
+	ld8.fill.nta r4=[r2],16	// r4
+	ld8.fill.nta r5=[r3],16		// r5 (gp)
+	cmp.geu p8,p0=r10,r11	// p8 <- (ar.bsp >= jmpbuf.ar_bsp)
+	;;
+	ld8.fill.nta r6=[r2],16	// r6
+	ld8.fill.nta r7=[r3],16		// r7
+	;;
+	mov ar.unat=r16			// restore caller's unat
+	mov ar.fpsr=r17			// restore fpsr
+	;;
+	ld8.nta r16=[r2],16		// b0
+	ld8.nta r17=[r3],16		// b1
+	;;
+(p8)	ld8 r26=[r11]		// r26 <- *ia64_rse_rnat_addr(jmpbuf.ar_bsp)
+	mov ar.bspstore=r23	// restore ar.bspstore
+	;;
+	ld8.nta r18=[r2],16		// b2
+	ld8.nta r19=[r3],16		// b3
+	;;
+	ld8.nta r20=[r2],16		// b4
+	ld8.nta r21=[r3],16		// b5
+	;;
+	ld8.nta r11=[r2],16		// ar.pfs
+	ld8.nta r22=[r3],56		// ar.lc
+	;;
+	ld8.nta r24=[r2],32		// pr
+	mov b0=r16
+	;;
+	ldf.fill.nta f2=[r2],32
+	ldf.fill.nta f3=[r3],32
+	mov b1=r17
+	;;
+	ldf.fill.nta f4=[r2],32
+	ldf.fill.nta f5=[r3],32
+	mov b2=r18
+	;;
+	ldf.fill.nta f16=[r2],32
+	ldf.fill.nta f17=[r3],32
+	mov b3=r19
+	;;
+	ldf.fill.nta f18=[r2],32
+	ldf.fill.nta f19=[r3],32
+	mov b4=r20
+	;;
+	ldf.fill.nta f20=[r2],32
+	ldf.fill.nta f21=[r3],32
+	mov b5=r21
+	;;
+	ldf.fill.nta f22=[r2],32
+	ldf.fill.nta f23=[r3],32
+	mov ar.lc=r22
+	;;
+	ldf.fill.nta f24=[r2],32
+	ldf.fill.nta f25=[r3],32
+	cmp.eq p8,p9=0,in1
+	;;
+	ldf.fill.nta f26=[r2],32
+	ldf.fill.nta f27=[r3],32
+	mov ar.pfs=r11
+	;;
+	ldf.fill.nta f28=[r2],32
+	ldf.fill.nta f29=[r3],32
+	;;
+	ldf.fill.nta f30=[r2]
+	ldf.fill.nta f31=[r3]
+(p8)	mov r8=1
+
+	mov ar.rnat=r26		// restore ar.rnat
+	;;
+	mov ar.rsc=r27		// restore ar.rsc
+(p9)	mov r8=in1
+
+	invala			// virt. -> phys. regnum mapping may change
+	mov pr=r24,-1
+	ret
+#ifndef __KERNEL__
+END(__longjmp)
+#else	/* __KERNEL__ */
+END(kdba_longjmp)
+#endif	/* !_KERNEL__ */
--- /dev/null
+++ b/arch/ia64/kdb/kdba_pod.c
@@ -0,0 +1,64 @@
+/*
+ * Kernel Debugger Architecture Dependent POD functions.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (c) 1999-2006 Silicon Graphics, Inc.  All Rights Reserved.
+ */
+
+#include <linux/types.h>
+#include <linux/kdb.h>
+#include <linux/kdbprivate.h>
+#include <linux/module.h>
+#include <asm/sal.h>
+#include <asm/sn/sn_sal.h>
+
+MODULE_AUTHOR("Jesse Barnes");
+MODULE_DESCRIPTION("Enter POD through KDB");
+MODULE_LICENSE("GPL");
+
+/**
+ * kdba_pod - enter POD mode from kdb
+ * @argc: arg count
+ * @argv: arg values
+ *
+ * Enter POD mode from kdb using SGI SN specific SAL function call.
+ */
+static int
+kdba_pod(int argc, const char **argv)
+{
+	kdb_printf("WARNING: pod commands are dangerous unless you know exactly\n"
+		   "what you are doing.  If in doubt, type exit immediately.\n");
+	return ia64_sn_pod_mode();
+}
+
+/**
+ * kdba_pod_init - register 'pod' command with kdb
+ *
+ * Register the 'pod' command with kdb at load time.
+ */
+static int __init
+kdba_pod_init(void)
+{
+	if (ia64_platform_is("sn2"))
+		kdb_register("pod", kdba_pod, NULL, "Enter POD", 0);
+
+	return 0;
+}
+
+/**
+ * kdba_pod_exit - unregister the 'pod' command
+ *
+ * Tell kdb that the 'pod' command is no longer available.
+ */
+static void __exit
+kdba_pod_exit(void)
+{
+	if (ia64_platform_is("sn2"))
+		kdb_unregister("pod");
+}
+
+module_init(kdba_pod_init)
+module_exit(kdba_pod_exit)
--- /dev/null
+++ b/arch/ia64/kdb/kdba_support.c
@@ -0,0 +1,1720 @@
+/*
+ * Kernel Debugger Architecture Independent Support Functions
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (c) 1999-2006 Silicon Graphics, Inc.  All Rights Reserved.
+ * Copyright (C) David Mosberger-Tang <davidm@hpl.hp.com>
+ */
+
+#include <linux/string.h>
+#include <linux/stddef.h>
+#include <linux/kernel.h>
+#include <linux/ptrace.h>
+#include <linux/interrupt.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/kdb.h>
+#include <linux/kdbprivate.h>
+#include <linux/module.h>
+#ifdef CONFIG_KDB_KDUMP
+#include <linux/kexec.h>
+#endif
+
+#include <asm/processor.h>
+#include <asm/uaccess.h>
+#include <asm/rse.h>
+#include <asm/delay.h>
+#ifdef CONFIG_SMP
+#include <asm/hw_irq.h>
+#endif
+#include <asm/mca.h>
+
+struct kdb_running_process *kdb_running_process_save; /* [NR_CPUS] */
+static int kdba_show_handlers = 0;
+
+static int
+kdba_itm (int argc, const char **argv)
+{
+	int diag;
+	unsigned long val;
+
+	diag = kdbgetularg(argv[1], &val);
+	if (diag)
+		return diag;
+	kdb_printf("new itm=" kdb_machreg_fmt "\n", val);
+
+	ia64_set_itm(val);
+	return 0;
+}
+
+static void
+kdba_show_intregs(void)
+{
+	u64 lid, tpr, lrr0, lrr1, itv, pmv, cmcv;
+
+	asm ("mov %0=cr.lid" : "=r"(lid));
+	asm ("mov %0=cr.tpr" : "=r"(tpr));
+	asm ("mov %0=cr.lrr0" : "=r"(lrr0));
+	asm ("mov %0=cr.lrr1" : "=r"(lrr1));
+	kdb_printf("lid=" kdb_machreg_fmt ", tpr=" kdb_machreg_fmt ", lrr0=" kdb_machreg_fmt ", llr1=" kdb_machreg_fmt "\n", lid, tpr, lrr0, lrr1);
+
+	asm ("mov %0=cr.itv" : "=r"(itv));
+	asm ("mov %0=cr.pmv" : "=r"(pmv));
+	asm ("mov %0=cr.cmcv" : "=r"(cmcv));
+	kdb_printf("itv=" kdb_machreg_fmt ", pmv=" kdb_machreg_fmt ", cmcv=" kdb_machreg_fmt "\n", itv, pmv, cmcv);
+
+	kdb_printf("irr=0x%016lx,0x%016lx,0x%016lx,0x%016lx\n",
+		ia64_getreg(_IA64_REG_CR_IRR0), ia64_getreg(_IA64_REG_CR_IRR1), ia64_getreg(_IA64_REG_CR_IRR2), ia64_getreg(_IA64_REG_CR_IRR3));
+
+	kdb_printf("itc=0x%016lx, itm=0x%016lx\n", ia64_get_itc(), ia64_get_itm());
+}
+
+static int
+kdba_sir (int argc, const char **argv)
+{
+	kdba_show_intregs();
+
+	return 0;
+}
+
+/*
+ * kdba_pt_regs
+ *
+ *	Format a struct pt_regs
+ *
+ * Inputs:
+ *	argc	argument count
+ *	argv	argument vector
+ * Outputs:
+ *	None.
+ * Returns:
+ *	zero for success, a kdb diagnostic if error
+ * Locking:
+ *	none.
+ * Remarks:
+ *	If no address is supplied, it uses the current irq pt_regs.
+ */
+
+static int
+kdba_pt_regs(int argc, const char **argv)
+{
+	int diag;
+	kdb_machreg_t addr;
+	long offset = 0;
+	int nextarg;
+	struct pt_regs *p;
+
+	if (argc == 0) {
+		addr = (kdb_machreg_t) get_irq_regs();
+	} else if (argc == 1) {
+		nextarg = 1;
+		diag = kdbgetaddrarg(argc, argv, &nextarg, &addr, &offset, NULL);
+		if (diag)
+			return diag;
+	} else {
+		return KDB_ARGCOUNT;
+	}
+
+	p = (struct pt_regs *) addr;
+	kdb_printf("struct pt_regs %p-%p\n", p, (unsigned char *)p + sizeof(*p) - 1);
+	kdb_print_nameval("b6", p->b6);
+	kdb_print_nameval("b7", p->b7);
+	kdb_printf("  ar_csd      0x%lx\n", p->ar_csd);
+	kdb_printf("  ar_ssd      0x%lx\n", p->ar_ssd);
+	kdb_print_nameval("r8", p->r8);
+	kdb_print_nameval("r9", p->r9);
+	kdb_print_nameval("r10", p->r10);
+	kdb_print_nameval("r11", p->r11);
+	kdb_printf("  cr_ipsr     0x%lx\n", p->cr_ipsr);
+	kdb_print_nameval("cr_iip", p->cr_iip);
+	kdb_printf("  cr_ifs      0x%lx\n", p->cr_ifs);
+	kdb_printf("  ar_unat     0x%lx\n", p->ar_unat);
+	kdb_printf("  ar_pfs      0x%lx\n", p->ar_pfs);
+	kdb_printf("  ar_rsc      0x%lx\n", p->ar_rsc);
+	kdb_printf("  ar_rnat     0x%lx\n", p->ar_rnat);
+	kdb_printf("  ar_bspstore 0x%lx\n", p->ar_bspstore);
+	kdb_printf("  pr          0x%lx\n", p->pr);
+	kdb_print_nameval("b0", p->b0);
+	kdb_printf("  loadrs      0x%lx\n", p->loadrs);
+	kdb_print_nameval("r1", p->r1);
+	kdb_print_nameval("r12", p->r12);
+	kdb_print_nameval("r13", p->r13);
+	kdb_printf("  ar_fpsr     0x%lx\n", p->ar_fpsr);
+	kdb_print_nameval("r15", p->r15);
+	kdb_print_nameval("r14", p->r14);
+	kdb_print_nameval("r2", p->r2);
+	kdb_print_nameval("r3", p->r3);
+	kdb_print_nameval("r16", p->r16);
+	kdb_print_nameval("r17", p->r17);
+	kdb_print_nameval("r18", p->r18);
+	kdb_print_nameval("r19", p->r19);
+	kdb_print_nameval("r20", p->r20);
+	kdb_print_nameval("r21", p->r21);
+	kdb_print_nameval("r22", p->r22);
+	kdb_print_nameval("r23", p->r23);
+	kdb_print_nameval("r24", p->r24);
+	kdb_print_nameval("r25", p->r25);
+	kdb_print_nameval("r26", p->r26);
+	kdb_print_nameval("r27", p->r27);
+	kdb_print_nameval("r28", p->r28);
+	kdb_print_nameval("r29", p->r29);
+	kdb_print_nameval("r30", p->r30);
+	kdb_print_nameval("r31", p->r31);
+	kdb_printf("  ar_ccv      0x%lx\n", p->ar_ccv);
+	kdb_printf("  f6          0x%lx 0x%lx\n", p->f6.u.bits[0], p->f6.u.bits[1]);
+	kdb_printf("  f7          0x%lx 0x%lx\n", p->f7.u.bits[0], p->f7.u.bits[1]);
+	kdb_printf("  f8          0x%lx 0x%lx\n", p->f8.u.bits[0], p->f8.u.bits[1]);
+	kdb_printf("  f9          0x%lx 0x%lx\n", p->f9.u.bits[0], p->f9.u.bits[1]);
+	kdb_printf("  f10         0x%lx 0x%lx\n", p->f10.u.bits[0], p->f10.u.bits[1]);
+	kdb_printf("  f11         0x%lx 0x%lx\n", p->f11.u.bits[0], p->f11.u.bits[1]);
+
+	return 0;
+}
+
+/*
+ * kdba_stackdepth
+ *
+ *	Print processes that are using more than a specific percentage of their
+ *	stack.
+ *
+ * Inputs:
+ *	argc	argument count
+ *	argv	argument vector
+ * Outputs:
+ *	None.
+ * Returns:
+ *	zero for success, a kdb diagnostic if error
+ * Locking:
+ *	none.
+ * Remarks:
+ *	If no percentage is supplied, it uses 60.
+ */
+
+static int
+kdba_stackdepth(int argc, const char **argv)
+{
+	int diag, threshold, used;
+	unsigned long percentage;
+	unsigned long esp;
+	long offset = 0;
+	int nextarg;
+	struct task_struct *p, *g;
+	struct switch_stack *sw;
+
+	if (argc == 0) {
+		percentage = 60;
+	} else if (argc == 1) {
+		nextarg = 1;
+		diag = kdbgetaddrarg(argc, argv, &nextarg, &percentage, &offset, NULL);
+		if (diag)
+			return diag;
+	} else {
+		return KDB_ARGCOUNT;
+	}
+	percentage = max_t(int, percentage, 1);
+	percentage = min_t(int, percentage, 100);
+	threshold = ((2 * THREAD_SIZE * percentage) / 100 + 1) >> 1;
+	kdb_printf("stackdepth: processes using more than %ld%% (%d bytes) of stack\n",
+		percentage, threshold);
+	kdb_do_each_thread(g, p) {
+		if (kdb_task_has_cpu(p)) {
+			struct kdb_running_process *krp = kdb_running_process + kdb_process_cpu(p);
+			if (krp->seqno)
+				sw = krp->arch.sw;
+			else
+				sw = NULL;
+		} else
+			sw = (struct switch_stack *) (p->thread.ksp + 16);
+		if (!sw)
+			continue;
+		esp = (unsigned long) sw;
+		used = THREAD_SIZE - (esp - sw->ar_bspstore);
+		if (used >= threshold) {
+			kdb_ps1(p);
+			kdb_printf("  esp %lx bsp %lx used %d\n", esp, sw->ar_bspstore, used);
+		}
+	} kdb_while_each_thread(g, p);
+
+	return 0;
+}
+
+/*
+ * kdb_switch_stack
+ *
+ *	Format a struct switch_stack
+ *
+ * Inputs:
+ *	argc	argument count
+ *	argv	argument vector
+ * Outputs:
+ *	None.
+ * Returns:
+ *	zero for success, a kdb diagnostic if error
+ * Locking:
+ *	none.
+ * Remarks:
+ *	If no address is supplied, it uses kdb_running_process[smp_processor_id()].arch.sw.
+ */
+
+static int
+kdba_switch_stack(int argc, const char **argv)
+{
+	int diag;
+	kdb_machreg_t addr;
+	long offset = 0;
+	int nextarg;
+	struct switch_stack *p;
+
+	if (argc == 0) {
+		addr = (kdb_machreg_t) kdb_running_process[smp_processor_id()].arch.sw;
+	} else if (argc == 1) {
+		nextarg = 1;
+		diag = kdbgetaddrarg(argc, argv, &nextarg, &addr, &offset, NULL);
+		if (diag)
+			return diag;
+	} else {
+		return KDB_ARGCOUNT;
+	}
+
+	p = (struct switch_stack *) addr;
+	kdb_printf("struct switch_stack %p-%p\n", p, (unsigned char *)p + sizeof(*p) - 1);
+	kdb_printf("  caller_unat 0x%lx\n", p->caller_unat);
+	kdb_printf("  ar_fpsr     0x%lx\n", p->ar_fpsr);
+	kdb_printf("  f2          0x%lx 0x%lx\n", p->f2.u.bits[0], p->f2.u.bits[1]);
+	kdb_printf("  f3          0x%lx 0x%lx\n", p->f3.u.bits[0], p->f3.u.bits[1]);
+	kdb_printf("  f4          0x%lx 0x%lx\n", p->f4.u.bits[0], p->f4.u.bits[1]);
+	kdb_printf("  f5          0x%lx 0x%lx\n", p->f5.u.bits[0], p->f5.u.bits[1]);
+	kdb_printf("  f12         0x%lx 0x%lx\n", p->f12.u.bits[0], p->f12.u.bits[1]);
+	kdb_printf("  f13         0x%lx 0x%lx\n", p->f13.u.bits[0], p->f13.u.bits[1]);
+	kdb_printf("  f14         0x%lx 0x%lx\n", p->f14.u.bits[0], p->f14.u.bits[1]);
+	kdb_printf("  f15         0x%lx 0x%lx\n", p->f15.u.bits[0], p->f15.u.bits[1]);
+	kdb_printf("  f16         0x%lx 0x%lx\n", p->f16.u.bits[0], p->f16.u.bits[1]);
+	kdb_printf("  f17         0x%lx 0x%lx\n", p->f17.u.bits[0], p->f17.u.bits[1]);
+	kdb_printf("  f18         0x%lx 0x%lx\n", p->f18.u.bits[0], p->f18.u.bits[1]);
+	kdb_printf("  f19         0x%lx 0x%lx\n", p->f19.u.bits[0], p->f19.u.bits[1]);
+	kdb_printf("  f20         0x%lx 0x%lx\n", p->f20.u.bits[0], p->f20.u.bits[1]);
+	kdb_printf("  f21         0x%lx 0x%lx\n", p->f21.u.bits[0], p->f21.u.bits[1]);
+	kdb_printf("  f22         0x%lx 0x%lx\n", p->f22.u.bits[0], p->f22.u.bits[1]);
+	kdb_printf("  f23         0x%lx 0x%lx\n", p->f23.u.bits[0], p->f23.u.bits[1]);
+	kdb_printf("  f24         0x%lx 0x%lx\n", p->f24.u.bits[0], p->f24.u.bits[1]);
+	kdb_printf("  f25         0x%lx 0x%lx\n", p->f25.u.bits[0], p->f25.u.bits[1]);
+	kdb_printf("  f26         0x%lx 0x%lx\n", p->f26.u.bits[0], p->f26.u.bits[1]);
+	kdb_printf("  f27         0x%lx 0x%lx\n", p->f27.u.bits[0], p->f27.u.bits[1]);
+	kdb_printf("  f28         0x%lx 0x%lx\n", p->f28.u.bits[0], p->f28.u.bits[1]);
+	kdb_printf("  f29         0x%lx 0x%lx\n", p->f29.u.bits[0], p->f29.u.bits[1]);
+	kdb_printf("  f30         0x%lx 0x%lx\n", p->f30.u.bits[0], p->f30.u.bits[1]);
+	kdb_printf("  f31         0x%lx 0x%lx\n", p->f31.u.bits[0], p->f31.u.bits[1]);
+	kdb_print_nameval("r4", p->r4);
+	kdb_print_nameval("r5", p->r5);
+	kdb_print_nameval("r6", p->r6);
+	kdb_print_nameval("r7", p->r7);
+	kdb_print_nameval("b0", p->b0);
+	kdb_print_nameval("b1", p->b1);
+	kdb_print_nameval("b2", p->b2);
+	kdb_print_nameval("b3", p->b3);
+	kdb_print_nameval("b4", p->b4);
+	kdb_print_nameval("b5", p->b5);
+	kdb_printf("  ar_pfs      0x%lx\n", p->ar_pfs);
+	kdb_printf("  ar_lc       0x%lx\n", p->ar_lc);
+	kdb_printf("  ar_unat     0x%lx\n", p->ar_unat);
+	kdb_printf("  ar_rnat     0x%lx\n", p->ar_rnat);
+	kdb_printf("  ar_bspstore 0x%lx\n", p->ar_bspstore);
+	kdb_printf("  pr          0x%lx\n", p->pr);
+
+	return 0;
+}
+
+/*
+ * kdb_minstate
+ *
+ *	Format the PAL minstate area.
+ *
+ * Inputs:
+ *	argc	argument count
+ *	argv	argument vector
+ * Outputs:
+ *	None.
+ * Returns:
+ *	zero for success, a kdb diagnostic if error
+ * Locking:
+ *	none.
+ * Remarks:
+ *	None.
+ */
+
+static int
+kdba_minstate(int argc, const char **argv)
+{
+	int diag;
+	kdb_machreg_t addr;
+	long offset = 0;
+	int nextarg;
+	pal_min_state_area_t *p;
+
+	if (argc == 1) {
+		nextarg = 1;
+		diag = kdbgetaddrarg(argc, argv, &nextarg, &addr, &offset, NULL);
+		if (diag)
+			return diag;
+	} else {
+		return KDB_ARGCOUNT;
+	}
+
+	p = (pal_min_state_area_t *) addr;
+	kdb_printf("PAL minstate %p-%p\n", p, (unsigned char *)p + sizeof(*p) - 1);
+	kdb_printf("  pmsa_nat_bits 0x%lx\n", p->pmsa_nat_bits);
+	kdb_print_nameval("r1", p->pmsa_gr[1-1]);
+	kdb_print_nameval("r2", p->pmsa_gr[2-1]);
+	kdb_print_nameval("r3", p->pmsa_gr[3-1]);
+	kdb_print_nameval("r4", p->pmsa_gr[4-1]);
+	kdb_print_nameval("r5", p->pmsa_gr[5-1]);
+	kdb_print_nameval("r6", p->pmsa_gr[6-1]);
+	kdb_print_nameval("r7", p->pmsa_gr[7-1]);
+	kdb_print_nameval("r8", p->pmsa_gr[8-1]);
+	kdb_print_nameval("r9", p->pmsa_gr[9-1]);
+	kdb_print_nameval("r10", p->pmsa_gr[10-1]);
+	kdb_print_nameval("r11", p->pmsa_gr[11-1]);
+	kdb_print_nameval("r12", p->pmsa_gr[12-1]);
+	kdb_print_nameval("r13", p->pmsa_gr[13-1]);
+	kdb_print_nameval("r14", p->pmsa_gr[14-1]);
+	kdb_print_nameval("r15", p->pmsa_gr[15-1]);
+	kdb_printf("  Bank 0\n");
+	kdb_print_nameval("r16", p->pmsa_bank0_gr[16-16]);
+	kdb_print_nameval("r17", p->pmsa_bank0_gr[17-16]);
+	kdb_print_nameval("r18", p->pmsa_bank0_gr[18-16]);
+	kdb_print_nameval("r19", p->pmsa_bank0_gr[19-16]);
+	kdb_print_nameval("r20", p->pmsa_bank0_gr[20-16]);
+	kdb_print_nameval("r21", p->pmsa_bank0_gr[21-16]);
+	kdb_print_nameval("r22", p->pmsa_bank0_gr[22-16]);
+	kdb_print_nameval("r23", p->pmsa_bank0_gr[23-16]);
+	kdb_print_nameval("r24", p->pmsa_bank0_gr[24-16]);
+	kdb_print_nameval("r25", p->pmsa_bank0_gr[25-16]);
+	kdb_print_nameval("r26", p->pmsa_bank0_gr[26-16]);
+	kdb_print_nameval("r27", p->pmsa_bank0_gr[27-16]);
+	kdb_print_nameval("r28", p->pmsa_bank0_gr[28-16]);
+	kdb_print_nameval("r29", p->pmsa_bank0_gr[29-16]);
+	kdb_print_nameval("r30", p->pmsa_bank0_gr[30-16]);
+	kdb_print_nameval("r31", p->pmsa_bank0_gr[31-16]);
+	kdb_printf("  Bank 1\n");
+	kdb_print_nameval("r16", p->pmsa_bank1_gr[16-16]);
+	kdb_print_nameval("r17", p->pmsa_bank1_gr[17-16]);
+	kdb_print_nameval("r18", p->pmsa_bank1_gr[18-16]);
+	kdb_print_nameval("r19", p->pmsa_bank1_gr[19-16]);
+	kdb_print_nameval("r20", p->pmsa_bank1_gr[20-16]);
+	kdb_print_nameval("r21", p->pmsa_bank1_gr[21-16]);
+	kdb_print_nameval("r22", p->pmsa_bank1_gr[22-16]);
+	kdb_print_nameval("r23", p->pmsa_bank1_gr[23-16]);
+	kdb_print_nameval("r24", p->pmsa_bank1_gr[24-16]);
+	kdb_print_nameval("r25", p->pmsa_bank1_gr[25-16]);
+	kdb_print_nameval("r26", p->pmsa_bank1_gr[26-16]);
+	kdb_print_nameval("r27", p->pmsa_bank1_gr[27-16]);
+	kdb_print_nameval("r28", p->pmsa_bank1_gr[28-16]);
+	kdb_print_nameval("r29", p->pmsa_bank1_gr[29-16]);
+	kdb_print_nameval("r30", p->pmsa_bank1_gr[30-16]);
+	kdb_print_nameval("r31", p->pmsa_bank1_gr[31-16]);
+	kdb_printf("  pr          0x%lx\n", p->pmsa_pr);
+	kdb_print_nameval("b0", p->pmsa_br0);
+	kdb_printf("  ar.rsc      0x%lx\n", p->pmsa_rsc);
+	kdb_print_nameval("cr.iip", p->pmsa_iip);
+	kdb_printf("  cr.ipsr     0x%lx\n", p->pmsa_ipsr);
+	kdb_printf("  cr.ifs      0x%lx\n", p->pmsa_ifs);
+	kdb_print_nameval("cr.xip", p->pmsa_xip);
+	kdb_printf("  cr.xpsr     0x%lx\n", p->pmsa_xpsr);
+	kdb_printf("  cr.xfs      0x%lx\n", p->pmsa_xfs);
+	kdb_print_nameval("b1", p->pmsa_br1);
+
+	return 0;
+}
+
+/*
+ * kdba_cpuinfo
+ *
+ *	Format struct cpuinfo_ia64.
+ *
+ * Inputs:
+ *	argc	argument count
+ *	argv	argument vector
+ * Outputs:
+ *	None.
+ * Returns:
+ *	zero for success, a kdb diagnostic if error
+ * Locking:
+ *	none.
+ * Remarks:
+ *	If no cpu is supplied, it prints cpuinfo for all online cpus.
+ */
+
+static int
+kdba_cpuinfo(int argc, const char **argv)
+{
+	int diag;
+	unsigned long cpunum = -1;
+	long offset = 0;
+	int nextarg, c, i;
+	struct cpuinfo_ia64 *cpuinfo;
+
+	if (argc == 1) {
+		nextarg = 1;
+		diag = kdbgetaddrarg(argc, argv, &nextarg, &cpunum, &offset, NULL);
+		if (diag)
+			return diag;
+		if (cpunum >= NR_CPUS || !cpu_online(cpunum))
+			return KDB_BADCPUNUM;
+	} else if (argc > 1) {
+		return KDB_ARGCOUNT;
+	}
+
+	for (c = (cpunum == -1 ? 0 : cpunum);
+	     c < (cpunum == -1 ? NR_CPUS : cpunum+1);
+	     ++c) {
+		if (!cpu_online(c))
+			continue;
+		cpuinfo = cpu_data(c);
+		kdb_printf("struct cpuinfo_ia64 for cpu %d is at 0x%p\n", c, cpuinfo);
+		kdb_printf("  softirq_pending  0x%x\n",   cpuinfo->softirq_pending);
+		kdb_printf("  itm_delta        %ld\n",    cpuinfo->itm_delta);
+		kdb_printf("  itm_next         %ld\n",    cpuinfo->itm_next);
+		kdb_printf("  nsec_per_cyc     %ld\n",    cpuinfo->nsec_per_cyc);
+		kdb_printf("  unimpl_va_mask   0x%lx\n",  cpuinfo->unimpl_va_mask);
+		kdb_printf("  unimpl_pa_mask   0x%lx\n",  cpuinfo->unimpl_pa_mask);
+		kdb_printf("  itc_freq         %ld\n",    cpuinfo->itc_freq);
+		kdb_printf("  proc_freq        %ld\n",    cpuinfo->proc_freq);
+		kdb_printf("  cyc_per_usec     %ld\n",    cpuinfo->cyc_per_usec);
+		kdb_printf("  cyc_per_usec     %ld\n",    cpuinfo->cyc_per_usec);
+#if 0	/* RJA per-cpu MCA */
+		kdb_printf("  percpu_paddr     0x%lx\n",  cpuinfo->percpu_paddr);
+#endif
+		kdb_printf("  ptce_base        0x%lx\n",  cpuinfo->ptce_base);
+		kdb_printf("  ptce_count       %d %d\n",  cpuinfo->ptce_count[0], cpuinfo->ptce_count[1]);
+		kdb_printf("  ptce_stride      %d %d\n",  cpuinfo->ptce_stride[0], cpuinfo->ptce_stride[1]);
+#if 0	/* RJA per-cpu MCA */
+		kdb_printf("  pal_paddr        0x%lx\n",  cpuinfo->pal_paddr);
+		kdb_printf("  pal_base         0x%lx\n",  cpuinfo->pal_base);
+#endif
+		kdb_printf("  ksoftirqd        0x%p\n",   cpuinfo->ksoftirqd);
+#ifdef CONFIG_SMP
+		kdb_printf("  loops_per_jiffy  %ld\n",    cpuinfo->loops_per_jiffy);
+		kdb_printf("  cpu              %d\n",     cpuinfo->cpu);
+		kdb_printf("  socket_id        %d\n",     cpuinfo->socket_id);
+		kdb_printf("  core_id          %d\n",     cpuinfo->core_id);
+		kdb_printf("  thread_id        %d\n",     cpuinfo->thread_id);
+		kdb_printf("  num_log          %d\n",     cpuinfo->num_log);
+		kdb_printf("  cores_per_socket %d\n",     cpuinfo->cores_per_socket);
+		kdb_printf("  threads_per_core %d\n",     cpuinfo->threads_per_core);
+#endif
+		kdb_printf("  ppn              0x%lx\n",  cpuinfo->ppn);
+		kdb_printf("  features         0x%lx\n",  cpuinfo->features);
+		kdb_printf("  number           %d\n",     cpuinfo->number);
+		kdb_printf("  revision         %d\n",     cpuinfo->revision);
+		kdb_printf("  model            %d\n",     cpuinfo->model);
+		kdb_printf("  family           %d\n",     cpuinfo->family);
+		kdb_printf("  archrev          %d\n",     cpuinfo->archrev);
+		kdb_printf("  vendor          ");
+		for (i = 0; i < sizeof(cpuinfo->vendor); ++i)
+			kdb_printf(" 0x%02x", cpuinfo->vendor[i]);
+		kdb_printf("\n");
+#ifdef CONFIG_NUMA
+		kdb_printf("  node_data        0x%p\n",   cpuinfo->node_data);
+#endif
+#if 0	/* RJA per-cpu MCA */
+		kdb_printf("  ia64_pa_mca_data 0x%p\n",   cpuinfo->ia64_pa_mca_data);
+#endif
+	}
+	return 0;
+}
+
+#ifdef CONFIG_KDB_HARDWARE_BREAKPOINTS
+void
+kdba_installdbreg(kdb_bp_t *bp)
+{
+	unsigned long mask;
+	unsigned int regbase;
+	static unsigned long masks[] = {
+	    0x00FFFFFFFFFFFFFFUL,   // 1 byte long
+	    0x00FFFFFFFFFFFFFEUL,   // 2 bytes long
+	    0x0000000000000000UL,   // invalid
+	    0x00FFFFFFFFFFFFFCUL    // 4 bytes long
+	};
+	static unsigned char modes[] = {
+	    0x81,		    // instruction => x, plm=priv level 0 only
+	    0x41,		    // write => w, plm=priv level 0 only
+	    0x00,		    // io
+	    0x81		    // read => r, plm=priv level 0 only
+	};
+
+	/* Note that bp->bp_hard[NR_CPU] is for x86.
+	 * The ia64 uses bp->bp_hard[0] only.
+	 */
+	if (KDB_DEBUG(BP))
+		kdb_printf("kdba_installdbreg:\n");
+	mask = masks[bp->bp_hard[0]->bph_length] |
+	       (((unsigned long)(modes[bp->bp_hard[0]->bph_mode])) << 56);
+	regbase = 2*bp->bp_hard[0]->bph_reg;
+
+	switch (bp->bp_hard[0]->bph_mode)
+	{
+	case 1:
+	case 3:
+		if (KDB_DEBUG(BP)) {
+			kdb_printf("kdba_installdbreg: dbr[%u]=%016lx\n",
+					regbase, bp->bp_addr);
+			kdb_printf("kdba_installdbreg: dbr[%u]=%016lx\n",
+					regbase+1, mask);
+		}
+
+		ia64_set_dbr(regbase, bp->bp_addr);
+		ia64_set_dbr(regbase+1, mask);
+		ia64_srlz_d();
+		break;
+
+	case 0:	/* instruction */
+#if 0
+		ia64_set_ibr(regbase, bp->bp_addr);
+		ia64_set_ibr(regbase+1, mask);
+		ia64_srlz_d();
+#else
+		kdb_printf("\"instr\" mode not implemented\n");
+#endif
+		break;
+
+	case 2:	/* io */
+		kdb_printf("\"io\" mode not implemented\n");
+		break;
+	}
+}
+
+void
+kdba_removedbreg(kdb_bp_t *bp)
+{
+	unsigned int regbase = 2*bp->bp_hard[0]->bph_reg;
+
+	/* Note that bp->bp_hard[NR_CPU] is for x86.
+	 * The ia64 uses bp->bp_hard[0] only.
+	 */
+	switch (bp->bp_hard[0]->bph_mode)
+	{
+	case 1:
+	case 3:
+		ia64_set_dbr(regbase, 0);
+		ia64_set_dbr(regbase+1, 0);
+		ia64_srlz_d();
+		break;
+
+	case 0:	/* instruction */
+#if 0
+		ia64_set_ibr(regbase, 0);
+		ia64_set_ibr(regbase+1, 0);
+		ia64_srlz_d();
+#else
+		kdb_printf("\"instr\" mode not implemented\n");
+#endif
+		break;
+
+	case 2:	/* io */
+		kdb_printf("\"io\" mode not implemented\n");
+		break;
+	}
+}
+#endif /* CONFIG_KDB_HARDWARE_BREAKPOINTS */
+
+
+static kdb_machreg_t
+kdba_getdr(int regnum)
+{
+	kdb_machreg_t contents = 0;
+	unsigned long reg = (unsigned long)regnum;
+
+	__asm__ ("mov %0=ibr[%1]"::"r"(contents),"r"(reg));
+//        __asm__ ("mov ibr[%0]=%1"::"r"(dbreg_cond),"r"(value));
+
+	return contents;
+}
+
+
+static void
+get_fault_regs(fault_regs_t *fr)
+{
+	fr->ifa = 0 ;
+	fr->isr = 0 ;
+
+	__asm__ ("rsm psr.ic;;") ;
+	ia64_srlz_d();
+	__asm__ ("mov %0=cr.ifa" : "=r"(fr->ifa));
+	__asm__ ("mov %0=cr.isr" : "=r"(fr->isr));
+	__asm__ ("ssm psr.ic;;") ;
+	ia64_srlz_d();
+}
+
+static void
+show_kernel_regs (void)
+{
+	unsigned long kr[8];
+	int i;
+
+	asm ("mov %0=ar.k0" : "=r"(kr[0])); asm ("mov %0=ar.k1" : "=r"(kr[1]));
+	asm ("mov %0=ar.k2" : "=r"(kr[2])); asm ("mov %0=ar.k3" : "=r"(kr[3]));
+	asm ("mov %0=ar.k4" : "=r"(kr[4])); asm ("mov %0=ar.k5" : "=r"(kr[5]));
+	asm ("mov %0=ar.k6" : "=r"(kr[6])); asm ("mov %0=ar.k7" : "=r"(kr[7]));
+
+	for (i = 0; i < 4; ++i)
+		kdb_printf(" kr%d: %016lx  kr%d: %016lx\n", 2*i, kr[2*i], 2*i+1, kr[2*i+1]);
+	kdb_printf("\n");
+}
+
+static int
+change_cur_stack_frame(int regno, unsigned long *contents)
+{
+	unsigned long sof, i, cfm, sp, *bsp, __user *ubsp;
+	struct unw_frame_info info;
+	mm_segment_t old_fs;
+	int cpu = kdb_process_cpu(kdb_current_task);
+	struct kdb_running_process *krp = kdb_running_process + cpu;
+
+	if (kdb_current_task != krp->p) {
+		kdb_printf("Stacked registers are not available for tasks that are not running.\n");
+		kdb_printf("Use bt with a large BTARGS value instead\n");
+		return 0;
+	}
+	unw_init_frame_info(&info, krp->p, krp->arch.sw);
+	do {
+		if (unw_unwind(&info) < 0) {
+			kdb_printf("Failed to unwind\n");
+			return 0;
+		}
+		unw_get_sp(&info, &sp);
+	} while (sp <= (unsigned long) kdb_current_regs);
+	unw_get_bsp(&info, (unsigned long *) &bsp);
+	unw_get_cfm(&info, &cfm);
+
+	if (!bsp) {
+		kdb_printf("Unable to get Current Stack Frame\n");
+		return 0;
+	}
+
+	sof = (cfm & 0x7f);
+
+	if(((unsigned long)regno - 32) >= (sof - 2)) return 1;
+
+	old_fs = set_fs(KERNEL_DS);
+	for (i = 0; i < (regno - 32); ++i)
+		bsp = ia64_rse_skip_regs(bsp, 1);
+	ubsp = (unsigned long __user *) bsp;
+	put_user(*contents, ubsp);
+	set_fs(old_fs);
+
+	return 0 ;
+}
+
+static int
+show_cur_stack_frame(int regno, unsigned long *contents)
+{
+	unsigned long sof, i, cfm, val, sp, *bsp, __user *ubsp;
+	struct unw_frame_info info;
+	mm_segment_t old_fs;
+	int cpu = kdb_process_cpu(kdb_current_task);
+	struct kdb_running_process *krp = kdb_running_process + cpu;
+
+	if (kdb_current_task != krp->p) {
+		kdb_printf("Stacked registers are not available for tasks that are not running.\n");
+		kdb_printf("Use bt with a large BTARGS value instead\n");
+		return 0;
+	}
+	unw_init_frame_info(&info, krp->p, krp->arch.sw);
+	do {
+		if (unw_unwind(&info) < 0) {
+			kdb_printf("Failed to unwind\n");
+			return 0;
+		}
+		unw_get_sp(&info, &sp);
+	} while (sp <= (unsigned long) kdb_current_regs);
+	unw_get_bsp(&info, (unsigned long *) &bsp);
+	unw_get_cfm(&info, &cfm);
+
+	if (!bsp) {
+		kdb_printf("Unable to display Current Stack Frame\n");
+		return 0;
+	}
+
+	sof = (cfm & 0x7f);
+
+	if (regno) {
+		if ((unsigned) regno - 32 >= sof)
+			return 0;
+		bsp = ia64_rse_skip_regs(bsp, regno - 32);
+		old_fs = set_fs(KERNEL_DS);
+		ubsp = (unsigned long __user *) bsp;
+		get_user(val, ubsp);
+		set_fs(old_fs);
+		*contents = val;
+		return 1;
+	}
+
+	old_fs = set_fs(KERNEL_DS);
+	for (i = 0; i < sof; ++i) {
+		ubsp = (unsigned long __user *) bsp;
+		get_user(val, ubsp);
+		kdb_printf(" r%lu: %016lx ", 32 + i, val);
+		if (!((i + 1) % 3))
+			kdb_printf("\n");
+		bsp = ia64_rse_skip_regs(bsp, 1);
+	}
+	kdb_printf("\n");
+	set_fs(old_fs);
+
+	return 0 ;
+}
+
+/*
+ * kdba_getregcontents
+ *
+ *	Return the contents of the register specified by the
+ *	input string argument.   Return an error if the string
+ *	does not match a machine register.
+ *
+ *	The following pseudo register names are supported:
+ *	   &regs	 - Prints address of exception frame
+ *	   kesp		 - Prints kernel stack pointer at time of fault
+ * 	   sstk		 - Prints switch stack for ia64
+ *	   %<regname>	 - Uses the value of the registers at the
+ *			   last time the user process entered kernel
+ *			   mode, instead of the registers at the time
+ *			   kdb was entered.
+ *
+ * Parameters:
+ *	regname		Pointer to string naming register
+ *	regs		Pointer to structure containing registers.
+ * Outputs:
+ *	*contents	Pointer to unsigned long to recieve register contents
+ * Returns:
+ *	0		Success
+ *	KDB_BADREG	Invalid register name
+ * Locking:
+ * 	None.
+ * Remarks:
+ *
+ * 	Note that this function is really machine independent.   The kdb
+ *	register list is not, however.
+ */
+
+static struct kdbregs {
+	char   *reg_name;
+	size_t	reg_offset;
+} kdbreglist[] = {
+	{ "psr",	offsetof(struct pt_regs, cr_ipsr) },
+	{ "ifs",	offsetof(struct pt_regs, cr_ifs) },
+	{ "ip",	offsetof(struct pt_regs, cr_iip) },
+
+	{ "unat", 	offsetof(struct pt_regs, ar_unat) },
+	{ "pfs",	offsetof(struct pt_regs, ar_pfs) },
+	{ "rsc", 	offsetof(struct pt_regs, ar_rsc) },
+
+	{ "rnat",	offsetof(struct pt_regs, ar_rnat) },
+	{ "bsps",	offsetof(struct pt_regs, ar_bspstore) },
+	{ "pr",	offsetof(struct pt_regs, pr) },
+
+	{ "ldrs",	offsetof(struct pt_regs, loadrs) },
+	{ "ccv",	offsetof(struct pt_regs, ar_ccv) },
+	{ "fpsr",	offsetof(struct pt_regs, ar_fpsr) },
+
+	{ "b0",	offsetof(struct pt_regs, b0) },
+	{ "b6",	offsetof(struct pt_regs, b6) },
+	{ "b7",	offsetof(struct pt_regs, b7) },
+
+	{ "r1",offsetof(struct pt_regs, r1) },
+	{ "r2",offsetof(struct pt_regs, r2) },
+	{ "r3",offsetof(struct pt_regs, r3) },
+
+	{ "r8",offsetof(struct pt_regs, r8) },
+	{ "r9",offsetof(struct pt_regs, r9) },
+	{ "r10",offsetof(struct pt_regs, r10) },
+
+	{ "r11",offsetof(struct pt_regs, r11) },
+	{ "r12",offsetof(struct pt_regs, r12) },
+	{ "r13",offsetof(struct pt_regs, r13) },
+
+	{ "r14",offsetof(struct pt_regs, r14) },
+	{ "r15",offsetof(struct pt_regs, r15) },
+	{ "r16",offsetof(struct pt_regs, r16) },
+
+	{ "r17",offsetof(struct pt_regs, r17) },
+	{ "r18",offsetof(struct pt_regs, r18) },
+	{ "r19",offsetof(struct pt_regs, r19) },
+
+	{ "r20",offsetof(struct pt_regs, r20) },
+	{ "r21",offsetof(struct pt_regs, r21) },
+	{ "r22",offsetof(struct pt_regs, r22) },
+
+	{ "r23",offsetof(struct pt_regs, r23) },
+	{ "r24",offsetof(struct pt_regs, r24) },
+	{ "r25",offsetof(struct pt_regs, r25) },
+
+	{ "r26",offsetof(struct pt_regs, r26) },
+	{ "r27",offsetof(struct pt_regs, r27) },
+	{ "r28",offsetof(struct pt_regs, r28) },
+
+	{ "r29",offsetof(struct pt_regs, r29) },
+	{ "r30",offsetof(struct pt_regs, r30) },
+	{ "r31",offsetof(struct pt_regs, r31) },
+
+};
+
+static const int nkdbreglist = sizeof(kdbreglist) / sizeof(struct kdbregs);
+
+int
+kdba_getregcontents(const char *regname, struct pt_regs *regs, unsigned long *contents)
+{
+	int i;
+
+	if (strcmp(regname, "isr") == 0) {
+		fault_regs_t fr ;
+		get_fault_regs(&fr) ;
+		*contents = fr.isr ;
+		return 0 ;
+	}
+
+	if (!regs) {
+		kdb_printf("%s: pt_regs not available, use bt* or pid to select a different task\n", __FUNCTION__);
+		return KDB_BADREG;
+	}
+
+	if (strcmp(regname, "&regs") == 0) {
+		*contents = (unsigned long)regs;
+		return 0;
+	}
+
+	if (strcmp(regname, "sstk") == 0) {
+		*contents = (unsigned long)getprsregs(regs) ;
+		return 0;
+	}
+
+	if (strcmp(regname, "ksp") == 0) {
+		*contents = (unsigned long) (regs + 1);
+		return 0;
+	}
+
+	for (i=0; i<nkdbreglist; i++) {
+		if (strstr(kdbreglist[i].reg_name, regname))
+			break;
+	}
+
+	if (i == nkdbreglist) {
+		/* Lets check the rse maybe */
+		if (regname[0] == 'r')
+			if (show_cur_stack_frame(simple_strtoul(regname+1, NULL, 0), contents))
+				return 0 ;
+		return KDB_BADREG;
+	}
+
+	*contents = *(unsigned long *)((unsigned long)regs +
+			kdbreglist[i].reg_offset);
+
+	return 0;
+}
+
+/*
+ * kdba_setregcontents
+ *
+ *	Set the contents of the register specified by the
+ *	input string argument.   Return an error if the string
+ *	does not match a machine register.
+ *
+ *	Supports modification of user-mode registers via
+ *	%<register-name>
+ *
+ * Parameters:
+ *	regname		Pointer to string naming register
+ *	regs		Pointer to structure containing registers.
+ *	contents	Unsigned long containing new register contents
+ * Outputs:
+ * Returns:
+ *	0		Success
+ *	KDB_BADREG	Invalid register name
+ * Locking:
+ * 	None.
+ * Remarks:
+ */
+
+int
+kdba_setregcontents(const char *regname,
+		  struct pt_regs *regs,
+		  unsigned long contents)
+{
+	int i, ret = 0, fixed = 0;
+	char *endp;
+	unsigned long regno;
+
+	if (regname[0] == '%') {
+		regname++;
+		regs = (struct pt_regs *)
+			(kdb_current_task->thread.ksp - sizeof(struct pt_regs));
+	}
+
+	if (!regs) {
+		kdb_printf("%s: pt_regs not available, use bt* or pid to select a different task\n", __FUNCTION__);
+		return KDB_BADREG;
+	}
+
+	/* fixed registers */
+	for (i=0; i<nkdbreglist; i++) {
+		if (strnicmp(kdbreglist[i].reg_name,
+			     regname,
+			     strlen(regname)) == 0) {
+			fixed = 1;
+			break;
+		}
+	}
+
+	/* stacked registers */
+	if (!fixed) {
+		regno = (simple_strtoul(&regname[1], &endp, 10));
+		if ((regname[0] == 'r') && regno > (unsigned long)31) {
+			ret = change_cur_stack_frame(regno, &contents);
+			if(!ret) return 0;
+		}
+	}
+
+	if ((i == nkdbreglist)
+	    || (strlen(kdbreglist[i].reg_name) != strlen(regname))
+	    || ret) {
+		return KDB_BADREG;
+	}
+
+	/* just in case of "standard" register */
+	*(unsigned long *)((unsigned long)regs + kdbreglist[i].reg_offset) =
+		contents;
+
+	return 0;
+}
+
+/*
+ * kdba_dumpregs
+ *
+ *	Dump the specified register set to the display.
+ *
+ * Parameters:
+ *	regs		Pointer to structure containing registers.
+ *	type		Character string identifying register set to dump
+ *	extra		string further identifying register (optional)
+ * Outputs:
+ * Returns:
+ *	0		Success
+ * Locking:
+ * 	None.
+ * Remarks:
+ *	This function will dump the general register set if the type
+ *	argument is NULL (struct pt_regs).   The alternate register
+ *	set types supported by this function:
+ *
+ *	d 		Debug registers
+ *	c		Control registers
+ *	u		User registers at most recent entry to kernel
+ *	i		Interrupt registers -- same as "irr" command
+ * Following not yet implemented:
+ *	m		Model Specific Registers (extra defines register #)
+ *	r		Memory Type Range Registers (extra defines register)
+ *
+ *	For now, all registers are covered as follows:
+ *
+ * 	rd 		- dumps all regs
+ *	rd	%isr	- current interrupt status reg, read freshly
+ *	rd	s	- valid stacked regs
+ * 	rd 	%sstk	- gets switch stack addr. dump memory and search
+ *	rd	d	- debug regs, may not be too useful
+ *	rd	k	- dump kernel regs
+ *
+ *	ARs		TB Done
+ *	OTHERS		TB Decided ??
+ *
+ *	Intel wish list
+ *	These will be implemented later - Srinivasa
+ *
+ *      type        action
+ *      ----        ------
+ *      g           dump all General static registers
+ *      s           dump all general Stacked registers
+ *      f           dump all Floating Point registers
+ *      p           dump all Predicate registers
+ *      b           dump all Branch registers
+ *      a           dump all Application registers
+ *      c           dump all Control registers
+ *
+ */
+
+int
+kdba_dumpregs(struct pt_regs *regs,
+	    const char *type,
+	    const char *extra)
+
+{
+	int i;
+	int count = 0;
+
+	if (type
+	 && (type[0] == 'u')) {
+		type = NULL;
+		regs = (struct pt_regs *)
+			(kdb_current_task->thread.ksp - sizeof(struct pt_regs));
+	}
+
+	if (type == NULL) {
+		if (!regs) {
+			kdb_printf("%s: pt_regs not available, use bt* or pid to select a different task\n", __FUNCTION__);
+			return KDB_BADREG;
+		}
+		for (i=0; i<nkdbreglist; i++) {
+			kdb_printf("%4s: 0x%16.16lx  ",
+				   kdbreglist[i].reg_name,
+				   *(unsigned long *)((unsigned long)regs +
+						  kdbreglist[i].reg_offset));
+
+			if ((++count % 3) == 0)
+				kdb_printf("\n");
+		}
+
+		kdb_printf("&regs = %p\n", (void *)regs);
+
+		return 0;
+	}
+
+	switch (type[0]) {
+	case 'd':
+	{
+		for(i=0; i<8; i+=2) {
+			kdb_printf("idr%d: 0x%16.16lx  idr%d: 0x%16.16lx\n", i,
+					kdba_getdr(i), i+1, kdba_getdr(i+1));
+
+		}
+		return 0;
+	}
+	case 'i':
+		kdba_show_intregs();
+		break;
+	case 'k':
+		show_kernel_regs();
+		break;
+	case 'm':
+		break;
+	case 'r':
+		break;
+
+	case 's':
+	{
+		if (!regs) {
+			kdb_printf("%s: pt_regs not available, use bt* or pid to select a different task\n", __FUNCTION__);
+			return KDB_BADREG;
+		}
+		show_cur_stack_frame(0, NULL) ;
+
+		return 0 ;
+	}
+
+	case '%':
+	{
+		unsigned long contents ;
+
+		if (!kdba_getregcontents(type+1, regs, &contents))
+			kdb_printf("%s = 0x%16.16lx\n", type+1, contents) ;
+		else
+			kdb_printf("diag: Invalid register %s\n", type+1) ;
+
+		return 0 ;
+	}
+
+	default:
+		return KDB_BADREG;
+	}
+
+	/* NOTREACHED */
+	return 0;
+}
+EXPORT_SYMBOL(kdba_dumpregs);
+
+kdb_machreg_t
+kdba_getpc(struct pt_regs *regs)
+{
+	return regs ? regs->cr_iip + ia64_psr(regs)->ri : 0;
+}
+
+int
+kdba_setpc(struct pt_regs *regs, kdb_machreg_t newpc)
+{
+	if (KDB_NULL_REGS(regs))
+		return KDB_BADREG;
+	regs->cr_iip = newpc & ~0xf;
+	ia64_psr(regs)->ri = newpc & 0x3;
+	KDB_STATE_SET(IP_ADJUSTED);
+	return 0;
+}
+
+struct kdba_main_loop_data {
+	kdb_reason_t reason;
+	kdb_reason_t reason2;
+	int error;
+	kdb_dbtrap_t db_result;
+	struct pt_regs *regs;
+	int ret;
+};
+
+/*
+ * do_kdba_main_loop
+ *
+ *	Invoked from kdba_main_loop via unw_init_running() after that routine
+ *	has pushed a struct switch_stack.
+ *
+ * Inputs:
+ *	info	Unwind information.
+ *	data	kdb data passed as void * to unw_init_running.
+ * Returns:
+ *	none (unw_init_running requires void).  vdata->ret is set to
+ *	0	KDB was invoked for an event which it wasn't responsible
+ *	1	KDB handled the event for which it was invoked.
+ * Outputs:
+ *	none
+ * Locking:
+ *	None.
+ * Remarks:
+ *	unw_init_running() creates struct switch_stack then struct
+ *	unw_frame_info.  We get the address of the info so step over
+ *	that to get switch_stack.  Just hope that unw_init_running
+ *	does not change its stack usage.  unw_init_running adds padding
+ *	to put switch_stack on a 16 byte boundary.
+ */
+
+static void
+do_kdba_main_loop(struct unw_frame_info *info, void *vdata)
+{
+	struct kdba_main_loop_data *data = vdata;
+	struct switch_stack *sw, *prev_sw;
+	struct pt_regs *prev_regs;
+	struct kdb_running_process *krp =
+		kdb_running_process + smp_processor_id();
+	KDB_DEBUG_STATE(__FUNCTION__, data->reason);
+	prev_sw = krp->arch.sw;
+	sw = (struct switch_stack *)(info+1);
+	/* padding from unw_init_running */
+	sw = (struct switch_stack *)(((unsigned long)sw + 15) & ~15);
+	krp->arch.sw = sw;
+	prev_regs = krp->regs;
+	data->ret = kdb_save_running(data->regs, data->reason, data->reason2,
+			data->error, data->db_result);
+	kdb_unsave_running(data->regs);
+	krp->regs = prev_regs;
+	krp->arch.sw = prev_sw;
+}
+
+/*
+ * kdba_main_loop
+ *
+ *	Do any architecture specific set up before entering the main kdb loop.
+ *	The primary function of this routine is to make all processes look the
+ *	same to kdb, kdb must be able to list a process without worrying if the
+ *	process is running or blocked, so make all processes look as though they
+ *	are blocked.
+ *
+ * Inputs:
+ *	reason		The reason KDB was invoked
+ *	error		The hardware-defined error code
+ *	error2		kdb's current reason code.  Initially error but can change
+ *			acording to kdb state.
+ *	db_result	Result from break or debug point.
+ *	regs		The exception frame at time of fault/breakpoint.  If reason
+ *			is SILENT or CPU_UP then regs is NULL, otherwise it should
+ *			always be valid.
+ * Returns:
+ *	0	KDB was invoked for an event which it wasn't responsible
+ *	1	KDB handled the event for which it was invoked.
+ * Outputs:
+ *	Builds a switch_stack structure before calling the main loop.
+ * Locking:
+ *	None.
+ * Remarks:
+ *	none.
+ */
+
+int
+kdba_main_loop(kdb_reason_t reason, kdb_reason_t reason2, int error,
+	       kdb_dbtrap_t db_result, struct pt_regs *regs)
+{
+	struct kdba_main_loop_data data;
+	KDB_DEBUG_STATE("kdba_main_loop", reason);
+	data.reason = reason;
+	data.reason2 = reason2;
+	data.error = error;
+	data.db_result = db_result;
+	data.regs = regs;
+	unw_init_running(do_kdba_main_loop, &data);
+	return(data.ret);
+}
+
+void
+kdba_disableint(kdb_intstate_t *state)
+{
+	unsigned long *fp = (unsigned long *)state;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	*fp = flags;
+}
+
+void
+kdba_restoreint(kdb_intstate_t *state)
+{
+	unsigned long flags = *(unsigned long *)state;
+	local_irq_restore(flags);
+}
+
+void
+kdba_setsinglestep(struct pt_regs *regs)
+{
+	if (KDB_NULL_REGS(regs))
+		return;
+	ia64_psr(regs)->ss = 1;
+}
+
+void
+kdba_clearsinglestep(struct pt_regs *regs)
+{
+	if (KDB_NULL_REGS(regs))
+		return;
+	ia64_psr(regs)->ss = 0;
+}
+
+/*
+ * kdb_tpa
+ *
+ * 	Virtual to Physical address translation command.
+ *
+ *	tpa  <addr>
+ *
+ * Parameters:
+ *	argc	Count of arguments in argv
+ *	argv	Space delimited command line arguments
+ * Outputs:
+ *	None.
+ * Returns:
+ *	Zero for success, a kdb diagnostic if failure.
+ * Locking:
+ *	None.
+ * Remarks:
+ */
+#define __xtpa(x)		({ia64_va _v; asm("tpa %0=%1" : "=r"(_v.l) : "r"(x)); _v.l;})
+static int
+kdba_tpa(int argc, const char **argv)
+{
+	kdb_machreg_t addr;
+	int diag;
+	long offset = 0;
+	int nextarg;
+	char c;
+
+	nextarg = 1;
+	if (argc != 1)
+		return KDB_ARGCOUNT;
+	diag = kdbgetaddrarg(argc, argv, &nextarg, &addr, &offset, NULL);
+	if (diag)
+		return diag;
+	if (kdb_getarea(c, addr))
+		return(0);
+	kdb_printf("vaddr: 0x%lx , paddr: 0x%lx\n", addr, __xtpa(addr));
+	return(0);
+}
+#if defined(CONFIG_NUMA)
+static int
+kdba_tpav(int argc, const char **argv)
+{
+	kdb_machreg_t addr, end, paddr;
+	int diag;
+	long offset = 0;
+	int nextarg, nid, nid_old;
+	char c;
+
+	nextarg = 1;
+	if (argc != 2)
+		return KDB_ARGCOUNT;
+	diag = kdbgetaddrarg(argc, argv, &nextarg, &addr, &offset, NULL);
+	if (diag)
+		return diag;
+	diag = kdbgetaddrarg(argc, argv, &nextarg, &end, &offset, NULL);
+	if (diag)
+		return diag;
+	if (kdb_getarea(c, addr))
+		return(0);
+	if (kdb_getarea(c, end))
+		return(0);
+	paddr=__xtpa(addr);
+	nid = paddr_to_nid(paddr);
+	kdb_printf("begin: 0x%lx , paddr: 0x%lx , nid: %d\n", addr, __xtpa(addr), nid);
+	for(;addr<end; addr += PAGE_SIZE) {
+		nid_old=nid;
+		paddr =__xtpa(addr);
+		nid = paddr_to_nid(paddr);
+		if (nid != nid_old)
+			kdb_printf("NOT on same NODE: addr: 0x%lx , paddr: 0x%lx , nid: %d\n", addr, paddr, nid);
+	}
+	paddr=__xtpa(end);
+	nid=paddr_to_nid(end);
+	kdb_printf("end: 0x%lx , paddr: 0x%lx , nid: %d\n", end, paddr, nid);
+	return(0);
+}
+#endif
+
+#if defined(CONFIG_SMP)
+/*
+ * kdba_sendinit
+ *
+ *      This function implements the 'init' command.
+ *
+ *      init    [<cpunum>]
+ *
+ * Inputs:
+ *      argc    argument count
+ *      argv    argument vector
+ * Outputs:
+ *      None.
+ * Returns:
+ *      zero for success, a kdb diagnostic if error
+ * Locking:
+ *      none.
+ * Remarks:
+ */
+
+static int
+kdba_sendinit(int argc, const char **argv)
+{
+	unsigned long cpunum;
+	int diag;
+
+	if (argc != 1)
+		return KDB_ARGCOUNT;
+
+	diag = kdbgetularg(argv[1], &cpunum);
+	if (diag)
+		return diag;
+
+	if (cpunum >= NR_CPUS || !cpu_online(cpunum))
+		return KDB_BADCPUNUM;
+
+	platform_send_ipi(cpunum, 0, IA64_IPI_DM_INIT, 0);
+	return 0;
+}
+
+/* Invoked once from kdb_wait_for_cpus when waiting for cpus.  For those cpus
+ * that have not responded to the normal KDB interrupt yet, hit them with an
+ * INIT event.
+ */
+void
+kdba_wait_for_cpus(void)
+{
+	int c;
+	if (KDB_FLAG(CATASTROPHIC))
+		return;
+	kdb_printf("  Sending INIT to cpus that have not responded yet\n");
+	for_each_online_cpu(c)
+		if (kdb_running_process[c].seqno < kdb_seqno - 1)
+			platform_send_ipi(c, 0, IA64_IPI_DM_INIT, 0);
+}
+
+#endif /* CONFIG_SMP */
+
+/* This code is sensitive to the layout of the MCA/INIT stack (see mca_asm.h)
+ * and to the stack layout that ia64_mca_modify_original_stack() creates when
+ * it makes the original task look blocked.
+ */
+static void
+kdba_handlers_modify(struct task_struct *task, int cpu)
+{
+	struct kdb_running_process *work, *save;
+	work = kdb_running_process + cpu;
+	save = kdb_running_process_save + cpu;
+	*work = *save;
+	if (!kdba_show_handlers && REGION_NUMBER(task) >= RGN_GATE &&
+	    (task_thread_info(task)->flags & _TIF_MCA_INIT)) {
+		struct ia64_sal_os_state *sos = (struct ia64_sal_os_state *)
+			((unsigned long)save->p + MCA_SOS_OFFSET);
+		char *p;
+		if (!sos->prev_task)
+			return;
+		work->p = sos->prev_task;
+		p = (char *)sos->prev_task->thread.ksp;
+		p += 16;
+		work->arch.sw = (struct switch_stack *)p;
+		p += sizeof(struct switch_stack);
+		work->regs = (struct pt_regs *)p;
+		work->irq_depth = 2;	/* any value >1 will do */
+	}
+}
+
+/* Turn the display of the MCA/INIT handlers on or off, or display the status
+ * of the MCA/INIT handlers.
+ */
+static int
+kdba_handlers(int argc, const char **argv)
+{
+	int cpu;
+	struct kdb_running_process *krp;
+	if (argc != 1)
+		return KDB_ARGCOUNT;
+	if (strcmp(argv[1], "show") == 0)
+		kdba_show_handlers = 1;
+	else if (strcmp(argv[1], "hide") == 0)
+		kdba_show_handlers = 0;
+	else if (strcmp(argv[1], "status") != 0) {
+		kdb_printf("handlers <show|hide|status>\n");
+		return 0;
+	}
+	for (cpu = 0, krp = kdb_running_process_save; cpu < NR_CPUS; ++cpu, ++krp) {
+		if (krp->p)
+			kdba_handlers_modify(krp->p, cpu);
+	}
+	if (strcmp(argv[1], "status") != 0)
+		return 0;
+	kdb_printf("handlers status is %s\n", kdba_show_handlers ? "'show'" : "'hide'");
+	kdb_printf(" cpu handler task       command            original task      command\n");
+	for (cpu = 0, krp = kdb_running_process_save; cpu < NR_CPUS; ++cpu, ++krp) {
+		struct task_struct *p = krp->p;
+		if (!p)
+			continue;
+		kdb_printf("%4d", cpu);
+		if (task_thread_info(p)->flags & _TIF_MCA_INIT) {
+			struct ia64_sal_os_state *sos;
+			kdb_printf(" " kdb_machreg_fmt0 " %-*s  ",
+				   (unsigned long)p, (int)sizeof(p->comm), p->comm);
+			sos = (struct ia64_sal_os_state *)((unsigned long)p + MCA_SOS_OFFSET);
+			p = sos->prev_task;
+		} else
+			kdb_printf("%*s", (int)(1+2+16+1+sizeof(p->comm)+2), " ");
+		if (p)
+			kdb_printf(" " kdb_machreg_fmt0 " %-*s",
+				   (unsigned long)p, (int)sizeof(p->comm), p->comm);
+		kdb_printf("\n");
+	}
+	return 0;
+}
+
+/* Executed once on each cpu at startup. */
+void
+kdba_cpu_up(void)
+{
+}
+
+/*
+ * kdba_init
+ *
+ * 	Architecture specific initialization.
+ *
+ * Parameters:
+ *	None.
+ * Returns:
+ *	None.
+ * Locking:
+ *	None.
+ * Remarks:
+ *	None.
+ */
+
+void
+kdba_init(void)
+{
+	kdb_running_process_save = kzalloc(
+		sizeof(*kdb_running_process_save) * NR_CPUS, GFP_KERNEL);
+	BUG_ON(!kdb_running_process_save);
+	kdb_register("irr", kdba_sir, "", "Show interrupt registers", 0);
+	kdb_register("itm", kdba_itm, "", "Set new ITM value", 0);
+#if defined(CONFIG_SMP)
+	kdb_register("init", kdba_sendinit, "", "Send INIT to cpu", 0);
+#endif
+	kdb_register("pt_regs", kdba_pt_regs, "address", "Format struct pt_regs", 0);
+	kdb_register("switch_stack", kdba_switch_stack, "address", "Format struct switch_stack", 0);
+	kdb_register("minstate", kdba_minstate, "address", "Format PAL minstate", 0);
+	kdb_register("tpa", kdba_tpa, "<vaddr>", "Translate virtual to physical address", 0);
+#if defined(CONFIG_NUMA)
+	kdb_register("tpav", kdba_tpav, "<begin addr> <end addr>", "Verify that physical addresses corresponding to virtual addresses from <begin addr> to <end addr> are in same node", 0);
+#endif
+	kdb_register("stackdepth", kdba_stackdepth, "[percentage]", "Print processes using >= stack percentage", 0);
+	kdb_register("cpuinfo", kdba_cpuinfo, "[cpu]", "Print struct cpuinfo_ia64", 0);
+	kdb_register("handlers", kdba_handlers, "<show|hide|status>", "Control the display of MCA/INIT handlers", 0);
+
+#ifdef CONFIG_SERIAL_8250_CONSOLE
+	kdba_serial_console = KDBA_SC_STANDARD;
+#endif
+#ifdef CONFIG_SERIAL_SGI_L1_CONSOLE
+	if (ia64_platform_is("sn2"))
+		kdba_serial_console = KDBA_SC_SGI_L1;
+#endif
+	return;
+}
+
+/*
+ * kdba_adjust_ip
+ *
+ * 	Architecture specific adjustment of instruction pointer before leaving
+ *	kdb.
+ *
+ * Parameters:
+ *	reason		The reason KDB was invoked
+ *	error		The hardware-defined error code
+ *	regs		The exception frame at time of fault/breakpoint.  If reason
+ *			is SILENT or CPU_UP then regs is NULL, otherwise it should
+ *			always be valid.
+ * Returns:
+ *	None.
+ * Locking:
+ *	None.
+ * Remarks:
+ *	On IA64, KDB_ENTER() and KDB_ENTER_SLAVE() use break which is a fault,
+ *	not a trap.  The instruction pointer must be stepped before leaving
+ *	kdb, otherwise we get a loop.
+ */
+
+void
+kdba_adjust_ip(kdb_reason_t reason, int error, struct pt_regs *regs)
+{
+	if ((reason == KDB_REASON_ENTER || reason == KDB_REASON_ENTER_SLAVE) &&
+	    !KDB_STATE(IP_ADJUSTED)) {
+		if (KDB_NULL_REGS(regs))
+			return;
+		if (ia64_psr(regs)->ri < 2)
+			kdba_setpc(regs, regs->cr_iip + ia64_psr(regs)->ri + 1);
+		else
+			kdba_setpc(regs, regs->cr_iip + 16);
+	}
+}
+
+void
+kdba_save_running(struct kdba_running_process *k, struct pt_regs *regs)
+{
+	struct kdb_running_process *work, *save;
+	int cpu = smp_processor_id();
+	work = kdb_running_process + cpu;
+	save = kdb_running_process_save + cpu;
+	*save = *work;
+	if (!regs)
+		return;
+	kdba_handlers_modify((struct task_struct *)regs->r13, cpu);
+}
+
+void
+kdba_unsave_running(struct kdba_running_process *k, struct pt_regs *regs)
+{
+	memset(kdb_running_process_save + smp_processor_id(), 0,
+			sizeof(*kdb_running_process_save));
+}
+
+void
+kdba_set_current_task(const struct task_struct *p)
+{
+	int cpu = kdb_process_cpu(p);
+	struct kdb_running_process *work, *save;
+	work = kdb_running_process + cpu;
+	save = kdb_running_process_save + cpu;
+	kdb_current_task = p;
+	if (kdb_task_has_cpu(p)) {
+		kdb_current_regs = work->regs;
+		return;
+	}
+	kdb_current_regs = NULL;
+	/* For most blocked tasks we cannot get the pt_regs without doing an
+	 * unwind, which is not worth doing.  For tasks interrupted by
+	 * MCA/INIT, when the user is not working on the handlers, we must use
+	 * the registers at the time of interrupt.
+	 */
+	if (work->p == save->p || work->p != p)
+		return;
+	kdb_current_regs = (struct pt_regs *)(work->p->thread.ksp + 16 +
+		sizeof(struct switch_stack));
+}
+
+/*
+ * asm-ia64 uaccess.h supplies __copy_to_user which relies on MMU to
+ * trap invalid addresses in the _xxx fields.  Verify the other address
+ * of the pair is valid by accessing the first and last byte ourselves,
+ * then any access violations should only be caused by the _xxx
+ * addresses,
+ */
+
+int
+kdba_putarea_size(unsigned long to_xxx, void *from, size_t size)
+{
+	mm_segment_t oldfs = get_fs();
+	int r;
+	char c;
+	c = *((volatile char *)from);
+	c = *((volatile char *)from + size - 1);
+
+	if (to_xxx >> 61 <= 4) {
+		return kdb_putuserarea_size(to_xxx, from, size);
+	}
+
+	set_fs(KERNEL_DS);
+	r = __copy_to_user_inatomic((void __user *)to_xxx, from, size);
+	set_fs(oldfs);
+	return r;
+}
+
+int
+kdba_getarea_size(void *to, unsigned long from_xxx, size_t size)
+{
+	mm_segment_t oldfs = get_fs();
+	int r;
+	*((volatile char *)to) = '\0';
+	*((volatile char *)to + size - 1) = '\0';
+
+	if (from_xxx >> 61 <= 4)
+		return kdb_getuserarea_size(to, from_xxx, size);
+
+	set_fs(KERNEL_DS);
+	switch (size) {
+	case 1:
+		r = __copy_to_user_inatomic((void __user *)to, (void *)from_xxx, 1);
+		break;
+	case 2:
+		r = __copy_to_user_inatomic((void __user *)to, (void *)from_xxx, 2);
+		break;
+	case 4:
+		r = __copy_to_user_inatomic((void __user *)to, (void *)from_xxx, 4);
+		break;
+	case 8:
+		r = __copy_to_user_inatomic((void __user *)to, (void *)from_xxx, 8);
+		break;
+	default:
+		r = __copy_to_user_inatomic((void __user *)to, (void *)from_xxx, size);
+		break;
+	}
+	set_fs(oldfs);
+	return r;
+}
+
+int
+kdba_verify_rw(unsigned long addr, size_t size)
+{
+	unsigned char data[(__force size_t) size];
+	return(kdba_getarea_size(data, addr, size) || kdba_putarea_size(addr, data, size));
+}
+
+#ifdef CONFIG_KDB_KDUMP
+void
+kdba_kdump_prepare(struct pt_regs *fixed_regs)
+{
+	int i;
+
+	/* Set on KEXEC bit on all onlinr cpus */
+	for (i = 1; i < NR_CPUS; ++i) {
+		if (!cpu_online(i))
+			continue;
+
+		KDB_STATE_SET_CPU(KEXEC, i);
+	}
+
+	machine_crash_shutdown(fixed_regs);
+}
+
+void kdba_kdump_shutdown_slave(struct pt_regs *regs)
+{
+	if (kdb_kdump_state != KDB_KDUMP_RESET) {
+		unw_init_running(kdump_cpu_freeze, NULL);
+	}
+}
+#endif
--- a/arch/ia64/kernel/head.S
+++ b/arch/ia64/kernel/head.S
@@ -259,8 +259,13 @@ start_ap:
 	/*
 	 * Switch into virtual mode:
 	 */
+#ifdef CONFIG_KDB_HARDWARE_BREAKPOINTS
+#define IA64_PSR_KDB_FLAGS IA64_PSR_DB
+#else
+#define IA64_PSR_KDB_FLAGS 0
+#endif
 	movl r16=(IA64_PSR_IT|IA64_PSR_IC|IA64_PSR_DT|IA64_PSR_RT|IA64_PSR_DFH|IA64_PSR_BN \
-		  |IA64_PSR_DI)
+		  |IA64_PSR_DI|IA64_PSR_KDB_FLAGS)
 	;;
 	mov cr.ipsr=r16
 	movl r17=1f
--- a/arch/ia64/kernel/mca.c
+++ b/arch/ia64/kernel/mca.c
@@ -88,6 +88,10 @@
 #include <linux/cpumask.h>
 #include <linux/kdebug.h>
 #include <linux/cpu.h>
+#ifdef CONFIG_KDB
+#include <linux/kdb.h>
+#include <linux/kdbprivate.h>  /* for switch state wrappers */
+#endif /* CONFIG_KDB */
 
 #include <asm/delay.h>
 #include <asm/machvec.h>
@@ -824,6 +828,14 @@ ia64_mca_rendez_int_handler(int rendez_i
 	 */
 	ia64_sal_mc_rendez();
 
+#ifdef CONFIG_KDB
+	/* We get here when the MCA monarch has entered and has woken up the
+	 * slaves.  Do a KDB rendezvous to meet the monarch cpu.
+	 */
+	if (monarch_cpu != -1)
+		KDB_ENTER_SLAVE();
+#endif
+
 	NOTIFY_MCA(DIE_MCA_RENDZVOUS_PROCESS, get_irq_regs(), (long)&nd, 1);
 
 	/* Wait for the monarch cpu to exit. */
@@ -1361,6 +1373,19 @@ ia64_mca_handler(struct pt_regs *regs, s
 		mca_insert_tr(0x2); /*Reload dynamic itrs*/
 	}
 
+#ifdef	CONFIG_KDB
+	kdb_save_flags();
+	KDB_FLAG_CLEAR(CATASTROPHIC);
+	KDB_FLAG_CLEAR(RECOVERY);
+	if (recover)
+		KDB_FLAG_SET(RECOVERY);
+	else
+		KDB_FLAG_SET(CATASTROPHIC);
+	KDB_FLAG_SET(NOIPI);		/* do not send IPI for MCA/INIT events */
+	KDB_ENTER();
+	kdb_restore_flags();
+#endif	/* CONFIG_KDB */
+
 	NOTIFY_MCA(DIE_MCA_MONARCH_LEAVE, regs, (long)&nd, 1);
 
 	if (atomic_dec_return(&mca_count) > 0) {
@@ -1373,6 +1398,12 @@ ia64_mca_handler(struct pt_regs *regs, s
 			if (cpu_isset(i, mca_cpu)) {
 				monarch_cpu = i;
 				cpu_clear(i, mca_cpu);	/* wake next cpu */
+#ifdef CONFIG_KDB
+				/*
+				 * No longer a monarch, report in as a slave.
+				 */
+				KDB_ENTER_SLAVE();
+#endif
 				while (monarch_cpu != -1)
 					cpu_relax();	/* spin until last cpu leaves */
 				set_curr_task(cpu, previous_current);
@@ -1382,6 +1413,7 @@ ia64_mca_handler(struct pt_regs *regs, s
 			}
 		}
 	}
+
 	set_curr_task(cpu, previous_current);
 	ia64_mc_info.imi_rendez_checkin[cpu] = IA64_MCA_RENDEZ_CHECKIN_NOTDONE;
 	monarch_cpu = -1;	/* This frees the slaves and previous monarchs */
@@ -1642,6 +1674,11 @@ default_monarch_init_process(struct noti
 		}
 	}
 	printk("\n\n");
+#ifdef	CONFIG_KDB
+	KDB_FLAG_SET(NOIPI);		/* do not send IPI for MCA/INIT events */
+	KDB_ENTER();
+	KDB_FLAG_CLEAR(NOIPI);
+#else	/* !CONFIG_KDB */
 	if (read_trylock(&tasklist_lock)) {
 		do_each_thread (g, t) {
 			printk("\nBacktrace of pid %d (%s)\n", t->pid, t->comm);
@@ -1649,6 +1686,7 @@ default_monarch_init_process(struct noti
 		} while_each_thread (g, t);
 		read_unlock(&tasklist_lock);
 	}
+#endif	/* CONFIG_KDB */
 	/* FIXME: This will not restore zapped printk locks. */
 	RESTORE_LOGLEVEL(console_loglevel);
 	return NOTIFY_DONE;
@@ -1681,6 +1719,20 @@ ia64_init_handler(struct pt_regs *regs,
 	int cpu = smp_processor_id();
 	struct ia64_mca_notify_die nd =
 		{ .sos = sos, .monarch_cpu = &monarch_cpu };
+#ifdef	CONFIG_KDB
+	int kdba_recalcitrant = 0;
+	/* kdba_wait_for_cpus() sends INIT to recalcitrant cpus which ends up
+	 * calling this routine.  If KDB is waiting for the IPI to be processed
+	 * then treat all INIT events as slaves, kdb_initial_cpu is the
+	 * monarch.
+	 */
+	if (KDB_STATE(WAIT_IPI)) {
+		monarch_cpu = kdb_initial_cpu;
+		sos->monarch = 0;
+		KDB_STATE_CLEAR(WAIT_IPI);
+		kdba_recalcitrant = 1;
+	}
+#endif	/* CONFIG_KDB */
 
 	NOTIFY_INIT(DIE_INIT_ENTER, regs, (long)&nd, 0);
 
@@ -1719,6 +1771,11 @@ ia64_init_handler(struct pt_regs *regs,
 		ia64_mc_info.imi_rendez_checkin[cpu] = IA64_MCA_RENDEZ_CHECKIN_INIT;
 		while (monarch_cpu == -1)
 		       cpu_relax();	/* spin until monarch enters */
+#ifdef CONFIG_KDB
+		KDB_ENTER_SLAVE();
+		if (kdba_recalcitrant)
+			monarch_cpu = -1;
+#endif /* CONFIG_KDB */
 
 		NOTIFY_INIT(DIE_INIT_SLAVE_ENTER, regs, (long)&nd, 1);
 		NOTIFY_INIT(DIE_INIT_SLAVE_PROCESS, regs, (long)&nd, 1);
@@ -1747,6 +1804,14 @@ ia64_init_handler(struct pt_regs *regs,
 	mprintk("Delaying for 5 seconds...\n");
 	udelay(5*1000000);
 	ia64_wait_for_slaves(cpu, "INIT");
+
+#ifdef	CONFIG_KDB
+	kdb_save_flags();
+	KDB_FLAG_SET(NOIPI);		/* do not send IPI for MCA/INIT events */
+	KDB_ENTER();
+	kdb_restore_flags();
+#endif	/* CONFIG_KDB */
+
 	/* If nobody intercepts DIE_INIT_MONARCH_PROCESS then we drop through
 	 * to default_monarch_init_process() above and just print all the
 	 * tasks.
@@ -1985,6 +2050,13 @@ ia64_mca_init(void)
 			printk(KERN_INFO "Increasing MCA rendezvous timeout from "
 				"%ld to %ld milliseconds\n", timeout, isrv.v0);
 			timeout = isrv.v0;
+#ifdef CONFIG_KDB
+			/* kdb must wait long enough for the MCA timeout to trip
+			 * and process.  The MCA timeout is in milliseconds.
+			 */
+			kdb_wait_for_cpus_secs = max(kdb_wait_for_cpus_secs,
+						(int)(timeout/1000) + 10);
+#endif /* CONFIG_KDB */
 			NOTIFY_MCA(DIE_MCA_NEW_TIMEOUT, NULL, timeout, 0);
 			continue;
 		}
--- a/arch/ia64/kernel/smp.c
+++ b/arch/ia64/kernel/smp.c
@@ -36,6 +36,11 @@
 #include <asm/current.h>
 #include <asm/delay.h>
 #include <asm/machvec.h>
+
+#ifdef	CONFIG_KDB
+#include <linux/kdb.h>
+#endif	/* CONFIG_KDB */
+
 #include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/page.h>
@@ -64,6 +69,9 @@ static DEFINE_PER_CPU(unsigned short, sh
 #define IPI_CPU_STOP		1
 #define IPI_CALL_FUNC_SINGLE	2
 #define IPI_KDUMP_CPU_STOP	3
+#ifdef CONFIG_KDB
+#define IPI_KDB_INTERRUPT	4
+#endif /* CONFIG_KDB */
 
 /* This needs to be cacheline aligned because it is written to by *other* CPUs.  */
 static DEFINE_PER_CPU_SHARED_ALIGNED(u64, ipi_operation);
@@ -124,6 +132,12 @@ handle_IPI (int irq, void *dev_id)
 				unw_init_running(kdump_cpu_freeze, NULL);
 				break;
 #endif
+#ifdef CONFIG_KDB
+			case IPI_KDB_INTERRUPT:
+				if (!kdb_ipi(get_irq_regs(), NULL))
+					printk(KERN_ERR "kdb_ipi() rejected IPI_KDB_INTERRUPT\n");
+				break;
+#endif
 			default:
 				printk(KERN_CRIT "Unknown IPI on CPU %d: %lu\n",
 						this_cpu, which);
@@ -332,3 +346,12 @@ setup_profiling_timer (unsigned int mult
 {
 	return -EINVAL;
 }
+
+#if defined(CONFIG_KDB)
+void
+smp_kdb_stop(void)
+{
+	if (!KDB_FLAG(NOIPI))
+		send_IPI_allbutself(IPI_KDB_INTERRUPT);
+}
+#endif	/* CONFIG_KDB */
--- a/arch/ia64/kernel/traps.c
+++ b/arch/ia64/kernel/traps.c
@@ -13,6 +13,9 @@
 #include <linux/tty.h>
 #include <linux/vt_kern.h>		/* For unblank_screen() */
 #include <linux/module.h>       /* for EXPORT_SYMBOL */
+#ifdef	CONFIG_KDB
+#include <linux/kdb.h>
+#endif	/* CONFIG_KDB */
 #include <linux/hardirq.h>
 #include <linux/kprobes.h>
 #include <linux/delay.h>		/* for ssleep() */
@@ -78,6 +81,10 @@ die (const char *str, struct pt_regs *re
 	if (!regs)
 		return 1;
 
+#ifdef	CONFIG_KDB
+	(void)kdb(KDB_REASON_OOPS, err, regs);
+#endif	/* CONFIG_KDB */
+
 	if (panic_on_oops)
 		panic("Fatal exception");
 
@@ -171,6 +178,17 @@ __kprobes ia64_bad_break (unsigned long
 		if (break_num < 0x80000) {
 			sig = SIGILL; code = __ILL_BREAK;
 		} else {
+#ifdef	CONFIG_KDB
+			if (break_num == KDB_BREAK_ENTER &&
+			    kdb(KDB_REASON_ENTER, break_num, regs))
+				return;		/* kdb handled it */
+			if (break_num == KDB_BREAK_ENTER_SLAVE &&
+			    kdb(KDB_REASON_ENTER_SLAVE, break_num, regs))
+				return;		/* kdb handled it */
+			if (break_num == KDB_BREAK_BREAK &&
+			    kdb(KDB_REASON_BREAK, break_num, regs))
+				return;		/* kdb handled it */
+#endif	/* CONFIG_KDB */
 			if (notify_die(DIE_BREAK, "bad break", regs, break_num, TRAP_BRKPT, SIGTRAP)
 					== NOTIFY_STOP)
 				return;
@@ -565,6 +583,10 @@ ia64_fault (unsigned long vector, unsign
 		if (notify_die(DIE_FAULT, "ia64_fault", &regs, vector, siginfo.si_code, SIGTRAP)
 			       	== NOTIFY_STOP)
 			return;
+#ifdef	CONFIG_KDB
+		if (!user_mode(&regs) && kdb(KDB_REASON_DEBUG, vector, &regs))
+			return; /* kdb handled this */
+#endif	/* CONFIG_KDB */
 		siginfo.si_signo = SIGTRAP;
 		siginfo.si_errno = 0;
 		siginfo.si_addr  = (void __user *) ifa;
--- a/arch/ia64/kernel/unwind.c
+++ b/arch/ia64/kernel/unwind.c
@@ -57,14 +57,27 @@
 
 #ifdef UNW_DEBUG
   static unsigned int unw_debug_level = UNW_DEBUG;
-#  define UNW_DEBUG_ON(n)	unw_debug_level >= n
-   /* Do not code a printk level, not all debug lines end in newline */
-#  define UNW_DPRINT(n, ...)  if (UNW_DEBUG_ON(n)) printk(__VA_ARGS__)
+#  ifdef CONFIG_KDB
+#    include <linux/kdb.h>
+#    include <linux/kdbprivate.h>
+#    define UNW_KMALLOC(s, f)	debug_kmalloc(s, f)
+#    define UNW_KFREE(p)	debug_kfree(p)
+#    define UNW_DEBUG_ON(n)	(unw_debug_level >= n && !KDB_IS_RUNNING())
+#    define UNW_DPRINT(n, ...)	if (UNW_DEBUG_ON(n)) kdb_printf(__VA_ARGS__)
+#  else	/* !CONFIG_KDB */
+#    define UNW_DEBUG_ON(n)	unw_debug_level >= n
+     /* Do not code a printk level, not all debug lines end in newline */
+#    define UNW_DPRINT(n, ...)  if (UNW_DEBUG_ON(n)) printk(__VA_ARGS__)
+#    define UNW_KMALLOC(s, f)	kmalloc(s, f)
+#    define UNW_KFREE(p)	kfree(p)
+#  endif /* CONFIG_KDB */
 #  undef inline
 #  define inline
 #else /* !UNW_DEBUG */
 #  define UNW_DEBUG_ON(n)  0
 #  define UNW_DPRINT(n, ...)
+#  define UNW_KMALLOC(s, f)	kmalloc(s, f)
+#  define UNW_KFREE(p)		kfree(p)
 #endif /* UNW_DEBUG */
 
 #if UNW_STATS
@@ -73,10 +86,10 @@
 # define STAT(x...)
 #endif
 
-#define alloc_reg_state()	kmalloc(sizeof(struct unw_reg_state), GFP_ATOMIC)
-#define free_reg_state(usr)	kfree(usr)
-#define alloc_labeled_state()	kmalloc(sizeof(struct unw_labeled_state), GFP_ATOMIC)
-#define free_labeled_state(usr)	kfree(usr)
+#define alloc_reg_state()	UNW_KMALLOC(sizeof(struct unw_reg_state), GFP_ATOMIC)
+#define free_reg_state(usr)	UNW_KFREE(usr)
+#define alloc_labeled_state()	UNW_KMALLOC(sizeof(struct unw_labeled_state), GFP_ATOMIC)
+#define free_labeled_state(usr)	UNW_KFREE(usr)
 
 typedef unsigned long unw_word;
 typedef unsigned char unw_hash_index_t;
@@ -2092,7 +2105,7 @@ unw_add_unwind_table (const char *name,
 		return NULL;
 	}
 
-	table = kmalloc(sizeof(*table), GFP_USER);
+	table = UNW_KMALLOC(sizeof(*table), GFP_USER);
 	if (!table)
 		return NULL;
 
@@ -2165,7 +2178,7 @@ unw_remove_unwind_table (void *handle)
 		write_unlock(&tmp->lock);
 	}
 
-	kfree(table);
+	UNW_KFREE(table);
 }
 
 static int __init
@@ -2199,7 +2212,7 @@ create_gate_table (void)
 		size += 3*8 + 8 + 8*UNW_LENGTH(*(u64 *) (segbase + entry->info_offset));
 	size += 8;	/* reserve space for "end of table" marker */
 
-	unw.gate_table = kmalloc(size, GFP_KERNEL);
+	unw.gate_table = UNW_KMALLOC(size, GFP_KERNEL);
 	if (!unw.gate_table) {
 		unw.gate_table_size = 0;
 		printk(KERN_ERR "%s: unable to create unwind data for gate page!\n", __func__);
