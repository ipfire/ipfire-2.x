From 9297af3ffd8a1c98f35fb7a273386576e061ff16 Mon Sep 17 00:00:00 2001
From: Greg Kroah-Hartman <gregkh@suse.de>
Date: Thu, 27 Mar 2008 10:40:48 -0700
Subject: novfs: Add the Novell filesystem client kernel module
Patch-mainline: not yet, being worked on.

This adds the Novell filesystem client kernel module.

Things to do before it can be submitted:
	- coding style cleanups
		- remove typedefs
		- function name lowercase
		- 80 chars wide
	- sparse cleanups
		- __user markings
		- endian markings
	- remove functions that are never called and structures never used
		- yeah, there are a lot of them...
	- remove wrapper functions
		- private kmalloc/free?
	- resolve FIXME markings that have been added to the code
		- wrong types passed to functions!!!
	- userspace interface revisit
		- uses /proc/novfs, not nice.
		- might need userspace tools rework

Cc: Lonnie Iverson <ldiverson@novell.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 fs/Kconfig          |    9 
 fs/Makefile         |    1 
 fs/novfs/Makefile   |   19 
 fs/novfs/commands.h | 1087 ++++++++++
 fs/novfs/daemon.c   | 2400 ++++++++++++++++++++++
 fs/novfs/file.c     | 1964 ++++++++++++++++++
 fs/novfs/inode.c    | 5563 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 fs/novfs/nwcapi.c   | 2537 +++++++++++++++++++++++
 fs/novfs/nwcapi.h   | 2213 ++++++++++++++++++++
 fs/novfs/nwerror.h  |  658 ++++++
 fs/novfs/proc.c     |  152 +
 fs/novfs/profile.c  |  687 ++++++
 fs/novfs/scope.c    |  675 ++++++
 fs/novfs/vfs.h      |  436 ++++
 14 files changed, 18401 insertions(+)

--- a/fs/Kconfig
+++ b/fs/Kconfig
@@ -2123,6 +2123,15 @@ config 9P_FS
 
 	  If unsure, say N.
 
+config NOVFS
+	tristate "Novell Netware Filesystem support (novfs) (EXPERIMENTAL)"
+	depends on INET && EXPERIMENTAL
+	help
+	  If you say Y here, you will get an experimental Novell Netware
+	  filesystem driver.
+
+	  If unsure, say N.
+
 endif # NETWORK_FILESYSTEMS
 
 if BLOCK
--- a/fs/Makefile
+++ b/fs/Makefile
@@ -125,3 +125,4 @@ obj-$(CONFIG_HPPFS)		+= hppfs/
 obj-$(CONFIG_DEBUG_FS)		+= debugfs/
 obj-$(CONFIG_OCFS2_FS)		+= ocfs2/
 obj-$(CONFIG_GFS2_FS)           += gfs2/
+obj-$(CONFIG_NOVFS)		+= novfs/
--- /dev/null
+++ b/fs/novfs/Makefile
@@ -0,0 +1,19 @@
+#
+# Makefile for the Novell NetWare Client for Linux filesystem.
+#
+
+NOVFS_VFS_MAJOR = 2
+NOVFS_VFS_MINOR = 0
+NOVFS_VFS_SUB = 0
+NOVFS_VFS_RELEASE = 440
+
+EXTRA_CFLAGS += -DNOVFS_VFS_MAJOR=$(NOVFS_VFS_MAJOR)
+EXTRA_CFLAGS += -DNOVFS_VFS_MINOR=$(NOVFS_VFS_MINOR)
+EXTRA_CFLAGS += -DNOVFS_VFS_SUB=$(NOVFS_VFS_SUB)
+EXTRA_CFLAGS += -DNOVFS_VFS_PATCH=$(NOVFS_VFS_PATCH)
+EXTRA_CFLAGS += -DNOVFS_VFS_RELEASE=$(NOVFS_VFS_RELEASE)
+
+obj-$(CONFIG_NOVFS) += novfs.o
+
+novfs-objs := inode.o proc.o profile.o daemon.o file.o scope.o nwcapi.o
+
--- /dev/null
+++ b/fs/novfs/commands.h
@@ -0,0 +1,1087 @@
+/*
+ * NetWare Redirector for Linux
+ * Author: James Turner/Richard Williams
+ *
+ * This file contains all defined commands.
+ *
+ * Copyright (C) 2005 Novell, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+
+#ifndef __NOVFS_COMMANDS_H
+#define __NOVFS_COMMANDS_H
+
+#define VFS_COMMAND_GET_CONNECTED_SERVER_LIST   0
+#define VFS_COMMAND_GET_SERVER_VOLUME_LIST      1
+#define VFS_COMMAND_VERIFY_FILE                 2
+#define VFS_COMMAND_OPEN_CONNECTION_BY_ADDR     3
+#define VFS_COMMAND_LOGIN_IDENTITY              4
+#define VFS_COMMAND_ENUMERATE_DIRECTORY         5
+#define VFS_COMMAND_OPEN_FILE                   6
+#define VFS_COMMAND_CREATE_FILE                 7
+#define VFS_COMMAND_CLOSE_FILE                  8
+#define VFS_COMMAND_READ_FILE                   9
+#define VFS_COMMAND_WRITE_FILE                  10
+#define VFS_COMMAND_DELETE_FILE                 11
+#define VFS_COMMAND_CREATE_DIRECOTRY            12
+#define VFS_COMMAND_START_ENUMERATE             13
+#define VFS_COMMAND_END_ENUMERATE               14
+#define VFS_COMMAND_LOGIN_USER                  15
+#define VFS_COMMAND_LOGOUT_USER                 16
+#define VFS_COMMAND_CREATE_CONTEXT              17
+#define VFS_COMMAND_DESTROY_CONTEXT             18
+#define VFS_COMMAND_SET_FILE_INFO               19
+#define VFS_COMMAND_TRUNCATE_FILE               20
+#define VFS_COMMAND_OPEN_CONNECTION_BY_NAME     21
+#define VFS_COMMAND_XPLAT_CALL                  22
+#define VFS_COMMAND_RENAME_FILE                 23
+#define VFS_COMMAND_ENUMERATE_DIRECTORY_EX      24
+#define VFS_COMMAND_GETPWUD                     25
+#define VFS_COMMAND_ENUM_XCONN                  26
+#define VFS_COMMAND_READ_STREAM                 27
+#define VFS_COMMAND_WRITE_STREAM                28
+#define VFS_COMMAND_CLOSE_STREAM                29
+#define VFS_COMMAND_GET_VERSION                 30
+#define VFS_COMMAND_SET_MOUNT_PATH              31
+#define VFS_COMMAND_GET_USER_SPACE              32
+#define VFS_COMMAND_DBG                         33
+#define VFS_COMMAND_GET_CACHE_FLAG              34
+#define VFS_COMMAND_GET_EXTENDED_ATTRIBUTE		35
+#define VFS_COMMAND_LIST_EXTENDED_ATTRIBUTES	36
+#define VFS_COMMAND_SET_EXTENDED_ATTRIBUTE		37
+#define VFS_COMMAND_SET_FILE_LOCK				38
+
+#define  NWD_ACCESS_QUERY                        0x00000001
+#define  NWD_ACCESS_READ                         0x00000002
+#define  NWD_ACCESS_WRITE                        0x00000004
+#define  NWD_ACCESS_EXECUTE                      0x00000008
+#define  NWD_ACCESS_VALID                        0x0000000F
+
+/*
+   Share Mode
+
+   A value of zero in a shared mode field specifies the caller
+   desires exclusive access to the object.
+*/
+
+#define  NWD_SHARE_READ                          0x00000001
+#define  NWD_SHARE_WRITE                         0x00000002
+#define  NWD_SHARE_DELETE                        0x00000004
+#define  NWD_SHARE_VALID                         0x00000007
+
+/*
+   Creates a new file.  The create API will fail if the specified
+   file already exists.
+*/
+#define  NWD_DISP_CREATE_NEW                     0x00000001
+
+/*
+   Creates a new file.  If the specified file already exists,
+   the create API will overwrite the old file and clear the
+   existing attributes.
+*/
+#define  NWD_DISP_CREATE_ALWAYS                  0x00000002
+
+/*
+   Opens the file.  The API will fail if the file does not exist.
+*/
+#define  NWD_DISP_OPEN_EXISTING                  0x00000003
+
+/*
+   Opens the file.  If the file does not exist, the API will
+   create the file.
+*/
+#define  NWD_DISP_OPEN_ALWAYS                    0x00000004
+
+/*
+   Opens the file.  When the file is opened the API will truncate
+   the stream to zero bytes.  The API will fail if the file
+   does not exist.
+*/
+#define  NWD_DISP_TRUNCATE_EXISTING              0x00000005
+#define  NWD_DISP_MAXIMUM                        0x00000005
+
+/*
+   Open/Create returned information values
+
+   The bottom two bytes of NWD_ACTION are returned
+   as a value.  All values are mutually exclusive.
+*/
+
+#define  NWD_ACTION_OPENED                       0x00000001
+#define  NWD_ACTION_CREATED                      0x00000002
+
+#define  MAX_IO_SIZE							(1024 * 32)
+
+#define  MAX_XATTR_NAME_LEN			255
+#define	 MAX_PATH_LENGTH			255
+#define  ENOATTR				ENODATA
+/*===[ Type definitions ]=================================================*/
+
+/*===[ Function prototypes ]==============================================*/
+
+#pragma pack(push, 1)
+
+#ifndef NWHANDLE
+typedef void *NWHANDLE;
+#endif
+
+/*typedef struct _ncl_string
+{
+	unsigned int  	type;
+	unsigned char 	*buffer;
+	unsigned int	len;
+
+} NclString, *PNclString;
+*/
+typedef struct _ncl_string {
+	unsigned int type;
+	unsigned char *buffer;
+	u32 len;
+
+} NclString, *PNclString;
+
+typedef struct _nwd_string {
+	unsigned int type;
+	unsigned int len;
+	unsigned int boffset;
+
+} NwdString, *PNwdString;
+
+typedef struct _COMMAND_REQUEST_HEADER {
+	unsigned int CommandType;
+	unsigned long SequenceNumber;
+	struct schandle SessionId;
+} COMMAND_REQUEST_HEADER, *PCOMMAND_REQUEST_HEADER;
+
+typedef struct _COMMAND_REPLY_HEADER {
+	unsigned long Sequence_Number;
+	unsigned int ErrorCode;
+
+} COMMAND_REPLY_HEADER, *PCOMMAND_REPLY_HEADER;
+
+typedef struct _CLOSE_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+	NWHANDLE FileHandle;
+} CLOSE_REQUEST, *PCLOSE_REQUEST;
+
+typedef struct _CLOSE_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+} CLOSE_REPLY, *PCLOSE_REPLY;
+
+typedef struct _DELETE_FILE_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+	unsigned int isDirectory;
+	unsigned int pathlength;
+	unsigned char path[1];
+} DELETE_FILE_REQUEST, *PDELETE_FILE_REQUEST;
+
+typedef struct _DELETE_FILE_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+} DELETE_FILE_REPLY, *PDELETE_FILE_REPLY;
+
+typedef struct _FLUSH_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+	NWHANDLE FileHandle;
+} FLUSH_REQUEST, *PFLUSH_REQUEST;
+
+typedef struct _FLUSH_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+} FLUSH_REPLY, *PFLUSH_REPLY;
+
+typedef struct _GET_FILEINFO_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+	NWHANDLE FileHandle;
+} GET_FILEINFO_REQUEST, *PGET_FILEINFO_REQUEST;
+
+typedef struct _GET_FILEINFO_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+} GET_FILEINFO_REPLY, *PGET_FILEINFO_REPLY;
+
+typedef struct _GET_CONNECTED_SERVER_LIST_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+} GET_CONNECTED_SERVER_LIST_REQUEST, *PGET_CONNECTED_SERVER_LIST_REQUEST;
+
+typedef struct _GET_CONNECTED_SERVER_LIST_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+	unsigned char List[1];
+} GET_CONNECTED_SERVER_LIST_REPLY, *PGET_CONNECTED_SERVER_LIST_REPLY;
+
+typedef struct _GET_CONNECTED_SERVER_LIST_REQUEST_EX {
+	COMMAND_REQUEST_HEADER Command;
+} GET_CONNECTED_SERVER_LIST_REQUEST_EX, *PGET_CONNECTED_SERVER_LIST_REQUEST_EX;
+
+typedef struct _GET_CONNECTED_SERVER_LIST_REPLY_EX {
+	COMMAND_REPLY_HEADER Reply;
+	unsigned int bufferLen;
+	unsigned char List[1];
+
+} GET_CONNECTED_SERVER_LIST_REPLY_EX, *PGET_CONNECTED_SERVER_LIST_REPLY_EX;
+
+typedef struct _GET_SERVER_VOLUME_LIST_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+	unsigned int Length;
+	unsigned char Name[1];
+} GET_SERVER_VOLUME_LIST_REQUEST, *PGET_SERVER_VOLUME_LIST_REQUEST;
+
+typedef struct _GET_SERVER_VOLUME_LIST_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+	unsigned char List[1];
+} GET_SERVER_VOLUME_LIST_REPLY, *PGET_SERVER_VOLUME_LIST_REPLY;
+
+typedef struct _OPEN_CONNECTION_BY_ADDR_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+	unsigned int address;
+
+} OPEN_CONNECTION_BY_ADDR_REQUEST, *POPEN_CONNECTION_BY_ADDR_REQUEST;
+
+typedef struct _OPEN_CONNECTION_BY_ADDR_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+	unsigned char serverName[64];
+	unsigned char treeName[64];
+	NWHANDLE connHandle;
+
+} OPEN_CONNECTION_BY_ADDR_REPLY, *POPEN_CONNECTION_BY_ADDR_REPLY;
+
+typedef struct _OPEN_CONNECTION_BY_NAME_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+	unsigned int NameLen;
+	unsigned char Name[1];
+
+} OPEN_CONNECTION_BY_NAME_REQUEST, *POPEN_CONNECTION_BY_NAME_REQUEST;
+
+typedef struct _OPEN_CONNECTION_BY_NAME_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+	unsigned char treeName[64];
+	NWHANDLE connHandle;
+
+} OPEN_CONNECTION_BY_NAME_REPLY, *POPEN_CONNECTION_BY_NAME_REPLY;
+
+/*
+typedef struct _LOGIN_IDENTITY_REQUEST
+{
+	COMMAND_REQUEST_HEADER Command;
+	unsigned int			treeFlags;
+	unsigned char			treeName[64];
+	unsigned int			serverFlags;
+	unsigned char			serverName[64];
+	unsigned int			userFlags;
+	unsigned char			userName[512];
+	unsigned int			passwordFlags;
+	unsigned char			password[128];
+
+} LOGIN_IDENTITY_REQUEST, *PLOGIN_IDENTITY_REQUEST;
+
+typedef struct _LOGIN_IDENTITY_REPLY
+{
+	COMMAND_REPLY_HEADER Reply;
+	unsigned char			serverName[64];
+	unsigned char			treeName[64];
+	NWHANDLE					connHandle;
+
+} LOGIN_IDENTITY_REPLY, *PLOGIN_IDENTITY_REPLY;
+*/
+
+typedef struct _VERIFY_FILE_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+	unsigned int pathLen;
+	unsigned char path[1];
+
+} VERIFY_FILE_REQUEST, *PVERIFY_FILE_REQUEST;
+
+typedef struct _VERIFY_FILE_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+	unsigned int lastAccessTime;
+	unsigned int modifyTime;
+	unsigned int createTime;
+	unsigned long long fileSize;
+	unsigned int fileMode;
+
+} VERIFY_FILE_REPLY, *PVERIFY_FILE_REPLY;
+
+typedef struct _BEGIN_ENUMERATE_DIRECTORY_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+	unsigned int pathLen;
+	unsigned char path[1];
+
+} BEGIN_ENUMERATE_DIRECTORY_REQUEST, *PBEGIN_ENUMERATE_DIRECTORY_REQUEST;
+
+typedef struct _BEGIN_ENUMERATE_DIRECTORY_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+	HANDLE enumerateHandle;
+
+} BEGIN_ENUMERATE_DIRECTORY_REPLY, *PBEGIN_ENUMERATE_DIRECTORY_REPLY;
+
+typedef struct _END_ENUMERATE_DIRECTORY_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+	HANDLE enumerateHandle;
+
+} END_ENUMERATE_DIRECTORY_REQUEST, *PEND_ENUMERATE_DIRECTORY_REQUEST;
+
+typedef struct _END_ENUMERATE_DIRECTORY_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+
+} END_ENUMERATE_DIRECTORY_REPLY, *PEND_ENUMERATE_DIRECTORY_REPLY;
+
+typedef struct _ENUMERATE_DIRECTORY_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+	HANDLE enumerateHandle;
+	unsigned int pathLen;
+	unsigned char path[1];
+
+} ENUMERATE_DIRECTORY_REQUEST, *PENUMERATE_DIRECTORY_REQUEST;
+
+typedef struct _ENUMERATE_DIRECTORY_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+	HANDLE enumerateHandle;
+	unsigned int lastAccessTime;
+	unsigned int modifyTime;
+	unsigned int createTime;
+	unsigned long long size;
+	unsigned int mode;
+	unsigned int nameLen;
+	unsigned char name[1];
+
+} ENUMERATE_DIRECTORY_REPLY, *PENUMERATE_DIRECTORY_REPLY;
+
+typedef struct _ENUMERATE_DIRECTORY_EX_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+	HANDLE enumerateHandle;
+	unsigned int pathLen;
+	unsigned char path[1];
+
+} ENUMERATE_DIRECTORY_EX_REQUEST, *PENUMERATE_DIRECTORY_EX_REQUEST;
+
+typedef struct _ENUMERATE_DIRECTORY_EX_DATA {
+	unsigned int length;
+	unsigned int lastAccessTime;
+	unsigned int modifyTime;
+	unsigned int createTime;
+	unsigned long long size;
+	unsigned int mode;
+	unsigned int nameLen;
+	unsigned char name[1];
+
+} ENUMERATE_DIRECTORY_EX_DATA, *PENUMERATE_DIRECTORY_EX_DATA;
+
+typedef struct _ENUMERATE_DIRECTORY_EX_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+	HANDLE enumerateHandle;
+	unsigned int enumCount;
+
+} ENUMERATE_DIRECTORY_EX_REPLY, *PENUMERATE_DIRECTORY_EX_REPLY;
+
+typedef struct _OPEN_FILE_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+	unsigned int access;	/* File Access */
+	unsigned int mode;	/* Sharing Mode */
+	unsigned int disp;	/* Create Disposition */
+	unsigned int pathLen;
+	unsigned char path[1];
+
+} OPEN_FILE_REQUEST, *POPEN_FILE_REQUEST;
+
+typedef struct _OPEN_FILE_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+	HANDLE handle;
+	unsigned int lastAccessTime;
+	unsigned int modifyTime;
+	unsigned int createTime;
+	unsigned int attributes;
+	loff_t size;
+
+} OPEN_FILE_REPLY, *POPEN_FILE_REPLY;
+
+typedef struct _CREATE_FILE_REQUEST {
+
+	COMMAND_REQUEST_HEADER Command;
+	unsigned int pathlength;
+	unsigned char path[1];
+
+} CREATE_FILE_REQUEST, *PCREATE_FILE_REQUEST;
+
+typedef struct _CREATE_FILE_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+
+} CREATE_FILE_REPLY, *PCREATE_FILE_REPLY;
+
+typedef struct _CLOSE_FILE_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+	HANDLE handle;
+
+} CLOSE_FILE_REQUEST, *PCLOSE_FILE_REQUEST;
+
+typedef struct _CLOSE_FILE_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+
+} CLOSE_FILE_REPLY, *PCLOSE_FILE_REPLY;
+
+typedef struct _READ_FILE_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+	HANDLE handle;
+	loff_t offset;
+	size_t len;
+
+} READ_FILE_REQUEST, *PREAD_FILE_REQUEST;
+
+typedef struct _READ_FILE_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+	unsigned long long bytesRead;
+	unsigned char data[1];
+
+} READ_FILE_REPLY, *PREAD_FILE_REPLY;
+
+typedef struct _WRITE_FILE_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+	HANDLE handle;
+	loff_t offset;
+	size_t len;
+	unsigned char data[1];
+
+} WRITE_FILE_REQUEST, *PWRITE_FILE_REQUEST;
+
+typedef struct _WRITE_FILE_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+	unsigned long long bytesWritten;
+} WRITE_FILE_REPLY, *PWRITE_FILE_REPLY;
+
+typedef struct _READ_STREAM_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+	HANDLE connection;
+	unsigned char handle[6];
+	loff_t offset;
+	size_t len;
+} READ_STREAM_REQUEST, *PREAD_STREAM_REQUEST;
+
+typedef struct _READ_STREAM_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+	size_t bytesRead;
+	unsigned char data[1];
+} READ_STREAM_REPLY, *PREAD_STREAM_REPLY;
+
+typedef struct _WRITE_STREAM_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+	HANDLE connection;
+	unsigned char handle[6];
+	loff_t offset;
+	size_t len;
+	unsigned char data[1];
+} WRITE_STREAM_REQUEST, *PWRITE_STREAM_REQUEST;
+
+typedef struct _WRITE_STREAM_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+	size_t bytesWritten;
+} WRITE_STREAM_REPLY, *PWRITE_STREAM_REPLY;
+
+typedef struct _CLOSE_STREAM_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+	HANDLE connection;
+	unsigned char handle[6];
+} CLOSE_STREAM_REQUEST, *PCLOSE_STREAM_REQUEST;
+
+typedef struct _CLOSE_STREAM_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+
+} CLOSE_STREAM_REPLY, *PCLOSE_STREAM_REPLY;
+
+typedef struct _CREATE_DIRECTORY_REQUEST {
+
+	COMMAND_REQUEST_HEADER Command;
+	unsigned int pathlength;
+	unsigned char path[1];
+
+} CREATE_DIRECTORY_REQUEST, *PCREATE_DIRECTORY_REQUEST;
+
+typedef struct _CREATE_DIRECTORY_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+
+} CREATE_DIRECTORY_REPLY, *PCREATE_DIRECTORY_REPLY;
+
+typedef struct _LOGIN_USER_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+	unsigned int srvNameType;
+	unsigned int serverLength;
+	unsigned int serverOffset;
+	unsigned int usrNameType;
+	unsigned int userNameLength;
+	unsigned int userNameOffset;
+	unsigned int pwdNameType;
+	unsigned int passwordLength;
+	unsigned int passwordOffset;
+
+} LOGIN_USER_REQUEST, *PLOGIN_USER_REQUEST;
+
+typedef struct _LOGIN_USER_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+	unsigned int connectionHandle;
+	HANDLE loginIdentity;
+
+} LOGIN_USER_REPLY, *PLOGIN_USER_REPLY;
+
+typedef struct _LOGOUT_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+	unsigned int length;
+	unsigned char Name[1];
+
+} LOGOUT_REQUEST, *PLOGOUT_REQUEST;
+
+typedef struct _LOGOUT_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+
+} LOGOUT_REPLY, *PLOGOUT_REPLY;
+
+typedef struct _CREATE_CONTEXT_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+
+} CREATE_CONTEXT_REQUEST, *PCREATE_CONTEXT_REQUEST;
+
+typedef struct _CREATE_CONTEXT_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+	struct schandle SessionId;
+} CREATE_CONTEXT_REPLY, *PCREATE_CONTEXT_REPLY;
+
+typedef struct _DESTROY_CONTEXT_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+
+} DESTROY_CONTEXT_REQUEST, *PDESTROY_CONTEXT_REQUEST;
+
+typedef struct _DESTROY_CONTEXT_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+
+} DESTROY_CONTEXT_REPLY, *PDESTROY_CONTEXT_REPLY;
+
+/*
+ * Attribute flags.  These should be or-ed together to figure out what
+ * has been changed!
+ */
+#ifndef ATTR_MODE
+#define ATTR_MODE	1
+#define ATTR_UID	2
+#define ATTR_GID	4
+#define ATTR_SIZE	8
+#define ATTR_ATIME	16
+#define ATTR_MTIME	32
+#define ATTR_CTIME	64
+#define ATTR_ATIME_SET	128
+#define ATTR_MTIME_SET	256
+#define ATTR_FORCE	512	/* Not a change, but a change it */
+#define ATTR_ATTR_FLAG	1024
+#endif
+
+typedef struct _LNX_FILE_INFO {
+	unsigned int ia_valid;
+	unsigned int ia_mode;
+	uid_t ia_uid;
+	gid_t ia_gid;
+	loff_t ia_size;
+	time_t ia_atime;
+	time_t ia_mtime;
+	time_t ia_ctime;
+	unsigned int ia_attr_flags;
+
+} LX_FILE_INFO, *PLX_FILE_INFO;
+
+typedef struct _SET_FILE_INFO_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+	LX_FILE_INFO fileInfo;
+	unsigned int pathlength;
+	char path[1];
+
+} SET_FILE_INFO_REQUEST, *PSET_FILE_INFO_REQUEST;
+
+typedef struct _SET_FILE_INFO_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+
+} SET_FILE_INFO_REPLY, *PSET_FILE_INFO_REPLY;
+
+typedef struct _TRUNCATE_FILE_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+	unsigned int pathLen;
+	char path[1];
+
+} TRUNCATE_FILE_REQUEST, *PTRUNCATE_FILE_REQUEST;
+
+typedef struct _TRUNCATE_FILE_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+
+} TRUNCATE_FILE_REPLY, *PTRUNCATE_FILE_REPLY;
+
+typedef struct _GETPWUID_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+	unsigned int uid;
+} GETPWUID_REQUEST, *PGETPWUID_REQUEST;
+
+typedef struct _GETPWUID_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+	unsigned char UserName[1];
+} GETPWUID_REPLY, *PGETPWUID_REPLY;
+
+typedef struct _GET_VERSION_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+} GET_VERSION_REQUEST, *PGET_VERSION_REQUEST;
+
+typedef struct _GET_VERSION_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+	unsigned char Version[1];
+} GET_VERSION_REPLY, *PGET_VERSION_REPLY;
+
+typedef struct _SET_MOUNT_PATH {
+	COMMAND_REQUEST_HEADER Command;
+	unsigned int PathLength;
+	unsigned char Path[1];
+} SET_MOUNT_PATH_REQUEST, *PSET_MOUNT_PATH_REQUEST;
+
+typedef struct _SET_MOUNT_PATH_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+} SET_MOUNT_PATH, *PSET_MOUNT_PATH_REPLY;
+
+typedef struct _GET_USER_SPACE {
+	COMMAND_REQUEST_HEADER Command;
+} GET_USER_SPACE_REQUEST, *PGET_USER_SPACE_REQUEST;
+
+typedef struct _GET_USER_SPACE_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+	uint64_t TotalSpace;
+	uint64_t FreeSpace;
+	uint64_t TotalEnties;
+	uint64_t FreeEnties;
+} GET_USER_SPACE_REPLY, *PGET_USER_SPACE_REPLY;
+
+typedef struct _XPLAT_CALL_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+	unsigned int NwcCommand;
+	unsigned long dataLen;
+	unsigned char data[1];
+
+} XPLAT_CALL_REQUEST, *PXPLAT_CALL_REQUEST;
+
+typedef struct _XPLAT_CALL_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+	unsigned long dataLen;
+	unsigned char data[1];
+
+} XPLAT_CALL_REPLY, *PXPLAT_CALL_REPLY;
+
+/* XPlat NWC structures used by the daemon */
+
+typedef struct _NWD_OPEN_CONN_BY_NAME {
+	HANDLE ConnHandle;
+	unsigned int nameLen;
+	unsigned int oName;	/* Ofset to the Name */
+	unsigned int serviceLen;
+	unsigned int oServiceType;	/* Offset to service Type; */
+	unsigned int uConnFlags;
+	unsigned int uTranType;
+	HANDLE newConnHandle;
+
+} NwdCOpenConnByName, *PNwdCOpenConnByName;
+
+typedef struct _NWD_TRAN_ADDR {
+	unsigned int uTransportType;
+	unsigned int uAddressLength;
+	unsigned int oAddress;
+
+} NwdCTranAddr, *PNwdCTranAddr;
+
+typedef struct _NWD_OPEN_CONN_BY_ADDR {
+	HANDLE ConnHandle;
+	unsigned int oServiceType;
+	unsigned int uConnFlags;
+	NwdCTranAddr TranAddr;
+
+} NwdCOpenConnByAddr, *PNwdCOpenConnByAddr;
+
+typedef struct _NWD_CLOSE_CONN {
+	HANDLE ConnHandle;
+
+} NwdCCloseConn, *PNwdCCloseConn;
+
+typedef struct _NWD_NCP_REQ {
+	HANDLE ConnHandle;
+	unsigned int replyLen;
+	unsigned int requestLen;
+	unsigned int function;
+/*	unsigned int 	subFunction; */
+/*	unsigned int 	verb; */
+	unsigned int flags;
+	unsigned char data[1];
+
+} NwdCNCPReq, *PNwdCNCPReq;
+
+typedef struct _NWD_NCP_REP {
+	unsigned int replyLen;
+	unsigned char data[1];
+
+} NwdCNCPRep, *PNwdCNCPRep;
+
+typedef struct _NWC_AUTH_WID {
+	HANDLE ConnHandle;
+	u32 AuthenticationId;
+
+} NwdCAuthenticateWithId, *PNwdCAuthenticateWithId;
+
+typedef struct _NWC_AUTHENTICATE {
+	HANDLE ConnHandle;
+	unsigned int uAuthenticationType;
+	unsigned int userNameOffset;
+	unsigned int passwordOffset;
+	unsigned int MaxInfoLength;
+	unsigned int InfoLength;
+	unsigned int authenInfoOffset;
+
+} NwdCAuthenticate, *PNwdCAuthenticate;
+
+typedef struct _NWC_UNAUTHENTICATE {
+	HANDLE ConnHandle;
+	unsigned int AuthenticationId;
+
+} NwdCUnauthenticate, *PNwdCUnauthenticate;
+
+typedef struct _NWC_LISC_ID {
+	HANDLE ConnHandle;
+
+} NwdCLicenseConn, *PNwdCLicenseConn;
+
+typedef struct _NWC_UNLIC_CONN {
+	HANDLE ConnHandle;
+
+} NwdCUnlicenseConn, *PNwdCUnlicenseConn;
+
+typedef struct _NWC_GET_IDENT_INFO {
+	u32 AuthenticationId;
+	unsigned int AuthType;
+	unsigned int NameType;
+	unsigned short int ObjectType;
+	unsigned int IdentityFlags;
+	unsigned int domainLen;
+	unsigned int pDomainNameOffset;
+	unsigned int objectLen;
+	unsigned int pObjectNameOffset;
+
+} NwdCGetIdentityInfo, *PNwdCGetIdentityInfo;
+
+typedef struct _NWC_LO_ID {
+	u32 AuthenticationId;
+
+} NwdCLogoutIdentity, *PNwdCLogoutIdentity;
+
+typedef struct _RENAME_FILE_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+	int directoryFlag;
+	unsigned int newnameLen;
+	unsigned char newname[256];
+	unsigned int oldnameLen;
+	unsigned char oldname[256];
+} RENAME_FILE_REQUEST, *PRENAME_FILE_REQUEST;
+
+typedef struct _RENAME_FILE_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+
+} RENAME_FILE_REPLY, *PRENAME_FILE_REPLY;
+
+typedef struct __NwdServerVersion {
+	unsigned int uMajorVersion;
+	unsigned short int uMinorVersion;
+	unsigned short int uRevision;
+
+} NwdServerVersion, *PNwdServerVersion;
+
+#define	MAX_ADDRESS_LENGTH	32
+
+typedef struct tagNwdTranAddrEx {
+	unsigned int uTransportType;
+	unsigned int uAddressLength;
+	unsigned char Buffer[MAX_ADDRESS_LENGTH];
+
+} NwdTranAddr, *PNwdTranAddr;
+
+typedef struct __NWD_CONN_INFO {
+	unsigned int uInfoVersion;
+	unsigned int uAuthenticationState;
+	unsigned int uBroadcastState;
+	u32 uConnectionReference;
+	unsigned int pTreeNameOffset;
+/*	unsigned int		pWorkGroupIdOffset;  Not used */
+	unsigned int uSecurityState;
+	unsigned int uConnectionNumber;
+	unsigned int uUserId;
+	unsigned int pServerNameOffset;
+	unsigned int uNdsState;
+	unsigned int uMaxPacketSize;
+	unsigned int uLicenseState;
+	unsigned int uPublicState;
+	unsigned int bcastState;
+	unsigned int pServiceTypeOffset;
+	unsigned int uDistance;
+	u32 uAuthId;
+	unsigned int uDisconnected;
+	NwdServerVersion ServerVersion;
+	NwdTranAddr TranAddress;
+
+} NwdConnInfo, *PNwdConnInfo;
+
+typedef struct _nwd_conn_info {
+	HANDLE ConnHandle;
+	unsigned int uInfoLevel;
+	unsigned int uInfoLength;
+
+} NwdCGetConnInfo, *PNwdCGetConnInfo;
+
+typedef struct nwd_open_conn_by_Ref {
+	HANDLE uConnReference;
+	unsigned int uConnFlags;
+	HANDLE ConnHandle;
+
+} NwdCOpenConnByRef, *PNwdCOpenConnByRef;
+
+typedef struct nwd_get_reqversion {
+	unsigned int uMajorVersion;
+	unsigned int uMinorVersion;
+	unsigned int uRevision;
+
+} NwdCGetRequesterVersion, *PNwdCGetRequesterVersion;
+
+typedef struct _nwc_scan_conn_info {
+	unsigned int uScanIndex;
+	unsigned int uScanInfoLevel;
+	unsigned int uScanInfoLen;
+	unsigned int uScanConnInfoOffset;
+	unsigned int uScanFlags;
+	unsigned int uReturnInfoLevel;
+	unsigned int uReturnInfoLength;
+	unsigned int uConnectionReference;
+	unsigned int uReturnConnInfoOffset;
+
+} NwdCScanConnInfo, *PNwdCScanConnInfo;
+
+typedef struct nwc_get_pref_ds_tree {
+	unsigned int uTreeLength;
+	unsigned int DsTreeNameOffset;
+
+} NwdCGetPreferredDsTree, *PNwdCGetPreferredDsTree;
+
+typedef struct nwc_set_pref_ds_tree {
+	unsigned int uTreeLength;
+	unsigned int DsTreeNameOffset;
+
+} NwdCSetPreferredDsTree, *PNwdCSetPreferredDsTree;
+
+typedef struct nwc_set_def_name_ctx {
+	unsigned int uTreeLength;
+	unsigned int TreeOffset;
+	unsigned int uNameLength;
+	unsigned int NameContextOffset;
+
+} NwdCSetDefaultNameContext, *PNwdCSetDefaultNameContext;
+
+typedef struct nwc_get_def_name_ctx {
+	unsigned int uTreeLength;
+	unsigned int TreeOffset;
+	unsigned int uNameLength;
+	unsigned int NameContextOffset;
+
+} NwdCGetDefaultNameContext, *PNwdCGetDefaultNameContext;
+
+typedef struct _nwc_get_treemonitored_connref {
+	NwdString TreeName;
+	HANDLE uConnReference;
+
+} NwdCGetTreeMonitoredConnRef, *PNwdCGetTreeMonitoredConnRef;
+
+typedef struct _nwc_enumerate_identities {
+	unsigned int Iterator;
+	unsigned int domainNameLen;
+	unsigned int domainNameOffset;
+	unsigned int AuthType;
+	unsigned int objectNameLen;
+	unsigned int objectNameOffset;
+	unsigned int NameType;
+	unsigned short int ObjectType;
+	unsigned int IdentityFlags;
+	u32 AuthenticationId;
+
+} NwdCDEnumerateIdentities, *PNwdCEnumerateIdentities;
+
+typedef struct nwd_change_key {
+	unsigned int domainNameOffset;
+	unsigned int domainNameLen;
+	unsigned int AuthType;
+	unsigned int objectNameOffset;
+	unsigned int objectNameLen;
+	unsigned int NameType;
+	unsigned short int ObjectType;
+	unsigned int verifyPasswordOffset;
+	unsigned int verifyPasswordLen;
+	unsigned int newPasswordOffset;
+	unsigned int newPasswordLen;
+
+} NwdCChangeKey, *PNwdCChangeKey;
+
+typedef struct _nwd_get_primary_conn {
+	HANDLE uConnReference;
+
+} NwdCGetPrimaryConnection, *PNwdCGetPrimaryConnection;
+
+typedef struct _nwd_set_primary_conn {
+	HANDLE ConnHandle;
+
+} NwdCSetPrimaryConnection, *PNwdCSetPrimaryConnection;
+
+typedef struct _nwd_map_drive_ex {
+	u32 ConnHandle;
+	u32 localUid;
+	u32 linkOffsetLength;
+	u32 linkOffset;
+	u32 dirPathOffsetLength;
+	u32 dirPathOffset;
+
+} NwdCMapDriveEx, *PNwdCMapDriveEx;
+
+typedef struct _nwd_unmap_drive_ex {
+	unsigned int linkLen;
+	char linkPath[1];
+
+} NwdCUnmapDriveEx, *PNwdCUnmapDriveEx;
+
+typedef struct _nwd_enum_links {
+	unsigned int totalLen;
+	unsigned int linkCount;
+
+} NwdCEnumLinks, *PNwdCEnumLinks;
+
+typedef struct nwd_getbroadcastnotification {
+	unsigned int uMessageFlags;
+	HANDLE uConnReference;
+	unsigned int messageLen;
+	char message[1];
+
+} NwdCGetBroadcastNotification, *PNwdCGetBroadcastNotification;
+
+typedef struct _enum_entry {
+	unsigned int entryLen;
+	u32 connHdl;
+	char data[0];
+} NwdCEnumEntry, *PNwdCEnumEntry;
+
+typedef struct _nwd_set_conn_info {
+	HANDLE ConnHandle;
+	unsigned int uInfoLevel;
+	unsigned int uInfoLength;
+	unsigned int offsetConnInfo;
+
+} NwdCSetConnInfo, *PNwdCSetConnInfo;
+
+typedef struct _len_string {
+	u32 stLen;
+	char string[1];
+
+} LString, *PLString;
+
+typedef struct _DEBUG_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+	int cmdlen;
+	char dbgcmd[1];
+
+} DEBUG_REQUEST, *PDEBUG_REQUEST;
+
+typedef struct _DEBUG_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+
+} DEBUG_REPLY, *PDEBUG_REPLY;
+
+typedef struct _Nwd_Set_Key {
+	HANDLE ConnHandle;
+	unsigned int AuthenticationId;
+	unsigned int objectNameLen;
+	unsigned int objectNameOffset;
+	unsigned short int ObjectType;
+	unsigned int newPasswordLen;
+	unsigned int newPasswordOffset;
+
+} NwdCSetKey, *PNwdCSetKey;
+
+typedef struct _Nwd_Verify_Key {
+	unsigned int AuthType;
+	unsigned int NameType;
+	unsigned short int ObjectType;
+	unsigned int domainNameLen;
+	unsigned int domainNameOffset;
+	unsigned int objectNameLen;
+	unsigned int objectNameOffset;
+	unsigned int verifyPasswordLen;
+	unsigned int verifyPasswordOffset;
+
+} NwdCVerifyKey, *PNwdCVerifyKey;
+
+typedef struct _GET_CACHE_FLAG {
+	COMMAND_REQUEST_HEADER Command;
+	int pathLen;
+	unsigned char path[0];
+
+} GET_CACHE_FLAG_REQUEST, *PGET_CACHE_FLAG_REQUEST;
+
+typedef struct _GET_CACHE_FLAG_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+	int CacheFlag;
+
+} GET_CACHE_FLAG_REPLY, *PGET_CACHE_FLAG_REPLY;
+
+typedef struct _XA_LIST_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+	unsigned char *pData;
+
+} XA_LIST_REPLY, *PXA_LIST_REPLY;
+
+typedef struct _XA_GET_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+	unsigned int pathLen;
+	unsigned int nameLen;
+	unsigned char data[1];	//hold path, attribute name
+
+} XA_GET_REQUEST, *PXA_GET_REQUEST;
+
+typedef struct _XA_GET_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+	unsigned char *pData;
+
+} XA_GET_REPLY, *PXA_GET_REPLY;
+
+typedef struct _XA_SET_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+	unsigned int TtlWriteDataSize;
+	unsigned int WritePosition;
+	int flags;
+	unsigned int pathLen;
+	unsigned int nameLen;
+	unsigned int valueLen;
+	unsigned char data[1];	//hold path, attribute name, value data
+
+} XA_SET_REQUEST, *PXA_SET_REQUEST;
+
+typedef struct _XA_SET_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+	unsigned char *pData;
+
+} XA_SET_REPLY, *PXA_SET_REPLY;
+
+typedef struct _SET_FILE_LOCK_REQUEST {
+	COMMAND_REQUEST_HEADER Command;
+	HANDLE handle;
+	unsigned char fl_type;
+	loff_t fl_start;
+	loff_t fl_len;
+
+} SET_FILE_LOCK_REQUEST, *PSET_FILE_LOCK_REQUEST;
+
+typedef struct _SET_FILE_LOCK_REPLY {
+	COMMAND_REPLY_HEADER Reply;
+
+} SET_FILE_LOCK_REPLY, *PSET_FILE_LOCK_REPLY;
+
+#pragma pack(pop)
+
+#endif	/* __NOVFS_COMMANDS_H */
--- /dev/null
+++ b/fs/novfs/daemon.c
@@ -0,0 +1,2400 @@
+/*
+ * Novell NCP Redirector for Linux
+ * Author: James Turner
+ *
+ * This file contains all the functions necessary for sending commands to our
+ * daemon module.
+ *
+ * Copyright (C) 2005 Novell, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/list.h>
+#include <linux/timer.h>
+#include <linux/poll.h>
+#include <linux/pagemap.h>
+#include <linux/smp_lock.h>
+#include <linux/semaphore.h>
+#include <asm/uaccess.h>
+#include <asm/atomic.h>
+#include <linux/time.h>
+
+#include "vfs.h"
+#include "nwcapi.h"
+#include "commands.h"
+#include "nwerror.h"
+
+#define QUEUE_SENDING 0
+#define QUEUE_WAITING 1
+#define QUEUE_TIMEOUT 2
+#define QUEUE_ACKED   3
+#define QUEUE_DONE    4
+
+#define TIMEOUT_VALUE 10
+
+#define DH_TYPE_UNDEFINED    0
+#define DH_TYPE_STREAM       1
+#define DH_TYPE_CONNECTION   2
+
+/*===[ Type definitions ]=================================================*/
+typedef struct _DAEMON_QUEUE {
+	struct list_head list;	/* Must be first entry */
+	spinlock_t lock;	/* Used to control access to list */
+	struct semaphore semaphore;	/* Used to signal when data is available */
+} daemon_queue_t;
+
+typedef struct _DAEMON_COMMAND {
+	struct list_head list;	/* Must be first entry */
+	atomic_t reference;
+	unsigned int status;
+	unsigned int flags;
+	struct semaphore semaphore;
+	unsigned long sequence;
+	struct timer_list timer;
+	void *request;
+	unsigned long reqlen;
+	void *data;
+	int datalen;
+	void *reply;
+	unsigned long replen;
+} daemon_command_t;
+
+typedef struct _DAEMON_HANDLE_ {
+	struct list_head list;
+	rwlock_t lock;
+	session_t session;
+} daemon_handle_t;
+
+typedef struct _DAEMON_RESOURCE_ {
+	struct list_head list;
+	int type;
+	HANDLE connection;
+	unsigned char handle[6];
+	mode_t mode;
+	loff_t size;
+} daemon_resource_t;
+
+typedef struct _DRIVE_MAP_ {
+	struct list_head list;	/* Must be first item */
+	session_t session;
+	unsigned long hash;
+	int namelen;
+	char name[1];
+} drive_map_t;
+
+/*===[ Function prototypes ]==============================================*/
+int Daemon_Close_Control(struct inode *Inode, struct file *File);
+int Daemon_Library_close(struct inode *inode, struct file *file);
+int Daemon_Library_open(struct inode *inode, struct file *file);
+loff_t Daemon_Library_llseek(struct file *file, loff_t offset, int origin);
+int Daemon_Open_Control(struct inode *Inode, struct file *File);
+uint Daemon_Poll(struct file *file, struct poll_table_struct *poll_table);
+int Daemon_Remove_Resource(daemon_handle_t * DHandle, int Type, HANDLE CHandle,
+			   unsigned long FHandle);
+
+int Daemon_SetMountPoint(char *Path);
+void Daemon_Timer(unsigned long data);
+int Daemon_getpwuid(uid_t uid, int unamelen, char *uname);
+int Queue_Daemon_Command(void *request, unsigned long reqlen, void *data, int dlen,
+			 void **reply, unsigned long * replen, int interruptible);
+void Queue_get(daemon_command_t * que);
+void Queue_put(daemon_command_t * que);
+void Uninit_Daemon_Queue(void);
+daemon_command_t *find_queue(unsigned long sequence);
+daemon_command_t *get_next_queue(int Set_Queue_Waiting);
+int NwdConvertNetwareHandle(PXPLAT pdata, daemon_handle_t * DHandle);
+int NwdConvertLocalHandle(PXPLAT pdata, daemon_handle_t * DHandle);
+int NwdGetMountPath(PXPLAT pdata);
+static int NwdSetMapDrive(PXPLAT pdata, session_t Session);
+static int NwdUnMapDrive(PXPLAT pdata, session_t Session);
+void RemoveDriveMaps(void);
+int local_unlink(const char *pathname);
+
+/*===[ Global variables ]=================================================*/
+static daemon_queue_t Daemon_Queue;
+
+static DECLARE_WAIT_QUEUE_HEAD(Read_waitqueue);
+
+static atomic_t Sequence = ATOMIC_INIT(-1);
+static atomic_t Daemon_Open_Count = ATOMIC_INIT(0);
+
+static unsigned long Daemon_Command_Timeout = TIMEOUT_VALUE;
+
+static DECLARE_MUTEX(DriveMapLock);
+static LIST_HEAD(DriveMapList);
+
+int MaxIoSize = PAGE_SIZE;
+
+void Init_Daemon_Queue(void)
+{
+	INIT_LIST_HEAD(&Daemon_Queue.list);
+	spin_lock_init(&Daemon_Queue.lock);
+	init_MUTEX_LOCKED(&Daemon_Queue.semaphore);
+}
+
+/*++======================================================================*/
+void Uninit_Daemon_Queue(void)
+/*
+ *
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	/* Does nothing for now but we maybe should clear the queue. */
+}
+
+/*++======================================================================*/
+void Daemon_Timer(unsigned long data)
+/*
+ *
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	daemon_command_t *que = (daemon_command_t *) data;
+
+	if (QUEUE_ACKED != que->status) {
+		que->status = QUEUE_TIMEOUT;
+	}
+	up(&que->semaphore);
+}
+
+int Queue_Daemon_Command(void *request, unsigned long reqlen, void *data, int dlen,
+			 void **reply, unsigned long * replen, int interruptible)
+/*
+ *  Arguments:     void *request - pointer to the request that is to be sent.  Needs to be kernel memory.
+ *                 int reqlen - length of the request.
+ *========================================================================*/
+{
+	daemon_command_t *que;
+	int retCode = 0;
+	uint64_t ts1, ts2;
+
+	ts1 = get_nanosecond_time();
+
+	DbgPrint("Queue_Daemon_Command: 0x%p %d\n", request, reqlen);
+
+	if (atomic_read(&Daemon_Open_Count)) {
+
+		que = kmalloc(sizeof(*que), GFP_KERNEL);
+		DbgPrint("Queue_Daemon_Command: que=0x%p\n", que);
+		if (que) {
+			atomic_set(&que->reference, 0);
+			que->status = QUEUE_SENDING;
+			que->flags = 0;
+
+			init_MUTEX_LOCKED(&que->semaphore);
+
+			que->sequence = atomic_inc_return(&Sequence);
+
+			((PCOMMAND_REQUEST_HEADER) request)->SequenceNumber =
+			    que->sequence;
+
+			/*
+			 * Setup and start que timer
+			 */
+			init_timer(&que->timer);
+			que->timer.expires = jiffies + (HZ * Daemon_Command_Timeout);
+			que->timer.data = (unsigned long) que;
+			que->timer.function = Daemon_Timer;
+			add_timer(&que->timer);
+
+			/*
+			 * Setup request
+			 */
+			que->request = request;
+			que->reqlen = reqlen;
+			que->data = data;
+			que->datalen = dlen;
+			que->reply = NULL;
+			que->replen = 0;
+
+			/*
+			 * Added entry to queue.
+			 */
+			/*
+			 * Check to see if interruptible and set flags.
+			 */
+			if (interruptible) {
+				que->flags |= INTERRUPTIBLE;
+			}
+
+			Queue_get(que);
+
+			spin_lock(&Daemon_Queue.lock);
+			list_add_tail(&que->list, &Daemon_Queue.list);
+			spin_unlock(&Daemon_Queue.lock);
+
+			/*
+			 * Signal that there is data to be read
+			 */
+			up(&Daemon_Queue.semaphore);
+
+			/*
+			 * Give a change to the other processes.
+			 */
+			yield();
+
+			/*
+			 * Block waiting for reply or timeout
+			 */
+			down(&que->semaphore);
+
+			if (QUEUE_ACKED == que->status) {
+				que->status = QUEUE_WAITING;
+				mod_timer(&que->timer,
+					  jiffies +
+					  (HZ * 2 * Daemon_Command_Timeout));
+				if (interruptible) {
+					retCode =
+					    down_interruptible(&que->semaphore);
+				} else {
+					down(&que->semaphore);
+				}
+			}
+
+			/*
+			 * Delete timer
+			 */
+			del_timer(&que->timer);
+
+			/*
+			 * Check for timeout
+			 */
+			if ((QUEUE_TIMEOUT == que->status)
+			    && (NULL == que->reply)) {
+				DbgPrint("Queue_Daemon_Command: Timeout\n");
+				retCode = -ETIME;
+			}
+			*reply = que->reply;
+			*replen = que->replen;
+
+			/*
+			 * Remove item from queue
+			 */
+			Queue_put(que);
+
+		} else {	/* Error case with no memory */
+
+			retCode = -ENOMEM;
+			*reply = NULL;
+			*replen = 0;
+		}
+	} else {
+		retCode = -EIO;
+		*reply = NULL;
+		*replen = 0;
+
+	}
+	ts2 = get_nanosecond_time();
+	ts2 = ts2 - ts1;
+
+	DbgPrint("Queue_Daemon_Command: %llu retCode=%d \n", ts2, retCode);
+	return (retCode);
+}
+
+/*++======================================================================*/
+void Queue_get(daemon_command_t * Que)
+/*
+ *
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	DbgPrint("Queue_get: que=0x%p %d\n", Que, atomic_read(&Que->reference));
+	atomic_inc(&Que->reference);
+}
+
+/*++======================================================================*/
+void Queue_put(daemon_command_t * Que)
+/*
+ *
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+
+	DbgPrint("Queue_put: que=0x%p %d\n", Que, atomic_read(&Que->reference));
+	spin_lock(&Daemon_Queue.lock);
+
+	if (atomic_dec_and_test(&Que->reference)) {
+		/*
+		 * Remove item from queue
+		 */
+		list_del(&Que->list);
+		spin_unlock(&Daemon_Queue.lock);
+
+		/*
+		 * Free item memory
+		 */
+		kfree(Que);
+	} else {
+		spin_unlock(&Daemon_Queue.lock);
+	}
+}
+
+/*++======================================================================*/
+daemon_command_t *get_next_queue(int Set_Queue_Waiting)
+/*
+ *
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	daemon_command_t *que;
+
+	DbgPrint("get_next_queue: que=0x%p\n", Daemon_Queue.list.next);
+
+	spin_lock(&Daemon_Queue.lock);
+	que = (daemon_command_t *) Daemon_Queue.list.next;
+
+	while (que && (que != (daemon_command_t *) & Daemon_Queue.list.next)
+	       && (que->status != QUEUE_SENDING)) {
+		que = (daemon_command_t *) que->list.next;
+	}
+
+	if ((NULL == que) || (que == (daemon_command_t *) & Daemon_Queue.list)
+	    || (que->status != QUEUE_SENDING)) {
+		que = NULL;
+	} else if (Set_Queue_Waiting) {
+		que->status = QUEUE_WAITING;
+	}
+
+	if (que) {
+		atomic_inc(&que->reference);
+	}
+
+	spin_unlock(&Daemon_Queue.lock);
+
+	DbgPrint("get_next_queue: return=0x%p\n", que);
+	return (que);
+}
+
+/*++======================================================================*/
+daemon_command_t *find_queue(unsigned long sequence)
+/*
+ *
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	daemon_command_t *que;
+
+	DbgPrint("find_queue: 0x%x\n", sequence);
+
+	spin_lock(&Daemon_Queue.lock);
+	que = (daemon_command_t *) Daemon_Queue.list.next;
+
+	while (que && (que != (daemon_command_t *) & Daemon_Queue.list.next)
+	       && (que->sequence != sequence)) {
+		que = (daemon_command_t *) que->list.next;
+	}
+
+	if ((NULL == que)
+	    || (que == (daemon_command_t *) & Daemon_Queue.list.next)
+	    || (que->sequence != sequence)) {
+		que = NULL;
+	}
+
+	if (que) {
+		atomic_inc(&que->reference);
+	}
+
+	spin_unlock(&Daemon_Queue.lock);
+
+	DbgPrint("find_queue: return 0x%p\n", que);
+	return (que);
+}
+
+/*++======================================================================*/
+int Daemon_Open_Control(struct inode *Inode, struct file *File)
+/*
+ *
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	DbgPrint("Daemon_Open_Control: pid=%d Count=%d\n", current->pid,
+		 atomic_read(&Daemon_Open_Count));
+	atomic_inc(&Daemon_Open_Count);
+
+	return (0);
+}
+
+/*++======================================================================*/
+int Daemon_Close_Control(struct inode *Inode, struct file *File)
+/*
+ *
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	daemon_command_t *que;
+
+	DbgPrint("Daemon_Close_Control: pid=%d Count=%d\n", current->pid,
+		 atomic_read(&Daemon_Open_Count));
+
+	if (atomic_dec_and_test(&Daemon_Open_Count)) {
+		/*
+		 * Signal any pending que itmes.
+		 */
+
+		spin_lock(&Daemon_Queue.lock);
+		que = (daemon_command_t *) Daemon_Queue.list.next;
+
+		while (que
+		       && (que != (daemon_command_t *) & Daemon_Queue.list.next)
+		       && (que->status != QUEUE_DONE)) {
+			que->status = QUEUE_TIMEOUT;
+			up(&que->semaphore);
+
+			que = (daemon_command_t *) que->list.next;
+		}
+		spin_unlock(&Daemon_Queue.lock);
+
+		RemoveDriveMaps();
+
+		Scope_Cleanup();
+	}
+
+	return (0);
+}
+
+ssize_t Daemon_Send_Command(struct file *file, char __user *buf, size_t len, loff_t * off)
+{
+	daemon_command_t *que;
+	size_t retValue = 0;
+	int Finished = 0;
+	struct data_list *dlist;
+	int i, dcnt, bcnt, ccnt, error;
+	char *vadr;
+	unsigned long cpylen;
+
+	DbgPrint("Daemon_Send_Command: %u %lld\n", len, *off);
+	if (len > MaxIoSize) {
+		MaxIoSize = len;
+	}
+
+	while (!Finished) {
+		que = get_next_queue(1);
+		DbgPrint("Daemon_Send_Command: 0x%p\n", que);
+		if (que) {
+			retValue = que->reqlen;
+			if (retValue > len) {
+				retValue = len;
+			}
+			if (retValue > 0x80)
+				mydump(0x80, que->request);
+			else
+				mydump(retValue, que->request);
+
+			cpylen = copy_to_user(buf, que->request, retValue);
+			if (que->datalen && (retValue < len)) {
+				buf += retValue;
+				dlist = que->data;
+				dcnt = que->datalen;
+				for (i = 0; i < dcnt; i++, dlist++) {
+					if (DLREAD == dlist->rwflag) {
+						bcnt = dlist->len;
+						DbgPrint
+						    ("Daemon_Send_Command%d: page=0x%p offset=0x%p len=%d\n",
+						     i, dlist->page,
+						     dlist->offset, dlist->len);
+						if ((bcnt + retValue) <= len) {
+							void *km_adr = NULL;
+
+							if (dlist->page) {
+								km_adr =
+								    kmap(dlist->
+									 page);
+								vadr = km_adr;
+								vadr +=
+								    (unsigned long)
+								    dlist->
+								    offset;
+							} else {
+								vadr =
+								    dlist->
+								    offset;
+							}
+
+							ccnt =
+							    copy_to_user(buf,
+									 vadr,
+									 bcnt);
+
+							DbgPrint
+							    ("Daemon_Send_Command: Copy %d from 0x%p to 0x%p.\n",
+							     bcnt, vadr, buf);
+							if (bcnt > 0x80)
+								mydump(0x80,
+								       vadr);
+							else
+								mydump(bcnt,
+								       vadr);
+
+							if (km_adr) {
+								kunmap(dlist->
+								       page);
+							}
+
+							retValue += bcnt;
+							buf += bcnt;
+						} else {
+							break;
+						}
+					}
+				}
+			}
+			Queue_put(que);
+			break;
+		}
+
+		if (O_NONBLOCK & file->f_flags) {
+			retValue = -EAGAIN;
+			break;
+		} else {
+			if ((error =
+			     down_interruptible(&Daemon_Queue.semaphore))) {
+				DbgPrint
+				    ("Daemon_Send_Command: after down_interruptible error...%d\n",
+				     error);
+				retValue = -EINTR;
+				break;
+			}
+			DbgPrint
+			    ("Daemon_Send_Command: after down_interruptible\n");
+		}
+	}
+
+	*off = *off;
+
+	DbgPrint("Daemon_Send_Command: return 0x%x\n", retValue);
+
+	return (retValue);
+}
+
+ssize_t Daemon_Receive_Reply(struct file *file, const char __user *buf, size_t nbytes, loff_t *ppos)
+{
+	daemon_command_t *que;
+	size_t retValue = 0;
+	void *reply;
+	unsigned long sequence, cpylen;
+
+	struct data_list *dlist;
+	char *vadr;
+	int i;
+
+	DbgPrint("Daemon_Receive_Reply: buf=0x%p nbytes=%d ppos=%llx\n", buf,
+		 nbytes, *ppos);
+
+	/*
+	 * Get sequence number from reply buffer
+	 */
+
+	cpylen = copy_from_user(&sequence, buf, sizeof(sequence));
+
+	/*
+	 * Find item based on sequence number
+	 */
+	que = find_queue(sequence);
+
+	DbgPrint("Daemon_Receive_Reply: 0x%x 0x%p %d\n", sequence, que, nbytes);
+	if (que) {
+		do {
+			retValue = nbytes;
+			/*
+			 * Ack packet from novfsd.  Remove timer and
+			 * return
+			 */
+			if (nbytes == sizeof(sequence)) {
+				que->status = QUEUE_ACKED;
+				break;
+			}
+
+			if (NULL != (dlist = que->data)) {
+				int thiscopy, left = nbytes;
+				retValue = 0;
+
+				DbgPrint
+				    ("Daemon_Receive_Reply: dlist=0x%p count=%d\n",
+				     dlist, que->datalen);
+				for (i = 0;
+				     (i < que->datalen) && (retValue < nbytes);
+				     i++, dlist++) {
+					DbgPrint("Daemon_Receive_Reply:\n"
+						 "   dlist[%d].page:   0x%p\n"
+						 "   dlist[%d].offset: 0x%p\n"
+						 "   dlist[%d].len:    0x%x\n"
+						 "   dlist[%d].rwflag: 0x%x\n",
+						 i, dlist->page, i,
+						 dlist->offset, i, dlist->len,
+						 i, dlist->rwflag);
+
+					if (DLWRITE == dlist->rwflag) {
+						void *km_adr = NULL;
+
+						if (dlist->page) {
+							km_adr =
+							    kmap(dlist->page);
+							vadr = km_adr;
+							vadr +=
+							    (unsigned long) dlist->
+							    offset;
+						} else {
+							vadr = dlist->offset;
+						}
+
+						thiscopy = dlist->len;
+						if (thiscopy > left) {
+							thiscopy = left;
+							dlist->len = left;
+						}
+						cpylen =
+						    copy_from_user(vadr, buf,
+								   thiscopy);
+
+						if (thiscopy > 0x80)
+							mydump(0x80, vadr);
+						else
+							mydump(thiscopy, vadr);
+
+						if (km_adr) {
+							kunmap(dlist->page);
+						}
+
+						left -= thiscopy;
+						retValue += thiscopy;
+						buf += thiscopy;
+					}
+				}
+				que->replen = retValue;
+			} else {
+				reply = kmalloc(nbytes, GFP_KERNEL);
+				DbgPrint("Daemon_Receive_Reply: reply=0x%p\n", reply);
+				if (reply) {
+					retValue = nbytes;
+					que->reply = reply;
+					que->replen = nbytes;
+
+					retValue -= copy_from_user(reply, buf, retValue);
+					if (retValue > 0x80)
+						mydump(0x80, reply);
+					else
+						mydump(retValue, reply);
+
+				} else {
+					retValue = -ENOMEM;
+				}
+			}
+
+			/*
+			 * Set status that packet is done.
+			 */
+			que->status = QUEUE_DONE;
+
+		} while (0);
+		up(&que->semaphore);
+		Queue_put(que);
+	}
+
+	DbgPrint("Daemon_Receive_Reply: return 0x%x\n", retValue);
+
+	return (retValue);
+}
+
+int do_login(NclString *Server, NclString *Username, NclString *Password, HANDLE *lgnId, struct schandle *Session)
+{
+	PLOGIN_USER_REQUEST cmd;
+	PLOGIN_USER_REPLY reply;
+	unsigned long replylen = 0;
+	int retCode, cmdlen, datalen;
+	unsigned char *data;
+
+	datalen = Server->len + Username->len + Password->len;
+	cmdlen = sizeof(*cmd) + datalen;
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
+	if (!cmd)
+		return -ENOMEM;
+
+	data = (unsigned char *) cmd + sizeof(*cmd);
+	cmd->Command.CommandType = VFS_COMMAND_LOGIN_USER;
+	cmd->Command.SequenceNumber = 0;
+	memcpy(&cmd->Command.SessionId, Session, sizeof(*Session));
+
+	cmd->srvNameType = Server->type;
+	cmd->serverLength = Server->len;
+	cmd->serverOffset = (unsigned long) (data - (unsigned char *) cmd);
+	memcpy(data, Server->buffer, Server->len);
+	data += Server->len;
+
+	cmd->usrNameType = Username->type;
+	cmd->userNameLength = Username->len;
+	cmd->userNameOffset = (unsigned long) (data - (unsigned char *) cmd);
+	memcpy(data, Username->buffer, Username->len);
+	data += Username->len;
+
+	cmd->pwdNameType = Password->type;
+	cmd->passwordLength = Password->len;
+	cmd->passwordOffset = (unsigned long) (data - (unsigned char *) cmd);
+	memcpy(data, Password->buffer, Password->len);
+	data += Password->len;
+
+	retCode = Queue_Daemon_Command(cmd, cmdlen, NULL, 0, (void *)&reply,
+				 &replylen, INTERRUPTIBLE);
+	if (reply) {
+		if (reply->Reply.ErrorCode) {
+			retCode = reply->Reply.ErrorCode;
+		} else {
+			retCode = 0;
+			if (lgnId) {
+				*lgnId = reply->loginIdentity;
+			}
+		}
+		kfree(reply);
+	}
+	memset(cmd, 0, cmdlen);
+	kfree(cmd);
+	return retCode;
+
+}
+
+int do_logout(struct qstr *Server, struct schandle *Session)
+{
+	PLOGOUT_REQUEST cmd;
+	PLOGOUT_REPLY reply;
+	unsigned long replylen = 0;
+	int retCode, cmdlen;
+
+	cmdlen = offsetof(LOGOUT_REQUEST, Name) + Server->len;
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
+	if (!cmd)
+		return -ENOMEM;
+
+	cmd->Command.CommandType = VFS_COMMAND_LOGOUT_USER;
+	cmd->Command.SequenceNumber = 0;
+	memcpy(&cmd->Command.SessionId, Session, sizeof(*Session));
+	cmd->length = Server->len;
+	memcpy(cmd->Name, Server->name, Server->len);
+
+	retCode = Queue_Daemon_Command(cmd, cmdlen, NULL, 0, (void *)&reply, &replylen, INTERRUPTIBLE);
+	if (reply) {
+		if (reply->Reply.ErrorCode) {
+			retCode = -EIO;
+		}
+		kfree(reply);
+	}
+	kfree(cmd);
+	return (retCode);
+
+}
+
+/*++======================================================================*/
+int Daemon_getpwuid(uid_t uid, int unamelen, char *uname)
+/*
+ *
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	GETPWUID_REQUEST cmd;
+	PGETPWUID_REPLY reply;
+	unsigned long replylen = 0;
+	int retCode;
+
+	cmd.Command.CommandType = VFS_COMMAND_GETPWUD;
+	cmd.Command.SequenceNumber = 0;
+	SC_INITIALIZE(cmd.Command.SessionId);
+	cmd.uid = uid;
+
+	retCode =
+	    Queue_Daemon_Command(&cmd, sizeof(cmd), NULL, 0, (void *)&reply,
+				 &replylen, INTERRUPTIBLE);
+	if (reply) {
+		if (reply->Reply.ErrorCode) {
+			retCode = -EIO;
+		} else {
+			retCode = 0;
+			memset(uname, 0, unamelen);
+			replylen = replylen - offsetof(GETPWUID_REPLY, UserName);
+			if (replylen) {
+				if (replylen > unamelen) {
+					retCode = -EINVAL;
+					replylen = unamelen - 1;
+				}
+				memcpy(uname, reply->UserName, replylen);
+			}
+		}
+		kfree(reply);
+	}
+	return (retCode);
+
+}
+
+/*++======================================================================*/
+int Daemon_getversion(char *Buf, int length)
+/*
+ *
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	GET_VERSION_REQUEST cmd;
+	PGET_VERSION_REPLY reply;
+	unsigned long replylen = 0;
+	int retVal = 0;
+
+	cmd.Command.CommandType = VFS_COMMAND_GET_VERSION;
+	cmd.Command.SequenceNumber = 0;
+	SC_INITIALIZE(cmd.Command.SessionId);
+
+	Queue_Daemon_Command(&cmd, sizeof(cmd), NULL, 0, (void *)&reply,
+			     &replylen, INTERRUPTIBLE);
+	if (reply) {
+		if (reply->Reply.ErrorCode) {
+			retVal = -EIO;
+		} else {
+			retVal = replylen - offsetof(GET_VERSION_REPLY, Version);
+			if (retVal < length) {
+				memcpy(Buf, reply->Version, retVal);
+				Buf[retVal] = '\0';
+			}
+		}
+		kfree(reply);
+	}
+	return (retVal);
+
+}
+
+static int daemon_login(struct login *Login, struct schandle *Session)
+{
+	int retCode = -ENOMEM;
+	struct login lLogin;
+	NclString server;
+	NclString username;
+	NclString password;
+
+	if (!copy_from_user(&lLogin, Login, sizeof(lLogin))) {
+		server.buffer = kmalloc(lLogin.Server.length, GFP_KERNEL);
+		if (server.buffer) {
+			server.len = lLogin.Server.length;
+			server.type = NWC_STRING_TYPE_ASCII;
+			if (!copy_from_user((void *)server.buffer, lLogin.Server.data, server.len)) {
+				username.buffer = kmalloc(lLogin.UserName.length, GFP_KERNEL);
+				if (username.buffer) {
+					username.len = lLogin.UserName.length;
+					username.type = NWC_STRING_TYPE_ASCII;
+					if (!copy_from_user((void *)username.buffer, lLogin.UserName.data, username.len)) {
+						password.buffer = kmalloc(lLogin.Password.length, GFP_KERNEL);
+						if (password.buffer) {
+							password.len = lLogin.Password.length;
+							password.type = NWC_STRING_TYPE_ASCII;
+							if (!copy_from_user((void *)password.buffer, lLogin.Password.data, password.len)) {
+								retCode = do_login (&server, &username, &password, NULL, Session);
+								if (!retCode) {
+									char *name;
+									name = Scope_Get_UserName();
+									if (name)
+										Novfs_Add_to_Root(name);
+								}
+							}
+							memset(password.buffer, 0, password.len);
+							kfree(password.buffer);
+						}
+					}
+					memset(username.buffer, 0, username.len);
+					kfree(username.buffer);
+				}
+			}
+			kfree(server.buffer);
+		}
+	}
+
+	return (retCode);
+}
+
+static int daemon_logout(struct logout *Logout, struct schandle *Session)
+{
+	struct logout lLogout;
+	struct qstr server;
+	int retCode = -ENOMEM;
+
+	if (copy_from_user(&lLogout, Logout, sizeof(lLogout)))
+		return -EFAULT;
+
+	server.name = kmalloc(lLogout.Server.length, GFP_KERNEL);
+	if (!server.name)
+		return -ENOMEM;
+	server.len = lLogout.Server.length;
+	if (copy_from_user((void *)server.name, lLogout.Server.data, server.len))
+		goto exit;
+
+	retCode = do_logout(&server, Session);
+exit:
+	kfree(server.name);
+	return retCode;
+}
+
+int Daemon_CreateSessionId(struct schandle *SessionId)
+{
+	CREATE_CONTEXT_REQUEST cmd;
+	PCREATE_CONTEXT_REPLY reply;
+	unsigned long replylen = 0;
+	int retCode = 0;
+
+	DbgPrint("Daemon_CreateSessionId: %d\n", current->pid);
+
+	cmd.Command.CommandType = VFS_COMMAND_CREATE_CONTEXT;
+	cmd.Command.SequenceNumber = 0;
+	SC_INITIALIZE(cmd.Command.SessionId);
+
+	retCode =
+	    Queue_Daemon_Command(&cmd, sizeof(cmd), NULL, 0, (void *)&reply,
+				 &replylen, INTERRUPTIBLE);
+	if (reply) {
+		if (!reply->Reply.ErrorCode
+		    && replylen > sizeof(COMMAND_REPLY_HEADER)) {
+			*SessionId = reply->SessionId;
+			retCode = 0;
+		} else {
+			SessionId->hTypeId = 0;
+			SessionId->hId = 0;
+			retCode = -EIO;
+		}
+		kfree(reply);
+	}
+	DbgPrint("Daemon_CreateSessionId: SessionId=0x%llx\n", *SessionId);
+	return (retCode);
+}
+
+int Daemon_DestroySessionId(struct schandle *SessionId)
+{
+	DESTROY_CONTEXT_REQUEST cmd;
+	PDESTROY_CONTEXT_REPLY reply;
+	unsigned long replylen = 0;
+	int retCode = 0;
+
+	DbgPrint("Daemon_DestroySessionId: 0x%p:%p\n",
+		 SessionId->hTypeId, SessionId->hId);
+
+	cmd.Command.CommandType = VFS_COMMAND_DESTROY_CONTEXT;
+	cmd.Command.SequenceNumber = 0;
+	memcpy(&cmd.Command.SessionId, SessionId, sizeof (*SessionId));
+
+	retCode =
+	    Queue_Daemon_Command(&cmd, sizeof(cmd), NULL, 0, (void *)&reply,
+				 &replylen, INTERRUPTIBLE);
+	if (reply) {
+		if (!reply->Reply.ErrorCode) {
+			drive_map_t *dm;
+			struct list_head *list;
+
+			retCode = 0;
+
+			/*
+			 * When destroying the session check to see if there are any
+			 * mapped drives.  If there are then remove them.
+			 */
+			down(&DriveMapLock);
+			list_for_each(list, &DriveMapList) {
+				struct schandle *temp;
+
+				dm = list_entry(list, drive_map_t, list);
+				temp = &dm->session;
+				if (SC_EQUAL(SessionId, temp)) {
+					local_unlink(dm->name);
+					list = list->prev;
+					list_del(&dm->list);
+					kfree(dm);
+				}
+
+			}
+			up(&DriveMapLock);
+
+		} else {
+			retCode = -EIO;
+		}
+		kfree(reply);
+	}
+	return (retCode);
+}
+
+int Daemon_Get_UserSpace(struct schandle *SessionId, uint64_t * TotalSize,
+			 uint64_t * Free, uint64_t * TotalEnties,
+			 uint64_t * FreeEnties)
+{
+	GET_USER_SPACE_REQUEST cmd;
+	PGET_USER_SPACE_REPLY reply;
+	unsigned long replylen = 0;
+	int retCode = 0;
+
+	DbgPrint("Daemon_Get_UserSpace: 0x%p:%p\n",
+		 SessionId->hTypeId, SessionId->hId);
+
+	cmd.Command.CommandType = VFS_COMMAND_GET_USER_SPACE;
+	cmd.Command.SequenceNumber = 0;
+	memcpy(&cmd.Command.SessionId, SessionId, sizeof (*SessionId));
+
+	retCode =
+	    Queue_Daemon_Command(&cmd, sizeof(cmd), NULL, 0, (void *)&reply,
+				 &replylen, INTERRUPTIBLE);
+	if (reply) {
+		if (!reply->Reply.ErrorCode) {
+
+			DbgPrint("TotalSpace:  %llu\n", reply->TotalSpace);
+			DbgPrint("FreeSpace:   %llu\n", reply->FreeSpace);
+			DbgPrint("TotalEnties: %llu\n", reply->TotalEnties);
+			DbgPrint("FreeEnties:  %llu\n", reply->FreeEnties);
+
+			if (TotalSize)
+				*TotalSize = reply->TotalSpace;
+			if (Free)
+				*Free = reply->FreeSpace;
+			if (TotalEnties)
+				*TotalEnties = reply->TotalEnties;
+			if (FreeEnties)
+				*FreeEnties = reply->FreeEnties;
+			retCode = 0;
+		} else {
+			retCode = -EIO;
+		}
+		kfree(reply);
+	}
+	return (retCode);
+}
+
+/*++======================================================================*/
+int Daemon_SetMountPoint(char *Path)
+/*
+ *
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	PSET_MOUNT_PATH_REQUEST cmd;
+	PSET_MOUNT_PATH_REPLY reply;
+	unsigned long replylen, cmdlen;
+	int retCode = -ENOMEM;
+
+	DbgPrint("Daemon_SetMountPoint: %s\n", Path);
+
+	replylen = strlen(Path);
+	cmdlen = sizeof(SET_MOUNT_PATH_REQUEST) + replylen;
+
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
+	if (!cmd)
+		return -ENOMEM;
+
+	cmd->Command.CommandType = VFS_COMMAND_SET_MOUNT_PATH;
+	cmd->Command.SequenceNumber = 0;
+	SC_INITIALIZE(cmd->Command.SessionId);
+	cmd->PathLength = replylen;
+
+	strcpy(cmd->Path, Path);
+
+	replylen = 0;
+
+	retCode = Queue_Daemon_Command(cmd, cmdlen, NULL, 0, (void *)&reply, &replylen, INTERRUPTIBLE);
+	if (reply) {
+		if (!reply->Reply.ErrorCode) {
+			retCode = 0;
+		} else {
+			retCode = -EIO;
+		}
+		kfree(reply);
+	}
+	kfree(cmd);
+	return retCode;
+}
+
+/*++======================================================================*/
+int Daemon_SendDebugCmd(char *Command)
+/*
+ *
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	DEBUG_REQUEST cmd;
+	PDEBUG_REPLY reply;
+	DEBUG_REPLY lreply;
+	unsigned long replylen, cmdlen;
+	struct data_list dlist[2];
+
+	int retCode = -ENOMEM;
+
+	DbgPrint("Daemon_SendDebugCmd: %s\n", Command);
+
+	dlist[0].page = NULL;
+	dlist[0].offset = (char *)Command;
+	dlist[0].len = strlen(Command);
+	dlist[0].rwflag = DLREAD;
+
+	dlist[1].page = NULL;
+	dlist[1].offset = (char *)&lreply;
+	dlist[1].len = sizeof(lreply);
+	dlist[1].rwflag = DLWRITE;
+
+	cmdlen = offsetof(DEBUG_REQUEST, dbgcmd);
+
+	cmd.Command.CommandType = VFS_COMMAND_DBG;
+	cmd.Command.SequenceNumber = 0;
+	SC_INITIALIZE(cmd.Command.SessionId);
+	cmd.cmdlen = strlen(Command);
+
+	replylen = 0;
+
+	retCode = Queue_Daemon_Command(&cmd, cmdlen, dlist, 2, (void *)&reply, &replylen, INTERRUPTIBLE);
+	if (reply) {
+		kfree(reply);
+	}
+	if (0 == retCode) {
+		retCode = lreply.Reply.ErrorCode;
+	}
+
+	return (retCode);
+}
+
+int Daemon_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int retCode = -ENOSYS;
+	unsigned long cpylen;
+	struct schandle session_id;
+
+	session_id = Scope_Get_SessionId(NULL);
+
+	switch (cmd) {
+	case IOC_LOGIN:
+		retCode = daemon_login((struct login *)arg, &session_id);
+		break;
+
+	case IOC_LOGOUT:
+		retCode = daemon_logout((struct logout *) arg, &session_id);
+		break;
+	case IOC_DEBUGPRINT:
+		{
+			struct Ioctl_Debug {
+				int length;
+				char *data;
+			} io;
+			char *buf;
+			io.length = 0;
+			cpylen = copy_from_user(&io, (char *)arg, sizeof(io));
+			if (io.length) {
+				buf = kmalloc(io.length + 1, GFP_KERNEL);
+				if (buf) {
+					buf[0] = 0;
+					cpylen =
+					    copy_from_user(buf, io.data,
+							   io.length);
+					buf[io.length] = '\0';
+					DbgPrint("%s", buf);
+					kfree(buf);
+					retCode = 0;
+				}
+			}
+			break;
+		}
+
+	case IOC_XPLAT:
+		{
+			XPLAT data;
+
+			cpylen =
+			    copy_from_user(&data, (void *)arg, sizeof(data));
+			retCode = ((data.xfunction & 0x0000FFFF) | 0xCC000000);
+
+			switch (data.xfunction) {
+			case NWC_GET_MOUNT_PATH:
+				DbgPrint
+				    ("[Daemon_ioctl] Call NwdGetMountPath\n");
+				retCode = NwdGetMountPath(&data);
+				break;
+			}
+
+			DbgPrint("[NOVFS XPLAT] status Code = %X\n", retCode);
+			break;
+		}
+
+	}
+	return (retCode);
+}
+
+int Daemon_Added_Resource(daemon_handle_t *DHandle, int Type, HANDLE CHandle, unsigned char *FHandle, unsigned long Mode, unsigned long Size)
+{
+	daemon_resource_t *resource;
+
+	if (FHandle)
+		DbgPrint("Daemon_Added_Resource: DHandle=0x%p Type=%d CHandle=0x%p FHandle=0x%x Mode=0x%x Size=%d\n", DHandle, Type, CHandle, *(u32 *) & FHandle[2], Mode, Size);
+	else
+		DbgPrint("Daemon_Added_Resource: DHandle=0x%p Type=%d CHandle=0x%p\n", DHandle, Type, CHandle);
+
+	resource = kmalloc(sizeof(daemon_resource_t), GFP_KERNEL);
+	if (!resource)
+		return -ENOMEM;
+
+	resource->type = Type;
+	resource->connection = CHandle;
+	if (FHandle)
+		memcpy(resource->handle, FHandle, sizeof(resource->handle));
+	else
+		memset(resource->handle, 0, sizeof(resource->handle));
+	resource->mode = Mode;
+	resource->size = Size;
+	write_lock(&DHandle->lock);
+	list_add(&resource->list, &DHandle->list);
+	write_unlock(&DHandle->lock);
+	DbgPrint("Daemon_Added_Resource: Adding resource=0x%p\n", resource);
+
+	return 0;
+}
+
+/*++======================================================================*/
+int Daemon_Remove_Resource(daemon_handle_t * DHandle, int Type, HANDLE CHandle,
+			   unsigned long FHandle)
+/*
+ *
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	daemon_resource_t *resource;
+	struct list_head *l;
+	int retVal = -ENOMEM;
+
+	DbgPrint
+	    ("Daemon_Remove_Resource: DHandle=0x%p Type=%d CHandle=0x%p FHandle=0x%x\n",
+	     DHandle, Type, CHandle, FHandle);
+
+	write_lock(&DHandle->lock);
+
+	list_for_each(l, &DHandle->list) {
+		resource = list_entry(l, daemon_resource_t, list);
+
+		if ((Type == resource->type) &&
+		    (resource->connection == CHandle)) {
+			DbgPrint
+			    ("Daemon_Remove_Resource: Found resource=0x%p\n",
+			     resource);
+			l = l->prev;
+			list_del(&resource->list);
+			kfree(resource);
+			break;
+		}
+	}
+
+	write_unlock(&DHandle->lock);
+
+	return (retVal);
+}
+
+int Daemon_Library_open(struct inode *inode, struct file *file)
+{
+	daemon_handle_t *dh;
+
+	DbgPrint("Daemon_Library_open: inode=0x%p file=0x%p\n", inode, file);
+
+	dh = kmalloc(sizeof(daemon_handle_t), GFP_KERNEL);
+	if (!dh)
+		return -ENOMEM;
+
+	file->private_data = dh;
+	INIT_LIST_HEAD(&dh->list);
+	rwlock_init(&dh->lock);
+	dh->session = Scope_Get_SessionId(NULL);
+
+	return 0;
+}
+
+/*++======================================================================*/
+int Daemon_Library_close(struct inode *inode, struct file *file)
+/*
+ *
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	daemon_handle_t *dh;
+	daemon_resource_t *resource;
+	struct list_head *l;
+
+	char commanddata[sizeof(XPLAT_CALL_REQUEST) + sizeof(NwdCCloseConn)];
+	PXPLAT_CALL_REQUEST cmd;
+	PXPLAT_CALL_REPLY reply;
+	PNwdCCloseConn nwdClose;
+	unsigned long cmdlen, replylen;
+
+	DbgPrint("Daemon_Library_close: inode=0x%p file=0x%p\n", inode, file);
+	if (file->private_data) {
+		dh = (daemon_handle_t *) file->private_data;
+
+		list_for_each(l, &dh->list) {
+			resource = list_entry(l, daemon_resource_t, list);
+
+			if (DH_TYPE_STREAM == resource->type) {
+				Novfs_Close_Stream(resource->connection,
+						   resource->handle,
+						   dh->session);
+			} else if (DH_TYPE_CONNECTION == resource->type) {
+				cmd = (PXPLAT_CALL_REQUEST) commanddata;
+				cmdlen =
+				    offsetof(XPLAT_CALL_REQUEST,
+					     data) + sizeof(NwdCCloseConn);
+				cmd->Command.CommandType =
+				    VFS_COMMAND_XPLAT_CALL;
+				cmd->Command.SequenceNumber = 0;
+				cmd->Command.SessionId = dh->session;
+				cmd->NwcCommand = NWC_CLOSE_CONN;
+
+				cmd->dataLen = sizeof(NwdCCloseConn);
+				nwdClose = (PNwdCCloseConn) cmd->data;
+				nwdClose->ConnHandle =
+				    (HANDLE) resource->connection;
+
+				Queue_Daemon_Command((void *)cmd, cmdlen, NULL,
+						     0, (void **)&reply,
+						     &replylen, 0);
+				if (reply)
+					kfree(reply);
+			}
+			l = l->prev;
+			list_del(&resource->list);
+			kfree(resource);
+		}
+		kfree(dh);
+		file->private_data = NULL;
+	}
+
+	return (0);
+}
+
+ssize_t Daemon_Library_read(struct file *file, char __user *buf, size_t len, loff_t *off)
+{
+	daemon_handle_t *dh;
+	daemon_resource_t *resource;
+
+	size_t thisread, totalread = 0;
+	loff_t offset = *off;
+
+	DbgPrint("Daemon_Library_read: file=0x%p len=%d off=%lld\n", file, len,
+		 *off);
+
+	if (file->private_data) {
+		dh = file->private_data;
+		read_lock(&dh->lock);
+		if (&dh->list != dh->list.next) {
+			resource =
+			    list_entry(dh->list.next, daemon_resource_t, list);
+
+			if (DH_TYPE_STREAM == resource->type) {
+				while (len > 0 && (offset < resource->size)) {
+					thisread = len;
+					if (Novfs_Read_Stream
+					    (resource->connection,
+					     resource->handle, buf, &thisread,
+					     &offset, 1, dh->session)
+					    || !thisread) {
+						break;
+					}
+					len -= thisread;
+					buf += thisread;
+					offset += thisread;
+					totalread += thisread;
+				}
+			}
+		}
+		read_unlock(&dh->lock);
+	}
+	*off = offset;
+	DbgPrint("Daemon_Library_read return = 0x%x\n", totalread);
+	return (totalread);
+}
+
+ssize_t Daemon_Library_write(struct file *file, const char __user *buf, size_t len, loff_t *off)
+{
+	daemon_handle_t *dh;
+	daemon_resource_t *resource;
+
+	size_t thiswrite, totalwrite = -EINVAL;
+	loff_t offset = *off;
+	int status;
+
+	DbgPrint("Daemon_Library_write: file=0x%p len=%d off=%lld\n", file, len,
+		 *off);
+
+	if (file->private_data) {
+		dh = file->private_data;
+		write_lock(&dh->lock);
+		if (&dh->list != dh->list.next) {
+			resource =
+			    list_entry(dh->list.next, daemon_resource_t, list);
+
+			if ((DH_TYPE_STREAM == resource->type) && (len >= 0)) {
+				totalwrite = 0;
+				do {
+					thiswrite = len;
+					status =
+					    Novfs_Write_Stream(resource->
+							       connection,
+							       resource->handle,
+							       (void *)buf,
+							       &thiswrite,
+							       &offset,
+							       dh->session);
+					if (status || !thiswrite) {
+						/*
+						 * If len is zero then the file will have just been
+						 * truncated to offset.  Update size.
+						 */
+						if (!status && !len) {
+							resource->size = offset;
+						}
+						totalwrite = status;
+						break;
+					}
+					len -= thiswrite;
+					buf += thiswrite;
+					offset += thiswrite;
+					totalwrite += thiswrite;
+					if (offset > resource->size) {
+						resource->size = offset;
+					}
+				} while (len > 0);
+			}
+		}
+		write_unlock(&dh->lock);
+	}
+	*off = offset;
+	DbgPrint("Daemon_Library_write return = 0x%x\n", totalwrite);
+
+	return (totalwrite);
+}
+
+/*++======================================================================*/
+loff_t Daemon_Library_llseek(struct file * file, loff_t offset, int origin)
+/*
+ *
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	daemon_handle_t *dh;
+	daemon_resource_t *resource;
+
+	loff_t retVal = -EINVAL;
+
+	DbgPrint("Daemon_Library_llseek: file=0x%p offset=%lld origin=%d\n",
+		 file, offset, origin);
+
+	if (file->private_data) {
+		dh = file->private_data;
+		read_lock(&dh->lock);
+		if (&dh->list != dh->list.next) {
+			resource =
+			    list_entry(dh->list.next, daemon_resource_t, list);
+
+			if (DH_TYPE_STREAM == resource->type) {
+				switch (origin) {
+				case 2:
+					offset += resource->size;
+					break;
+				case 1:
+					offset += file->f_pos;
+				}
+				if (offset >= 0) {
+					if (offset != file->f_pos) {
+						file->f_pos = offset;
+						file->f_version = 0;
+					}
+					retVal = offset;
+				}
+			}
+		}
+		read_unlock(&dh->lock);
+	}
+
+	DbgPrint("Daemon_Library_llseek: ret %lld\n", retVal);
+
+	return retVal;
+}
+
+int Daemon_Library_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int retCode = -ENOSYS;
+	daemon_handle_t *dh;
+	HANDLE handle = NULL;
+	unsigned long cpylen;
+
+	dh = file->private_data;
+
+	DbgPrint("Daemon_Library_ioctl: file=0x%p 0x%x 0x%p dh=0x%p\n", file,
+		 cmd, arg, dh);
+
+	if (dh) {
+
+		switch (cmd) {
+		case IOC_LOGIN:
+			retCode = daemon_login((struct login *)arg, &dh->session);
+			break;
+
+		case IOC_LOGOUT:
+			retCode = daemon_logout((struct logout *)arg, &dh->session);
+			break;
+
+		case IOC_DEBUGPRINT:
+			{
+				struct Ioctl_Debug {
+					int length;
+					char *data;
+				} io;
+				char *buf;
+				io.length = 0;
+				cpylen =
+				    copy_from_user(&io, (void *)arg,
+						   sizeof(io));
+				if (io.length) {
+					buf = kmalloc(io.length + 1, GFP_KERNEL);
+					if (buf) {
+						buf[0] = 0;
+						cpylen = copy_from_user(buf, io.data, io.length);
+						buf[io.length] = '\0';
+						DbgPrint("%s", buf);
+						kfree(buf);
+						retCode = 0;
+					}
+				}
+				break;
+			}
+
+		case IOC_XPLAT:
+			{
+				XPLAT data;
+
+				cpylen =
+				    copy_from_user(&data, (void *)arg,
+						   sizeof(data));
+				retCode =
+				    ((data.
+				      xfunction & 0x0000FFFF) | 0xCC000000);
+
+				switch (data.xfunction) {
+				case NWC_OPEN_CONN_BY_NAME:
+					DbgPrint("[VFS XPLAT] Call NwOpenConnByName\n");
+					retCode = NwOpenConnByName(&data, &handle, dh->session);
+					if (!retCode)
+						Daemon_Added_Resource(dh, DH_TYPE_CONNECTION, handle, NULL, 0, 0);
+					break;
+
+				case NWC_OPEN_CONN_BY_ADDRESS:
+					DbgPrint("[VFS XPLAT] Call NwOpenConnByAddress\n");
+					retCode = NwOpenConnByAddr(&data, &handle, dh->session);
+					if (!retCode)
+						Daemon_Added_Resource(dh, DH_TYPE_CONNECTION, handle, NULL, 0, 0);
+					break;
+
+				case NWC_OPEN_CONN_BY_REFERENCE:
+					DbgPrint("[VFS XPLAT] Call NwOpenConnByReference\n");
+					retCode = NwOpenConnByRef(&data, &handle, dh->session);
+					if (!retCode)
+						Daemon_Added_Resource(dh,
+								      DH_TYPE_CONNECTION,
+								      handle, NULL,
+								      0, 0);
+					break;
+
+				case NWC_SYS_CLOSE_CONN:
+					DbgPrint("[VFS XPLAT] Call NwSysCloseConn\n");
+					retCode = NwSysConnClose(&data, (unsigned long *)&handle, dh->session);
+					Daemon_Remove_Resource(dh, DH_TYPE_CONNECTION, handle, 0);
+					break;
+
+				case NWC_CLOSE_CONN:
+					DbgPrint
+					    ("[VFS XPLAT] Call NwCloseConn\n");
+					retCode =
+					    NwConnClose(&data, &handle,
+							dh->session);
+					Daemon_Remove_Resource(dh,
+							       DH_TYPE_CONNECTION,
+							       handle, 0);
+					break;
+
+				case NWC_LOGIN_IDENTITY:
+					DbgPrint("[VFS XPLAT] Call NwLoginIdentity\n");
+					retCode = NwLoginIdentity(&data, &dh->session);
+					break;
+
+				case NWC_RAW_NCP_REQUEST:
+					DbgPrint("[VFS XPLAT] Send Raw NCP Request\n");
+					retCode = NwRawSend(&data, dh->session);
+					break;
+
+				case NWC_AUTHENTICATE_CONN_WITH_ID:
+					DbgPrint
+					    ("[VFS XPLAT] Authenticate Conn With ID\n");
+					retCode =
+					    NwAuthConnWithId(&data,
+							     dh->session);
+					break;
+
+				case NWC_UNAUTHENTICATE_CONN:
+					DbgPrint
+					    ("[VFS XPLAT] UnAuthenticate Conn With ID\n");
+					retCode =
+					    NwUnAuthenticate(&data,
+							     dh->session);
+					break;
+
+				case NWC_LICENSE_CONN:
+					DbgPrint("Call NwLicenseConn\n");
+					retCode =
+					    NwLicenseConn(&data, dh->session);
+					break;
+
+				case NWC_LOGOUT_IDENTITY:
+					DbgPrint
+					    ("[VFS XPLAT] Call NwLogoutIdentity\n");
+					retCode =
+					    NwLogoutIdentity(&data,
+							     dh->session);
+					break;
+
+				case NWC_UNLICENSE_CONN:
+					DbgPrint
+					    ("[VFS XPLAT] Call NwUnlicense\n");
+					retCode =
+					    NwUnlicenseConn(&data, dh->session);
+					break;
+
+				case NWC_GET_CONN_INFO:
+					DbgPrint
+					    ("[VFS XPLAT] Call NwGetConnInfo\n");
+					retCode =
+					    NwGetConnInfo(&data, dh->session);
+					break;
+
+				case NWC_SET_CONN_INFO:
+					DbgPrint
+					    ("[VFS XPLAT] Call NwGetConnInfo\n");
+					retCode =
+					    NwSetConnInfo(&data, dh->session);
+					break;
+
+				case NWC_SCAN_CONN_INFO:
+					DbgPrint
+					    ("[VFS XPLAT] Call NwScanConnInfo\n");
+					retCode =
+					    NwScanConnInfo(&data, dh->session);
+					break;
+
+				case NWC_GET_IDENTITY_INFO:
+					DbgPrint
+					    ("[VFS XPLAT] Call NwGetIdentityInfo\n");
+					retCode =
+					    NwGetIdentityInfo(&data,
+							      dh->session);
+					break;
+
+				case NWC_GET_REQUESTER_VERSION:
+					DbgPrint
+					    ("[VFS XPLAT] Call NwGetDaemonVersion\n");
+					retCode =
+					    NwGetDaemonVersion(&data,
+							       dh->session);
+					break;
+
+				case NWC_GET_PREFERRED_DS_TREE:
+					DbgPrint
+					    ("[VFS XPLAT] Call NwcGetPreferredDsTree\n");
+					retCode =
+					    NwcGetPreferredDSTree(&data,
+								  dh->session);
+					break;
+
+				case NWC_SET_PREFERRED_DS_TREE:
+					DbgPrint
+					    ("[VFS XPLAT] Call NwcSetPreferredDsTree\n");
+					retCode =
+					    NwcSetPreferredDSTree(&data,
+								  dh->session);
+					break;
+
+				case NWC_GET_DEFAULT_NAME_CONTEXT:
+					DbgPrint
+					    ("[VFS XPLAT] Call NwcGetDefaultNameContext\n");
+					retCode =
+					    NwcGetDefaultNameCtx(&data,
+								 dh->session);
+					break;
+
+				case NWC_SET_DEFAULT_NAME_CONTEXT:
+					DbgPrint
+					    ("[VFS XPLAT] Call NwcSetDefaultNameContext\n");
+					retCode =
+					    NwcSetDefaultNameCtx(&data,
+								 dh->session);
+					break;
+
+				case NWC_QUERY_FEATURE:
+					DbgPrint
+					    ("[VFS XPLAT] Call NwQueryFeature\n");
+					retCode =
+					    NwQueryFeature(&data, dh->session);
+					break;
+
+				case NWC_GET_TREE_MONITORED_CONN_REF:
+					DbgPrint
+					    ("[VFS XPLAT] Call NwcGetTreeMonitoredConn\n");
+					retCode =
+					    NwcGetTreeMonitoredConn(&data,
+								    dh->
+								    session);
+					break;
+
+				case NWC_ENUMERATE_IDENTITIES:
+					DbgPrint
+					    ("[VFS XPLAT] Call NwcEnumerateIdentities\n");
+					retCode =
+					    NwcEnumIdentities(&data,
+							      dh->session);
+					break;
+
+				case NWC_CHANGE_KEY:
+					DbgPrint
+					    ("[VFS XPLAT] Call NwcChangeAuthKey\n");
+					retCode =
+					    NwcChangeAuthKey(&data,
+							     dh->session);
+					break;
+
+				case NWC_CONVERT_LOCAL_HANDLE:
+					DbgPrint
+					    ("[VFS XPLAT] Call NwdConvertLocalHandle\n");
+					retCode =
+					    NwdConvertLocalHandle(&data, dh);
+					break;
+
+				case NWC_CONVERT_NETWARE_HANDLE:
+					DbgPrint
+					    ("[VFS XPLAT] Call NwdConvertNetwareHandle\n");
+					retCode =
+					    NwdConvertNetwareHandle(&data, dh);
+					break;
+
+				case NWC_SET_PRIMARY_CONN:
+					DbgPrint
+					    ("[VFS XPLAT] Call NwcSetPrimaryConn\n");
+					retCode =
+					    NwcSetPrimaryConn(&data,
+							      dh->session);
+					break;
+
+				case NWC_GET_PRIMARY_CONN:
+					DbgPrint
+					    ("[VFS XPLAT] Call NwcGetPrimaryConn\n");
+					retCode =
+					    NwcGetPrimaryConn(&data,
+							      dh->session);
+					break;
+
+				case NWC_MAP_DRIVE:
+					DbgPrint("[VFS XPLAT] Call NwcMapDrive\n");
+					retCode = NwdSetMapDrive(&data, dh->session);
+					break;
+
+				case NWC_UNMAP_DRIVE:
+					DbgPrint
+					    ("[VFS XPLAT] Call NwcUnMapDrive\n");
+					retCode = NwdUnMapDrive(&data, dh->session);
+					break;
+
+				case NWC_ENUMERATE_DRIVES:
+					DbgPrint
+					    ("[VFS XPLAT] Call NwcEnumerateDrives\n");
+					retCode =
+					    NwcEnumerateDrives(&data,
+							       dh->session);
+					break;
+
+				case NWC_GET_MOUNT_PATH:
+					DbgPrint
+					    ("[VFS XPLAT] Call NwdGetMountPath\n");
+					retCode = NwdGetMountPath(&data);
+					break;
+
+				case NWC_GET_BROADCAST_MESSAGE:
+					DbgPrint
+					    ("[VSF XPLAT Call NwdGetBroadcastMessage\n");
+					retCode =
+					    NwcGetBroadcastMessage(&data,
+								   dh->session);
+					break;
+
+				case NWC_SET_KEY:
+					DbgPrint("[VSF XPLAT Call NwdSetKey\n");
+					retCode =
+					    NwdSetKeyValue(&data, dh->session);
+					break;
+
+				case NWC_VERIFY_KEY:
+					DbgPrint
+					    ("[VSF XPLAT Call NwdVerifyKey\n");
+					retCode =
+					    NwdVerifyKeyValue(&data,
+							      dh->session);
+					break;
+
+				case NWC_RAW_NCP_REQUEST_ALL:
+				case NWC_NDS_RESOLVE_NAME_TO_ID:
+				case NWC_FRAGMENT_REQUEST:
+				case NWC_GET_CONFIGURED_NSPS:
+				default:
+					break;
+
+				}
+
+				DbgPrint("[NOVFS XPLAT] status Code = %X\n",
+					 retCode);
+				break;
+			}
+		}
+	}
+
+	return (retCode);
+}
+
+unsigned int Daemon_Poll(struct file *file, struct poll_table_struct *poll_table)
+{
+	daemon_command_t *que;
+	unsigned int mask = POLLOUT | POLLWRNORM;
+
+	que = get_next_queue(0);
+	if (que)
+		mask |= (POLLIN | POLLRDNORM);
+	return mask;
+}
+
+int NwdConvertNetwareHandle(PXPLAT pdata, daemon_handle_t *DHandle)
+{
+	int retVal;
+	NwcConvertNetWareHandle nh;
+	unsigned long cpylen;
+
+	DbgPrint("NwdConvertNetwareHandle: DHandle=0x%p\n", DHandle);
+
+	cpylen = copy_from_user(&nh, pdata->reqData, sizeof(NwcConvertNetWareHandle));
+
+	retVal = Daemon_Added_Resource(DHandle, DH_TYPE_STREAM,
+				       Uint32toHandle(nh.ConnHandle),
+				       nh.NetWareHandle, nh.uAccessMode,
+				       nh.uFileSize);
+
+	return retVal;
+}
+
+/*++======================================================================*/
+int NwdConvertLocalHandle(PXPLAT pdata, daemon_handle_t * DHandle)
+/*
+ *
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	int retVal = NWE_REQUESTER_FAILURE;
+	daemon_resource_t *resource;
+	NwcConvertLocalHandle lh;
+	struct list_head *l;
+	unsigned long cpylen;
+
+	DbgPrint("NwdConvertLocalHandle: DHandle=0x%p\n", DHandle);
+
+	read_lock(&DHandle->lock);
+
+	list_for_each(l, &DHandle->list) {
+		resource = list_entry(l, daemon_resource_t, list);
+
+		if (DH_TYPE_STREAM == resource->type) {
+			lh.uConnReference =
+			    HandletoUint32(resource->connection);
+
+//sgled         memcpy(lh.NwWareHandle, resource->handle, sizeof(resource->handle));
+			memcpy(lh.NetWareHandle, resource->handle, sizeof(resource->handle));	//sgled
+			if (pdata->repLen >= sizeof(NwcConvertLocalHandle)) {
+				cpylen =
+				    copy_to_user(pdata->repData, &lh,
+						 sizeof(NwcConvertLocalHandle));
+				retVal = 0;
+			} else {
+				retVal = NWE_BUFFER_OVERFLOW;
+			}
+			break;
+		}
+	}
+
+	read_unlock(&DHandle->lock);
+
+	return (retVal);
+}
+
+/*++======================================================================*/
+int NwdGetMountPath(PXPLAT pdata)
+/*
+ *
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	int retVal = NWE_REQUESTER_FAILURE;
+	int len;
+	unsigned long cpylen;
+	NwcGetMountPath mp;
+
+	cpylen = copy_from_user(&mp, pdata->reqData, pdata->reqLen);
+
+	if (Novfs_CurrentMount) {
+
+		len = strlen(Novfs_CurrentMount) + 1;
+		if ((len > mp.MountPathLen) && mp.pMountPath) {
+			retVal = NWE_BUFFER_OVERFLOW;
+		} else {
+			if (mp.pMountPath) {
+				cpylen =
+				    copy_to_user(mp.pMountPath,
+						 Novfs_CurrentMount, len);
+			}
+			retVal = 0;
+		}
+
+		mp.MountPathLen = len;
+
+		if (pdata->repData && (pdata->repLen >= sizeof(mp))) {
+			cpylen = copy_to_user(pdata->repData, &mp, sizeof(mp));
+		}
+	}
+
+	return (retVal);
+}
+
+static int NwdSetMapDrive(PXPLAT pdata, session_t Session)
+{
+	int retVal;
+	NwcMapDriveEx symInfo;
+	char *path;
+	drive_map_t *drivemap, *dm;
+	struct list_head *list;
+
+	retVal = NwcSetMapDrive(pdata, Session);
+	if (retVal)
+		return retVal;
+
+	if (copy_from_user(&symInfo, pdata->reqData, sizeof(symInfo)))
+		return -EFAULT;
+
+	drivemap = kmalloc(sizeof(drive_map_t) + symInfo.linkOffsetLength, GFP_KERNEL);
+	if (!drivemap)
+		return -ENOMEM;
+
+	path = (char *)pdata->reqData;
+	path += symInfo.linkOffset;
+	if (copy_from_user(drivemap->name, path, symInfo.linkOffsetLength)) {
+		kfree(drivemap);
+		return -EFAULT;
+	}
+
+	drivemap->session = Session;
+	drivemap->hash = full_name_hash(drivemap->name, symInfo.linkOffsetLength - 1);
+	drivemap->namelen = symInfo.linkOffsetLength - 1;
+	DbgPrint("NwdSetMapDrive: hash=0x%x path=%s\n", drivemap->hash, drivemap->name);
+
+	dm = (drive_map_t *) & DriveMapList.next;
+
+	down(&DriveMapLock);
+
+	list_for_each(list, &DriveMapList) {
+		dm = list_entry(list, drive_map_t, list);
+		DbgPrint("NwdSetMapDrive: dm=0x%p\n"
+			 "   hash:    0x%x\n"
+			 "   namelen: %d\n"
+			 "   name:    %s\n",
+			 dm, dm->hash, dm->namelen, dm->name);
+
+		if (drivemap->hash == dm->hash) {
+			if (0 ==
+			    strcmp(dm->name, drivemap->name)) {
+				dm = NULL;
+				break;
+			}
+		} else if (drivemap->hash < dm->hash) {
+			break;
+		}
+	}
+
+	if (dm) {
+		if ((dm == (drive_map_t *) & DriveMapList) ||
+		    (dm->hash < drivemap->hash)) {
+			list_add(&drivemap->list, &dm->list);
+		} else {
+			list_add_tail(&drivemap->list,
+				      &dm->list);
+		}
+	} else {
+		kfree(drivemap);
+	}
+	up(&DriveMapLock);
+
+	return (retVal);
+}
+
+static int NwdUnMapDrive(PXPLAT pdata, session_t Session)
+{
+	int retVal = NWE_REQUESTER_FAILURE;
+	NwcUnmapDriveEx symInfo;
+	char *path;
+	drive_map_t *dm;
+	struct list_head *list;
+	unsigned long hash;
+
+	retVal = NwcUnMapDrive(pdata, Session);
+	if (retVal)
+		return retVal;
+
+	if (copy_from_user(&symInfo, pdata->reqData, sizeof(symInfo)))
+		return -EFAULT;
+
+	path = kmalloc(symInfo.linkLen, GFP_KERNEL);
+	if (!path)
+		return -ENOMEM;
+
+	if (copy_from_user(path, ((NwcUnmapDriveEx *)pdata->reqData)->linkData, symInfo.linkLen)) {
+		kfree(path);
+		return -EFAULT;
+	}
+
+	hash = full_name_hash(path, symInfo.linkLen - 1);
+	DbgPrint("NwdUnMapDrive: hash=0x%x path=%s\n", hash, path);
+
+	dm = NULL;
+
+	down(&DriveMapLock);
+
+	list_for_each(list, &DriveMapList) {
+		dm = list_entry(list, drive_map_t, list);
+		DbgPrint("NwdUnMapDrive: dm=0x%p %s\n"
+			 "   hash:    0x%x\n"
+			 "   namelen: %d\n",
+			 dm, dm->name, dm->hash, dm->namelen);
+
+		if (hash == dm->hash) {
+			if (0 == strcmp(dm->name, path)) {
+				break;
+			}
+		} else if (hash < dm->hash) {
+			dm = NULL;
+			break;
+		}
+	}
+
+	if (dm) {
+		DbgPrint("NwdUnMapDrive: Remove dm=0x%p %s\n"
+			 "   hash:    0x%x\n"
+			 "   namelen: %d\n",
+			 dm, dm->name, dm->hash, dm->namelen);
+		list_del(&dm->list);
+		kfree(dm);
+	}
+
+	up(&DriveMapLock);
+
+	return retVal;
+}
+
+/*++======================================================================*/
+void RemoveDriveMaps(void)
+/*
+ *
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	drive_map_t *dm;
+	struct list_head *list;
+
+	down(&DriveMapLock);
+	list_for_each(list, &DriveMapList) {
+		dm = list_entry(list, drive_map_t, list);
+
+		DbgPrint("RemoveDriveMap: dm=0x%p\n"
+			 "   hash:    0x%x\n"
+			 "   namelen: %d\n"
+			 "   name:    %s\n",
+			 dm, dm->hash, dm->namelen, dm->name);
+		local_unlink(dm->name);
+		list = list->prev;
+		list_del(&dm->list);
+		kfree(dm);
+	}
+	up(&DriveMapLock);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,15)
+/*++======================================================================*/
+int local_unlink(const char *pathname)
+{
+	int error;
+	struct dentry *dentry;
+	struct nameidata nd;
+	struct inode *inode = NULL;
+
+	DbgPrint("local_unlink: %s\n", pathname);
+	error = path_lookup(pathname, LOOKUP_PARENT, &nd);
+	DbgPrint("local_unlink: path_lookup %d\n", error);
+	if (!error) {
+		error = -EISDIR;
+		if (nd.last_type == LAST_NORM) {
+			dentry = lookup_create(&nd, 1);
+			DbgPrint("local_unlink: lookup_hash 0x%p\n", dentry);
+
+			error = PTR_ERR(dentry);
+			if (!IS_ERR(dentry)) {
+				if (nd.last.name[nd.last.len]) {
+					error =
+					    !dentry->
+					    d_inode ? -ENOENT : S_ISDIR(dentry->
+									d_inode->
+									i_mode)
+					    ? -EISDIR : -ENOTDIR;
+				} else {
+					inode = dentry->d_inode;
+					if (inode) {
+						atomic_inc(&inode->i_count);
+					}
+					error = vfs_unlink(nd.path.dentry->d_inode, dentry, nd.path.mnt);
+					DbgPrint
+					    ("local_unlink: vfs_unlink %d\n",
+					     error);
+				}
+				dput(dentry);
+			}
+			mutex_unlock(&nd.path.dentry->d_inode->i_mutex);
+
+		}
+		path_put(&nd.path);
+	}
+
+	if (inode) {
+		iput(inode);	/* truncate the inode here */
+	}
+
+	DbgPrint("local_unlink: error=%d\n", error);
+	return error;
+}
+
+#else
+/*++======================================================================*/
+int local_unlink(const char *pathname)
+{
+	int error;
+	struct dentry *dentry;
+	struct nameidata nd;
+	struct inode *inode = NULL;
+
+	DbgPrint("local_unlink: %s\n", pathname);
+	error = path_lookup(pathname, LOOKUP_PARENT, &nd);
+	DbgPrint("local_unlink: path_lookup %d\n", error);
+	if (!error) {
+		error = -EISDIR;
+		if (nd.last_type == LAST_NORM) {
+			down(&nd.dentry->d_inode->i_sem);
+			dentry =
+			    lookup_one_len(&nd.last, nd.dentry,
+					   sizeof(nd.last));
+			DbgPrint("local_unlink: lookup_hash 0x%p\n", dentry);
+
+			error = PTR_ERR(dentry);
+			if (!IS_ERR(dentry)) {
+				if (nd.last.name[nd.last.len]) {
+					error =
+					    !dentry->
+					    d_inode ? -ENOENT : S_ISDIR(dentry->
+									d_inode->
+									i_mode)
+					    ? -EISDIR : -ENOTDIR;
+				} else {
+					inode = dentry->d_inode;
+					if (inode) {
+						atomic_inc(&inode->i_count);
+					}
+					error =
+					    vfs_unlink(nd.dentry->d_inode,
+						       dentry);
+					DbgPrint
+					    ("local_unlink: vfs_unlink %d\n",
+					     error);
+				}
+				dput(dentry);
+			}
+			up(&nd.dentry->d_inode->i_sem);
+		}
+		path_release(&nd);
+	}
+
+	if (inode) {
+		iput(inode);	/* truncate the inode here */
+	}
+
+	DbgPrint("local_unlink: error=%d\n", error);
+	return error;
+}
+#endif
--- /dev/null
+++ b/fs/novfs/file.c
@@ -0,0 +1,1964 @@
+/*
+ * Novell NCP Redirector for Linux
+ * Author: James Turner
+ *
+ * This file contains functions for accessing files through the daemon.
+ *
+ * Copyright (C) 2005 Novell, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/kthread.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/sched.h>
+#include <linux/dcache.h>
+#include <linux/pagemap.h>
+#include <linux/stat.h>
+#include <linux/slab.h>
+#include <asm/uaccess.h>
+
+#include "vfs.h"
+#include "commands.h"
+#include "nwerror.h"
+
+/*===[ Function prototypes ]==============================================*/
+int Novfs_get_alltrees(struct dentry *parent);
+ssize_t Novfs_tree_read(struct file *file, char *buf, size_t len, loff_t * off);
+
+int Novfs_Find_Name_In_List(struct qstr *Name, unsigned char * List);
+
+int Novfs_Create(unsigned char * Path, int DirectoryFlag, session_t SessionId);
+int Novfs_Close_File(HANDLE Handle, session_t SessionId);
+int Novfs_Read_File(HANDLE Handle, unsigned char * Buffer, size_t * Bytes,
+		    loff_t * Offset, session_t SessionId);
+int Novfs_Write_File(HANDLE Handle, unsigned char * Buffer, size_t * Bytes,
+		     loff_t * Offset, session_t SessionId);
+int Novfs_Write_Page(HANDLE Handle, struct page *Page, session_t SessionId);
+int Novfs_Read_Stream(HANDLE ConnHandle, unsigned char * Handle, unsigned char * Buffer,
+		      size_t * Bytes, loff_t * Offset, int User,
+		      session_t SessionId);
+int Novfs_Write_Stream(HANDLE ConnHandle, unsigned char * Handle, unsigned char * Buffer,
+		       size_t * Bytes, loff_t * Offset, session_t SessionId);
+int Novfs_Close_Stream(HANDLE ConnHandle, unsigned char * Handle, session_t SessionId);
+int Novfs_Delete(unsigned char * Path, int DirectoryFlag, session_t SessionId);
+int Novfs_Truncate_File(unsigned char * Path, int PathLen, session_t SessionId);
+int Novfs_Truncate_File_Ex(HANDLE Handle, loff_t Offset, session_t SessionId);
+int Novfs_Rename_File(int DirectoryFlag, unsigned char * OldName, int OldLen,
+		      unsigned char * NewName, int NewLen, session_t SessionId);
+int Novfs_Set_Attr(unsigned char * Path, struct iattr *Attr, session_t SessionId);
+int Novfs_Get_File_Cache_Flag(unsigned char * Path, session_t SessionId);
+
+static struct file_operations Novfs_tree_operations = {
+      read:Novfs_tree_read,
+};
+
+/*
+ * StripTrailingDots was added because some apps will
+ * try and create a file name with a trailing dot.  NetWare
+ * doesn't like this and will return an error.
+ */
+static int StripTrailingDots = 1;
+
+int Novfs_get_alltrees(struct dentry *parent)
+{
+	unsigned char *p;
+	PCOMMAND_REPLY_HEADER reply = NULL;
+	unsigned long replylen = 0;
+	COMMAND_REQUEST_HEADER cmd;
+	int retCode;
+	struct dentry *entry;
+	struct qstr name;
+	struct inode *inode;
+
+	cmd.CommandType = 0;
+	cmd.SequenceNumber = 0;
+//sg ???   cmd.SessionId = 0x1234;
+	SC_INITIALIZE(cmd.SessionId);
+
+	DbgPrint("Novfs_get_alltrees:\n");
+
+	retCode = Queue_Daemon_Command(&cmd, sizeof(cmd), NULL, 0, (void *)&reply, &replylen, INTERRUPTIBLE);
+	DbgPrint("Novfs_get_alltrees: relpy=0x%p replylen=%d\n", reply,
+		 replylen);
+	if (reply) {
+		mydump(replylen, reply);
+		if (!reply->ErrorCode
+		    && (replylen > sizeof(COMMAND_REPLY_HEADER))) {
+			p = (char *)reply + 8;
+			while (*p) {
+				DbgPrint("Novfs_get_alltrees: %s\n", p);
+				name.len = strlen(p);
+				name.name = p;
+				name.hash = full_name_hash(name.name, name.len);
+				entry = d_lookup(parent, &name);
+				if (NULL == entry) {
+					DbgPrint("Novfs_get_alltrees: adding %s\n", p);
+					entry = d_alloc(parent, &name);
+					if (entry) {
+						entry->d_op = &Novfs_dentry_operations;
+						inode = Novfs_get_inode(parent->d_sb, S_IFREG | 0400, 0, 0, 0, &name);
+						if (inode) {
+							inode->i_fop = &Novfs_tree_operations;
+							d_add(entry, inode);
+						}
+					}
+				}
+				p += (name.len + 1);
+			}
+		}
+		kfree(reply);
+	}
+	return (retCode);
+}
+
+ssize_t Novfs_tree_read(struct file * file, char *buf, size_t len, loff_t * off)
+{
+	if (file->f_pos != 0) {
+		return (0);
+	}
+	if (copy_to_user(buf, "Tree\n", 5)) {
+		return (0);
+	}
+	return (5);
+}
+
+int Novfs_Get_Connected_Server_List(unsigned char ** ServerList, struct schandle *SessionId)
+{
+	GET_CONNECTED_SERVER_LIST_REQUEST req;
+	PGET_CONNECTED_SERVER_LIST_REPLY reply = NULL;
+	unsigned long replylen = 0;
+	int retCode = 0;
+
+	*ServerList = NULL;
+
+	req.Command.CommandType = VFS_COMMAND_GET_CONNECTED_SERVER_LIST;
+	memcpy(&req.Command.SessionId, SessionId, sizeof(*SessionId));
+
+	retCode =
+	    Queue_Daemon_Command(&req, sizeof(req), NULL, 0, (void *)&reply,
+				 &replylen, INTERRUPTIBLE);
+	if (reply) {
+		DbgPrint("Novfs_Get_Connected_Server_List: reply\n");
+		replylen -= sizeof(COMMAND_REPLY_HEADER);
+		if (!reply->Reply.ErrorCode && replylen) {
+			memcpy(reply, reply->List, replylen);
+			*ServerList = (unsigned char *) reply;
+			retCode = 0;
+		} else {
+			kfree(reply);
+			retCode = -ENOENT;
+		}
+	}
+	return (retCode);
+}
+
+int Novfs_Get_Server_Volume_List(struct qstr *Server, unsigned char ** VolumeList,
+				 struct schandle *SessionId)
+{
+	PGET_SERVER_VOLUME_LIST_REQUEST req;
+	PGET_SERVER_VOLUME_LIST_REPLY reply = NULL;
+	unsigned long replylen = 0, reqlen;
+	int retCode;
+
+	*VolumeList = NULL;
+	reqlen = sizeof(GET_SERVER_VOLUME_LIST_REQUEST) + Server->len;
+	req = kmalloc(reqlen, GFP_KERNEL);
+	if (!req)
+		return -ENOMEM;
+	req->Command.CommandType = VFS_COMMAND_GET_SERVER_VOLUME_LIST;
+	req->Length = Server->len;
+	memcpy(req->Name, Server->name, Server->len);
+	memcpy(&req->Command.SessionId, SessionId, sizeof(*SessionId));
+
+	retCode = Queue_Daemon_Command(req, reqlen, NULL, 0, (void *)&reply,
+					 &replylen, INTERRUPTIBLE);
+	if (reply) {
+		DbgPrint("Novfs_Get_Server_Volume_List: reply\n");
+		mydump(replylen, reply);
+		replylen -= sizeof(COMMAND_REPLY_HEADER);
+
+		if (!reply->Reply.ErrorCode && replylen) {
+			memcpy(reply, reply->List, replylen);
+			*VolumeList = (unsigned char *) reply;
+			retCode = 0;
+		} else {
+			kfree(reply);
+			retCode = -ENOENT;
+		}
+	}
+	kfree(req);
+	return retCode;
+}
+
+int Novfs_Find_Name_In_List(struct qstr *Name, unsigned char * List)
+{
+	int len;
+	int retCode = 0;
+
+	while (*List) {
+		len = strlen(List);
+		if ((len == Name->len) && !strncmp(Name->name, List, len)) {
+			retCode = 1;
+			break;
+		}
+		List += (len + 1);
+	}
+	return (retCode);
+}
+
+int Novfs_Get_File_Info(unsigned char * Path, struct entry_info *Info, struct schandle *SessionId)
+{
+	PVERIFY_FILE_REPLY reply = NULL;
+	unsigned long replylen = 0;
+	PVERIFY_FILE_REQUEST cmd;
+	int cmdlen;
+	int retCode = -ENOENT;
+	int pathlen;
+
+	DbgPrint("%s: Path = %s\n", __func__, Path);
+
+	Info->mode = S_IFDIR | 0700;
+	Info->uid = current->uid;
+	Info->gid = current->gid;
+	Info->size = 0;
+	Info->atime = Info->mtime = Info->ctime = CURRENT_TIME;
+
+	if (Path && *Path) {
+		pathlen = strlen(Path);
+		if (StripTrailingDots) {
+			if ('.' == Path[pathlen - 1])
+				pathlen--;
+		}
+		cmdlen = offsetof(VERIFY_FILE_REQUEST, path) + pathlen;
+		cmd = (PVERIFY_FILE_REQUEST) Novfs_Malloc(cmdlen, GFP_KERNEL);
+		if (cmd) {
+			cmd->Command.CommandType = VFS_COMMAND_VERIFY_FILE;
+			cmd->Command.SequenceNumber = 0;
+			memcpy(&cmd->Command.SessionId, SessionId, sizeof(*SessionId));
+			cmd->pathLen = pathlen;
+			memcpy(cmd->path, Path, cmd->pathLen);
+
+			retCode =
+			    Queue_Daemon_Command(cmd, cmdlen, NULL, 0,
+						 (void *)&reply, &replylen,
+						 INTERRUPTIBLE);
+
+			if (reply) {
+
+				if (reply->Reply.ErrorCode) {
+					retCode = -ENOENT;
+				} else {
+					Info->type = 3;
+					Info->mode = S_IRWXU;
+
+					if (reply->
+					    fileMode & NW_ATTRIBUTE_DIRECTORY) {
+						Info->mode |= S_IFDIR;
+					} else {
+						Info->mode |= S_IFREG;
+					}
+
+					if (reply->
+					    fileMode & NW_ATTRIBUTE_READ_ONLY) {
+						Info->mode &= ~(S_IWUSR);
+					}
+
+					Info->uid = current->euid;
+					Info->gid = current->egid;
+					Info->size = reply->fileSize;
+					Info->atime.tv_sec =
+					    reply->lastAccessTime;
+					Info->atime.tv_nsec = 0;
+					Info->mtime.tv_sec = reply->modifyTime;
+					Info->mtime.tv_nsec = 0;
+					Info->ctime.tv_sec = reply->createTime;
+					Info->ctime.tv_nsec = 0;
+					DbgPrint("%s: replylen=%d sizeof(VERIFY_FILE_REPLY)=%d\n", __func__, replylen, sizeof(VERIFY_FILE_REPLY));
+					if (replylen > sizeof(VERIFY_FILE_REPLY)) {
+						unsigned int *lp = &reply->fileMode;
+						lp++;
+						DbgPrint("%s: extra data 0x%x\n", __func__, *lp);
+						Info->mtime.tv_nsec = *lp;
+					}
+					retCode = 0;
+				}
+
+				kfree(reply);
+			}
+			kfree(cmd);
+		}
+	}
+
+	DbgPrint("%s: return 0x%x\n", __func__, retCode);
+	return (retCode);
+}
+
+int Novfs_GetX_File_Info(char *Path, const char *Name, char *buffer,
+			 ssize_t buffer_size, ssize_t * dataLen,
+			 session_t *SessionId)
+{
+	PXA_GET_REPLY reply = NULL;
+	unsigned long replylen = 0;
+	PXA_GET_REQUEST cmd;
+	int cmdlen;
+	int retCode = -ENOENT;
+
+	int namelen = strlen(Name);
+	int pathlen = strlen(Path);
+
+	DbgPrint("%s: xattr: Path = %s, pathlen = %i, Name = %s, namelen = %i\n", __func__, Path, pathlen, Name, namelen);
+
+	if (namelen > MAX_XATTR_NAME_LEN) {
+		return ENOATTR;
+	}
+
+	cmdlen = offsetof(XA_GET_REQUEST, data) + pathlen + 1 + namelen + 1;	// two '\0'
+	cmd = (PXA_GET_REQUEST) Novfs_Malloc(cmdlen, GFP_KERNEL);
+	if (cmd) {
+		cmd->Command.CommandType = VFS_COMMAND_GET_EXTENDED_ATTRIBUTE;
+		cmd->Command.SequenceNumber = 0;
+		memcpy(&cmd->Command.SessionId, SessionId, sizeof(*SessionId));
+
+		cmd->pathLen = pathlen;
+		memcpy(cmd->data, Path, cmd->pathLen + 1);	//+ '\0'
+
+		cmd->nameLen = namelen;
+		memcpy(cmd->data + cmd->pathLen + 1, Name, cmd->nameLen + 1);
+
+		DbgPrint("%s xattr: PXA_GET_REQUEST BEGIN\n", __func__);
+		DbgPrint("%s xattr: Queue_Daemon_Command %d\n", __func__, cmd->Command.CommandType);
+		DbgPrint("%s xattr: Command.SessionId = %d\n", __func__, cmd->Command.SessionId);
+		DbgPrint("%s xattr: pathLen = %d\n", __func__, cmd->pathLen);
+		DbgPrint("%s xattr: Path = %s\n", __func__, cmd->data);
+		DbgPrint("%s xattr: nameLen = %d\n", __func__, cmd->nameLen);
+		DbgPrint("%s xattr: name = %s\n", __func__, (cmd->data + cmd->pathLen + 1));
+		DbgPrint("%s xattr: PXA_GET_REQUEST END\n", __func__);
+
+		retCode =
+		    Queue_Daemon_Command(cmd, cmdlen, NULL, 0, (void *)&reply,
+					 &replylen, INTERRUPTIBLE);
+
+		if (reply) {
+
+			if (reply->Reply.ErrorCode) {
+				DbgPrint("%s xattr: reply->Reply.ErrorCode=%d, %X\n", __func__, reply->Reply.ErrorCode, reply->Reply.ErrorCode);
+				DbgPrint("%s xattr: replylen=%d\n", __func__, replylen);
+
+				//0xC9 = EA not found (C9), 0xD1 = EA access denied
+				if ((reply->Reply.ErrorCode == 0xC9)
+				    || (reply->Reply.ErrorCode == 0xD1)) {
+					retCode = -ENOATTR;
+				} else {
+					retCode = -ENOENT;
+				}
+			} else {
+
+				*dataLen =
+				    replylen - sizeof(COMMAND_REPLY_HEADER);
+				DbgPrint("%s xattr: replylen=%u, dataLen=%u\n", __func__, replylen, *dataLen);
+
+				if (buffer_size >= *dataLen) {
+					DbgPrint("%s xattr: copying to buffer from &reply->pData\n", __func__);
+					memcpy(buffer, &reply->pData, *dataLen);
+
+					retCode = 0;
+				} else {
+					DbgPrint("%s xattr: (!!!) buffer is smaller then reply\n", __func__);
+					retCode = -ERANGE;
+				}
+				DbgPrint("%s xattr: /dumping buffer\n", __func__);
+				mydump(*dataLen, buffer);
+				DbgPrint("%s xattr: \\after dumping buffer\n", __func__);
+			}
+
+			kfree(reply);
+		} else {
+			DbgPrint("%s xattr: reply = NULL\n", __func__);
+		}
+		kfree(cmd);
+
+	}
+
+	return retCode;
+}
+
+int Novfs_SetX_File_Info(char *Path, const char *Name, const void *Value,
+			 unsigned long valueLen, unsigned long *bytesWritten,
+			 int flags, struct schandle *SessionId)
+{
+	PXA_SET_REPLY reply = NULL;
+	unsigned long replylen = 0;
+	PXA_SET_REQUEST cmd;
+	int cmdlen;
+	int retCode = -ENOENT;
+
+	int namelen = strlen(Name);
+	int pathlen = strlen(Path);
+
+	DbgPrint("%s xattr: Path = %s, pathlen = %i, Name = %s, namelen = %i, value len = %u\n", __func__,
+	     Path, pathlen, Name, namelen, valueLen);
+
+	if (namelen > MAX_XATTR_NAME_LEN) {
+		return ENOATTR;
+	}
+
+	cmdlen = offsetof(XA_SET_REQUEST, data) + pathlen + 1 + namelen + 1 + valueLen;
+	cmd = (PXA_SET_REQUEST) Novfs_Malloc(cmdlen, GFP_KERNEL);
+	if (cmd) {
+		cmd->Command.CommandType = VFS_COMMAND_SET_EXTENDED_ATTRIBUTE;
+		cmd->Command.SequenceNumber = 0;
+		memcpy(&cmd->Command.SessionId, SessionId, sizeof(*SessionId));
+
+		cmd->flags = flags;
+		cmd->pathLen = pathlen;
+		memcpy(cmd->data, Path, cmd->pathLen + 1);	//+ '\0'
+
+		cmd->nameLen = namelen;
+		memcpy(cmd->data + cmd->pathLen + 1, Name, cmd->nameLen + 1);
+
+		cmd->valueLen = valueLen;
+		memcpy(cmd->data + cmd->pathLen + 1 + cmd->nameLen + 1, Value,
+		       valueLen);
+
+		DbgPrint("%s xattr: PXA_SET_REQUEST BEGIN\n", __func__);
+		DbgPrint("%s xattr: Queue_Daemon_Command %d\n", __func__, cmd->Command.CommandType);
+		DbgPrint("%s xattr: Command.SessionId = %d\n", __func__, cmd->Command.SessionId);
+		DbgPrint("%s xattr: pathLen = %d\n", __func__, cmd->pathLen);
+		DbgPrint("%s xattr: Path = %s\n", __func__, cmd->data);
+		DbgPrint("%s xattr: nameLen = %d\n", __func__, cmd->nameLen);
+		DbgPrint("%s xattr: name = %s\n", __func__, (cmd->data + cmd->pathLen + 1));
+		mydump(valueLen < 16 ? valueLen : 16, (char *)Value);
+
+		DbgPrint("%s xattr: PXA_SET_REQUEST END\n", __func__);
+
+		retCode =
+		    Queue_Daemon_Command(cmd, cmdlen, NULL, 0, (void *)&reply,
+					 &replylen, INTERRUPTIBLE);
+
+		if (reply) {
+
+			if (reply->Reply.ErrorCode) {
+				DbgPrint("%s xattr: reply->Reply.ErrorCode=%d, %X\n", __func__, reply->Reply.ErrorCode, reply->Reply.ErrorCode);
+				DbgPrint("%s xattr: replylen=%d\n", __func__, replylen);
+
+				retCode = -reply->Reply.ErrorCode;	//-ENOENT;
+			} else {
+
+				DbgPrint("%s xattr: replylen=%u, real len = %u\n", __func__, replylen, replylen - sizeof(COMMAND_REPLY_HEADER));
+				memcpy(bytesWritten, &reply->pData,
+				       replylen - sizeof(COMMAND_REPLY_HEADER));
+
+				retCode = 0;
+			}
+
+			kfree(reply);
+		} else {
+			DbgPrint("%s xattr: reply = NULL\n", __func__);
+		}
+		kfree(cmd);
+
+	}
+
+	return retCode;
+}
+
+int Novfs_ListX_File_Info(char *Path, char *buffer, ssize_t buffer_size, ssize_t * dataLen, struct schandle *SessionId)
+{
+	PXA_LIST_REPLY reply = NULL;
+	unsigned long replylen = 0;
+	PVERIFY_FILE_REQUEST cmd;
+	int cmdlen;
+	int retCode = -ENOENT;
+
+	int pathlen = strlen(Path);
+	DbgPrint("%s xattr: Path = %s, pathlen = %i\n", __func__, Path, pathlen);
+
+	*dataLen = 0;
+	cmdlen = offsetof(VERIFY_FILE_REQUEST, path) + pathlen;
+	cmd = (PVERIFY_FILE_REQUEST) Novfs_Malloc(cmdlen, GFP_KERNEL);
+	if (cmd) {
+		cmd->Command.CommandType = VFS_COMMAND_LIST_EXTENDED_ATTRIBUTES;
+		cmd->Command.SequenceNumber = 0;
+		memcpy(&cmd->Command.SessionId, SessionId, sizeof(*SessionId));
+		cmd->pathLen = pathlen;
+		memcpy(cmd->path, Path, cmd->pathLen + 1);	//+ '\0'
+		DbgPrint("%s xattr: PVERIFY_FILE_REQUEST BEGIN\n", __func__);
+		DbgPrint("%s xattr: Queue_Daemon_Command %d\n", __func__, cmd->Command.CommandType);
+		DbgPrint("%s xattr: Command.SessionId = %d\n", __func__, cmd->Command.SessionId);
+		DbgPrint("%s xattr: pathLen = %d\n", __func__, cmd->pathLen);
+		DbgPrint("%s xattr: Path = %s\n", __func__, cmd->path);
+		DbgPrint("%s xattr: PVERIFY_FILE_REQUEST END\n", __func__);
+
+		retCode =
+		    Queue_Daemon_Command(cmd, cmdlen, NULL, 0, (void *)&reply,
+					 &replylen, INTERRUPTIBLE);
+
+		if (reply) {
+
+			if (reply->Reply.ErrorCode) {
+				DbgPrint("%s xattr: reply->Reply.ErrorCode=%d, %X\n", __func__, reply->Reply.ErrorCode, reply->Reply.ErrorCode);
+				DbgPrint("%s xattr: replylen=%d\n", __func__, replylen);
+
+				retCode = -ENOENT;
+			} else {
+				*dataLen = replylen - sizeof(COMMAND_REPLY_HEADER);
+				DbgPrint("%s xattr: replylen=%u, dataLen=%u\n", __func__, replylen, *dataLen);
+
+				if (buffer_size >= *dataLen) {
+					DbgPrint("%s xattr: copying to buffer from &reply->pData\n", __func__);
+					memcpy(buffer, &reply->pData, *dataLen);
+				} else {
+					DbgPrint("%s xattr: (!!!) buffer is smaller then reply\n", __func__);
+					retCode = -ERANGE;
+				}
+				DbgPrint("%s xattr: /dumping buffer\n", __func__);
+				mydump(*dataLen, buffer);
+				DbgPrint("%s xattr: \\after dumping buffer\n", __func__);
+
+				retCode = 0;
+			}
+
+			kfree(reply);
+		} else {
+			DbgPrint("%s xattr: reply = NULL\n", __func__);
+		}
+		kfree(cmd);
+
+	}
+
+	return retCode;
+}
+
+static int begin_directory_enumerate(unsigned char *Path, int PathLen, HANDLE *EnumHandle, struct schandle *SessionId)
+{
+	PBEGIN_ENUMERATE_DIRECTORY_REQUEST cmd;
+	PBEGIN_ENUMERATE_DIRECTORY_REPLY reply = NULL;
+	unsigned long replylen = 0;
+	int retCode, cmdlen;
+
+	*EnumHandle = 0;
+
+	cmdlen = offsetof(BEGIN_ENUMERATE_DIRECTORY_REQUEST, path) + PathLen;
+	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	if (cmd) {
+		cmd->Command.CommandType = VFS_COMMAND_START_ENUMERATE;
+		cmd->Command.SequenceNumber = 0;
+		memcpy(&cmd->Command.SessionId, SessionId, sizeof(*SessionId));
+
+		cmd->pathLen = PathLen;
+		memcpy(cmd->path, Path, PathLen);
+
+		retCode =
+		    Queue_Daemon_Command(cmd, cmdlen, NULL, 0, (void *)&reply,
+					 &replylen, INTERRUPTIBLE);
+/*
+ *      retCode = Queue_Daemon_Command(cmd, cmdlen, NULL, 0, (void *)&reply, &replylen, 0);
+ */
+		if (reply) {
+			if (reply->Reply.ErrorCode) {
+				retCode = -EIO;
+			} else {
+				*EnumHandle = reply->enumerateHandle;
+				retCode = 0;
+			}
+			kfree(reply);
+		}
+		kfree(cmd);
+	} else {
+		retCode = -ENOMEM;
+	}
+	return (retCode);
+}
+
+static int end_directory_enumerate(HANDLE EnumHandle, struct schandle *SessionId)
+{
+	END_ENUMERATE_DIRECTORY_REQUEST cmd;
+	PEND_ENUMERATE_DIRECTORY_REPLY reply = NULL;
+	unsigned long replylen = 0;
+	int retCode;
+
+	cmd.Command.CommandType = VFS_COMMAND_END_ENUMERATE;
+	cmd.Command.SequenceNumber = 0;
+	copy_session_id(&cmd.Command.SessionId, SessionId);
+
+	cmd.enumerateHandle = EnumHandle;
+
+	retCode =
+	    Queue_Daemon_Command(&cmd, sizeof(cmd), NULL, 0, (void *)&reply,
+				 &replylen, 0);
+	if (reply) {
+		retCode = 0;
+		if (reply->Reply.ErrorCode) {
+			retCode = -EIO;
+		}
+		kfree(reply);
+	}
+
+	return (retCode);
+}
+
+int directory_enumerate(HANDLE * EnumHandle, struct entry_info *Info,
+			session_t SessionId)
+{
+	ENUMERATE_DIRECTORY_REQUEST cmd;
+	PENUMERATE_DIRECTORY_REPLY reply = NULL;
+	unsigned long replylen = 0;
+	int retCode;
+
+	cmd.Command.CommandType = VFS_COMMAND_ENUMERATE_DIRECTORY;
+	cmd.Command.SequenceNumber = 0;
+	cmd.Command.SessionId = SessionId;
+
+	cmd.enumerateHandle = *EnumHandle;
+	cmd.pathLen = 0;
+	cmd.path[0] = '\0';
+
+	retCode =
+	    Queue_Daemon_Command(&cmd, sizeof(cmd), NULL, 0, (void *)&reply,
+				 &replylen, INTERRUPTIBLE);
+
+	if (reply) {
+		/*
+		 * The VFS_COMMAND_ENUMERATE_DIRECTORY call can return an
+		 * error but there could still be valid data.
+		 */
+		if (!reply->Reply.ErrorCode ||
+		    ((replylen > sizeof(COMMAND_REPLY_HEADER)) &&
+		     (reply->nameLen > 0))) {
+			Info->type = 3;
+			Info->mode = S_IRWXU;
+
+			if (reply->mode & NW_ATTRIBUTE_DIRECTORY) {
+				Info->mode |= S_IFDIR;
+				Info->mode |= S_IXUSR;
+			} else {
+				Info->mode |= S_IFREG;
+			}
+
+			if (reply->mode & NW_ATTRIBUTE_READ_ONLY) {
+				Info->mode &= ~(S_IWUSR);
+			}
+
+			if (reply->mode & NW_ATTRIBUTE_EXECUTE) {
+				Info->mode |= S_IXUSR;
+			}
+
+			Info->uid = current->uid;
+			Info->gid = current->gid;
+			Info->size = reply->size;
+			Info->atime.tv_sec = reply->lastAccessTime;
+			Info->atime.tv_nsec = 0;
+			Info->mtime.tv_sec = reply->modifyTime;
+			Info->mtime.tv_nsec = 0;
+			Info->ctime.tv_sec = reply->createTime;
+			Info->ctime.tv_nsec = 0;
+			Info->namelength = reply->nameLen;
+			memcpy(Info->name, reply->name, reply->nameLen);
+			retCode = 0;
+			if (reply->Reply.ErrorCode) {
+				retCode = -1;	/* Eof of data */
+			}
+			*EnumHandle = reply->enumerateHandle;
+		} else {
+			retCode = -ENODATA;
+		}
+		kfree(reply);
+	}
+
+	return (retCode);
+}
+
+static int directory_enumerate_ex(HANDLE *EnumHandle, struct schandle *SessionId, int *Count, struct entry_info **PInfo, int Interrupt)
+{
+	ENUMERATE_DIRECTORY_EX_REQUEST cmd;
+	PENUMERATE_DIRECTORY_EX_REPLY reply = NULL;
+	unsigned long replylen = 0;
+	int retCode = 0;
+	struct entry_info *info;
+	PENUMERATE_DIRECTORY_EX_DATA data;
+	int isize;
+
+	if (PInfo) {
+		*PInfo = NULL;
+	}
+	*Count = 0;
+
+	cmd.Command.CommandType = VFS_COMMAND_ENUMERATE_DIRECTORY_EX;
+	cmd.Command.SequenceNumber = 0;
+	copy_session_id(&cmd.Command.SessionId, SessionId);
+
+	cmd.enumerateHandle = *EnumHandle;
+	cmd.pathLen = 0;
+	cmd.path[0] = '\0';
+
+	retCode =
+	    Queue_Daemon_Command(&cmd, sizeof(cmd), NULL, 0, (void *)&reply,
+				 &replylen, Interrupt);
+
+	if (reply) {
+		retCode = 0;
+		/*
+		 * The VFS_COMMAND_ENUMERATE_DIRECTORY call can return an
+		 * error but there could still be valid data.
+		 */
+
+		if (!reply->Reply.ErrorCode ||
+		    ((replylen > sizeof(COMMAND_REPLY_HEADER)) &&
+		     (reply->enumCount > 0))) {
+			DbgPrint("directory_enumerate_ex: isize=%d\n",
+				 replylen);
+			data = (PENUMERATE_DIRECTORY_EX_DATA) ((char *)reply + sizeof(ENUMERATE_DIRECTORY_EX_REPLY));
+			isize = replylen - sizeof(PENUMERATE_DIRECTORY_EX_REPLY) - reply->enumCount * offsetof(ENUMERATE_DIRECTORY_EX_DATA, name);
+			isize += (reply->enumCount * offsetof(struct entry_info, name));
+
+			if (PInfo) {
+				*PInfo = info = Novfs_Malloc(isize, GFP_KERNEL);
+				if (*PInfo) {
+					DbgPrint("directory_enumerate_ex1: data=0x%p info=0x%p\n", data, info);
+					*Count = reply->enumCount;
+					do {
+						DbgPrint("directory_enumerate_ex2: data=0x%p length=%d\n", data);
+
+						info->type = 3;
+						info->mode = S_IRWXU;
+
+						if (data->mode & NW_ATTRIBUTE_DIRECTORY) {
+							info->mode |= S_IFDIR;
+							info->mode |= S_IXUSR;
+						} else {
+							info->mode |= S_IFREG;
+						}
+
+						if (data->mode & NW_ATTRIBUTE_READ_ONLY) {
+							info->mode &= ~(S_IWUSR);
+						}
+
+						if (data->mode & NW_ATTRIBUTE_EXECUTE) {
+							info->mode |= S_IXUSR;
+						}
+
+						info->uid = current->euid;
+						info->gid = current->egid;
+						info->size = data->size;
+						info->atime.tv_sec = data->lastAccessTime;
+						info->atime.tv_nsec = 0;
+						info->mtime.tv_sec = data->modifyTime;
+						info->mtime.tv_nsec = 0;
+						info->ctime.tv_sec = data->createTime;
+						info->ctime.tv_nsec = 0;
+						info->namelength = data->nameLen;
+						memcpy(info->name, data->name, data->nameLen);
+						data = (PENUMERATE_DIRECTORY_EX_DATA)&data->name[data->nameLen];
+						replylen = (int)((char *)&info->name[info->namelength] - (char *)info);
+						DbgPrint("directory_enumerate_ex3: info=0x%p\n", info);
+						mydump(replylen, info);
+
+						info = (struct entry_info *)&info->name[info->namelength];
+
+					} while (--reply->enumCount);
+				}
+			}
+
+			if (reply->Reply.ErrorCode) {
+				retCode = -1;	/* Eof of data */
+			}
+			*EnumHandle = reply->enumerateHandle;
+		} else {
+			retCode = -ENODATA;
+		}
+		kfree(reply);
+	}
+
+	return (retCode);
+}
+
+int Novfs_Get_Directory_ListEx(unsigned char * Path, HANDLE * EnumHandle, int *Count,
+			       struct entry_info **Info, struct schandle *SessionId)
+{
+	int retCode = -ENOENT;
+
+	if (Count)
+		*Count = 0;
+	if (Info)
+		*Info = NULL;
+
+	if ((HANDLE) - 1 == *EnumHandle) {
+		return (-ENODATA);
+	}
+
+	if (0 == *EnumHandle)
+		retCode = begin_directory_enumerate(Path, strlen(Path), EnumHandle, SessionId);
+
+	if (*EnumHandle) {
+		retCode = directory_enumerate_ex(EnumHandle, SessionId, Count, Info, INTERRUPTIBLE);
+		if (retCode) {
+			end_directory_enumerate(*EnumHandle, SessionId);
+			if (-1 == retCode) {
+				retCode = 0;
+				*EnumHandle = Uint32toHandle(-1);
+			}
+		}
+	}
+	return (retCode);
+}
+
+int Novfs_Open_File(unsigned char * Path, int Flags, struct entry_info *Info, HANDLE * Handle,
+		    session_t SessionId)
+{
+	POPEN_FILE_REQUEST cmd;
+	POPEN_FILE_REPLY reply;
+	unsigned long replylen = 0;
+	int retCode, cmdlen, pathlen;
+
+	pathlen = strlen(Path);
+
+	if (StripTrailingDots) {
+		if ('.' == Path[pathlen - 1])
+			pathlen--;
+	}
+
+	*Handle = 0;
+
+	cmdlen = offsetof(OPEN_FILE_REQUEST, path) + pathlen;
+	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	if (cmd) {
+		cmd->Command.CommandType = VFS_COMMAND_OPEN_FILE;
+		cmd->Command.SequenceNumber = 0;
+		cmd->Command.SessionId = SessionId;
+
+		cmd->access = 0;
+
+		if (!(Flags & O_WRONLY) || (Flags & O_RDWR)) {
+			cmd->access |= NWD_ACCESS_READ;
+		}
+
+		if ((Flags & O_WRONLY) || (Flags & O_RDWR)) {
+			cmd->access |= NWD_ACCESS_WRITE;
+		}
+
+		switch (Flags & (O_CREAT | O_EXCL | O_TRUNC)) {
+		case O_CREAT:
+			cmd->disp = NWD_DISP_OPEN_ALWAYS;
+			break;
+
+		case O_CREAT | O_EXCL:
+			cmd->disp = NWD_DISP_CREATE_NEW;
+			break;
+
+		case O_TRUNC:
+			cmd->disp = NWD_DISP_CREATE_ALWAYS;
+			break;
+
+		case O_CREAT | O_TRUNC:
+			cmd->disp = NWD_DISP_CREATE_ALWAYS;
+			break;
+
+		case O_CREAT | O_EXCL | O_TRUNC:
+			cmd->disp = NWD_DISP_CREATE_NEW;
+			break;
+
+		default:
+			cmd->disp = NWD_DISP_OPEN_EXISTING;
+			break;
+		}
+
+		cmd->mode = NWD_SHARE_READ | NWD_SHARE_WRITE | NWD_SHARE_DELETE;
+
+		cmd->pathLen = pathlen;
+		memcpy(cmd->path, Path, pathlen);
+
+		retCode =
+		    Queue_Daemon_Command(cmd, cmdlen, NULL, 0, (void *)&reply,
+					 &replylen, INTERRUPTIBLE);
+
+		if (reply) {
+			if (reply->Reply.ErrorCode) {
+				if (NWE_OBJECT_EXISTS == reply->Reply.ErrorCode) {
+					retCode = -EEXIST;
+				} else if (NWE_ACCESS_DENIED ==
+					   reply->Reply.ErrorCode) {
+					retCode = -EACCES;
+				} else if (NWE_FILE_IN_USE ==
+					   reply->Reply.ErrorCode) {
+					retCode = -EBUSY;
+				} else {
+					retCode = -ENOENT;
+				}
+			} else {
+				*Handle = reply->handle;
+				retCode = 0;
+			}
+			kfree(reply);
+		}
+		kfree(cmd);
+	} else {
+		retCode = -ENOMEM;
+	}
+	return (retCode);
+}
+
+int Novfs_Create(unsigned char * Path, int DirectoryFlag, session_t SessionId)
+{
+	PCREATE_FILE_REQUEST cmd;
+	PCREATE_FILE_REPLY reply;
+	unsigned long replylen = 0;
+	int retCode, cmdlen, pathlen;
+
+	pathlen = strlen(Path);
+
+	if (StripTrailingDots) {
+		if ('.' == Path[pathlen - 1])
+			pathlen--;
+	}
+
+	cmdlen = offsetof(CREATE_FILE_REQUEST, path) + pathlen;
+	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	if (cmd) {
+		cmd->Command.CommandType = VFS_COMMAND_CREATE_FILE;
+		if (DirectoryFlag) {
+			cmd->Command.CommandType = VFS_COMMAND_CREATE_DIRECOTRY;
+		}
+		cmd->Command.SequenceNumber = 0;
+		cmd->Command.SessionId = SessionId;
+
+		cmd->pathlength = pathlen;
+		memcpy(cmd->path, Path, pathlen);
+
+		retCode =
+		    Queue_Daemon_Command(cmd, cmdlen, NULL, 0, (void *)&reply,
+					 &replylen, INTERRUPTIBLE);
+
+		if (reply) {
+			retCode = 0;
+			if (reply->Reply.ErrorCode) {
+				retCode = -EIO;
+			}
+			kfree(reply);
+		}
+		kfree(cmd);
+	} else {
+		retCode = -ENOMEM;
+	}
+	return (retCode);
+}
+
+int Novfs_Close_File(HANDLE Handle, session_t SessionId)
+{
+	CLOSE_FILE_REQUEST cmd;
+	PCLOSE_FILE_REPLY reply;
+	unsigned long replylen = 0;
+	int retCode;
+
+	cmd.Command.CommandType = VFS_COMMAND_CLOSE_FILE;
+	cmd.Command.SequenceNumber = 0;
+	cmd.Command.SessionId = SessionId;
+
+	cmd.handle = Handle;
+
+	retCode =
+	    Queue_Daemon_Command(&cmd, sizeof(cmd), NULL, 0, (void *)&reply,
+				 &replylen, 0);
+	if (reply) {
+		retCode = 0;
+		if (reply->Reply.ErrorCode) {
+			retCode = -EIO;
+		}
+		kfree(reply);
+	}
+	return (retCode);
+}
+
+int Novfs_Read_File(HANDLE Handle, unsigned char * Buffer, size_t * Bytes,
+		    loff_t * Offset, session_t SessionId)
+{
+	READ_FILE_REQUEST cmd;
+	PREAD_FILE_REPLY reply = NULL;
+	unsigned long replylen = 0;
+	int retCode = 0;
+	size_t len;
+
+	len = *Bytes;
+	*Bytes = 0;
+
+	if ((offsetof(READ_FILE_REPLY, data) + len) > MaxIoSize) {
+		len = MaxIoSize - offsetof(READ_FILE_REPLY, data);
+		len = (len / PAGE_SIZE) * PAGE_SIZE;
+	}
+
+	cmd.Command.CommandType = VFS_COMMAND_READ_FILE;
+	cmd.Command.SequenceNumber = 0;
+	cmd.Command.SessionId = SessionId;
+
+	cmd.handle = Handle;
+	cmd.len = len;
+	cmd.offset = *Offset;
+
+	retCode = Queue_Daemon_Command(&cmd, sizeof(cmd), NULL, 0, (void *)&reply, &replylen, INTERRUPTIBLE);
+
+	DbgPrint("Novfs_Read_File: Queue_Daemon_Command 0x%x replylen=%d\n", retCode, replylen);
+
+	if (!retCode) {
+		if (reply->Reply.ErrorCode) {
+			if (NWE_FILE_IO_LOCKED == reply->Reply.ErrorCode) {
+				retCode = -EBUSY;
+			} else {
+				retCode = -EIO;
+			}
+		} else {
+			replylen -= offsetof(READ_FILE_REPLY, data);
+			if (replylen > 0) {
+				replylen -= copy_to_user(Buffer, reply->data, replylen);
+				*Bytes = replylen;
+			}
+		}
+	}
+
+	if (reply) {
+		kfree(reply);
+	}
+
+	DbgPrint("Novfs_Read_File *Bytes=0x%x retCode=0x%x\n", *Bytes, retCode);
+
+	return (retCode);
+}
+
+int Novfs_Read_Pages(HANDLE Handle, struct data_list *DList, int DList_Cnt,
+		     size_t * Bytes, loff_t * Offset, session_t SessionId)
+{
+	READ_FILE_REQUEST cmd;
+	PREAD_FILE_REPLY reply = NULL;
+	READ_FILE_REPLY lreply;
+	unsigned long replylen = 0;
+	int retCode = 0;
+	size_t len;
+
+	len = *Bytes;
+	*Bytes = 0;
+
+	DbgPrint
+	    ("Novfs_Read_Pages: Handle=0x%p Dlst=0x%p Dlcnt=%d Bytes=%d Offset=%lld SessionId=0x%p:%p\n",
+	     Handle, DList, DList_Cnt, len, *Offset, SessionId.hTypeId,
+	     SessionId.hId);
+
+	cmd.Command.CommandType = VFS_COMMAND_READ_FILE;
+	cmd.Command.SequenceNumber = 0;
+	cmd.Command.SessionId = SessionId;
+
+	cmd.handle = Handle;
+	cmd.len = len;
+	cmd.offset = *Offset;
+
+	/*
+	 * Dlst first entry is reserved for reply header.
+	 */
+	DList[0].page = NULL;
+	DList[0].offset = &lreply;
+	DList[0].len = offsetof(READ_FILE_REPLY, data);
+	DList[0].rwflag = DLWRITE;
+
+	retCode =
+	    Queue_Daemon_Command(&cmd, sizeof(cmd), DList, DList_Cnt,
+				 (void *)&reply, &replylen, INTERRUPTIBLE);
+
+	DbgPrint("Novfs_Read_Pages: Queue_Daemon_Command 0x%x\n", retCode);
+
+	if (!retCode) {
+		if (reply) {
+			memcpy(&lreply, reply, sizeof(lreply));
+		}
+
+		if (lreply.Reply.ErrorCode) {
+			if (NWE_FILE_IO_LOCKED == lreply.Reply.ErrorCode) {
+				retCode = -EBUSY;
+			} else {
+				retCode = -EIO;
+			}
+		}
+		*Bytes = replylen - offsetof(READ_FILE_REPLY, data);
+	}
+
+	if (reply) {
+		kfree(reply);
+	}
+
+	DbgPrint("Novfs_Read_Pages: retCode=0x%x\n", retCode);
+
+	return (retCode);
+}
+
+int Novfs_Write_File(HANDLE Handle, unsigned char * Buffer, size_t * Bytes,
+		     loff_t * Offset, session_t SessionId)
+{
+	WRITE_FILE_REQUEST cmd;
+	PWRITE_FILE_REPLY reply = NULL;
+	unsigned long replylen = 0;
+	int retCode = 0, cmdlen;
+	size_t len;
+
+	unsigned long boff;
+	struct page **pages;
+	struct data_list *dlist;
+	int res = 0, npage, i;
+	WRITE_FILE_REPLY lreply;
+
+	len = *Bytes;
+	cmdlen = offsetof(WRITE_FILE_REQUEST, data);
+
+	*Bytes = 0;
+
+	memset(&lreply, 0, sizeof(lreply));
+
+	DbgPrint("Novfs_Write_File cmdlen=%ld len=%ld\n", cmdlen, len);
+
+	if ((cmdlen + len) > MaxIoSize) {
+		len = MaxIoSize - cmdlen;
+		len = (len / PAGE_SIZE) * PAGE_SIZE;
+	}
+	cmd.Command.CommandType = VFS_COMMAND_WRITE_FILE;
+	cmd.Command.SequenceNumber = 0;
+	cmd.Command.SessionId = SessionId;
+	cmd.handle = Handle;
+	cmd.len = len;
+	cmd.offset = *Offset;
+
+	DbgPrint("Novfs_Write_File cmdlen=%ld len=%ld\n", cmdlen, len);
+
+	npage =
+	    (((unsigned long)Buffer & ~PAGE_MASK) + len +
+	     (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+
+	dlist = Novfs_Malloc(sizeof(struct data_list) * (npage + 1), GFP_KERNEL);
+	if (NULL == dlist) {
+		return (-ENOMEM);
+	}
+
+	pages = Novfs_Malloc(sizeof(struct page *) * npage, GFP_KERNEL);
+
+	if (NULL == pages) {
+		kfree(dlist);
+		return (-ENOMEM);
+	}
+
+	down_read(&current->mm->mmap_sem);
+
+	res = get_user_pages(current, current->mm, (unsigned long)Buffer, npage, 0,	/* read type */
+			     0,	/* don't force */
+			     pages, NULL);
+
+	up_read(&current->mm->mmap_sem);
+
+	DbgPrint("Novfs_Write_File res=%d\n", res);
+
+	if (res > 0) {
+		boff = (unsigned long)Buffer & ~PAGE_MASK;
+
+		flush_dcache_page(pages[0]);
+		dlist[0].page = pages[0];
+		dlist[0].offset = (char *)boff;
+		dlist[0].len = PAGE_SIZE - boff;
+		dlist[0].rwflag = DLREAD;
+
+		if (dlist[0].len > len) {
+			dlist[0].len = len;
+		}
+
+		DbgPrint("Novfs_Write_File0: page=0x%p offset=0x%p len=%d\n",
+			 dlist[0].page, dlist[0].offset, dlist[0].len);
+
+		boff = dlist[0].len;
+
+		DbgPrint("Novfs_Write_File len=%d boff=%d\n", len, boff);
+
+		for (i = 1; (i < res) && (boff < len); i++) {
+			flush_dcache_page(pages[i]);
+
+			dlist[i].page = pages[i];
+			dlist[i].offset = NULL;
+			dlist[i].len = len - boff;
+			if (dlist[i].len > PAGE_SIZE) {
+				dlist[i].len = PAGE_SIZE;
+			}
+			dlist[i].rwflag = DLREAD;
+
+			boff += dlist[i].len;
+			DbgPrint
+			    ("Novfs_Write_File%d: page=0x%p offset=0x%p len=%d\n",
+			     i, dlist[i].page, dlist[i].offset, dlist[i].len);
+		}
+
+		dlist[i].page = NULL;
+		dlist[i].offset = &lreply;
+		dlist[i].len = sizeof(lreply);
+		dlist[i].rwflag = DLWRITE;
+		res++;
+
+		DbgPrint("Novfs_Write_File Buffer=0x%p boff=0x%x len=%d\n",
+			 Buffer, boff, len);
+
+		retCode =
+		    Queue_Daemon_Command(&cmd, cmdlen, dlist, res,
+					 (void *)&reply, &replylen,
+					 INTERRUPTIBLE);
+
+	} else {
+		char *kdata;
+
+		res = 0;
+
+		kdata = Novfs_Malloc(len, GFP_KERNEL);
+		if (kdata) {
+			len -= copy_from_user(kdata, Buffer, len);
+			dlist[0].page = NULL;
+			dlist[0].offset = kdata;
+			dlist[0].len = len;
+			dlist[0].rwflag = DLREAD;
+
+			dlist[1].page = NULL;
+			dlist[1].offset = &lreply;
+			dlist[1].len = sizeof(lreply);
+			dlist[1].rwflag = DLWRITE;
+
+			retCode =
+			    Queue_Daemon_Command(&cmd, cmdlen, dlist, 2,
+						 (void *)&reply, &replylen,
+						 INTERRUPTIBLE);
+
+			kfree(kdata);
+		}
+	}
+
+	DbgPrint("Novfs_Write_File retCode=0x%x reply=0x%p\n", retCode, reply);
+
+	if (!retCode) {
+		switch (lreply.Reply.ErrorCode) {
+		case 0:
+			*Bytes = (size_t) lreply.bytesWritten;
+			retCode = 0;
+			break;
+
+		case NWE_INSUFFICIENT_SPACE:
+			retCode = -ENOSPC;
+			break;
+
+		case NWE_ACCESS_DENIED:
+			retCode = -EACCES;
+			break;
+
+		default:
+			retCode = -EIO;
+			break;
+		}
+	}
+
+	if (res) {
+		for (i = 0; i < res; i++) {
+			if (dlist[i].page) {
+				page_cache_release(dlist[i].page);
+			}
+		}
+	}
+
+	kfree(pages);
+	kfree(dlist);
+
+	DbgPrint("Novfs_Write_File *Bytes=0x%x retCode=0x%x\n", *Bytes,
+		 retCode);
+
+	return (retCode);
+}
+
+/*
+ *  Arguments: HANDLE Handle - novfsd file handle
+ *             struct page *Page - Page to be written out
+ *             session_t SessionId - novfsd session handle
+ *
+ *  Returns:   0 - Success
+ *             -ENOSPC - Out of space on server
+ *             -EACCES - Access denied
+ *             -EIO - Any other error
+ *
+ *  Abstract:  Write page to file.
+ */
+int Novfs_Write_Page(HANDLE Handle, struct page *Page, session_t SessionId)
+{
+	WRITE_FILE_REQUEST cmd;
+	WRITE_FILE_REPLY lreply;
+	PWRITE_FILE_REPLY reply = NULL;
+	unsigned long replylen = 0;
+	int retCode = 0, cmdlen;
+	struct data_list dlst[2];
+
+	DbgPrint
+	    ("Novfs_Write_Page: Handle=0x%p Page=0x%p Index=%lu SessionId=0x%llx\n",
+	     Handle, Page, Page->index, SessionId);
+
+	dlst[0].page = NULL;
+	dlst[0].offset = &lreply;
+	dlst[0].len = sizeof(lreply);
+	dlst[0].rwflag = DLWRITE;
+
+	dlst[1].page = Page;
+	dlst[1].offset = 0;
+	dlst[1].len = PAGE_CACHE_SIZE;
+	dlst[1].rwflag = DLREAD;
+
+	cmdlen = offsetof(WRITE_FILE_REQUEST, data);
+
+	cmd.Command.CommandType = VFS_COMMAND_WRITE_FILE;
+	cmd.Command.SequenceNumber = 0;
+	cmd.Command.SessionId = SessionId;
+
+	cmd.handle = Handle;
+	cmd.len = PAGE_CACHE_SIZE;
+	cmd.offset = (loff_t) Page->index << PAGE_CACHE_SHIFT;;
+
+	retCode =
+	    Queue_Daemon_Command(&cmd, cmdlen, &dlst, 2, (void *)&reply,
+				 &replylen, INTERRUPTIBLE);
+	if (!retCode) {
+		if (reply) {
+			memcpy(&lreply, reply, sizeof(lreply));
+		}
+		switch (lreply.Reply.ErrorCode) {
+		case 0:
+			retCode = 0;
+			break;
+
+		case NWE_INSUFFICIENT_SPACE:
+			retCode = -ENOSPC;
+			break;
+
+		case NWE_ACCESS_DENIED:
+			retCode = -EACCES;
+			break;
+
+		default:
+			retCode = -EIO;
+			break;
+		}
+	}
+
+	if (reply) {
+		kfree(reply);
+	}
+
+	DbgPrint("Novfs_Write_Page retCode=0x%x\n", retCode);
+
+	return (retCode);
+}
+
+int Novfs_Write_Pages(HANDLE Handle, struct data_list *DList, int DList_Cnt,
+		      size_t Bytes, loff_t Offset, session_t SessionId)
+{
+	WRITE_FILE_REQUEST cmd;
+	WRITE_FILE_REPLY lreply;
+	PWRITE_FILE_REPLY reply = NULL;
+	unsigned long replylen = 0;
+	int retCode = 0, cmdlen;
+	size_t len;
+
+	DbgPrint
+	    ("Novfs_Write_Pages: Handle=0x%p Dlst=0x%p Dlcnt=%d Bytes=%d Offset=%lld SessionId=0x%llx\n",
+	     Handle, DList, DList_Cnt, Bytes, Offset, SessionId);
+
+	DList[0].page = NULL;
+	DList[0].offset = &lreply;
+	DList[0].len = sizeof(lreply);
+	DList[0].rwflag = DLWRITE;
+
+	len = Bytes;
+	cmdlen = offsetof(WRITE_FILE_REQUEST, data);
+
+	if (len) {
+		cmd.Command.CommandType = VFS_COMMAND_WRITE_FILE;
+		cmd.Command.SequenceNumber = 0;
+		cmd.Command.SessionId = SessionId;
+
+		cmd.handle = Handle;
+		cmd.len = len;
+		cmd.offset = Offset;
+
+		retCode =
+		    Queue_Daemon_Command(&cmd, cmdlen, DList, DList_Cnt,
+					 (void *)&reply, &replylen,
+					 INTERRUPTIBLE);
+		if (!retCode) {
+			if (reply) {
+				memcpy(&lreply, reply, sizeof(lreply));
+			}
+			switch (lreply.Reply.ErrorCode) {
+			case 0:
+				retCode = 0;
+				break;
+
+			case NWE_INSUFFICIENT_SPACE:
+				retCode = -ENOSPC;
+				break;
+
+			case NWE_ACCESS_DENIED:
+				retCode = -EACCES;
+				break;
+
+			default:
+				retCode = -EIO;
+				break;
+			}
+		}
+		if (reply) {
+			kfree(reply);
+		}
+	}
+	DbgPrint("Novfs_Write_Pages retCode=0x%x\n", retCode);
+
+	return (retCode);
+}
+
+int Novfs_Read_Stream(HANDLE ConnHandle, unsigned char * Handle, unsigned char * Buffer,
+		      size_t * Bytes, loff_t * Offset, int User,
+		      session_t SessionId)
+{
+	READ_STREAM_REQUEST cmd;
+	PREAD_STREAM_REPLY reply = NULL;
+	unsigned long replylen = 0;
+	int retCode = 0;
+	size_t len;
+
+	len = *Bytes;
+	*Bytes = 0;
+
+	if ((offsetof(READ_FILE_REPLY, data) + len) > MaxIoSize) {
+		len = MaxIoSize - offsetof(READ_FILE_REPLY, data);
+		len = (len / PAGE_SIZE) * PAGE_SIZE;
+	}
+
+	cmd.Command.CommandType = VFS_COMMAND_READ_STREAM;
+	cmd.Command.SequenceNumber = 0;
+	cmd.Command.SessionId = SessionId;
+
+	cmd.connection = ConnHandle;
+	memcpy(cmd.handle, Handle, sizeof(cmd.handle));
+	cmd.len = len;
+	cmd.offset = *Offset;
+
+	retCode = Queue_Daemon_Command(&cmd, sizeof(cmd), NULL, 0, (void *)&reply, &replylen, INTERRUPTIBLE);
+
+	DbgPrint("Novfs_Read_Stream: Queue_Daemon_Command 0x%x replylen=%d\n", retCode, replylen);
+
+	if (reply) {
+		retCode = 0;
+		if (reply->Reply.ErrorCode) {
+			retCode = -EIO;
+		} else {
+			replylen -= offsetof(READ_STREAM_REPLY, data);
+			if (replylen > 0) {
+				if (User)
+					replylen -= copy_to_user(Buffer, reply->data, replylen);
+				else
+					memcpy(Buffer, reply->data, replylen);
+				*Bytes = replylen;
+			}
+		}
+		kfree(reply);
+	}
+
+	DbgPrint("Novfs_Read_Stream *Bytes=0x%x retCode=0x%x\n", *Bytes, retCode);
+
+	return (retCode);
+}
+
+int Novfs_Write_Stream(HANDLE ConnHandle, unsigned char * Handle, unsigned char * Buffer,
+		       size_t * Bytes, loff_t * Offset, session_t SessionId)
+{
+	PWRITE_STREAM_REQUEST cmd;
+	PWRITE_STREAM_REPLY reply = NULL;
+	unsigned long replylen = 0;
+	int retCode = 0, cmdlen;
+	size_t len;
+
+	len = *Bytes;
+	cmdlen = len + offsetof(WRITE_STREAM_REQUEST, data);
+	*Bytes = 0;
+
+	if (cmdlen > MaxIoSize) {
+		cmdlen = MaxIoSize;
+		len = cmdlen - offsetof(WRITE_STREAM_REQUEST, data);
+	}
+
+	DbgPrint("Novfs_Write_Stream cmdlen=%d len=%d\n", cmdlen, len);
+
+	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+
+	if (cmd) {
+		if (Buffer && len) {
+			len -= copy_from_user(cmd->data, Buffer, len);
+		}
+
+		DbgPrint("Novfs_Write_Stream len=%d\n", len);
+
+		cmd->Command.CommandType = VFS_COMMAND_WRITE_STREAM;
+		cmd->Command.SequenceNumber = 0;
+		cmd->Command.SessionId = SessionId;
+
+		cmd->connection = ConnHandle;
+		memcpy(cmd->handle, Handle, sizeof(cmd->handle));
+		cmd->len = len;
+		cmd->offset = *Offset;
+
+		retCode =
+		    Queue_Daemon_Command(cmd, cmdlen, NULL, 0, (void *)&reply,
+					 &replylen, INTERRUPTIBLE);
+		if (reply) {
+			switch (reply->Reply.ErrorCode) {
+			case 0:
+				retCode = 0;
+				break;
+
+			case NWE_INSUFFICIENT_SPACE:
+				retCode = -ENOSPC;
+				break;
+
+			case NWE_ACCESS_DENIED:
+				retCode = -EACCES;
+				break;
+
+			default:
+				retCode = -EIO;
+				break;
+			}
+			DbgPrint
+			    ("Novfs_Write_Stream reply->bytesWritten=0x%lx\n",
+			     reply->bytesWritten);
+			*Bytes = reply->bytesWritten;
+			kfree(reply);
+		}
+		kfree(cmd);
+	}
+	DbgPrint("Novfs_Write_Stream *Bytes=0x%x retCode=0x%x\n", *Bytes,
+		 retCode);
+
+	return (retCode);
+}
+
+int Novfs_Close_Stream(HANDLE ConnHandle, unsigned char * Handle, session_t SessionId)
+{
+	CLOSE_STREAM_REQUEST cmd;
+	PCLOSE_STREAM_REPLY reply;
+	unsigned long replylen = 0;
+	int retCode;
+
+	cmd.Command.CommandType = VFS_COMMAND_CLOSE_STREAM;
+	cmd.Command.SequenceNumber = 0;
+	cmd.Command.SessionId = SessionId;
+
+	cmd.connection = ConnHandle;
+	memcpy(cmd.handle, Handle, sizeof(cmd.handle));
+
+	retCode =
+	    Queue_Daemon_Command(&cmd, sizeof(cmd), NULL, 0, (void *)&reply,
+				 &replylen, 0);
+	if (reply) {
+		retCode = 0;
+		if (reply->Reply.ErrorCode) {
+			retCode = -EIO;
+		}
+		kfree(reply);
+	}
+	return (retCode);
+}
+
+int Novfs_Delete(unsigned char * Path, int DirectoryFlag, session_t SessionId)
+{
+	PDELETE_FILE_REQUEST cmd;
+	PDELETE_FILE_REPLY reply;
+	unsigned long replylen = 0;
+	int retCode, cmdlen, pathlen;
+
+	pathlen = strlen(Path);
+
+	if (StripTrailingDots) {
+		if ('.' == Path[pathlen - 1])
+			pathlen--;
+	}
+
+	cmdlen = offsetof(DELETE_FILE_REQUEST, path) + pathlen;
+	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	if (cmd) {
+		cmd->Command.CommandType = VFS_COMMAND_DELETE_FILE;
+		cmd->Command.SequenceNumber = 0;
+		cmd->Command.SessionId = SessionId;
+
+		cmd->isDirectory = DirectoryFlag;
+		cmd->pathlength = pathlen;
+		memcpy(cmd->path, Path, pathlen);
+
+		retCode =
+		    Queue_Daemon_Command(cmd, cmdlen, NULL, 0, (void *)&reply,
+					 &replylen, INTERRUPTIBLE);
+		if (reply) {
+			retCode = 0;
+			if (reply->Reply.ErrorCode) {
+				if ((reply->Reply.ErrorCode & 0xFFFF) == 0x0006) {	/* Access Denied Error */
+					retCode = -EACCES;
+				} else {
+					retCode = -EIO;
+				}
+			}
+			kfree(reply);
+		}
+		kfree(cmd);
+	} else {
+		retCode = -ENOMEM;
+	}
+	return (retCode);
+}
+
+int Novfs_Truncate_File(unsigned char * Path, int PathLen, session_t SessionId)
+{
+	PTRUNCATE_FILE_REQUEST cmd;
+	PTRUNCATE_FILE_REPLY reply;
+	unsigned long replylen = 0;
+	int retCode, cmdlen;
+
+	if (StripTrailingDots) {
+		if ('.' == Path[PathLen - 1])
+			PathLen--;
+	}
+	cmdlen = offsetof(TRUNCATE_FILE_REQUEST, path) + PathLen;
+	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	if (cmd) {
+		cmd->Command.CommandType = VFS_COMMAND_TRUNCATE_FILE;
+		cmd->Command.SequenceNumber = 0;
+		cmd->Command.SessionId = SessionId;
+
+		cmd->pathLen = PathLen;
+		memcpy(cmd->path, Path, PathLen);
+
+		retCode =
+		    Queue_Daemon_Command(cmd, cmdlen, NULL, 0, (void *)&reply,
+					 &replylen, INTERRUPTIBLE);
+		if (reply) {
+			if (reply->Reply.ErrorCode) {
+				retCode = -EIO;
+			}
+			kfree(reply);
+		}
+		kfree(cmd);
+	} else {
+		retCode = -ENOMEM;
+	}
+	return (retCode);
+}
+
+int Novfs_Truncate_File_Ex(HANDLE Handle, loff_t Offset, session_t SessionId)
+{
+	WRITE_FILE_REQUEST cmd;
+	PWRITE_FILE_REPLY reply = NULL;
+	unsigned long replylen = 0;
+	int retCode = 0, cmdlen;
+
+	DbgPrint("Novfs_Truncate_File_Ex Handle=0x%p Offset=%lld\n", Handle,
+		 Offset);
+
+	cmdlen = offsetof(WRITE_FILE_REQUEST, data);
+
+	cmd.Command.CommandType = VFS_COMMAND_WRITE_FILE;
+	cmd.Command.SequenceNumber = 0;
+	cmd.Command.SessionId = SessionId;
+	cmd.handle = Handle;
+	cmd.len = 0;
+	cmd.offset = Offset;
+
+	retCode =
+	    Queue_Daemon_Command(&cmd, cmdlen, NULL, 0, (void *)&reply,
+				 &replylen, INTERRUPTIBLE);
+
+	DbgPrint("Novfs_Truncate_File_Ex retCode=0x%x reply=0x%p\n", retCode,
+		 reply);
+
+	if (!retCode) {
+		switch (reply->Reply.ErrorCode) {
+		case 0:
+			retCode = 0;
+			break;
+
+		case NWE_INSUFFICIENT_SPACE:
+			retCode = -ENOSPC;
+			break;
+
+		case NWE_ACCESS_DENIED:
+			retCode = -EACCES;
+			break;
+
+		case NWE_FILE_IO_LOCKED:
+			retCode = -EBUSY;
+			break;
+
+		default:
+			retCode = -EIO;
+			break;
+		}
+	}
+
+	if (reply) {
+		kfree(reply);
+	}
+
+	DbgPrint("Novfs_Truncate_File_Ex retCode=%d\n", retCode);
+
+	return (retCode);
+}
+
+int Novfs_Rename_File(int DirectoryFlag, unsigned char * OldName, int OldLen,
+		      unsigned char * NewName, int NewLen, session_t SessionId)
+{
+	RENAME_FILE_REQUEST cmd;
+	PRENAME_FILE_REPLY reply;
+	unsigned long replylen = 0;
+	int retCode;
+
+	DbgPrint("Novfs_Rename_File:\n"
+		 "   DirectoryFlag: %d\n"
+		 "   OldName:       %.*s\n"
+		 "   NewName:       %.*s\n"
+		 "   SessionId:     0x%llx\n",
+		 DirectoryFlag, OldLen, OldName, NewLen, NewName, SessionId);
+
+	cmd.Command.CommandType = VFS_COMMAND_RENAME_FILE;
+	cmd.Command.SequenceNumber = 0;
+	cmd.Command.SessionId = SessionId;
+
+	cmd.directoryFlag = DirectoryFlag;
+
+	if (StripTrailingDots) {
+		if ('.' == OldName[OldLen - 1])
+			OldLen--;
+		if ('.' == NewName[NewLen - 1])
+			NewLen--;
+	}
+
+	cmd.newnameLen = NewLen;
+	memcpy(cmd.newname, NewName, NewLen);
+
+	cmd.oldnameLen = OldLen;
+	memcpy(cmd.oldname, OldName, OldLen);
+
+	retCode =
+	    Queue_Daemon_Command(&cmd, sizeof(cmd), NULL, 0, (void *)&reply,
+				 &replylen, INTERRUPTIBLE);
+	if (reply) {
+		retCode = 0;
+		if (reply->Reply.ErrorCode) {
+			retCode = -ENOENT;
+		}
+		kfree(reply);
+	}
+	return (retCode);
+}
+
+int Novfs_Set_Attr(unsigned char * Path, struct iattr *Attr, session_t SessionId)
+{
+	PSET_FILE_INFO_REQUEST cmd;
+	PSET_FILE_INFO_REPLY reply;
+	unsigned long replylen = 0;
+	int retCode, cmdlen, pathlen;
+
+	pathlen = strlen(Path);
+
+	if (StripTrailingDots) {
+		if ('.' == Path[pathlen - 1])
+			pathlen--;
+	}
+
+	cmdlen = offsetof(SET_FILE_INFO_REQUEST, path) + pathlen;
+	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	if (cmd) {
+		cmd->Command.CommandType = VFS_COMMAND_SET_FILE_INFO;
+		cmd->Command.SequenceNumber = 0;
+		cmd->Command.SessionId = SessionId;
+		cmd->fileInfo.ia_valid = Attr->ia_valid;
+		cmd->fileInfo.ia_mode = Attr->ia_mode;
+		cmd->fileInfo.ia_uid = Attr->ia_uid;
+		cmd->fileInfo.ia_gid = Attr->ia_uid;
+		cmd->fileInfo.ia_size = Attr->ia_size;
+		cmd->fileInfo.ia_atime = Attr->ia_atime.tv_sec;
+		cmd->fileInfo.ia_mtime = Attr->ia_mtime.tv_sec;;
+		cmd->fileInfo.ia_ctime = Attr->ia_ctime.tv_sec;;
+/*
+      cmd->fileInfo.ia_attr_flags = Attr->ia_attr_flags;
+*/
+		cmd->fileInfo.ia_attr_flags = 0;
+
+		cmd->pathlength = pathlen;
+		memcpy(cmd->path, Path, pathlen);
+
+		retCode =
+		    Queue_Daemon_Command(cmd, cmdlen, NULL, 0, (void *)&reply,
+					 &replylen, INTERRUPTIBLE);
+		if (reply) {
+			switch (reply->Reply.ErrorCode) {
+			case 0:
+				retCode = 0;
+				break;
+
+			case NWE_PARAM_INVALID:
+				retCode = -EINVAL;
+				break;
+
+			case NWE_FILE_IO_LOCKED:
+				retCode = -EBUSY;
+				break;
+
+			default:
+				retCode = -EIO;
+				break;
+			}
+			kfree(reply);
+		}
+		kfree(cmd);
+	} else {
+		retCode = -ENOMEM;
+	}
+	return (retCode);
+}
+
+int Novfs_Get_File_Cache_Flag(unsigned char * Path, session_t SessionId)
+{
+	PGET_CACHE_FLAG_REQUEST cmd;
+	PGET_CACHE_FLAG_REPLY reply = NULL;
+	unsigned long replylen = 0;
+	int cmdlen;
+	int retCode = 0;
+	int pathlen;
+
+	DbgPrint("Novfs_Get_File_Cache_Flag: Path = %s\n", Path);
+
+	if (Path && *Path) {
+		pathlen = strlen(Path);
+		if (StripTrailingDots) {
+			if ('.' == Path[pathlen - 1])
+				pathlen--;
+		}
+		cmdlen = offsetof(GET_CACHE_FLAG_REQUEST, path) + pathlen;
+		cmd = (PGET_CACHE_FLAG_REQUEST) Novfs_Malloc(cmdlen, GFP_KERNEL);
+		if (cmd) {
+			cmd->Command.CommandType = VFS_COMMAND_GET_CACHE_FLAG;
+			cmd->Command.SequenceNumber = 0;
+			cmd->Command.SessionId = SessionId;
+			cmd->pathLen = pathlen;
+			memcpy(cmd->path, Path, cmd->pathLen);
+
+			Queue_Daemon_Command(cmd, cmdlen, NULL, 0,
+					     (void *)&reply, &replylen,
+					     INTERRUPTIBLE);
+
+			if (reply) {
+
+				if (!reply->Reply.ErrorCode) {
+					retCode = reply->CacheFlag;
+				}
+
+				kfree(reply);
+			}
+			kfree(cmd);
+		}
+	}
+
+	DbgPrint("Novfs_Get_File_Cache_Flag: return %d\n", retCode);
+	return (retCode);
+}
+
+/*
+ *  Arguments:
+ *      SessionId, file handle, type of lock (read/write or unlock),
+ *	    start of lock area, length of lock area
+ *
+ *  Returns:
+ *      0 on success
+ *      negative value on error
+ *
+ *  Abstract:
+ *
+ *  Notes: lock type - fcntl
+ */
+int Novfs_Set_File_Lock(session_t SessionId, HANDLE Handle,
+			unsigned char fl_type, loff_t fl_start, loff_t fl_len)
+{
+	PSET_FILE_LOCK_REQUEST cmd;
+	PSET_FILE_LOCK_REPLY reply = NULL;
+	unsigned long replylen = 0;
+	int retCode;
+
+	retCode = -1;
+
+	DbgPrint("Novfs_Set_File_Lock:\n"
+		 "   SessionId:     0x%llx\n", SessionId);
+
+	cmd =
+	    (PSET_FILE_LOCK_REQUEST) Novfs_Malloc(sizeof(SET_FILE_LOCK_REQUEST),
+						  GFP_KERNEL);
+
+	if (cmd) {
+		DbgPrint("Novfs_Set_File_Lock 2\n");
+
+		cmd->Command.CommandType = VFS_COMMAND_SET_FILE_LOCK;
+		cmd->Command.SequenceNumber = 0;
+		cmd->Command.SessionId = SessionId;
+
+		cmd->handle = Handle;
+		if (F_RDLCK == fl_type) {
+			fl_type = 1;	// LockRegionExclusive
+		} else if (F_WRLCK == fl_type) {
+			fl_type = 0;	// LockRegionShared
+		}
+
+		cmd->fl_type = fl_type;
+		cmd->fl_start = fl_start;
+		cmd->fl_len = fl_len;
+
+		DbgPrint("Novfs_Set_File_Lock 3\n");
+
+		DbgPrint("Novfs_Set_File_Lock: BEGIN dump arguments\n");
+		DbgPrint("Novfs_Set_File_Lock: Queue_Daemon_Command %d\n",
+			 cmd->Command.CommandType);
+		DbgPrint("Novfs_Set_File_Lock: cmd->handle   = 0x%p\n",
+			 cmd->handle);
+		DbgPrint("Novfs_Set_File_Lock: cmd->fl_type  = %u\n",
+			 cmd->fl_type);
+		DbgPrint("Novfs_Set_File_Lock: cmd->fl_start = 0x%X\n",
+			 cmd->fl_start);
+		DbgPrint("Novfs_Set_File_Lock: cmd->fl_len   = 0x%X\n",
+			 cmd->fl_len);
+		DbgPrint
+		    ("Novfs_Set_File_Lock: sizeof(SET_FILE_LOCK_REQUEST) = %u\n",
+		     sizeof(SET_FILE_LOCK_REQUEST));
+		DbgPrint("Novfs_Set_File_Lock: END dump arguments\n");
+
+		retCode =
+		    Queue_Daemon_Command(cmd, sizeof(SET_FILE_LOCK_REQUEST),
+					 NULL, 0, (void *)&reply, &replylen,
+					 INTERRUPTIBLE);
+		DbgPrint("Novfs_Set_File_Lock 4\n");
+
+		if (reply) {
+			DbgPrint("Novfs_Set_File_Lock 5, ErrorCode = %X\n",
+				 reply->Reply.ErrorCode);
+
+			if (reply->Reply.ErrorCode) {
+				retCode = reply->Reply.ErrorCode;
+			}
+			kfree(reply);
+		}
+
+		kfree(cmd);
+	}
+
+	DbgPrint("Novfs_Set_File_Lock 6\n");
+
+	return (retCode);
+}
--- /dev/null
+++ b/fs/novfs/inode.c
@@ -0,0 +1,5563 @@
+/*
+ * Novell NCP Redirector for Linux
+ * Author: James Turner
+ *
+ * This file contains functions used to control access to the Linux file
+ * system.
+ *
+ * Copyright (C) 2005 Novell, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/autoconf.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/dcache.h>
+#include <linux/mount.h>
+#include <linux/pagemap.h>
+#include <linux/string.h>
+#include <linux/smp_lock.h>
+#include <linux/slab.h>
+#include <linux/unistd.h>
+#include <asm/statfs.h>
+#include <asm/uaccess.h>
+#include <linux/ctype.h>
+#include <linux/statfs.h>
+#include <linux/pagevec.h>
+#include <linux/writeback.h>
+#include <linux/backing-dev.h>
+#include <linux/mm.h>
+#include <linux/file.h>
+
+/*===[ Include files specific to this module ]============================*/
+#include "vfs.h"
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,18)
+#define FSPRIVATE u.generic_ip
+#else
+#define FSPRIVATE i_private
+#endif
+
+
+#define FILE_UPDATE_TIMEOUT   2
+
+struct inode_data {
+	void *Scope;
+	unsigned long Flags;
+	struct list_head IList;
+	struct inode *Inode;
+	unsigned long cntDC;
+	struct list_head DirCache;
+	struct semaphore DirCacheLock;
+	HANDLE FileHandle;
+	int CacheFlag;
+	char Name[1];		/* Needs to be last entry */
+};
+
+// FIXME these are wrong, but fake the compiler out for now until the proper people can be flogged...
+extern void *Scope_Get_ScopefromName(struct qstr *Name);
+extern void *Scope_Get_ScopefromPath(struct dentry *Dentry);
+
+/*===[ Function prototypes ]==============================================*/
+int Novfs_Remove_from_Root(char *RemoveName);
+int Novfs_Add_to_Root(char *);
+char *Novfs_dget_path(struct dentry *d, char *path, unsigned int pathlen);
+int verify_dentry(struct dentry *dentry, int Flags);
+int invalidate_dentry(struct dentry *parent);
+struct dentry *Novfs_d_lookup(struct dentry *Parent, struct qstr *Name);
+int Novfs_d_add(struct dentry *p, struct dentry *d, struct inode *i, int add);
+int Novfs_d_strcmp(struct qstr *s1, struct qstr *s2);
+unsigned long Novfs_internal_hash(struct qstr *name);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+int Novfs_get_sb(struct file_system_type *Fstype, int Flags,
+		 const char *Dev_name, void *Data, struct vfsmount *Mnt);
+#else
+struct super_block *Novfs_get_sb(struct file_system_type *Fstype, int Flags,
+				 const char *Dev_name, void *Data);
+#endif
+
+int Novfs_fill_super(struct super_block *SB, void *Data, int Silent);
+
+/*
+ * Declared dentry_operations
+ */
+int Novfs_d_revalidate(struct dentry *, struct nameidata *);
+int Novfs_d_hash(struct dentry *, struct qstr *);
+int Novfs_d_compare(struct dentry *, struct qstr *, struct qstr *);
+int Novfs_d_delete(struct dentry *dentry);
+void Novfs_d_release(struct dentry *dentry);
+void Novfs_d_iput(struct dentry *dentry, struct inode *inode);
+
+/*
+ * Declared directory operations
+ */
+int Novfs_dir_open(struct inode *inode, struct file *file);
+int Novfs_dir_release(struct inode *inode, struct file *file);
+loff_t Novfs_dir_lseek(struct file *file, loff_t offset, int origin);
+ssize_t Novfs_dir_read(struct file *file, char *buf, size_t len, loff_t * off);
+void addtodentry(struct dentry *Parent, unsigned char *List, int Level);
+int Novfs_filldir(void *data, const char *name, int namelen, loff_t off,
+		  ino_t ino, unsigned ftype);
+int Novfs_dir_readdir(struct file *filp, void *dirent, filldir_t filldir);
+int Novfs_dir_fsync(struct file *file, struct dentry *dentry, int datasync);
+
+/*
+ * Declared address space operations
+ */
+int Novfs_a_writepage(struct page *page, struct writeback_control *wbc);
+int Novfs_a_writepages(struct address_space *mapping,
+		       struct writeback_control *wbc);
+int Novfs_a_prepare_write(struct file *file, struct page *page, unsigned from,
+			  unsigned to);
+int Novfs_a_commit_write(struct file *file, struct page *page, unsigned offset,
+			 unsigned to);
+int Novfs_a_readpage(struct file *file, struct page *page);
+int Novfs_a_readpages(struct file *file, struct address_space *mapping,
+		      struct list_head *page_lst, unsigned nr_pages);
+ssize_t Novfs_a_direct_IO(int rw, struct kiocb *kiocb, const struct iovec *iov,
+			  loff_t offset, unsigned long nr_segs);
+
+/*
+ * Declared file_operations
+ */
+ssize_t Novfs_f_read(struct file *, char *, size_t, loff_t *);
+ssize_t Novfs_f_write(struct file *, const char *, size_t, loff_t *);
+int Novfs_f_readdir(struct file *, void *, filldir_t);
+int Novfs_f_ioctl(struct inode *, struct file *, unsigned int, unsigned long);
+int Novfs_f_mmap(struct file *file, struct vm_area_struct *vma);
+int Novfs_f_open(struct inode *, struct file *);
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,16)
+int Novfs_f_flush(struct file *);
+#else
+int Novfs_f_flush(struct file *, fl_owner_t);
+#endif
+int Novfs_f_release(struct inode *, struct file *);
+int Novfs_f_fsync(struct file *, struct dentry *, int datasync);
+int Novfs_f_lock(struct file *, int, struct file_lock *);
+
+/*
+ * Declared inode_operations
+ */
+int Novfs_i_create(struct inode *, struct dentry *, int, struct nameidata *);
+struct dentry *Novfs_i_lookup(struct inode *, struct dentry *,
+			      struct nameidata *);
+int Novfs_i_mkdir(struct inode *, struct dentry *, int);
+int Novfs_i_unlink(struct inode *dir, struct dentry *dentry);
+int Novfs_i_rmdir(struct inode *, struct dentry *);
+int Novfs_i_mknod(struct inode *, struct dentry *, int, dev_t);
+int Novfs_i_rename(struct inode *, struct dentry *, struct inode *,
+		   struct dentry *);
+int Novfs_i_permission(struct inode *inode, int mask);
+int Novfs_i_setattr(struct dentry *, struct iattr *);
+int Novfs_i_getattr(struct vfsmount *mnt, struct dentry *, struct kstat *);
+int Novfs_i_revalidate(struct dentry *dentry);
+
+/*
+ * Extended attributes operations
+ */
+
+int Novfs_i_getxattr(struct dentry *dentry, const char *name, void *buffer,
+		     size_t size);
+int Novfs_i_setxattr(struct dentry *dentry, const char *name, const void *value,
+		     size_t value_size, int flags);
+int Novfs_i_listxattr(struct dentry *dentry, char *buffer, size_t buffer_size);
+
+void update_inode(struct inode *Inode, struct entry_info *Info);
+
+/*
+ * Declared super_operations
+ */
+void Novfs_read_inode(struct inode *inode);
+void Novfs_write_inode(struct inode *inode);
+int Novfs_notify_change(struct dentry *dentry, struct iattr *attr);
+void Novfs_clear_inode(struct inode *inode);
+int Novfs_show_options(struct seq_file *s, struct vfsmount *m);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+int Novfs_statfs(struct dentry *de, struct kstatfs *buf);
+#else
+int Novfs_statfs(struct super_block *sb, struct kstatfs *buf);
+#endif
+
+/*
+ * Declared control interface functions
+ */
+ssize_t
+Novfs_Control_read(struct file *file, char *buf, size_t nbytes, loff_t * ppos);
+
+ssize_t
+Novfs_Control_write(struct file *file, const char *buf, size_t nbytes,
+		    loff_t * ppos);
+
+int Novfs_Control_ioctl(struct inode *inode, struct file *file,
+			unsigned int cmd, unsigned long arg);
+
+int __init init_novfs(void);
+void __exit exit_novfs(void);
+
+int Novfs_lock_inode_cache(struct inode *i);
+void Novfs_unlock_inode_cache(struct inode *i);
+int Novfs_enumerate_inode_cache(struct inode *i, struct list_head **iteration,
+				ino_t * ino, struct entry_info *info);
+int Novfs_get_entry(struct inode *i, struct qstr *name, ino_t * ino,
+		    struct entry_info *info);
+int Novfs_get_entry_by_pos(struct inode *i, loff_t pos, ino_t * ino,
+			   struct entry_info *info);
+int Novfs_get_entry_time(struct inode *i, struct qstr *name, ino_t * ino,
+			 struct entry_info *info, u64 * EntryTime);
+int Novfs_get_remove_entry(struct inode *i, ino_t * ino, struct entry_info *info);
+void Novfs_invalidate_inode_cache(struct inode *i);
+static struct dir_cache *Novfs_lookup_inode_cache(struct inode *i, struct qstr *name, ino_t ino);
+int Novfs_lookup_validate(struct inode *i, struct qstr *name, ino_t ino);
+int Novfs_add_inode_entry(struct inode *i, struct qstr *name, ino_t ino,
+			  struct entry_info *info);
+int Novfs_update_entry(struct inode *i, struct qstr *name, ino_t ino,
+		       struct entry_info *info);
+void Novfs_remove_inode_entry(struct inode *i, struct qstr *name, ino_t ino);
+void Novfs_free_invalid_entries(struct inode *i);
+void Novfs_free_inode_cache(struct inode *i);
+
+/*===[ Global variables ]=================================================*/
+struct dentry_operations Novfs_dentry_operations = {
+	.d_revalidate = Novfs_d_revalidate,
+	.d_hash = Novfs_d_hash,
+	.d_compare = Novfs_d_compare,
+	//.d_delete      = Novfs_d_delete,
+	.d_release = Novfs_d_release,
+	.d_iput = Novfs_d_iput,
+};
+
+struct file_operations Novfs_dir_operations = {
+	.owner = THIS_MODULE,
+	.open = Novfs_dir_open,
+	.release = Novfs_dir_release,
+	.llseek = Novfs_dir_lseek,
+	.read = Novfs_dir_read,
+	.readdir = Novfs_dir_readdir,
+	.fsync = Novfs_dir_fsync,
+};
+
+static struct file_operations Novfs_file_operations = {
+	.owner = THIS_MODULE,
+	.read = Novfs_f_read,
+	.write = Novfs_f_write,
+	.readdir = Novfs_f_readdir,
+	.ioctl = Novfs_f_ioctl,
+	.mmap = Novfs_f_mmap,
+	.open = Novfs_f_open,
+	.flush = Novfs_f_flush,
+	.release = Novfs_f_release,
+	.fsync = Novfs_f_fsync,
+	.llseek = generic_file_llseek,
+	.lock = Novfs_f_lock,
+};
+
+static struct address_space_operations Novfs_nocache_aops = {
+	.readpage = Novfs_a_readpage,
+};
+
+struct backing_dev_info Novfs_backing_dev_info = {
+	.ra_pages = (VM_MAX_READAHEAD * 1024) / PAGE_CACHE_SIZE,
+	.state = 0,
+	.capabilities = BDI_CAP_NO_WRITEBACK | BDI_CAP_MAP_COPY,
+	.unplug_io_fn = default_unplug_io_fn,
+};
+
+static struct address_space_operations Novfs_aops = {
+	.readpage = Novfs_a_readpage,
+	.readpages = Novfs_a_readpages,
+	.writepage = Novfs_a_writepage,
+	.writepages = Novfs_a_writepages,
+	.prepare_write = Novfs_a_prepare_write,
+	.commit_write = Novfs_a_commit_write,
+	.set_page_dirty = __set_page_dirty_nobuffers,
+	.direct_IO = Novfs_a_direct_IO,
+};
+
+static struct inode_operations Novfs_inode_operations = {
+	.create = Novfs_i_create,
+	.lookup = Novfs_i_lookup,
+	.unlink = Novfs_i_unlink,
+	.mkdir = Novfs_i_mkdir,
+	.rmdir = Novfs_i_rmdir,
+	.mknod = Novfs_i_mknod,
+	.rename = Novfs_i_rename,
+	.setattr = Novfs_i_setattr,
+	.getattr = Novfs_i_getattr,
+/*
+	.getxattr = Novfs_i_getxattr,
+	.setxattr = Novfs_i_setxattr,
+	.listxattr = Novfs_i_listxattr,
+*/
+};
+
+static struct inode_operations Novfs_file_inode_operations = {
+	.setattr = Novfs_i_setattr,
+	.getattr = Novfs_i_getattr,
+/*
+	.getxattr = Novfs_i_getxattr,
+	.setxattr = Novfs_i_setxattr,
+	.listxattr = Novfs_i_listxattr,
+*/
+};
+
+static struct super_operations Novfs_ops = {
+	.statfs = Novfs_statfs,
+	.clear_inode = Novfs_clear_inode,
+	.drop_inode = generic_delete_inode,
+	.show_options = Novfs_show_options,
+
+};
+
+/* Not currently used
+static struct file_operations Novfs_Control_operations = {
+   .read    = Novfs_Control_read,
+   .write   = Novfs_Control_write,
+   .ioctl   = Novfs_Control_ioctl,
+};
+*/
+
+static atomic_t Novfs_Inode_Number = ATOMIC_INIT(0);
+
+struct dentry *Novfs_root = NULL;
+
+int Novfs_Version_Major = NOVFS_VFS_MAJOR;
+int Novfs_Version_Minor = NOVFS_VFS_MINOR;
+int Novfs_Version_Sub = NOVFS_VFS_SUB;
+int Novfs_Version_Release = NOVFS_VFS_RELEASE;
+
+char *Novfs_CurrentMount = NULL;
+
+DECLARE_MUTEX(InodeList_lock);
+
+LIST_HEAD(InodeList);
+
+DECLARE_MUTEX(TimeDir_Lock);
+uint64_t lastTime;
+char lastDir[PATH_MAX];
+
+uint64_t inHAXTime;
+int inHAX;
+
+unsigned long InodeCount = 0, DCCount = 0;
+unsigned long File_update_timeout = FILE_UPDATE_TIMEOUT;
+int PageCache = 0;
+
+typedef struct _Novfs_List2 {
+	struct list_head list;
+	void *data;
+} Novfs_List2;
+
+typedef struct _File_Private2 {
+	int listedall;
+	HANDLE enumHandle;
+} FilePrivate2;
+
+static void PRINT_DENTRY(const char *s, struct dentry *d)
+{
+	DbgPrint("%s: 0x%p\n", s, d);
+	DbgPrint("   d_count:      0x%x\n", d->d_count);
+	DbgPrint("   d_lock:       0x%x\n", d->d_lock);
+	DbgPrint("   d_inode:      0x%x\n", d->d_inode);
+	DbgPrint("   d_lru:        0x%p\n"
+		 "      next:      0x%p\n"
+		 "      prev:      0x%p\n", &d->d_lru, d->d_lru.next,
+		 d->d_lru.prev);
+	DbgPrint("   d_child:      0x%p\n" "      next:      0x%p\n"
+		 "      prev:      0x%p\n", &d->D_CHILD, d->D_CHILD.next,
+		 d->D_CHILD.prev);
+	DbgPrint("   d_subdirs:    0x%p\n" "      next:      0x%p\n"
+		 "      prev:      0x%p\n", &d->d_subdirs, d->d_subdirs.next,
+		 d->d_subdirs.prev);
+	DbgPrint("   d_alias:      0x%p\n" "      next:      0x%p\n"
+		 "      prev:      0x%p\n", &d->d_alias, d->d_alias.next,
+		 d->d_alias.prev);
+	DbgPrint("   d_time:       0x%x\n", d->d_time);
+	DbgPrint("   d_op:         0x%p\n", d->d_op);
+	DbgPrint("   d_sb:         0x%p\n", d->d_sb);
+	DbgPrint("   d_flags:      0x%x\n", d->d_flags);
+	DbgPrint("   d_mounted:    0x%x\n", d->d_mounted);
+	DbgPrint("   d_fsdata:     0x%p\n", d->d_fsdata);
+/*   DbgPrint("   d_cookie:     0x%x\n", d->d_cookie); */
+	DbgPrint("   d_parent:     0x%p\n", d->d_parent);
+	DbgPrint("   d_name:       0x%p %.*s\n", &d->d_name, d->d_name.len,
+		 d->d_name.name);
+	DbgPrint("      name:      0x%p\n" "      len:       %d\n"
+		 "      hash:      0x%x\n", d->d_name.name, d->d_name.len,
+		 d->d_name.hash);
+	DbgPrint("   d_hash:       0x%x\n" "      next:      0x%x\n"
+		 "      pprev:     0x%x\n", d->d_hash, d->d_hash.next,
+		 d->d_hash.pprev);
+}
+
+/*++======================================================================*/
+int Novfs_Remove_from_Root(char *RemoveName)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	struct qstr name;
+	struct dentry *dentry;
+	struct inode *dir;
+
+	DbgPrint("Novfs_Remove_from_Root: %s\n", RemoveName);
+	name.len = strlen(RemoveName);
+	name.name = RemoveName;
+	Novfs_d_hash(Novfs_root, &name);
+
+	dentry = d_lookup(Novfs_root, &name);
+	if (dentry) {
+		if (dentry->d_inode && dentry->d_inode->FSPRIVATE) {
+			((struct inode_data *)(dentry->d_inode->FSPRIVATE))->Scope =
+			    NULL;
+		}
+		dput(dentry);
+	}
+
+	dir = Novfs_root->d_inode;
+
+	Novfs_lock_inode_cache(dir);
+	Novfs_remove_inode_entry(dir, &name, 0);
+	Novfs_unlock_inode_cache(dir);
+
+	return (0);
+}
+
+/*++======================================================================*/
+int Novfs_Add_to_Root(char *AddName)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	struct qstr name;
+	struct inode *dir;
+	struct entry_info info;
+	ino_t ino;
+
+	DbgPrint("Novfs_Add_to_Root: %s\n", AddName);
+	name.len = strlen(AddName);
+	name.name = AddName;
+	Novfs_d_hash(Novfs_root, &name);
+
+	dir = Novfs_root->d_inode;
+
+	Novfs_lock_inode_cache(dir);
+
+	ino = 0;
+
+	if (!Novfs_lookup_inode_cache(dir, &name, 0)) {
+		info.mode = S_IFDIR | 0700;
+		info.size = 0;
+		info.atime = info.ctime = info.mtime = CURRENT_TIME;
+
+		ino = (ino_t)atomic_inc_return(&Novfs_Inode_Number);
+		Novfs_add_inode_entry(dir, &name, ino, &info);
+	}
+
+	Novfs_unlock_inode_cache(dir);
+
+	return (0);
+}
+
+/*++======================================================================*/
+int Novfs_Add_to_Root2(char *AddName)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	struct dentry *entry;
+	struct qstr name;
+	struct inode *inode;
+	void *scope;
+
+	DbgPrint("Novfs_Add_to_Root: %s\n", AddName);
+	name.len = strlen(AddName);
+	name.name = AddName;
+
+	Novfs_d_hash(Novfs_root, &name);
+
+	entry = Novfs_d_lookup(Novfs_root, &name);
+	DbgPrint("Novfs_Add_to_Root: Novfs_d_lookup 0x%p\n", entry);
+	if (NULL == entry) {
+		scope = Scope_Lookup();
+
+		entry = d_alloc(Novfs_root, &name);
+		DbgPrint("Novfs_Add_to_Root: d_alloc 0x%p\n", entry);
+		if (entry) {
+			entry->d_op = &Novfs_dentry_operations;
+			entry->d_time = jiffies + (File_update_timeout * HZ);
+			/*
+			 * done in Novfs_d_add now... entry->d_fsdata = (void *)Novfs_internal_hash( &name );
+			 */
+			inode =
+			    Novfs_get_inode(Novfs_root->d_sb, S_IFDIR | 0700, 0, Scope_Get_Uid(scope), 0, &name);
+			DbgPrint("Novfs_Add_to_Root: Inode=0x%p\n", inode);
+			if (inode) {
+				inode->i_atime =
+				    inode->i_ctime =
+				    inode->i_mtime = CURRENT_TIME;
+				if (!Novfs_d_add(Novfs_root, entry, inode, 1)) {
+					if (inode->FSPRIVATE) {
+						((struct inode_data *) inode->
+						 FSPRIVATE)->Flags = USER_INODE;
+					}
+					PRINT_DENTRY("After Novfs_d_add",
+						     entry);
+				} else {
+					dput(entry);
+					iput(inode);
+				}
+			}
+		}
+	} else {
+		dput(entry);
+		PRINT_DENTRY("Novfs_Add_to_Root: After dput Dentry", entry);
+	}
+	return (0);
+}
+
+/*++======================================================================*/
+char *Novfs_dget_path(struct dentry *Dentry, char *Buf, unsigned int Buflen)
+/*
+ *  Arguments:   struct dentry *Dentry - starting entry
+ *               char *Buf - pointer to memory buffer
+ *               unsigned int Buflen - size of memory buffer
+ *
+ *  Returns:     pointer to path.
+ *
+ *  Abstract:    Walks the dentry chain building a path.
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	char *retval = &Buf[Buflen];
+	struct dentry *p = Dentry;
+
+	*(--retval) = '\0';
+	Buflen--;
+
+	if (!IS_ROOT(p) && !IS_ROOT(p->d_parent)) {
+		while (Buflen && !IS_ROOT(p) && !IS_ROOT(p->d_parent)) {
+			if (Buflen > p->d_name.len) {
+				retval -= p->d_name.len;
+				Buflen -= p->d_name.len;
+				memcpy(retval, p->d_name.name, p->d_name.len);
+				*(--retval) = '\\';
+				Buflen--;
+				p = p->d_parent;
+			} else {
+				retval = NULL;
+				break;
+			}
+		}
+	} else {
+		*(--retval) = '\\';
+	}
+
+	if (retval)
+		DbgPrint("Novfs_dget_path: %s\n", retval);
+	return (retval);
+}
+
+/*++======================================================================*/
+int verify_dentry(struct dentry *dentry, int Flags)
+/*
+ *  Arguments:   struct dentry *dentry - entry to verify
+ *
+ *  Returns:     zero - Inode cache has been updated.  If not in the cache
+ *                      then file doesn't exist.
+ *               !zero - Error
+ *
+ *  Abstract:    This routine will verify if the file that dentry is pointing
+ *               at exist and if it does it will put it in the inode cache of
+ *               the parent.
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	int retVal = -ENOENT;
+	struct inode *dir;
+	struct entry_info *info = NULL;
+	struct inode_data *id;
+	session_t session;
+	char *path, *list = NULL, *cp;
+	ino_t ino = 0;
+	struct qstr name;
+	int iLock = 0;
+	struct dentry *parent = NULL;
+	u64 ctime;
+	struct inode *inode;
+
+	if (IS_ROOT(dentry)) {
+		DbgPrint("verify_dentry: Root entry\n");
+		return (0);
+	}
+
+	if (dentry && dentry->d_parent &&
+	    (dir = dentry->d_parent->d_inode) && (id = dir->FSPRIVATE)) {
+		parent = dget_parent(dentry);
+
+		info = Novfs_Malloc(sizeof(struct entry_info) + PATH_LENGTH_BUFFER, GFP_KERNEL);
+
+		if (info) {
+			if (Novfs_lock_inode_cache(dir)) {
+				name.len = dentry->d_name.len;
+				name.name = dentry->d_name.name;
+				name.hash = Novfs_internal_hash(&name);
+				if (!Novfs_get_entry_time(dir, &name, &ino, info, &ctime)) {
+					inode = dentry->d_inode;
+					if (inode && inode->FSPRIVATE &&
+					    ((inode->i_size != info->size) ||
+					     (inode->i_mtime.tv_sec !=
+					      info->mtime.tv_sec)
+					     || (inode->i_mtime.tv_nsec !=
+						 info->mtime.tv_nsec))) {
+						/*
+						 * Values don't match so update.
+						 */
+						((struct inode_data *) inode->FSPRIVATE)->Flags |= UPDATE_INODE;
+					}
+
+					ctime = get_jiffies_64() - ctime;
+					if (Flags || ctime < (u64) (File_update_timeout * HZ)) {
+						retVal = 0;
+						Novfs_unlock_inode_cache(dir);
+						dput(parent);
+						kfree(info);
+						return (0);
+					}
+				}
+				Novfs_unlock_inode_cache(dir);
+			}
+
+			if (IS_ROOT(dentry->d_parent)) {
+				session = Scope_Get_SessionId(Scope_Get_ScopefromName(&dentry->d_name));
+			} else {
+				session = Scope_Get_SessionId(id->Scope);
+			}
+
+			if (!SC_PRESENT(session)) {
+				id->Scope = Scope_Get_ScopefromPath(dentry);
+				session = Scope_Get_SessionId(id->Scope);
+			}
+
+			ino = 0;
+			retVal = 0;
+
+			if (IS_ROOT(dentry->d_parent)) {
+				DbgPrint("verify_dentry: parent is Root directory\n");
+				list = Scope_Get_ScopeUsers();
+
+				iLock = Novfs_lock_inode_cache(dir);
+				Novfs_invalidate_inode_cache(dir);
+
+				if (list) {
+					cp = list;
+					while (*cp) {
+						name.name = cp;
+						name.len = strlen(cp);
+						name.hash = Novfs_internal_hash(&name);
+						cp += (name.len + 1);
+						ino = 0;
+						if (Novfs_get_entry(dir, &name, &ino, info)) {
+							info->mode = S_IFDIR | 0700;
+							info->size = 0;
+							info->atime = info->ctime = info->mtime = CURRENT_TIME;
+							ino = (ino_t)atomic_inc_return(&Novfs_Inode_Number);
+							Novfs_add_inode_entry(dir, &name, ino, info);
+						}
+					}
+				}
+				Novfs_free_invalid_entries(dir);
+			} else {
+
+				path =
+				    Novfs_dget_path(dentry, info->name,
+						    PATH_LENGTH_BUFFER);
+				if (path) {
+					if (dentry->d_name.len <=
+					    NW_MAX_PATH_LENGTH) {
+						name.hash =
+						    Novfs_internal_hash
+						    (&dentry->d_name);
+						name.len = dentry->d_name.len;
+						name.name = dentry->d_name.name;
+
+						retVal = Novfs_Get_File_Info(path, info, &session);
+						if (0 == retVal) {
+							dentry->d_time =
+							    jiffies +
+							    (File_update_timeout
+							     * HZ);
+							iLock =
+							    Novfs_lock_inode_cache
+							    (dir);
+							if (Novfs_update_entry
+							    (dir, &name, 0,
+							     info)) {
+								if (dentry->
+								    d_inode) {
+									ino = dentry->d_inode->i_ino;
+								} else {
+									ino = (ino_t)atomic_inc_return(&Novfs_Inode_Number);
+								}
+								Novfs_add_inode_entry
+								    (dir, &name,
+								     ino, info);
+							}
+							if (dentry->d_inode) {
+								update_inode
+								    (dentry->
+								     d_inode,
+								     info);
+								id->Flags &=
+								    ~UPDATE_INODE;
+
+								dentry->
+								    d_inode->
+								    i_flags &=
+								    ~S_DEAD;
+								if (dentry->
+								    d_inode->
+								    FSPRIVATE) {
+									((struct inode_data *) dentry->d_inode->FSPRIVATE)->Scope = id->Scope;
+								}
+							}
+						} else if (-EINTR != retVal) {
+							retVal = 0;
+							iLock = Novfs_lock_inode_cache(dir);
+							Novfs_remove_inode_entry(dir, &name, 0);
+							if (dentry->d_inode
+							    && !(dentry->d_inode->i_flags & S_DEAD)) {
+								dentry->d_inode->i_flags |= S_DEAD;
+								dentry->d_inode-> i_size = 0;
+								dentry->d_inode->i_atime.tv_sec =
+									dentry->d_inode->i_atime.tv_nsec =
+									dentry->d_inode->i_ctime.tv_sec =
+									dentry->d_inode->i_ctime.tv_nsec =
+									dentry->d_inode->i_mtime.tv_sec =
+									dentry->d_inode->i_mtime.tv_nsec = 0;
+								dentry->d_inode->i_blocks = 0;
+								d_delete(dentry);	/* Remove from cache */
+							}
+						}
+					} else {
+						retVal = -ENAMETOOLONG;
+					}
+				}
+			}
+		} else {
+			retVal = -ENOMEM;
+		}
+		if (iLock) {
+			Novfs_unlock_inode_cache(dir);
+		}
+		dput(parent);
+	}
+
+	if (list)
+		kfree(list);
+	if (info)
+		kfree(info);
+
+	DbgPrint("verify_dentry: return=0x%x\n", retVal);
+
+	return (retVal);
+}
+
+/*++======================================================================*/
+struct dentry *Novfs_d_lookup(struct dentry *Parent, struct qstr *Name)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	return (d_lookup(Parent, Name));
+}
+
+/*++======================================================================*/
+int Novfs_d_add(struct dentry *Parent, struct dentry *d, struct inode *i, int a)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	void *scope;
+	struct inode_data *id = NULL;
+
+	char *path, *buf;
+
+	buf = (char *)Novfs_Malloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
+	if (buf) {
+		path = Novfs_dget_path(d, buf, PATH_LENGTH_BUFFER);
+		if (path) {
+			DbgPrint("Novfs_d_add: inode=0x%p ino=%d path %s\n", i,
+				 i->i_ino, path);
+		}
+		kfree(buf);
+	}
+
+	if (Parent && Parent->d_inode && Parent->d_inode->FSPRIVATE) {
+		id = (struct inode_data *) Parent->d_inode->FSPRIVATE;
+	}
+
+	if (id && id->Scope) {
+		scope = id->Scope;
+	} else {
+		scope = Scope_Get_ScopefromPath(d);
+	}
+
+	((struct inode_data *) i->FSPRIVATE)->Scope = scope;
+
+	d->d_time = jiffies + (File_update_timeout * HZ);
+	if (a) {
+		d_add(d, i);
+	} else {
+		d_instantiate(d, i);
+	}
+
+	return (0);
+}
+
+/*++======================================================================*/
+int Novfs_d_revalidate(struct dentry *dentry, struct nameidata *nd)
+/*
+ *  Arguments:   struct dentry *dentry - pointer to dentry to revalidate.
+ *               struct nameidata *nd - pointer to nameidata.
+ *
+ *  Returns:     zero - dentry is not valid.
+ *               !zero - valid entry
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	int retCode = 0;
+	struct inode *dir;
+	struct inode_data *id;
+	struct qstr name;
+
+	DbgPrint("Novfs_d_revalidate: 0x%p %.*s\n"
+		 "   d_count: %d\n"
+		 "   d_inode: 0x%p\n",
+		 dentry, dentry->d_name.len, dentry->d_name.name,
+		 dentry->d_count, dentry->d_inode);
+
+	if (IS_ROOT(dentry)) {
+		retCode = 1;
+	} else {
+		if (dentry->d_inode &&
+		    dentry->d_parent &&
+		    (dir = dentry->d_parent->d_inode) &&
+		    (id = dir->FSPRIVATE)) {
+			/*
+			 * Check timer to see if in valid time limit
+			 */
+			if (jiffies > dentry->d_time) {
+				/*
+				 * Revalidate entry
+				 */
+				name.len = dentry->d_name.len;
+				name.name = dentry->d_name.name;
+				name.hash =
+				    Novfs_internal_hash(&dentry->d_name);
+				dentry->d_time = 0;
+
+				if (0 == verify_dentry(dentry, 0)) {
+					if (Novfs_lock_inode_cache(dir)) {
+						if (Novfs_lookup_inode_cache
+						    (dir, &name, 0)) {
+							dentry->d_time =
+							    jiffies +
+							    (File_update_timeout
+							     * HZ);
+							retCode = 1;
+						}
+						Novfs_unlock_inode_cache(dir);
+					}
+				}
+			} else {
+				retCode = 1;
+			}
+		}
+	}
+
+	if ((0 == retCode) && dentry->d_inode) {
+		/*
+		 * Entry has become invalid
+		 */
+/*      dput(dentry);
+*/
+	}
+
+	DbgPrint("Novfs_d_revalidate: return 0x%x %.*s\n", retCode,
+		 dentry->d_name.len, dentry->d_name.name);
+
+	return (retCode);
+}
+
+/*++======================================================================*/
+unsigned long Novfs_internal_hash(struct qstr *name)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	unsigned long hash = 0;
+	unsigned int len = name->len;
+	unsigned char *c = (unsigned char *)name->name;
+
+	while (len--) {
+		/*
+		 * Lower case values for the hash.
+		 */
+		hash = partial_name_hash(tolower(*c++), hash);
+	}
+
+	return (hash);
+}
+
+/*++======================================================================*/
+int Novfs_d_hash(struct dentry *dentry, struct qstr *name)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	DbgPrint("Novfs_d_hash: %.*s\n", name->len, name->name);
+
+	name->hash = Novfs_internal_hash(name);
+
+	return (0);
+}
+
+/*++======================================================================*/
+int Novfs_d_strcmp(struct qstr *s1, struct qstr *s2)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	int retCode = 1;
+	unsigned char *str1, *str2;
+	unsigned int len;
+
+	DbgPrint("Novfs_d_strcmp: s1=%.*s s2=%.*s\n", s1->len, s1->name,
+		 s2->len, s2->name);
+
+	if (s1->len && (s1->len == s2->len) && (s1->hash == s2->hash)) {
+		len = s1->len;
+		str1 = (unsigned char *)s1->name;
+		str2 = (unsigned char *)s2->name;
+		for (retCode = 0; len--; str1++, str2++) {
+			if (*str1 != *str2) {
+				if (tolower(*str1) != tolower(*str2)) {
+					retCode = 1;
+					break;
+				}
+			}
+		}
+	}
+
+	DbgPrint("Novfs_d_strcmp: retCode=0x%x\n", retCode);
+	return (retCode);
+}
+
+/*++======================================================================*/
+int Novfs_d_compare(struct dentry *parent, struct qstr *s1, struct qstr *s2)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	int retCode;
+
+	retCode = Novfs_d_strcmp(s1, s2);
+
+	DbgPrint("Novfs_d_compare: retCode=0x%x\n", retCode);
+	return (retCode);
+}
+
+/*++======================================================================*/
+int Novfs_d_delete(struct dentry *dentry)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	int retVal = 0;
+
+	DbgPrint("Novfs_d_delete: 0x%p %.*s\n"
+		 "   d_count: %d\n"
+		 "   d_inode: 0x%p\n",
+		 dentry, dentry->d_name.len, dentry->d_name.name,
+		 dentry->d_count, dentry->d_inode);
+
+	if (dentry->d_inode && (dentry->d_inode->i_flags & S_DEAD)) {
+		retVal = 1;
+	}
+
+	dentry->d_time = 0;
+
+	return (retVal);
+}
+
+/*++======================================================================*/
+void Novfs_d_release(struct dentry *dentry)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	DbgPrint("Novfs_d_release: 0x%p %.*s\n", dentry, dentry->d_name.len,
+		 dentry->d_name.name);
+}
+
+/*++======================================================================*/
+void Novfs_d_iput(struct dentry *dentry, struct inode *inode)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	DbgPrint
+	    ("Novfs_d_iput: Inode=0x%p Ino=%d Dentry=0x%p i_state=%d Name=%.*s\n",
+	     inode, inode->i_ino, dentry, inode->i_state, dentry->d_name.len,
+	     dentry->d_name.name);
+
+	iput(inode);
+
+}
+
+/*++======================================================================*/
+int Novfs_dir_open(struct inode *dir, struct file *file)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	char *path, *buf;
+	FilePrivate2 *file_private = NULL;
+
+	DbgPrint("Novfs_dir_open: Inode 0x%p %d Name %.*s\n", dir, dir->i_ino,
+		 file->f_dentry->d_name.len, file->f_dentry->d_name.name);
+
+	buf = (char *)Novfs_Malloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
+	if (buf) {
+		path = Novfs_dget_path(file->f_dentry, buf, PATH_LENGTH_BUFFER);
+		if (path) {
+			DbgPrint("Novfs_dir_open: path %s\n", path);
+		}
+		kfree(buf);
+	}
+
+	file_private = Novfs_Malloc(sizeof(FilePrivate2), GFP_KERNEL);
+	file_private->listedall = 0;
+	file_private->enumHandle = NULL;
+
+	file->private_data = file_private;
+
+	return (0);
+}
+
+/*++======================================================================*/
+int Novfs_dir_release(struct inode *dir, struct file *file)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	FilePrivate2 *file_private;
+	file_private = (FilePrivate2 *) file->private_data;
+
+	DbgPrint("Novfs_dir_release: Inode 0x%p %d Name %.*s\n", dir,
+		 dir->i_ino, file->f_dentry->d_name.len,
+		 file->f_dentry->d_name.name);
+
+	if (file_private) {
+		kfree(file_private);
+		file->private_data = NULL;
+	}
+
+	return (0);
+}
+
+/*++======================================================================*/
+loff_t Novfs_dir_lseek(struct file * file, loff_t offset, int origin)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	FilePrivate2 *file_private = NULL;
+
+	DbgPrint("Novfs_dir_lseek: offset %lld %d Name %.*s\n", offset, origin,
+		 file->f_dentry->d_name.len, file->f_dentry->d_name.name);
+	//printk("<1> seekdir file = %.*s offset = %i\n", file->f_dentry->d_name.len, file->f_dentry->d_name.name, (int)offset);
+
+	if (0 != offset) {
+		return -ESPIPE;
+	}
+
+	file->f_pos = 0;
+
+	file_private = (FilePrivate2 *) file->private_data;
+	file_private->listedall = 0;
+	file_private->enumHandle = NULL;
+
+	return 0;
+	//return(default_llseek(file, offset, origin));
+}
+
+/*++======================================================================*/
+ssize_t Novfs_dir_read(struct file * file, char *buf, size_t len, loff_t * off)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+/*
+   int rlen = 0;
+
+   DbgPrint("Novfs_dir_readdir: dentry path %.*s buf=0x%p len=%d off=%lld\n", file->f_dentry->d_name.len, file->f_dentry->d_name.name, buf, len, *off);
+
+   if (0 == *off)
+   {
+      rlen = 8;
+      rlen -= copy_to_user(buf, "Testing\n", 8);
+      *off += rlen;
+   }
+   return(rlen);
+*/
+	DbgPrint("Novfs_dir_read: %lld %d Name %.*s\n", *off, len,
+		 file->f_dentry->d_name.len, file->f_dentry->d_name.name);
+	return (generic_read_dir(file, buf, len, off));
+}
+
+static void Novfs_Dump_Info(struct entry_info *info)
+{
+	char atime_buf[32], mtime_buf[32], ctime_buf[32];
+	char namebuf[512];
+	int len = 0;
+
+	if (info == NULL) {
+		DbgPrint("Novfs_dir_readdir : Dump_Info info == NULL\n");
+		return;
+	}
+
+	if (info->namelength >= 512) {
+		len = 511;
+	} else {
+		len = info->namelength;
+	}
+
+	memcpy(namebuf, info->name, len);
+	namebuf[len] = '\0';
+
+	ctime_r(&info->atime.tv_sec, atime_buf);
+	ctime_r(&info->mtime.tv_sec, mtime_buf);
+	ctime_r(&info->ctime.tv_sec, ctime_buf);
+	DbgPrint("Novfs_dir_readdir : type = %i\n", info->type);
+	DbgPrint("Novfs_dir_readdir : mode = %x\n", info->mode);
+	DbgPrint("Novfs_dir_readdir : uid = %d\n", info->uid);
+	DbgPrint("Novfs_dir_readdir : gid = %d\n", info->gid);
+	DbgPrint("Novfs_dir_readdir : size = %i\n", info->size);
+	DbgPrint("Novfs_dir_readdir : atime = %s\n", atime_buf);
+	DbgPrint("Novfs_dir_readdir : mtime = %s\n", mtime_buf);
+	DbgPrint("Novfs_dir_readdir : ctime = %s\n", ctime_buf);
+	DbgPrint("Novfs_dir_readdir : namelength = %i\n", info->namelength);
+	DbgPrint("Novfs_dir_readdir : name = %s\n", namebuf);
+}
+
+/*++======================================================================*/
+void processList(struct file *file, void *dirent, filldir_t filldir, char *list,
+		 int type, session_t SessionId)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	unsigned char *path, *buf = NULL, *cp;
+	struct qstr name;
+	struct entry_info *pinfo = NULL;
+
+	buf = (char *)Novfs_Malloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
+	path = buf;
+	if (buf) {
+		path = Novfs_dget_path(file->f_dentry, buf, PATH_LENGTH_BUFFER);
+		if (path) {
+			strcpy(buf, path);
+		}
+		path = buf + strlen(buf);
+		*path++ = '\\';
+	}
+
+	if (list) {
+		cp = list;
+		while (*cp) {
+			name.name = cp;
+			DbgPrint("Novfs_dir_readdir : name.name = %s\n",
+				 name.name);
+			name.len = strlen(cp);
+			name.hash = Novfs_internal_hash(&name);
+			cp += (name.len + 1);
+
+			pinfo =
+			    Novfs_Malloc(sizeof(struct entry_info) +
+					 PATH_LENGTH_BUFFER, GFP_KERNEL);
+			pinfo->mode = S_IFDIR | 0700;
+			pinfo->size = 0;
+			pinfo->atime = pinfo->ctime = pinfo->mtime =
+			    CURRENT_TIME;
+			strcpy(pinfo->name, name.name);
+			pinfo->namelength = name.len;
+
+			Novfs_Dump_Info(pinfo);
+
+			filldir(dirent, pinfo->name, pinfo->namelength,
+				file->f_pos, file->f_pos, pinfo->mode >> 12);
+			file->f_pos += 1;
+
+			kfree(pinfo);
+		}
+	}
+
+	if (buf) {
+		kfree(buf);
+	}
+}
+
+int processEntries(struct file *file, void *dirent, filldir_t filldir,
+		   HANDLE * enumHandle, session_t sessionId)
+{
+	unsigned char *path = NULL, *buf = NULL;
+	int count = 0, status = 0;
+	struct entry_info *pinfo = NULL;
+	struct entry_info *pInfoMem = NULL;
+
+	buf = (char *)Novfs_Malloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
+	if (!buf) {
+		return -ENOMEM;
+	}
+
+	path = Novfs_dget_path(file->f_dentry, buf, PATH_LENGTH_BUFFER);
+	if (!path) {
+		kfree(buf);
+		return -ENOMEM;
+	}
+	//NWSearchfiles
+	count = 0;
+	status = Novfs_Get_Directory_ListEx(path, enumHandle, &count, &pinfo, &sessionId);
+	pInfoMem = pinfo;
+
+	if ((count == -1) || (count == 0) || (status != 0)) {
+		kfree(pInfoMem);
+		kfree(buf);
+		return -1;
+	}
+	// parse resultset
+	while (pinfo && count--) {
+		filldir(dirent, pinfo->name, pinfo->namelength, file->f_pos,
+			file->f_pos, pinfo->mode >> 12);
+		file->f_pos += 1;
+
+		pinfo = (struct entry_info *)(pinfo->name + pinfo->namelength);
+	}
+
+	kfree(pInfoMem);
+	kfree(buf);
+	return 0;
+}
+
+/*++======================================================================*/
+int Novfs_dir_readdir(struct file *file, void *dirent, filldir_t filldir)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	unsigned char *list = NULL;
+	int status = 0;		//-ENOMEM;
+	struct inode *inode = file->f_dentry->d_inode;
+	session_t sessionId;
+	uid_t uid;
+	int type = 0;
+	FilePrivate2 *file_private = NULL;
+	int lComm;
+
+	file_private = (FilePrivate2 *) file->private_data;
+	DbgPrint("Novfs_dir_readdir: Name %.*s\n", file->f_dentry->d_name.len,
+		 file->f_dentry->d_name.name);
+
+	//printk("<1> file = %.*s\n", file->f_dentry->d_name.len, file->f_dentry->d_name.name);
+
+// Use this hack by default
+#ifndef SKIP_CROSSOVER_HACK
+	// Hack for crossover - begin
+	down(&TimeDir_Lock);
+	if ((file->f_dentry->d_name.len == 7) &&
+	    ((0 == strncmp(file->f_dentry->d_name.name, " !xover", 7)) ||
+	     (0 == strncmp(file->f_dentry->d_name.name, "z!xover", 7)))) {
+		//printk("<1> xoverhack: we are in xoverHack\n");
+
+		inHAX = 1;
+		inHAXTime = get_nanosecond_time();
+		//up( &TimeDir_Lock );
+		//return 0;
+		file_private->listedall = 1;
+	} else {
+		if (inHAX) {
+			if (get_nanosecond_time() - inHAXTime >
+			    100 * 1000 * 1000) {
+				//printk("<1> xoverhack: it was long, long, long ago...\n");
+				inHAX = 0;
+			} else {
+				//printk("<1> xoverhack: word gotcha in xoverHack...\n");
+				inHAXTime = get_nanosecond_time();
+				//up( &TimeDir_Lock );
+				//return 0;
+				file_private->listedall = 1;
+			}
+		}
+	}
+
+	up(&TimeDir_Lock);
+	// Hack for crossover - end
+#endif
+
+	if (file->f_pos == 0) {
+		if (filldir(dirent, ".", 1, file->f_pos, inode->i_ino, DT_DIR) <
+		    0)
+			return 1;
+		file->f_pos++;
+		return 1;
+	}
+
+	if (file->f_pos == 1) {
+		if (filldir
+		    (dirent, "..", 2, file->f_pos,
+		     file->f_dentry->d_parent->d_inode->i_ino, DT_DIR) < 0)
+			return 1;
+		file->f_pos++;
+		return 1;
+	}
+
+	if (file_private->listedall != 0) {
+		return 0;
+	}
+
+	inode = file->f_dentry->d_inode;
+	if (inode && inode->FSPRIVATE) {
+		sessionId =
+		    Scope_Get_SessionId(((struct inode_data *)inode->FSPRIVATE)-> Scope);
+		if (0 == SC_PRESENT(sessionId)) {
+			((struct inode_data *)inode->FSPRIVATE)->Scope =
+			    Scope_Get_ScopefromPath(file->f_dentry);
+			sessionId =
+			    Scope_Get_SessionId(((struct inode_data *)inode->FSPRIVATE)->Scope);
+		}
+		uid = Scope_Get_Uid(((struct inode_data *)inode->FSPRIVATE)->Scope);
+	} else {
+		SC_INITIALIZE(sessionId);
+		uid = current->euid;
+	}
+
+	if (IS_ROOT(file->f_dentry) ||	// Root
+	    IS_ROOT(file->f_dentry->d_parent) ||	// User
+	    IS_ROOT(file->f_dentry->d_parent->d_parent))	// Server
+	{
+		if (IS_ROOT(file->f_dentry)) {
+			DbgPrint("Novfs_dir_readdir: Root directory\n");
+			list = Scope_Get_ScopeUsers();
+			type = USER_LIST;
+		} else if (IS_ROOT(file->f_dentry->d_parent)) {
+			DbgPrint
+			    ("Novfs_dir_readdir: Parent is Root directory\n");
+			Novfs_Get_Connected_Server_List(&list, &sessionId);
+			type = SERVER_LIST;
+		} else {
+			DbgPrint
+			    ("Novfs_dir_readdir: Parent-Parent is Root directory\n");
+			Novfs_Get_Server_Volume_List(&file->f_dentry->d_name,
+						     &list, &sessionId);
+			type = VOLUME_LIST;
+		}
+
+		processList(file, dirent, filldir, list, type, sessionId);
+		file_private->listedall = 1;
+	} else {
+		status =
+		    processEntries(file, dirent, filldir,
+				   &file_private->enumHandle, sessionId);
+
+		if (status != 0) {
+			file_private->listedall = 1;
+#ifndef SKIP_CROSSOVER_HACK
+			// Hack for crossover part 2 - begin
+			lComm = strlen(current->comm);
+			if ((lComm > 4)
+			    && (0 ==
+				strcmp(current->comm + lComm - 4, ".EXE"))) {
+				if (filldir
+				    (dirent, " !xover", 7, file->f_pos,
+				     inode->i_ino, DT_DIR) < 0)
+					return 1;
+				if (filldir
+				    (dirent, "z!xover", 7, file->f_pos,
+				     inode->i_ino, DT_DIR) < 0)
+					return 1;
+				file->f_pos += 2;
+			}
+			// Hack for crossover part2 - end
+#endif
+		}
+	}
+
+	file->private_data = file_private;
+	return 1;
+}
+
+/*++======================================================================*/
+int Novfs_dir_fsync(struct file *file, struct dentry *dentry, int datasync)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	DbgPrint("Novfs_dir_fsync: Name %.*s\n", file->f_dentry->d_name.len,
+		 file->f_dentry->d_name.name);
+	return (simple_sync_file(file, dentry, datasync));
+}
+
+/*++======================================================================*/
+ssize_t Novfs_f_read(struct file * file, char *buf, size_t len, loff_t * off)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	size_t thisread, totalread = 0;
+	loff_t offset = *off;
+	struct inode *inode;
+	session_t session;
+	struct inode_data *id;
+
+	if (file->f_dentry &&
+	    (inode = file->f_dentry->d_inode) &&
+	    (id = (struct inode_data *)inode->FSPRIVATE)) {
+
+		DbgPrint("Novfs_f_read(0x%p 0x%p %d %lld %.*s)\n",
+			 file->private_data,
+			 buf, len, offset,
+			 file->f_dentry->d_name.len,
+			 file->f_dentry->d_name.name);
+
+		if (PageCache && !(file->f_flags & O_DIRECT) && id->CacheFlag) {
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,18)
+			totalread = generic_file_read(file, buf, len, off);
+#else
+			totalread = do_sync_read(file, buf, len, off);
+#endif
+		} else {
+			session = Scope_Get_SessionId(id->Scope);
+			if (0 == SC_PRESENT(session)) {
+				id->Scope =
+				    Scope_Get_ScopefromPath(file->f_dentry);
+				session = Scope_Get_SessionId(id->Scope);
+			}
+
+			while (len > 0 && (offset < i_size_read(inode))) {
+				int retval;
+				thisread = len;
+				retval =
+				    Novfs_Read_File(file->private_data, buf,
+						    &thisread, &offset,
+						    session);
+				if (retval || !thisread) {
+					if (retval) {
+						totalread = retval;
+					}
+					break;
+				}
+				DbgPrint("Novfs_f_read thisread = 0x%x\n",
+					 thisread);
+				len -= thisread;
+				buf += thisread;
+				offset += thisread;
+				totalread += thisread;
+			}
+			*off = offset;
+		}
+	}
+	DbgPrint("Novfs_f_read return = %d\n", totalread);
+
+	return (totalread);
+}
+
+/*++======================================================================*/
+ssize_t Novfs_f_write(struct file * file, const char *buf, size_t len,
+		      loff_t * off)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	ssize_t thiswrite, totalwrite = 0;
+	loff_t offset = *off;
+	session_t session;
+	struct inode *inode;
+	int status;
+	struct inode_data *id;
+
+	if (file->f_dentry &&
+	    (inode = file->f_dentry->d_inode) &&
+	    (id = file->f_dentry->d_inode->FSPRIVATE)) {
+		DbgPrint("Novfs_f_write(0x%p 0x%p 0x%p %d %lld %.*s)\n",
+			 file->private_data, inode, id->FileHandle, len, offset,
+			 file->f_dentry->d_name.len,
+			 file->f_dentry->d_name.name);
+
+		if (PageCache &&
+		    !(file->f_flags & O_DIRECT) &&
+		    id->CacheFlag && !(file->f_flags & O_WRONLY)) {
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,18)
+			totalwrite = generic_file_write(file, buf, len, off);
+#else
+			totalwrite = do_sync_write(file, buf, len, off);
+#endif
+		} else {
+			if (file->f_flags & O_APPEND) {
+				offset = i_size_read(inode);
+				DbgPrint
+				    ("Novfs_f_write appending to end %lld %.*s\n",
+				     offset, file->f_dentry->d_name.len,
+				     file->f_dentry->d_name.name);
+			}
+
+			session = Scope_Get_SessionId(id->Scope);
+			if (0 == SC_PRESENT(session)) {
+				id->Scope =
+				    Scope_Get_ScopefromPath(file->f_dentry);
+				session = Scope_Get_SessionId(id->Scope);
+			}
+
+			while (len > 0) {
+				thiswrite = len;
+				if ((status =
+				     Novfs_Write_File(file->private_data,
+						      (unsigned char *)buf,
+						      &thiswrite, &offset,
+						      session)) || !thiswrite) {
+					totalwrite = status;
+					break;
+				}
+				DbgPrint("Novfs_f_write thiswrite = 0x%x\n",
+					 thiswrite);
+				len -= thiswrite;
+				buf += thiswrite;
+				offset += thiswrite;
+				totalwrite += thiswrite;
+				if (offset > i_size_read(inode)) {
+					i_size_write(inode, offset);
+					inode->i_blocks =
+					    (offset + inode->i_sb->s_blocksize -
+					     1) >> inode->i_blkbits;
+				}
+				inode->i_mtime = inode->i_atime = CURRENT_TIME;
+				id->Flags |= UPDATE_INODE;
+
+			}
+			*off = offset;
+		}
+	}
+	DbgPrint("Novfs_f_write return = 0x%x\n", totalwrite);
+
+	return (totalwrite);
+}
+
+int Novfs_f_readdir(struct file *file, void *data, filldir_t fill)
+{
+	return -EISDIR;
+}
+
+int Novfs_f_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+		  unsigned long arg)
+{
+	DbgPrint("Novfs_f_ioctl: file=0x%p cmd=0x%x arg=0x%p\n", file, cmd,
+		 arg);
+
+	return -ENOSYS;
+}
+
+/*++======================================================================*/
+int Novfs_f_mmap(struct file *file, struct vm_area_struct *vma)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	int retCode = -EINVAL;
+
+	DbgPrint("Novfs_f_mmap: file=0x%p %.*s\n", file,
+		 file->f_dentry->d_name.len, file->f_dentry->d_name.name);
+
+	retCode = generic_file_mmap(file, vma);
+
+	DbgPrint("Novfs_f_mmap: retCode=0x%x\n", retCode);
+	return (retCode);
+}
+
+/*++======================================================================*/
+int Novfs_f_open(struct inode *inode, struct file *file)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	struct entry_info *info = NULL;
+	int retCode = -ENOENT;
+	session_t session;
+	char *path;
+	struct dentry *parent;
+	ino_t ino;
+	struct inode_data *id;
+	int errInfo;
+
+	DbgPrint
+	    ("Novfs_f_open: inode=0x%p file=0x%p dentry=0x%p dentry->d_inode=0x%p %.*s\n",
+	     inode, file, file->f_dentry, file->f_dentry->d_inode,
+	     file->f_dentry->d_name.len, file->f_dentry->d_name.name);
+	if (file->f_dentry) {
+		DbgPrint
+		    ("Novfs_f_open: %.*s f_flags=0%o f_mode=0%o i_mode=0%o\n",
+		     file->f_dentry->d_name.len, file->f_dentry->d_name.name,
+		     file->f_flags, file->f_mode, inode->i_mode);
+	}
+
+	if (inode && inode->FSPRIVATE) {
+		id = (struct inode_data *) file->f_dentry->d_inode->FSPRIVATE;
+		session = Scope_Get_SessionId(id->Scope);
+		if (0 == SC_PRESENT(session)) {
+			id->Scope = Scope_Get_ScopefromPath(file->f_dentry);
+			session = Scope_Get_SessionId(id->Scope);
+		}
+
+		info = Novfs_Malloc(sizeof(struct entry_info) + PATH_LENGTH_BUFFER, GFP_KERNEL);
+		if (info) {
+			path =
+			    Novfs_dget_path(file->f_dentry, info->name,
+					    PATH_LENGTH_BUFFER);
+			if (path) {
+				if (file->f_flags & O_TRUNC) {
+					errInfo = Novfs_Get_File_Info(path, info, &session);
+
+					if (errInfo || info->size == 0) {
+						// clear O_TRUNC flag, bug #275366
+						file->f_flags =
+						    file->f_flags & (~O_TRUNC);
+					}
+				}
+
+				DbgPrint("Novfs_f_open: %s\n", path);
+				retCode = Novfs_Open_File(path,
+							  file->
+							  f_flags & ~O_EXCL,
+							  info,
+							  &file->private_data,
+							  session);
+
+				DbgPrint("Novfs_f_open: 0x%x 0x%p\n", retCode,
+					 file->private_data);
+				if (!retCode) {
+					/*
+					 *update_inode(inode, &info);
+					 */
+					//id->FileHandle = file->private_data;
+					id->CacheFlag =
+					    Novfs_Get_File_Cache_Flag(path,
+								      session);
+
+					if (!Novfs_Get_File_Info(path, info, &session))
+						update_inode(inode, info);
+
+					parent = dget_parent(file->f_dentry);
+
+					if (parent && parent->d_inode) {
+						struct inode *dir =
+						    parent->d_inode;
+						Novfs_lock_inode_cache(dir);
+						ino = 0;
+						if (Novfs_get_entry
+						    (dir,
+						     &file->f_dentry->d_name,
+						     &ino, info)) {
+							((struct inode_data *)inode->FSPRIVATE)->Flags |=
+				       UPDATE_INODE;
+						}
+
+						Novfs_unlock_inode_cache(dir);
+					}
+					dput(parent);
+				}
+			}
+			kfree(info);
+		}
+	}
+	DbgPrint("Novfs_f_open: retCode=0x%x\n", retCode);
+	return (retCode);
+}
+
+/*++======================================================================*/
+int Novfs_flush_mapping(HANDLE Handle, struct address_space *mapping,
+			session_t Session)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	struct pagevec pagevec;
+	unsigned nrpages;
+	pgoff_t index = 0;
+	int done, rc = 0;
+
+	pagevec_init(&pagevec, 0);
+
+	do {
+		done = 1;
+		nrpages = pagevec_lookup_tag(&pagevec,
+					     mapping,
+					     &index,
+					     PAGECACHE_TAG_DIRTY, PAGEVEC_SIZE);
+
+		if (nrpages) {
+			struct page *page;
+			int i;
+
+			DbgPrint("Novfs_flush_mapping: %u\n", nrpages);
+
+			done = 0;
+			for (i = 0; !rc && (i < nrpages); i++) {
+				page = pagevec.pages[i];
+
+				DbgPrint("Novfs_flush_mapping: page 0x%p %lu\n",
+					 page, page->index);
+
+				lock_page(page);
+				page_cache_get(page);
+				if (page->mapping == mapping) {
+					if (clear_page_dirty_for_io(page)) {
+						rc = Novfs_Write_Page(Handle,
+								      page,
+								      Session);
+						if (!rc) {
+							//ClearPageDirty(page);
+							radix_tree_tag_clear
+							    (&mapping->
+							     page_tree,
+							     page_index(page),
+							     PAGECACHE_TAG_DIRTY);
+						}
+					}
+				}
+
+				page_cache_release(page);
+				unlock_page(page);
+			}
+			pagevec_release(&pagevec);
+		}
+	} while (!rc && !done);
+
+	DbgPrint("Novfs_flush_mapping: return %d\n", rc);
+
+	return (rc);
+}
+
+/*++======================================================================*/
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,16)
+int Novfs_f_flush(struct file *file)
+#else
+int Novfs_f_flush(struct file *file, fl_owner_t ownid)
+#endif
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+
+	int rc = 0;
+#ifdef FLUSH
+	struct inode *inode;
+	session_t session;
+	struct inode_data *id;
+
+	DbgPrint("Novfs_f_flush: Called from 0x%p\n",
+		 __builtin_return_address(0));
+	if (file->f_dentry && (inode = file->f_dentry->d_inode)
+	    && (id = file->f_dentry->d_inode->FSPRIVATE)) {
+
+		if ((file->f_flags & O_ACCMODE) != O_RDONLY) {
+			inode = file->f_dentry->d_inode;
+			DbgPrint
+			    ("Novfs_f_flush: %.*s f_flags=0%o f_mode=0%o i_mode=0%o\n",
+			     file->f_dentry->d_name.len,
+			     file->f_dentry->d_name.name, file->f_flags,
+			     file->f_mode, inode->i_mode);
+
+			session = Scope_Get_SessionId(id->Scope);
+			if (0 == SC_PRESENT(session)) {
+				id->Scope =
+				    Scope_Get_ScopefromPath(file->f_dentry);
+				session = Scope_Get_SessionId(id->Scope);
+			}
+
+			if (inode &&
+			    inode->i_mapping && inode->i_mapping->nrpages) {
+
+				DbgPrint("Novfs_f_flush: %.*s pages=%lu\n",
+					 file->f_dentry->d_name.len,
+					 file->f_dentry->d_name.name,
+					 inode->i_mapping->nrpages);
+
+				if (file->f_dentry &&
+				    file->f_dentry->d_inode &&
+				    file->f_dentry->d_inode->i_mapping &&
+				    file->f_dentry->d_inode->i_mapping->a_ops &&
+				    file->f_dentry->d_inode->i_mapping->a_ops->
+				    writepage) {
+					rc = filemap_fdatawrite(file->f_dentry->
+								d_inode->
+								i_mapping);
+				} else {
+					rc = Novfs_flush_mapping(file->
+								 private_data,
+								 file->
+								 f_dentry->
+								 d_inode->
+								 i_mapping,
+								 session);
+				}
+			}
+		}
+	}
+#endif
+	return (rc);
+}
+
+/*++======================================================================*/
+int Novfs_f_release(struct inode *inode, struct file *file)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	int retCode = -EACCES;
+	session_t session;
+	struct inode_data *id;
+
+	DbgPrint("Novfs_f_release: path=%.*s handle=%p\n",
+		 file->f_dentry->d_name.len,
+		 file->f_dentry->d_name.name, file->private_data);
+
+	if (inode && (id = inode->FSPRIVATE)) {
+		session = Scope_Get_SessionId(id->Scope);
+		if (0 == SC_PRESENT(session)) {
+			id->Scope = Scope_Get_ScopefromPath(file->f_dentry);
+			session = Scope_Get_SessionId(id->Scope);
+		}
+
+		if ((file->f_flags & O_ACCMODE) != O_RDONLY) {
+			DbgPrint
+			    ("Novfs_f_release: %.*s f_flags=0%o f_mode=0%o i_mode=0%o\n",
+			     file->f_dentry->d_name.len,
+			     file->f_dentry->d_name.name, file->f_flags,
+			     file->f_mode, inode->i_mode);
+
+			if (inode->i_mapping && inode->i_mapping->nrpages) {
+
+				DbgPrint("Novfs_f_release: %.*s pages=%lu\n",
+					 file->f_dentry->d_name.len,
+					 file->f_dentry->d_name.name,
+					 inode->i_mapping->nrpages);
+
+				if (inode->i_mapping->a_ops &&
+				    inode->i_mapping->a_ops->writepage) {
+					filemap_fdatawrite(file->f_dentry->
+							   d_inode->i_mapping);
+				} else {
+					Novfs_flush_mapping(file->private_data,
+							    file->f_dentry->
+							    d_inode->i_mapping,
+							    session);
+				}
+			}
+		}
+
+		if (file->f_dentry && file->f_dentry->d_inode) {
+			invalidate_remote_inode(file->f_dentry->d_inode);
+		}
+
+		retCode = Novfs_Close_File(file->private_data, session);
+		//id->FileHandle = 0;
+	}
+	return (retCode);
+}
+
+int Novfs_f_fsync(struct file *file, struct dentry *dentry, int datasync)
+{
+	return 0;
+}
+
+/*++======================================================================*/
+int Novfs_f_llseek(struct file *file, loff_t offset, int origin)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	DbgPrint("Novfs_f_llseek: File=0x%p Name=%.*s offset=%lld origin=%d\n",
+		 file, file->f_dentry->d_name.len, file->f_dentry->d_name.name,
+		 offset, origin);
+	return (generic_file_llseek(file, offset, origin));
+}
+
+/*++======================================================================*/
+int Novfs_f_lock(struct file *file, int cmd, struct file_lock *lock)
+/*
+ *  Arguments:
+ *      "file" - pointer to file structure - contains file handle in "file->private_data"
+ *
+ *      "cmd" could be F_SETLK, F_SETLKW, F_GETLK
+ *      F_SETLK/F_SETLKW are for setting/unsetting file lock
+ *      F_GETLK is for getting infomation about region - is it locked, or not
+ *
+ *      "lock" structure - contains "start" and "end" of locking region
+ *
+ *  Returns:
+ *      0 on success
+ *      -ENOSYS on F_GETLK cmd. It's not implemented.
+ *      -EINVAL if (lock->fl_start > lock->fl_end)
+ *      -EAGAIN on all other errors
+ *  Abstract:
+ *
+ *  Notes:
+ *      "lock->fl_start" and "lock->fl_end" are of type "long long",
+ *      but xtier functions in novfsd "NCFsdLockFile" and "NCFsdUnlockFile"
+ *      receive arguments in u64 type.
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	int err_code;
+
+	struct inode *inode;
+	session_t session;
+	struct inode_data *id;
+	loff_t len;
+
+	DbgPrint("Novfs_f_lock(0x%p): begin in Novfs_f_lock 0x%p\n",
+		 __builtin_return_address(0), file->private_data);
+	DbgPrint
+	    ("Novfs_f_lock: cmd = %d, F_GETLK = %d, F_SETLK = %d, F_SETLKW = %d\n",
+	     cmd, F_GETLK, F_SETLK, F_SETLKW);
+	DbgPrint
+	    ("Novfs_f_lock: lock->fl_start = 0x%llX, lock->fl_end = 0x%llX\n",
+	     lock->fl_start, lock->fl_end);
+
+	err_code = -1;
+	if (lock->fl_start <= lock->fl_end) {
+		/* Get len from "start" and "end" */
+		len = lock->fl_end - lock->fl_start + 1;
+		if ((0 == lock->fl_start) && (OFFSET_MAX == lock->fl_end)) {
+			len = 0;
+		}
+
+		if (file->f_dentry &&
+		    (inode = file->f_dentry->d_inode) &&
+		    (id = (struct inode_data *)inode->FSPRIVATE)) {
+			DbgPrint("Novfs_f_lock: (0x%p 0x%p %.*s)\n",
+				 file->private_data, inode,
+				 file->f_dentry->d_name.len,
+				 file->f_dentry->d_name.name);
+
+			session = Scope_Get_SessionId(id->Scope);
+			if (0 == SC_PRESENT(session)) {
+				id->Scope =
+				    Scope_Get_ScopefromPath(file->f_dentry);
+				session = Scope_Get_SessionId(id->Scope);
+			}
+
+			/* fl_type = F_RDLCK, F_WRLCK, F_UNLCK */
+			switch (cmd) {
+			case F_SETLK:
+#ifdef F_GETLK64
+			case F_SETLK64:
+#endif
+
+				err_code =
+				    Novfs_Set_File_Lock(session,
+							file->private_data,
+							lock->fl_type,
+							lock->fl_start, len);
+				break;
+
+			case F_SETLKW:
+#ifdef F_GETLK64
+			case F_SETLKW64:
+#endif
+				err_code =
+				    Novfs_Set_File_Lock(session,
+							file->private_data,
+							lock->fl_type,
+							lock->fl_start, len);
+				break;
+
+			case F_GETLK:
+#ifdef F_GETLK64
+			case F_GETLK64:
+#endif
+				err_code = -ENOSYS;
+				/*
+				 * Not implemented. We doesn't have appropriate xtier function.
+				 * */
+				break;
+
+			default:
+				printk
+				    ("<1> novfs in Novfs_f_lock, not implemented cmd = %d\n",
+				     cmd);
+				DbgPrint
+				    ("Novfs_f_lock: novfs in Novfs_f_lock, not implemented cmd = %d\n",
+				     cmd);
+				break;
+			}
+		}
+
+		DbgPrint("Novfs_f_lock: lock->fl_type = %u, err_code 0x%X\n",
+			 lock->fl_type, err_code);
+
+		if ((err_code != 0) && (err_code != -1)
+		    && (err_code != -ENOSYS)) {
+			err_code = -EAGAIN;
+		}
+	} else {
+		err_code = -EINVAL;
+	}
+
+	return (err_code);
+}
+
+/*++======================================================================*/
+static void Novfs_copy_cache_pages(struct address_space *mapping,
+				   struct list_head *pages, int bytes_read,
+				   char *data, struct pagevec *plru_pvec)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	struct page *page;
+	char *target;
+
+	while (bytes_read > 0) {
+		if (list_empty(pages))
+			break;
+
+		page = list_entry(pages->prev, struct page, lru);
+		list_del(&page->lru);
+
+		if (add_to_page_cache(page, mapping, page->index, GFP_KERNEL)) {
+			page_cache_release(page);
+			data += PAGE_CACHE_SIZE;
+			bytes_read -= PAGE_CACHE_SIZE;
+			continue;
+		}
+
+		target = kmap_atomic(page, KM_USER0);
+
+		if (PAGE_CACHE_SIZE > bytes_read) {
+			memcpy(target, data, bytes_read);
+			/* zero the tail end of this partial page */
+			memset(target + bytes_read, 0,
+			       PAGE_CACHE_SIZE - bytes_read);
+			bytes_read = 0;
+		} else {
+			memcpy(target, data, PAGE_CACHE_SIZE);
+			bytes_read -= PAGE_CACHE_SIZE;
+		}
+		kunmap_atomic(target, KM_USER0);
+
+		flush_dcache_page(page);
+		SetPageUptodate(page);
+		unlock_page(page);
+		if (!pagevec_add(plru_pvec, page))
+			__pagevec_lru_add(plru_pvec);
+		data += PAGE_CACHE_SIZE;
+	}
+	return;
+}
+
+/*++======================================================================*/
+int Novfs_a_writepage(struct page *page, struct writeback_control *wbc)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	int retCode = -EFAULT;
+	struct inode *inode = page->mapping->host;
+	struct inode_data *id = inode->FSPRIVATE;
+	loff_t pos = ((loff_t) page->index << PAGE_CACHE_SHIFT);
+	session_t session;
+	struct data_list dlst[2];
+	size_t len = PAGE_CACHE_SIZE;
+
+	session = Scope_Get_SessionId(((struct inode_data *)inode->FSPRIVATE)->Scope);
+
+	page_cache_get(page);
+
+	pos = ((loff_t) page->index << PAGE_CACHE_SHIFT);
+
+	/*
+	 * Leave first dlst entry for reply header.
+	 */
+	dlst[1].page = page;
+	dlst[1].offset = NULL;
+	dlst[1].len = len;
+	dlst[1].rwflag = DLREAD;
+
+	/*
+	 * Check size so we don't write pass end of file.
+	 */
+	if ((pos + (loff_t) len) > i_size_read(inode)) {
+		len = (size_t) (i_size_read(inode) - pos);
+	}
+
+	retCode = Novfs_Write_Pages(id->FileHandle, dlst, 2, len, pos, session);
+	if (!retCode) {
+		SetPageUptodate(page);
+	}
+
+	unlock_page(page);
+	page_cache_release(page);
+
+	return (retCode);
+}
+
+/*++======================================================================*/
+int Novfs_a_writepages(struct address_space *mapping,
+		       struct writeback_control *wbc)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	int retCode = 0;
+	struct inode *inode = mapping->host;
+	session_t session;
+	HANDLE fh = 0;
+	struct inode_data *id = NULL;
+
+	int max_page_lookup = MaxIoSize / PAGE_CACHE_SIZE;
+
+	struct data_list *dlist;
+	struct data_list *dlptr;
+	struct page **pages;
+
+	int dlist_idx, i = 0;
+	pgoff_t index, next_index = 0;
+	loff_t pos = 0;
+	size_t tsize;
+
+	SC_INITIALIZE(session);
+	DbgPrint
+	    ("Novfs_a_writepages: inode=0x%p mapping=0x%p wbc=0x%p nr_to_write=%d\n",
+	     inode, mapping, wbc, wbc->nr_to_write);
+
+	if (inode) {
+		DbgPrint(" Inode=0x%p Ino=%d Id=0x%p\n", inode, inode->i_ino,
+			 inode->FSPRIVATE);
+
+		if (NULL != (id = inode->FSPRIVATE)) {
+			session =
+			    Scope_Get_SessionId(((struct inode_data *)inode->FSPRIVATE)->Scope);
+			fh = ((struct inode_data *)inode->FSPRIVATE)->FileHandle;
+		}
+	}
+
+	dlist = Novfs_Malloc(sizeof(struct data_list) * max_page_lookup, GFP_KERNEL);
+	pages =
+	    Novfs_Malloc(sizeof(struct page *) * max_page_lookup, GFP_KERNEL);
+
+	if (id)
+		DbgPrint
+		    ("Novfs_a_writepages: inode=0x%p fh=0x%p dlist=0x%p pages=0x%p %s\n",
+		     inode, fh, dlist, pages, id->Name);
+	else
+		DbgPrint
+		    ("Novfs_a_writepages: inode=0x%p fh=0x%p dlist=0x%p pages=0x%p\n",
+		     inode, fh, dlist, pages);
+
+	if (dlist && pages) {
+		struct backing_dev_info *bdi = mapping->backing_dev_info;
+		int done = 0;
+		int nr_pages = 0;
+		int scanned = 0;
+
+		if (wbc->nonblocking && bdi_write_congested(bdi)) {
+			wbc->encountered_congestion = 1;
+			return 0;
+		}
+
+		if (wbc->sync_mode == WB_SYNC_NONE) {
+			index = mapping->writeback_index;	/* Start from prev offset */
+		} else {
+			index = 0;	/* whole-file sweep */
+			scanned = 1;
+		}
+
+		next_index = index;
+
+		while (!done && (wbc->nr_to_write > 0)) {
+			dlist_idx = 0;
+			dlptr = &dlist[1];
+
+			DbgPrint("Novfs_a_writepages1: nr_pages=%d\n",
+				 nr_pages);
+			if (!nr_pages) {
+				memset(pages, 0,
+				       sizeof(struct page *) * max_page_lookup);
+
+				AS_TREE_LOCK(&mapping->tree_lock);
+
+				/*
+				 * Need to ask for one less then max_page_lookup or we
+				 * will overflow the request buffer.  This also frees
+				 * the first entry for the reply buffer.
+				 */
+				nr_pages =
+				    radix_tree_gang_lookup_tag(&mapping->
+							       page_tree,
+							       (void **)pages,
+							       index,
+							       max_page_lookup -
+							       1,
+							       PAGECACHE_TAG_DIRTY);
+
+				DbgPrint("Novfs_a_writepages2: nr_pages=%d\n",
+					 nr_pages);
+				/*
+				 * Check to see if there are dirty pages and there is a valid
+				 * file handle.
+				 */
+				if (nr_pages && !fh) {
+					set_bit(AS_EIO, &mapping->flags);
+					done = 1;
+					DbgPrint
+					    ("Novfs_a_writepage: set_bit AS_EIO\n");
+					break;
+				}
+
+				for (i = 0; i < nr_pages; i++) {
+					page_cache_get(pages[i]);
+				}
+
+				AS_TREE_UNLOCK(&mapping->tree_lock);
+
+				if (nr_pages) {
+					index = pages[nr_pages - 1]->index + 1;
+					pos =
+					    (loff_t) pages[0]->
+					    index << PAGE_CACHE_SHIFT;
+				}
+
+				if (!nr_pages) {
+					if (scanned) {
+						index = 0;
+						scanned = 0;
+						continue;
+					}
+					done = 1;
+				} else {
+					next_index = pages[0]->index;
+					i = 0;
+				}
+			} else {
+				if (pages[i]) {
+					pos =
+					    (loff_t) pages[i]->
+					    index << PAGE_CACHE_SHIFT;
+				}
+			}
+
+			for (; i < nr_pages; i++) {
+				struct page *page = pages[i];
+
+				/*
+				 * At this point we hold neither mapping->tree_lock nor
+				 * lock on the page itself: the page may be truncated or
+				 * invalidated (changing page->mapping to NULL), or even
+				 * swizzled back from swapper_space to tmpfs file
+				 * mapping
+				 */
+
+				DbgPrint
+				    ("Novfs_a_writepages: pos=0x%llx index=%d page->index=%d next_index=%d\n",
+				     pos, index, page->index, next_index);
+
+				if (page->index != next_index) {
+					next_index = page->index;
+					break;
+				}
+				next_index = page->index + 1;
+
+				lock_page(page);
+
+				if (wbc->sync_mode != WB_SYNC_NONE)
+					wait_on_page_writeback(page);
+
+				if (page->mapping != mapping
+				    || PageWriteback(page)
+				    || !clear_page_dirty_for_io(page)) {
+					unlock_page(page);
+					continue;
+				}
+
+				dlptr[dlist_idx].page = page;
+				dlptr[dlist_idx].offset = NULL;
+				dlptr[dlist_idx].len = PAGE_CACHE_SIZE;
+				dlptr[dlist_idx].rwflag = DLREAD;
+				dlist_idx++;
+				DbgPrint
+				    ("Novfs_a_writepages: Add page=0x%p index=0x%lx\n",
+				     page, page->index);
+			}
+
+			DbgPrint("Novfs_a_writepages: dlist_idx=%d\n",
+				 dlist_idx);
+			if (dlist_idx) {
+				tsize = dlist_idx * PAGE_CACHE_SIZE;
+				/*
+				 * Check size so we don't write pass end of file.
+				 */
+				if ((pos + tsize) > i_size_read(inode)) {
+					tsize =
+					    (size_t) (i_size_read(inode) - pos);
+				}
+
+				retCode =
+				    Novfs_Write_Pages(fh, dlist, dlist_idx + 1,
+						      tsize, pos, session);
+				switch (retCode) {
+				case 0:
+					wbc->nr_to_write -= dlist_idx;
+					break;
+
+				case -ENOSPC:
+					set_bit(AS_ENOSPC, &mapping->flags);
+					done = 1;
+					break;
+
+				default:
+					set_bit(AS_EIO, &mapping->flags);
+					done = 1;
+					break;
+				}
+
+				do {
+					unlock_page((struct page *)
+						    dlptr[dlist_idx - 1].page);
+					page_cache_release((struct page *)
+							   dlptr[dlist_idx -
+								 1].page);
+					DbgPrint
+					    ("Novfs_a_writepages: release page=0x%p index=0x%lx\n",
+					     dlptr[dlist_idx - 1].page,
+					     ((struct page *)
+					      dlptr[dlist_idx -
+						    1].page)->index);
+					if (!retCode) {
+						wbc->nr_to_write--;
+					}
+				} while (--dlist_idx);
+			}
+
+			if (i >= nr_pages) {
+				nr_pages = 0;
+			}
+		}
+
+		mapping->writeback_index = index;
+
+	} else {
+		DbgPrint("Novfs_a_writepage: set_bit AS_EIO\n");
+		set_bit(AS_EIO, &mapping->flags);
+	}
+	if (dlist)
+		kfree(dlist);
+	if (pages)
+		kfree(pages);
+
+	DbgPrint("Novfs_a_writepage: retCode=%d\n", retCode);
+	return (0);
+
+}
+
+/*++======================================================================*/
+int Novfs_a_readpage(struct file *file, struct page *page)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	int retCode = 0;
+	void *pbuf;
+	struct inode *inode = NULL;
+	struct dentry *dentry = NULL;
+	loff_t offset;
+	size_t len;
+	session_t session;
+
+	SC_INITIALIZE(session);
+	DbgPrint("Novfs_a_readpage: File=0x%p Name=%.*s Page=0x%p", file,
+		 file->f_dentry->d_name.len, file->f_dentry->d_name.name, page);
+
+	dentry = file->f_dentry;
+
+	if (dentry) {
+		DbgPrint(" Dentry=0x%p Name=%.*s", dentry, dentry->d_name.len,
+			 dentry->d_name.name);
+		if (dentry->d_inode) {
+			inode = dentry->d_inode;
+		}
+	}
+
+	if (inode) {
+		DbgPrint(" Inode=0x%p Ino=%d", inode, inode->i_ino);
+
+		if (inode->FSPRIVATE) {
+			session =
+			    Scope_Get_SessionId(((struct inode_data *)inode->
+						 FSPRIVATE)->Scope);
+			if (0 == SC_PRESENT(session)) {
+				((struct inode_data *)inode->FSPRIVATE)->Scope =
+				    Scope_Get_ScopefromPath(file->f_dentry);
+				session = Scope_Get_SessionId(((struct inode_data *)inode->FSPRIVATE)->Scope);
+			}
+		}
+	}
+
+	DbgPrint("\n");
+
+	if (!PageUptodate(page)) {
+		struct data_list dlst[2];
+
+		offset = page->index << PAGE_CACHE_SHIFT;
+		len = PAGE_CACHE_SIZE;
+
+		/*
+		 * Save the first entry for the reply header.
+		 */
+		dlst[1].page = page;
+		dlst[1].offset = NULL;
+		dlst[1].len = PAGE_CACHE_SIZE;
+		dlst[1].rwflag = DLWRITE;
+
+		DbgPrint("Novfs_a_readpage: calling= Novfs_Read_Pages %lld\n",
+			 offset);
+		retCode =
+		    Novfs_Read_Pages(file->private_data, dlst, 2, &len, &offset,
+				     session);
+		if (len && (len < PAGE_CACHE_SIZE)) {
+			pbuf = kmap_atomic(page, KM_USER0);
+			memset(&((char *)pbuf)[len], 0, PAGE_CACHE_SIZE - len);
+			kunmap_atomic(pbuf, KM_USER0);
+		}
+
+		flush_dcache_page(page);
+		SetPageUptodate(page);
+	}
+	unlock_page(page);
+
+	DbgPrint("Novfs_a_readpage: retCode=%d\n", retCode);
+	return (retCode);
+
+}
+
+/*++======================================================================*/
+int Novfs_a_readpages(struct file *file, struct address_space *mapping,
+		      struct list_head *page_lst, unsigned nr_pages)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	int retCode = 0;
+	struct inode *inode = NULL;
+	struct dentry *dentry = NULL;
+	session_t session;
+	loff_t offset;
+	size_t len;
+
+	unsigned page_idx;
+	struct pagevec lru_pvec;
+	pgoff_t next_index;
+
+	char *rbuf, done = 0;
+	SC_INITIALIZE(session);
+
+	DbgPrint("Novfs_a_readpages: File=0x%p Name=%.*s Pages=%d\n", file,
+		 file->f_dentry->d_name.len, file->f_dentry->d_name.name,
+		 nr_pages);
+
+	dentry = file->f_dentry;
+
+	if (dentry) {
+		DbgPrint(" Dentry=0x%p Name=%.*s\n", dentry, dentry->d_name.len,
+			 dentry->d_name.name);
+		if (dentry->d_inode) {
+			inode = dentry->d_inode;
+		}
+	}
+
+	if (inode) {
+		DbgPrint(" Inode=0x%p Ino=%d\n", inode, inode->i_ino);
+
+		if (inode->FSPRIVATE) {
+			session =
+			    Scope_Get_SessionId(((struct inode_data *)inode->
+						 FSPRIVATE)->Scope);
+			if (0 == SC_PRESENT(session)) {
+				((struct inode_data *) inode->FSPRIVATE)->Scope =
+				    Scope_Get_ScopefromPath(file->f_dentry);
+				session =
+				    Scope_Get_SessionId(((struct inode_data *) inode->
+							 FSPRIVATE)->Scope);
+			}
+		}
+	}
+
+	rbuf = (char *)Novfs_Malloc(MaxIoSize, GFP_KERNEL);
+	if (rbuf) {
+		pagevec_init(&lru_pvec, 0);
+		for (page_idx = 0; page_idx < nr_pages && !done;) {
+			struct page *page, *tpage;
+
+			if (list_empty(page_lst))
+				break;
+
+			page = list_entry(page_lst->prev, struct page, lru);
+
+			next_index = page->index;
+			offset = (loff_t) page->index << PAGE_CACHE_SHIFT;
+			len = 0;
+
+			/*
+			 * Count number of contiguous pages.
+			 */
+			list_for_each_entry_reverse(tpage, page_lst, lru) {
+				if ((next_index != tpage->index) ||
+				    (len >= MaxIoSize - PAGE_SIZE)) {
+					break;
+				}
+				len += PAGE_SIZE;
+				next_index++;
+			}
+
+			if (len && !done) {
+				struct data_list dllst[2];
+
+				dllst[1].page = NULL;
+				dllst[1].offset = rbuf;
+				dllst[1].len = len;
+				dllst[1].rwflag = DLWRITE;
+
+				DbgPrint
+				    ("Novfs_a_readpages: calling Novfs_Read_Pages %lld\n",
+				     offset);
+				if (!Novfs_Read_Pages
+				    (file->private_data, dllst, 2, &len,
+				     &offset, session)) {
+					Novfs_copy_cache_pages(mapping,
+							       page_lst, len,
+							       rbuf, &lru_pvec);
+					page_idx += len >> PAGE_CACHE_SHIFT;
+					if ((int)(len & PAGE_CACHE_MASK) != len) {
+						page_idx++;
+					}
+					if (len == 0) {
+						done = 1;
+					}
+				} else {
+					done = 1;
+				}
+			}
+		}
+
+		/*
+		 * Free any remaining pages.
+		 */
+		while (!list_empty(page_lst)) {
+			struct page *page =
+			    list_entry(page_lst->prev, struct page, lru);
+
+			list_del(&page->lru);
+			page_cache_release(page);
+		}
+
+		pagevec_lru_add(&lru_pvec);
+		kfree(rbuf);
+	} else {
+		retCode = -ENOMEM;
+	}
+
+	DbgPrint("Novfs_a_readpages: retCode=%d\n", retCode);
+	return (retCode);
+
+}
+
+/*++======================================================================*/
+int Novfs_a_prepare_write(struct file *file, struct page *page, unsigned from,
+			  unsigned to)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	int retVal = 0;
+	loff_t offset = (loff_t) page->index << PAGE_CACHE_SHIFT;
+	size_t len = PAGE_CACHE_SIZE;
+	session_t session;
+	struct data_list dllst[2];
+	struct inode *inode = file->f_dentry->d_inode;
+	SC_INITIALIZE(session);
+
+	DbgPrint
+	    ("Novfs_a_prepare_write: File=0x%p Page=0x%p offset=0x%llx From=%u To=%u filesize=%lld\n",
+	     file, page, offset, from, to,
+	     i_size_read(file->f_dentry->d_inode));
+	if (!PageUptodate(page)) {
+		/*
+		 * Check to see if whole page
+		 */
+		if ((to == PAGE_CACHE_SIZE) && (from == 0)) {
+			SetPageUptodate(page);
+		}
+
+		/*
+		 * Check to see if we can read page.
+		 */
+		else if ((file->f_flags & O_ACCMODE) != O_WRONLY) {
+			/*
+			 * Get session.
+			 */
+			if (file->f_dentry && file->f_dentry->d_inode) {
+				if (file->f_dentry->d_inode->FSPRIVATE) {
+					session =
+					    Scope_Get_SessionId(((struct inode_data *)inode->FSPRIVATE)->Scope);
+					if (0 == SC_PRESENT(session)) {
+						((struct inode_data *)inode->FSPRIVATE)->Scope = Scope_Get_ScopefromPath(file->f_dentry);
+						session = Scope_Get_SessionId(((struct inode_data *)inode->FSPRIVATE)->Scope);
+					}
+				}
+			}
+
+			page_cache_get(page);
+
+			len = i_size_read(inode) - offset;
+			if (len > PAGE_CACHE_SIZE) {
+				len = PAGE_CACHE_SIZE;
+			}
+
+			if (len) {
+				/*
+				 * Read page from server.
+				 */
+
+				dllst[1].page = page;
+				dllst[1].offset = 0;
+				dllst[1].len = len;
+				dllst[1].rwflag = DLWRITE;
+
+				DbgPrint
+				    ("Novfs_a_prepare_write: calling Novfs_Read_Pages %lld\n",
+				     offset);
+				Novfs_Read_Pages(file->private_data, dllst, 2,
+						 &len, &offset, session);
+
+				/*
+				 * Zero unnsed page.
+				 */
+			}
+
+			if (len < PAGE_CACHE_SIZE) {
+				char *adr = kmap_atomic(page, KM_USER0);
+				memset(adr + len, 0, PAGE_CACHE_SIZE - len);
+				kunmap_atomic(adr, KM_USER0);
+			}
+		} else {
+			/*
+			 * Zero section of memory that not going to be used.
+			 */
+			char *adr = kmap_atomic(page, KM_USER0);
+			memset(adr, 0, from);
+			memset(adr + to, 0, PAGE_CACHE_SIZE - to);
+			kunmap_atomic(adr, KM_USER0);
+
+			DbgPrint("Novfs_a_prepare_write: memset 0x%p\n", adr);
+		}
+		flush_dcache_page(page);
+		SetPageUptodate(page);
+	}
+//   DbgPrint("Novfs_a_prepare_write: return %d\n", retVal);
+	return (retVal);
+}
+
+/*++======================================================================*/
+int Novfs_a_commit_write(struct file *file, struct page *page, unsigned offset,
+			 unsigned to)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	int retCode = 0;
+	struct inode *inode = page->mapping->host;
+	loff_t pos = ((loff_t) page->index << PAGE_CACHE_SHIFT) + to;
+	session_t session;
+	struct inode_data *id;
+	struct data_list dlst[1];
+	size_t len = to - offset;
+
+	SC_INITIALIZE(session);
+
+	DbgPrint
+	    ("Novfs_a_commit_write: File=0x%p Page=0x%p offset=0x%x To=%u filesize=%lld\n",
+	     file, page, offset, to, i_size_read(file->f_dentry->d_inode));
+	if (file->f_dentry->d_inode
+	    && (id = file->f_dentry->d_inode->FSPRIVATE)) {
+		session = Scope_Get_SessionId(id->Scope);
+		if (0 == SC_PRESENT(session)) {
+			id->Scope = Scope_Get_ScopefromPath(file->f_dentry);
+			session = Scope_Get_SessionId(id->Scope);
+		}
+
+		/*
+		 * Setup file handle
+		 */
+		id->FileHandle = file->private_data;
+
+		if (pos > inode->i_size) {
+			i_size_write(inode, pos);
+		}
+
+		if (!PageUptodate(page)) {
+			pos =
+			    ((loff_t) page->index << PAGE_CACHE_SHIFT) + offset;
+
+			if (to < offset) {
+				return (retCode);
+			}
+			dlst[0].page = page;
+			dlst[0].offset = (void *)(unsigned long) offset;
+			dlst[0].len = len;
+			dlst[0].rwflag = DLREAD;
+
+			retCode =
+			    Novfs_Write_Pages(id->FileHandle, dlst, 1, len, pos,
+					      session);
+
+		} else {
+			set_page_dirty(page);
+		}
+	}
+
+	return (retCode);
+}
+
+/*++======================================================================*/
+ssize_t Novfs_a_direct_IO(int rw, struct kiocb * kiocb,
+			  const struct iovec * iov,
+			  loff_t offset, unsigned long nr_segs)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:        This is a dummy function so that we can allow a file
+ *                to get the direct IO flag set.  Novfs_f_read and
+ *                Novfs_f_write will do the work.  Maybe not the best
+ *                way to do but it was the easiest to implement.
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	return (-EIO);
+}
+
+/*++======================================================================*/
+int Novfs_i_create(struct inode *dir, struct dentry *dentry, int mode,
+		   struct nameidata *nd)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	char *path, *buf;
+	struct entry_info info;
+	HANDLE handle;
+	session_t session;
+	int retCode = -EACCES;
+
+	DbgPrint("Novfs_i_create: mode=0%o flags=0%o %.*s\n", mode,
+		 nd->NDOPENFLAGS, dentry->d_name.len, dentry->d_name.name);
+
+	if (IS_ROOT(dentry) ||	/* Root */
+	    IS_ROOT(dentry->d_parent) ||	/* User */
+	    IS_ROOT(dentry->d_parent->d_parent) ||	/* Server */
+	    IS_ROOT(dentry->d_parent->d_parent->d_parent)) {	/* Volume */
+		return (-EACCES);
+	}
+
+	if (mode | S_IFREG) {
+		if (dir->FSPRIVATE) {
+			session =
+			    Scope_Get_SessionId(((struct inode_data *)dir->FSPRIVATE)->
+						Scope);
+			if (0 == SC_PRESENT(session)) {
+				((struct inode_data *) dir->FSPRIVATE)->Scope =
+				    Scope_Get_ScopefromPath(dentry);
+				session = Scope_Get_SessionId(((struct inode_data *)dir->FSPRIVATE)->Scope);
+			}
+
+			buf =
+			    (char *)Novfs_Malloc(PATH_LENGTH_BUFFER,
+						 GFP_KERNEL);
+			if (buf) {
+				path =
+				    Novfs_dget_path(dentry, buf,
+						    PATH_LENGTH_BUFFER);
+				if (path) {
+					retCode =
+					    Novfs_Open_File(path,
+							    nd->
+							    NDOPENFLAGS |
+							    O_RDWR, &info,
+							    &handle, session);
+					if (!retCode && handle) {
+						Novfs_Close_File(handle,
+								 session);
+						if (!Novfs_i_mknod
+						    (dir, dentry,
+						     mode | S_IFREG, 0)) {
+							if (dentry->d_inode) {
+								((struct inode_data *)dentry->d_inode->FSPRIVATE)->Flags |= UPDATE_INODE;
+							}
+						}
+					}
+				}
+				kfree(buf);
+			}
+		}
+	}
+	return (retCode);
+}
+
+/*++======================================================================*/
+void update_inode(struct inode *Inode, struct entry_info *Info)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	static char dbuf[128];
+
+	DbgPrint("update_inode: Inode=0x%p I_ino=%d\n", Inode, Inode->i_ino);
+
+	DbgPrint("update_inode: atime=%s\n",
+		 ctime_r(&Info->atime.tv_sec, dbuf));
+	DbgPrint("update_inode: ctime=%s\n",
+		 ctime_r(&Info->ctime.tv_sec, dbuf));
+	DbgPrint("update_inode: mtime=%s %d\n",
+		 ctime_r(&Info->mtime.tv_sec, dbuf), Info->mtime.tv_nsec);
+	DbgPrint("update_inode: size=%lld\n", Info->size);
+	DbgPrint("update_inode: mode=0%o\n", Info->mode);
+
+	if (Inode &&
+	    ((Inode->i_size != Info->size) ||
+	     (Inode->i_mtime.tv_sec != Info->mtime.tv_sec) ||
+	     (Inode->i_mtime.tv_nsec != Info->mtime.tv_nsec))) {
+		DbgPrint
+		    ("update_inode: calling invalidate_remote_inode sz  %d %d\n",
+		     Inode->i_size, Info->size);
+		DbgPrint
+		    ("update_inode: calling invalidate_remote_inode sec %d %d\n",
+		     Inode->i_mtime.tv_sec, Info->mtime.tv_sec);
+		DbgPrint
+		    ("update_inode: calling invalidate_remote_inode ns  %d %d\n",
+		     Inode->i_mtime.tv_nsec, Info->mtime.tv_nsec);
+
+		if (Inode && Inode->i_mapping) {
+			invalidate_remote_inode(Inode);
+		}
+	}
+
+	Inode->i_mode = Info->mode;
+	Inode->i_size = Info->size;
+	Inode->i_atime = Info->atime;
+	Inode->i_ctime = Info->ctime;
+	Inode->i_mtime = Info->mtime;
+
+	if (Inode->i_size && Inode->i_sb->s_blocksize) {
+		Inode->i_blocks = (unsigned long) (Info->size >> (loff_t) Inode->i_blkbits);
+		Inode->i_bytes = Info->size & (Inode->i_sb->s_blocksize - 1);
+
+		DbgPrint("update_inode: i_sb->s_blocksize=%d\n", Inode->i_sb->s_blocksize);
+		DbgPrint("update_inode: i_blkbits=%d\n", Inode->i_blkbits);
+		DbgPrint("update_inode: i_blocks=%d\n", Inode->i_blocks);
+		DbgPrint("update_inode: i_bytes=%d\n", Inode->i_bytes);
+	}
+}
+
+/*++======================================================================*/
+struct dentry *Novfs_i_lookup(struct inode *dir, struct dentry *dentry,
+			      struct nameidata *nd)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	struct dentry *retVal = ERR_PTR(-ENOENT);
+	struct dentry *parent;
+	struct entry_info *info = NULL;
+	struct inode_data *id;
+	struct inode *inode = NULL;
+	uid_t uid = current->euid;
+	ino_t ino = 0;
+	struct qstr name;
+	char *buf;
+
+	buf = (char *)Novfs_Malloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
+	if (buf) {
+		char *path;
+		path = Novfs_dget_path(dentry, buf, PATH_LENGTH_BUFFER);
+		if (path) {
+			DbgPrint
+			    ("Novfs_i_lookup: dir 0x%p %d hash %d inode 0x%0p %s\n",
+			     dir, dir->i_ino, dentry->d_name.hash,
+			     dentry->d_inode, path);
+		}
+		kfree(buf);
+	} else {
+		DbgPrint
+		    ("Novfs_i_lookup: dir 0x%p %d name %.*s hash %d inode 0x%0p\n",
+		     dir, dir->i_ino, dentry->d_name.len, dentry->d_name.name,
+		     dentry->d_name.hash, dentry->d_inode);
+	}
+
+	if ((dentry->d_name.len == 7)
+	    && (0 == strncmp(dentry->d_name.name, " !xover", 7))) {
+		dentry->d_op = &Novfs_dentry_operations;
+		igrab(dir);
+		d_add(dentry, dir);
+		return NULL;
+	}
+	if ((dentry->d_name.len == 7)
+	    && (0 == strncmp(dentry->d_name.name, "z!xover", 7))) {
+		dentry->d_op = &Novfs_dentry_operations;
+		igrab(dir);
+		d_add(dentry, dir);
+		return NULL;
+	}
+
+	if (dir && (id = dir->FSPRIVATE)) {
+		retVal = 0;
+		if (IS_ROOT(dentry)) {
+			DbgPrint("Novfs_i_lookup: Root entry=0x%p\n",
+				 Novfs_root);
+			inode = Novfs_root->d_inode;
+			return (0);
+		} else {
+			info =
+			    Novfs_Malloc(sizeof(struct entry_info) +
+					 PATH_LENGTH_BUFFER, GFP_KERNEL);
+			if (info) {
+				if (NULL ==
+				    (retVal =
+				     ERR_PTR(verify_dentry(dentry, 1)))) {
+					name.name = dentry->d_name.name;
+					name.len = dentry->d_name.len;
+					name.hash = Novfs_internal_hash(&name);
+
+					if (Novfs_lock_inode_cache(dir)) {
+						if (!Novfs_get_entry
+						    (dir, &name, &ino, info)) {
+							inode =
+							    ilookup(dentry->
+								    d_sb, ino);
+							if (inode) {
+								update_inode
+								    (inode,
+								     info);
+							}
+						}
+						Novfs_unlock_inode_cache(dir);
+					}
+
+					if (!inode && ino) {
+						uid = Scope_Get_Uid(id->Scope);
+						if (Novfs_lock_inode_cache(dir)) {
+							inode = Novfs_get_inode (dentry->d_sb, info->mode, 0, uid, ino, &name);
+							if (inode) {
+								if (!Novfs_get_entry(dir, &dentry->d_name, &ino, info)) {
+									update_inode
+									    (inode,
+									     info);
+								}
+							}
+							Novfs_unlock_inode_cache
+							    (dir);
+						}
+					}
+				}
+			}
+		}
+	}
+
+	if (!retVal) {
+		dentry->d_op = &Novfs_dentry_operations;
+		if (inode) {
+			parent = dget_parent(dentry);
+			Novfs_d_add(dentry->d_parent, dentry, inode, 1);
+			dput(parent);
+		} else {
+			d_add(dentry, inode);
+		}
+	}
+
+	if (info)
+		kfree(info);
+
+	DbgPrint
+	    ("Novfs_i_lookup: inode=0x%p dentry->d_inode=0x%p return=0x%p\n",
+	     dir, dentry->d_inode, retVal);
+
+	return (retVal);
+}
+
+/*++======================================================================*/
+int Novfs_i_unlink(struct inode *dir, struct dentry *dentry)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	int retCode = -ENOENT;
+	struct inode *inode;
+	session_t session;
+	char *path, *buf;
+	uint64_t t64;
+
+	DbgPrint("Novfs_i_unlink: dir=0x%p dir->i_ino=%d %.*s\n", dir,
+		 dir->i_ino, dentry->d_name.len, dentry->d_name.name);
+	DbgPrint("Novfs_i_unlink: IS_ROOT(dentry)=%d\n", IS_ROOT(dentry));
+	DbgPrint("Novfs_i_unlink: IS_ROOT(dentry->d_parent)=%d\n",
+		 IS_ROOT(dentry->d_parent));
+	DbgPrint("Novfs_i_unlink: IS_ROOT(dentry->d_parent->d_parent)=%d\n",
+		 IS_ROOT(dentry->d_parent->d_parent));
+	DbgPrint
+	    ("Novfs_i_unlink: IS_ROOT(dentry->d_parent->d_parent->d_parent)=%d\n",
+	     IS_ROOT(dentry->d_parent->d_parent->d_parent));
+
+	if (IS_ROOT(dentry) ||	/* Root */
+	    IS_ROOT(dentry->d_parent) ||	/* User */
+	    (!IS_ROOT(dentry->d_parent->d_parent) &&	/* Server */
+	     IS_ROOT(dentry->d_parent->d_parent->d_parent))) {	/* Volume */
+		return (-EACCES);
+	}
+
+	inode = dentry->d_inode;
+	if (inode) {
+		DbgPrint
+		    ("Novfs_i_unlink: dir=0x%p dir->i_ino=%d inode=0x%p ino=%d\n",
+		     dir, dir->i_ino, inode, inode->i_ino);
+		if (inode->FSPRIVATE) {
+			session =
+			    Scope_Get_SessionId(((struct inode_data *)inode->FSPRIVATE)->Scope);
+			if (0 == SC_PRESENT(session)) {
+				((struct inode_data *)inode->FSPRIVATE)->Scope = Scope_Get_ScopefromPath(dentry);
+				session = Scope_Get_SessionId(((struct inode_data *)inode->FSPRIVATE)->Scope);
+			}
+
+			buf =
+			    (char *)Novfs_Malloc(PATH_LENGTH_BUFFER,
+						 GFP_KERNEL);
+			if (buf) {
+				path =
+				    Novfs_dget_path(dentry, buf,
+						    PATH_LENGTH_BUFFER);
+				if (path) {
+					DbgPrint
+					    ("Novfs_i_unlink: path %s mode 0%o\n",
+					     path, inode->i_mode);
+					if (IS_ROOT(dentry->d_parent->d_parent)) {
+						retCode = do_logout(&dentry->d_name, &session);
+					} else {
+						retCode =
+						    Novfs_Delete(path,
+								 S_ISDIR(inode->
+									 i_mode),
+								 session);
+					}
+					if (!retCode || IS_DEADDIR(inode)) {
+						Novfs_remove_inode_entry(dir,
+									 &dentry->
+									 d_name,
+									 0);
+						dentry->d_time = 0;
+						t64 = 0;
+						Scope_Set_UserSpace(&t64, &t64,
+								    &t64, &t64);
+						retCode = 0;
+					}
+				}
+				kfree(buf);
+			}
+		}
+	}
+
+	DbgPrint("Novfs_i_unlink: retCode 0x%x\n", retCode);
+	return (retCode);
+}
+
+/*++======================================================================*/
+int Novfs_i_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	char *path, *buf;
+	session_t session;
+	int retCode = 0;
+	struct inode *inode;
+	struct entry_info info;
+	uid_t uid;
+
+	DbgPrint("Novfs_i_mkdir: dir=0x%p ino=%d dentry=0x%p %.*s mode=0%lo\n",
+		 dir, dir->i_ino, dentry, dentry->d_name.len,
+		 dentry->d_name.name, mode);
+
+	if (IS_ROOT(dentry) ||	/* Root */
+	    IS_ROOT(dentry->d_parent) ||	/* User */
+	    IS_ROOT(dentry->d_parent->d_parent) ||	/* Server */
+	    IS_ROOT(dentry->d_parent->d_parent->d_parent)) {	/* Volume */
+		return (-EACCES);
+	}
+
+	mode |= S_IFDIR;
+	mode &= (S_IFMT | S_IRWXU);
+	if (dir->FSPRIVATE) {
+		session =
+		    Scope_Get_SessionId(((struct inode_data *)dir->FSPRIVATE)->Scope);
+		if (0 == SC_PRESENT(session)) {
+			((struct inode_data *)dir->FSPRIVATE)->Scope =
+			    Scope_Get_ScopefromPath(dentry);
+			session =
+			    Scope_Get_SessionId(((struct inode_data *)dir->FSPRIVATE)->Scope);
+		}
+
+		uid = Scope_Get_Uid(((struct inode_data *)dir->FSPRIVATE)->Scope);
+		buf = (char *)Novfs_Malloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
+		if (buf) {
+			path = Novfs_dget_path(dentry, buf, PATH_LENGTH_BUFFER);
+			if (path) {
+				DbgPrint("Novfs_i_mkdir: path %s\n", path);
+				retCode =
+				    Novfs_Create(path, S_ISDIR(mode), session);
+				if (!retCode) {
+					retCode = Novfs_Get_File_Info(path, &info, &session);
+					if (!retCode) {
+						retCode = Novfs_i_mknod(dir, dentry, mode, 0);
+						inode = dentry->d_inode;
+						if (inode) {
+							update_inode(inode,
+								     &info);
+							((struct inode_data *)inode->FSPRIVATE)->Flags &= ~UPDATE_INODE;
+
+							dentry->d_time =
+							    jiffies +
+							    (File_update_timeout
+							     * HZ);
+
+							Novfs_lock_inode_cache
+							    (dir);
+							if (Novfs_update_entry
+							    (dir,
+							     &dentry->d_name, 0,
+							     &info)) {
+								Novfs_add_inode_entry
+								    (dir,
+								     &dentry->
+								     d_name,
+								     inode->
+								     i_ino,
+								     &info);
+							}
+							Novfs_unlock_inode_cache
+							    (dir);
+						}
+
+					}
+				}
+			}
+			kfree(buf);
+		}
+	}
+
+	return (retCode);
+}
+
+/*++======================================================================*/
+int Novfs_i_rmdir(struct inode *inode, struct dentry *dentry)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	return (Novfs_i_unlink(inode, dentry));
+}
+
+/*++======================================================================*/
+int Novfs_i_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	struct inode *inode = NULL;
+	int retCode = -EACCES;
+	uid_t uid;
+	struct dentry *parent;
+
+	if (IS_ROOT(dentry) ||	/* Root */
+	    IS_ROOT(dentry->d_parent) ||	/* User */
+	    IS_ROOT(dentry->d_parent->d_parent) ||	/* Server */
+	    IS_ROOT(dentry->d_parent->d_parent->d_parent)) {	/* Volume */
+		return (-EACCES);
+	}
+
+	if (((struct inode_data *)dir->FSPRIVATE)) {
+		uid = Scope_Get_Uid(((struct inode_data *)dir->FSPRIVATE)->Scope);
+		if (mode & (S_IFREG | S_IFDIR)) {
+			inode =
+			    Novfs_get_inode(dir->i_sb, mode, dev, uid, 0, &dentry->d_name);
+		}
+	}
+	if (inode) {
+		struct entry_info info;
+
+		dentry->d_op = &Novfs_dentry_operations;
+		parent = dget_parent(dentry);
+		Novfs_d_add(parent, dentry, inode, 0);
+		memset(&info, 0, sizeof(info));
+		info.mode = inode->i_mode;
+		Novfs_lock_inode_cache(dir);
+		Novfs_add_inode_entry(dir, &dentry->d_name, inode->i_ino,
+				      &info);
+		Novfs_unlock_inode_cache(dir);
+
+		dput(parent);
+
+		retCode = 0;
+	}
+	DbgPrint("Novfs_i_mknod: return 0x%x\n", retCode);
+	return retCode;
+}
+
+int Novfs_i_rename(struct inode *odir, struct dentry *od, struct inode *ndir,
+		   struct dentry *nd)
+{
+	int retCode = -ENOTEMPTY;
+	char *newpath, *newbuf, *newcon;
+	char *oldpath, *oldbuf, *oldcon;
+	struct qstr newname, oldname;
+	struct entry_info *info = NULL;
+	int oldlen, newlen;
+	session_t session;
+	ino_t ino;
+
+	if (IS_ROOT(od) ||	/* Root */
+	    IS_ROOT(od->d_parent) ||	/* User */
+	    IS_ROOT(od->d_parent->d_parent) ||	/* Server */
+	    IS_ROOT(od->d_parent->d_parent->d_parent)) {	/* Volume */
+		return (-EACCES);
+	}
+
+	DbgPrint("Novfs_i_rename: odir=0x%p ino=%d ndir=0x%p ino=%d\n", odir,
+		 odir->i_ino, ndir, ndir->i_ino);
+
+	oldbuf = Novfs_Malloc(PATH_LENGTH_BUFFER * 2, GFP_KERNEL);
+	newbuf = oldbuf + PATH_LENGTH_BUFFER;
+	if (oldbuf && newbuf) {
+		oldpath = Novfs_dget_path(od, oldbuf, PATH_LENGTH_BUFFER);
+		newpath = Novfs_dget_path(nd, newbuf, PATH_LENGTH_BUFFER);
+		if (oldpath && newpath) {
+			oldlen = PATH_LENGTH_BUFFER - (int)(oldpath - oldbuf);
+			newlen = PATH_LENGTH_BUFFER - (int)(newpath - newbuf);
+
+			DbgPrint
+			    ("Novfs_i_rename: od=0x%p od->inode=0x%p od->inode->i_ino=%d %s\n",
+			     od, od->d_inode, od->d_inode->i_ino, oldpath);
+			if (nd->d_inode) {
+				DbgPrint
+				    ("Novfs_i_rename: nd=0x%p nd->inode=0x%p nd->inode->i_ino=%d %s\n",
+				     nd, nd->d_inode, nd->d_inode->i_ino,
+				     newpath);
+			} else {
+				DbgPrint
+				    ("Novfs_i_rename: nd=0x%p nd->inode=0x%p %s\n",
+				     nd, nd->d_inode, newpath);
+			}
+
+			/*
+			 * Check to see if two different servers or different volumes
+			 */
+			newcon = strchr(newpath + 1, '\\');
+			oldcon = strchr(oldpath + 1, '\\');
+			DbgPrint("Novfs_i_rename: newcon=0x%p newpath=0x%p\n",
+				 newcon, newpath);
+			DbgPrint("Novfs_i_rename: oldcon=0x%p oldpath=0x%p\n",
+				 oldcon, oldpath);
+			retCode = -EXDEV;
+			if (newcon && oldcon
+			    && ((int)(newcon - newpath) ==
+				(int)(oldcon - oldpath))) {
+				newcon = strchr(newcon + 1, '\\');
+				oldcon = strchr(oldcon + 1, '\\');
+				DbgPrint("Novfs_i_rename2: newcon=0x%p newpath=0x%p\n", newcon, newpath);
+				DbgPrint("Novfs_i_rename2: oldcon=0x%p oldpath=0x%p\n", oldcon, oldpath);
+				if (newcon && oldcon &&
+				    ((int)(newcon - newpath) == (int)(oldcon - oldpath))) {
+					newname.name = newpath;
+					newname.len = (int)(newcon - newpath);
+					newname.hash = 0;
+
+					oldname.name = oldpath;
+					oldname.len = (int)(oldcon - oldpath);
+					oldname.hash = 0;
+					if (!Novfs_d_strcmp(&newname, &oldname)) {
+
+						if (od->d_inode
+						    && od->d_inode->FSPRIVATE) {
+
+							if ((nd->d_inode) &&
+							    (nd->d_inode->FSPRIVATE)) {
+								session = Scope_Get_SessionId(((struct inode_data *)ndir->FSPRIVATE)->Scope);
+								if (0 == SC_PRESENT(session)) {
+									((struct inode_data *)ndir->FSPRIVATE)->Scope = Scope_Get_ScopefromPath(nd);
+									session = Scope_Get_SessionId(((struct inode_data *)ndir->FSPRIVATE)->Scope);
+								}
+
+								retCode = Novfs_Delete(newpath, S_ISDIR(nd->d_inode->i_mode), session);
+							}
+
+							session = Scope_Get_SessionId(((struct inode_data *) ndir->FSPRIVATE)->Scope);
+							if (0 == SC_PRESENT(session)) {
+								((struct inode_data *)ndir->FSPRIVATE)->Scope = Scope_Get_ScopefromPath(nd);
+								session = Scope_Get_SessionId(((struct inode_data *) ndir->FSPRIVATE)->Scope);
+							}
+							retCode = Novfs_Rename_File(S_ISDIR(od->d_inode->i_mode), oldpath, oldlen - 1, newpath, newlen - 1, session);
+
+							if (!retCode) {
+								info = (struct entry_info *) oldbuf;
+								od->d_time = 0;
+								Novfs_remove_inode_entry(odir, &od->d_name, 0);
+								Novfs_remove_inode_entry(ndir, &nd->d_name, 0);
+								Novfs_Get_File_Info(newpath, info, &session);
+								nd->d_time = jiffies + (File_update_timeout * HZ);
+
+								if (od->d_inode && od->d_inode->i_ino) {
+									ino = od->d_inode-> i_ino;
+								} else {
+									ino = (ino_t)atomic_inc_return(&Novfs_Inode_Number);
+								}
+								Novfs_add_inode_entry(ndir, &nd->d_name, ino, info);
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+	if (oldbuf)
+		kfree(oldbuf);
+
+	DbgPrint("Novfs_i_rename: return %d\n", retCode);
+	return (retCode);
+}
+
+/*++======================================================================*/
+int Novfs_i_permission(struct inode *inode, int mask)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	int retCode = 0;
+
+	return (retCode);
+}
+
+/*++======================================================================*/
+int Novfs_i_setattr(struct dentry *dentry, struct iattr *attr)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	char *path, *buf;
+	struct inode *inode = dentry->d_inode;
+	char atime_buf[32];
+	char mtime_buf[32];
+	char ctime_buf[32];
+	unsigned int ia_valid = attr->ia_valid;
+	session_t session;
+	int retVal = 0;
+	struct iattr mattr;
+
+	if (IS_ROOT(dentry) ||	/* Root */
+	    IS_ROOT(dentry->d_parent) ||	/* User */
+	    IS_ROOT(dentry->d_parent->d_parent) ||	/* Server */
+	    IS_ROOT(dentry->d_parent->d_parent->d_parent)) {	/* Volume */
+		return (-EACCES);
+	}
+
+	if (inode && inode->FSPRIVATE) {
+		session =
+		    Scope_Get_SessionId(((struct inode_data *)inode->FSPRIVATE)->Scope);
+		if (0 == SC_PRESENT(session)) {
+			((struct inode_data *)inode->FSPRIVATE)->Scope =
+			    Scope_Get_ScopefromPath(dentry);
+			session =
+			    Scope_Get_SessionId(((struct inode_data *) inode->
+						 FSPRIVATE)->Scope);
+		}
+
+		buf = (char *)Novfs_Malloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
+		if (buf) {
+			path = Novfs_dget_path(dentry, buf, PATH_LENGTH_BUFFER);
+			if (path) {
+				strcpy(atime_buf, "Unspecified");
+				strcpy(mtime_buf, "Unspecified");
+				strcpy(ctime_buf, "Unspecified");
+				if (attr->ia_valid & ATTR_ATIME) {
+					ctime_r(&attr->ia_atime.tv_sec,
+						atime_buf);
+				}
+				if (attr->ia_valid & ATTR_MTIME) {
+					ctime_r(&attr->ia_mtime.tv_sec,
+						mtime_buf);
+				}
+				if (attr->ia_valid & ATTR_CTIME) {
+					ctime_r(&attr->ia_ctime.tv_sec,
+						ctime_buf);
+				}
+				/* Removed for Bug 132374. jlt */
+				DbgPrint("Novfs_i_setattr: %s\n"
+					 "   ia_valid:      0x%x\n"
+					 "   ia_mode:       0%o\n"
+					 "   ia_uid:        %d\n"
+					 "   ia_gid:        %d\n"
+					 "   ia_size:       %lld\n"
+					 "   ia_atime:      %s\n"
+					 "   ia_mtime:      %s\n"
+					 "   ia_ctime:      %s\n",
+					 path,
+					 attr->ia_valid,
+					 attr->ia_mode,
+					 attr->ia_uid,
+					 attr->ia_gid,
+					 attr->ia_size,
+					 atime_buf, mtime_buf, ctime_buf);
+
+				if ((attr->ia_valid & ATTR_FILE)
+				    && (attr->ia_valid & ATTR_SIZE)) {
+					memcpy(&mattr, attr, sizeof(mattr));
+					mattr.ia_valid &=
+					    ~(ATTR_FILE | ATTR_SIZE);
+					attr = &mattr;
+					ia_valid = attr->ia_valid;
+#if 0	// thanks to vfs changes in our tree...
+					retVal = Novfs_Truncate_File_Ex(attr->ia_file->private_data, attr->ia_size, session);
+					if (!retVal) {
+						inode->i_size = attr->ia_size;
+						((struct inode_data *)inode->FSPRIVATE)->Flags |= UPDATE_INODE;
+					}
+#endif
+				}
+
+				if (ia_valid
+				    && !(retVal =
+					 Novfs_Set_Attr(path, attr, session))) {
+					((struct inode_data *)inode->FSPRIVATE)->Flags |= UPDATE_INODE;
+
+					if (ia_valid & ATTR_ATIME)
+						inode->i_atime = attr->ia_atime;
+					if (ia_valid & ATTR_MTIME)
+						inode->i_mtime = attr->ia_mtime;
+					if (ia_valid & ATTR_CTIME)
+						inode->i_ctime = attr->ia_ctime;
+					if (ia_valid & ATTR_MODE) {
+						inode->i_mode =
+						    attr->
+						    ia_mode & (S_IFMT |
+							       S_IRWXU);
+					}
+				}
+			}
+		}
+		kfree(buf);
+	}
+	DbgPrint("Novfs_i_setattr: return 0x%x\n", retVal);
+
+	return (retVal);
+}
+
+/*++======================================================================*/
+int Novfs_i_getattr(struct vfsmount *mnt, struct dentry *dentry,
+		    struct kstat *kstat)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	int retCode = 0;
+	char atime_buf[32];
+	char mtime_buf[32];
+	char ctime_buf[32];
+	struct inode *inode = dentry->d_inode;
+
+	struct entry_info info;
+	char *path, *buf;
+	session_t session;
+	struct inode_data *id;
+
+	if (!IS_ROOT(dentry) && !IS_ROOT(dentry->d_parent)) {
+		SC_INITIALIZE(session);
+		id = dentry->d_inode->FSPRIVATE;
+
+		if (id && (id->Flags & UPDATE_INODE)) {
+			session = Scope_Get_SessionId(id->Scope);
+
+			if (0 == SC_PRESENT(session)) {
+				id->Scope = Scope_Get_ScopefromPath(dentry);
+				session = Scope_Get_SessionId(id->Scope);
+			}
+
+			buf =
+			    (char *)Novfs_Malloc(PATH_LENGTH_BUFFER,
+						 GFP_KERNEL);
+			if (buf) {
+				path =
+				    Novfs_dget_path(dentry, buf,
+						    PATH_LENGTH_BUFFER);
+				if (path) {
+					retCode = Novfs_Get_File_Info(path, &info, &session);
+					if (!retCode) {
+						update_inode(inode, &info);
+						id->Flags &= ~UPDATE_INODE;
+					}
+				}
+				kfree(buf);
+			}
+		}
+	}
+
+	kstat->ino = inode->i_ino;
+	kstat->dev = inode->i_sb->s_dev;
+	kstat->mode = inode->i_mode;
+	kstat->nlink = inode->i_nlink;
+	kstat->uid = inode->i_uid;
+	kstat->gid = inode->i_gid;
+	kstat->rdev = inode->i_rdev;
+	kstat->size = i_size_read(inode);
+	kstat->atime = inode->i_atime;
+	kstat->mtime = inode->i_mtime;
+	kstat->ctime = inode->i_ctime;
+	kstat->blksize = inode->i_sb->s_blocksize;
+	kstat->blocks = inode->i_blocks;
+	if (inode->i_bytes) {
+		kstat->blocks++;
+	}
+	ctime_r(&kstat->atime.tv_sec, atime_buf);
+	ctime_r(&kstat->mtime.tv_sec, mtime_buf);
+	ctime_r(&kstat->ctime.tv_sec, ctime_buf);
+
+	DbgPrint("Novfs_i_getattr: 0x%x 0x%p <%.*s>\n"
+		 "   ino: %d\n"
+		 "   dev: 0x%x\n"
+		 "   mode: 0%o\n"
+		 "   nlink: 0x%x\n"
+		 "   uid: 0x%x\n"
+		 "   gid: 0x%x\n"
+		 "   rdev: 0x%x\n"
+		 "   size: 0x%llx\n"
+		 "   atime: %s\n"
+		 "   mtime: %s\n"
+		 "   ctime: %s\n"
+		 "   blksize: 0x%x\n"
+		 "   blocks: 0x%x\n",
+		 retCode, dentry, dentry->d_name.len, dentry->d_name.name,
+		 kstat->ino,
+		 kstat->dev,
+		 kstat->mode,
+		 kstat->nlink,
+		 kstat->uid,
+		 kstat->gid,
+		 kstat->rdev,
+		 kstat->size,
+		 atime_buf,
+		 mtime_buf, ctime_buf, kstat->blksize, kstat->blocks);
+	return (retCode);
+}
+
+/*++======================================================================*/
+int Novfs_i_getxattr(struct dentry *dentry, const char *name, void *buffer,
+		     size_t buffer_size)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	struct inode *inode = dentry->d_inode;
+	session_t sessionId;
+	char *path, *buf, *bufRead;
+	ssize_t dataLen;
+
+	int retxcode = 0;
+
+	SC_INITIALIZE(sessionId);
+
+	DbgPrint("Novfs_i_getxattr: Ian\n");	/*%.*s\n", dentry->d_name.len, dentry->d_name.name); */
+	DbgPrint
+	    ("Novfs_i_getxattr: dentry->d_name.len %u, dentry->d_name.name %s\n",
+	     dentry->d_name.len, dentry->d_name.name);
+	DbgPrint("Novfs_i_getxattr: name %s\n", name);
+	DbgPrint("Novfs_i_getxattr: size %u\n", buffer_size);
+
+	if (inode && inode->FSPRIVATE) {
+		sessionId =
+		    Scope_Get_SessionId(((struct inode_data *)inode->FSPRIVATE)->Scope);
+		DbgPrint("Novfs_i_getxattr: SessionId = %u\n", sessionId);
+		//if (0 == sessionId)
+		if (0 == SC_PRESENT(sessionId)) {
+			((struct inode_data *) inode->FSPRIVATE)->Scope = Scope_Get_ScopefromPath(dentry);
+			sessionId = Scope_Get_SessionId(((struct inode_data *)inode->FSPRIVATE)->Scope);
+			DbgPrint("Novfs_i_getxattr: SessionId = %u\n",
+				 sessionId);
+		}
+	}
+
+	dataLen = 0;
+	buf = (char *)Novfs_Malloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
+	if (buf) {
+		path = Novfs_dget_path(dentry, buf, PATH_LENGTH_BUFFER);
+		if (path) {
+			bufRead = (char *)Novfs_Malloc(XA_BUFFER, GFP_KERNEL);
+			if (bufRead) {
+				retxcode = Novfs_GetX_File_Info(path, name, bufRead, XA_BUFFER, &dataLen, &sessionId);
+				DbgPrint("Novfs_i_getxattr: after Novfs_GetX_File_Info retxcode = %d\n", retxcode);
+				if (!retxcode) {
+					mydump(64, bufRead);
+					if (buffer_size != 0) {
+						if (buffer_size >= dataLen) {
+							memcpy(buffer, bufRead,
+							       dataLen);
+						} else {
+							DbgPrint
+							    ("Novfs_i_getxattr: (!!!) not enough buffer_size. buffer_size = %d, dataLen = %d\n",
+							     buffer_size,
+							     dataLen);
+							retxcode = -ERANGE;
+						}
+					}
+
+					if (bufRead) {
+						kfree(bufRead);
+					}
+				}
+			}
+		}
+		kfree(buf);
+	}
+
+	if (retxcode) {
+		dataLen = retxcode;
+	} else {
+		if ((buffer_size > 0) && (buffer_size < dataLen)) {
+			dataLen = -ERANGE;
+		}
+	}
+
+	return (dataLen);
+}
+
+/*++======================================================================*/
+int Novfs_i_setxattr(struct dentry *dentry, const char *name, const void *value,
+		     size_t value_size, int flags)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+
+	struct inode *inode = dentry->d_inode;
+	session_t sessionId;
+	char *path, *buf;
+	unsigned long bytesWritten = 0;
+	int retError = 0;
+	int retxcode = 0;
+
+	SC_INITIALIZE(sessionId);
+
+	DbgPrint("Novfs_i_setxattr: Ian\n");	/*%.*s\n", dentry->d_name.len, dentry->d_name.name); */
+	DbgPrint
+	    ("Novfs_i_setxattr: dentry->d_name.len %u, dentry->d_name.name %s\n",
+	     dentry->d_name.len, dentry->d_name.name);
+	DbgPrint("Novfs_i_setxattr: name %s\n", name);
+	DbgPrint("Novfs_i_setxattr: value_size %u\n", value_size);
+	DbgPrint("Novfs_i_setxattr: flags %d\n", flags);
+
+	if (inode && inode->FSPRIVATE) {
+		sessionId =
+		    Scope_Get_SessionId(((struct inode_data *)inode->FSPRIVATE)->
+					Scope);
+		DbgPrint("Novfs_i_setxattr: SessionId = %u\n", sessionId);
+		//if (0 == sessionId)
+		if (0 == SC_PRESENT(sessionId)) {
+			((struct inode_data *)inode->FSPRIVATE)->Scope =
+			    Scope_Get_ScopefromPath(dentry);
+			sessionId =
+			    Scope_Get_SessionId(((struct inode_data *)inode->
+						 FSPRIVATE)->Scope);
+			DbgPrint("Novfs_i_setxattr: SessionId = %u\n",
+				 sessionId);
+		}
+	}
+
+	buf = (char *)Novfs_Malloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
+	if (buf) {
+		path = Novfs_dget_path(dentry, buf, PATH_LENGTH_BUFFER);
+		if (path) {
+			retxcode =
+			    Novfs_SetX_File_Info(path, name, value, value_size,
+						 &bytesWritten, flags,
+						 &sessionId);
+			if (!retxcode) {
+				DbgPrint
+				    ("Novfs_i_setxattr: bytesWritten = %u\n",
+				     bytesWritten);
+			}
+		}
+		kfree(buf);
+	}
+
+	if (retxcode) {
+		retError = retxcode;
+	}
+
+	if (bytesWritten < value_size) {
+		retError = retxcode;
+	}
+	return (retError);
+}
+
+int Novfs_i_listxattr(struct dentry *dentry, char *buffer, size_t buffer_size)
+{
+	struct inode *inode = dentry->d_inode;
+	session_t sessionId;
+	char *path, *buf, *bufList;
+	ssize_t dataLen;
+
+	int retxcode = 0;
+
+	SC_INITIALIZE(sessionId);
+
+	DbgPrint("Novfs_i_listxattr: Ian\n");	//%.*s\n", dentry->d_name.len, dentry->d_name.name);
+	DbgPrint
+	    ("Novfs_i_listxattr: dentry->d_name.len %u, dentry->d_name.name %s\n",
+	     dentry->d_name.len, dentry->d_name.name);
+	DbgPrint("Novfs_i_listxattr: size %u\n", buffer_size);
+
+	if (inode && inode->FSPRIVATE) {
+		sessionId =
+		    Scope_Get_SessionId(((struct inode_data *)inode->FSPRIVATE)-> Scope);
+		DbgPrint("Novfs_i_listxattr: SessionId = %u\n", sessionId);
+		//if (0 == sessionId)
+		if (0 == SC_PRESENT(sessionId)) {
+			((struct inode_data *)inode->FSPRIVATE)->Scope = Scope_Get_ScopefromPath(dentry);
+			sessionId = Scope_Get_SessionId(((struct inode_data *)inode->FSPRIVATE)->Scope);
+			DbgPrint("Novfs_i_listxattr: SessionId = %u\n",
+				 sessionId);
+		}
+	}
+
+	dataLen = 0;
+	buf = (char *)Novfs_Malloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
+	if (buf) {
+		path = Novfs_dget_path(dentry, buf, PATH_LENGTH_BUFFER);
+		if (path) {
+			bufList = (char *)Novfs_Malloc(XA_BUFFER, GFP_KERNEL);
+			if (bufList) {
+				retxcode = Novfs_ListX_File_Info(path, bufList, XA_BUFFER, &dataLen, &sessionId);
+
+				mydump(64, bufList);
+				if (buffer_size != 0) {
+					if (buffer_size >= dataLen) {
+						memcpy(buffer, bufList,
+						       dataLen);
+					} else {
+						DbgPrint
+						    ("Novfs_i_listxattr: (!!!) not enough buffer_size. buffer_size = %d, dataLen = %d\n",
+						     buffer_size, dataLen);
+						retxcode = -1;
+					}
+				}
+
+				if (bufList) {
+					kfree(bufList);
+				}
+			}
+
+		}
+		kfree(buf);
+	}
+
+	if (retxcode) {
+		dataLen = -1;
+	} else {
+
+		if ((buffer_size > 0) && (buffer_size < dataLen)) {
+			dataLen = -ERANGE;
+		}
+	}
+	return (dataLen);
+}
+
+int Novfs_i_revalidate(struct dentry *dentry)
+{
+
+	DbgPrint("Novfs_i_revalidate: name %.*s\n", dentry->d_name.len,
+		 dentry->d_name.name);
+
+	return (0);
+}
+
+void Novfs_read_inode(struct inode *inode)
+{
+	DbgPrint("Novfs_read_inode: 0x%p %d\n", inode, inode->i_ino);
+}
+
+void Novfs_write_inode(struct inode *inode)
+{
+	DbgPrint("Novfs_write_inode: Inode=0x%p Ino=%d\n", inode, inode->i_ino);
+}
+
+int Novfs_notify_change(struct dentry *dentry, struct iattr *attr)
+{
+	struct inode *inode = dentry->d_inode;
+
+	DbgPrint
+	    ("Novfs_notify_change: Dentry=0x%p Name=%.*s Inode=0x%p Ino=%d ia_valid=0x%x\n",
+	     dentry, dentry->d_name.len, dentry->d_name.name, inode,
+	     inode->i_ino, attr->ia_valid);
+	return (0);
+}
+
+/*++======================================================================*/
+void Novfs_clear_inode(struct inode *inode)
+/*
+ * Arguments:    sb - pointer to the super_block
+ *               buf - pointer to the statfs buffer
+ *
+ *  Returns:      0
+ *
+ *  Abstract:     Called when statfs(2) system called.
+ *
+ *  Notes:
+ *
+ *  Environment:  Superblock operation
+ *
+ *========================================================================*/
+{
+	InodeCount--;
+
+	if (inode->FSPRIVATE) {
+		struct inode_data *id = inode->FSPRIVATE;
+
+		DbgPrint
+		    ("Novfs_clear_inode: inode=0x%p ino=%d Scope=0x%p Name=%s\n",
+		     inode, inode->i_ino, id->Scope, id->Name);
+
+		Novfs_free_inode_cache(inode);
+
+		down(&InodeList_lock);
+		list_del(&id->IList);
+		up(&InodeList_lock);
+
+		kfree(inode->FSPRIVATE);
+		inode->FSPRIVATE = NULL;
+
+		remove_inode_hash(inode);
+
+	} else {
+		DbgPrint("Novfs_clear_inode: inode=0x%p ino=%d\n", inode,
+			 inode->i_ino);
+	}
+}
+
+/*++======================================================================*/
+int Novfs_show_options(struct seq_file *s, struct vfsmount *m)
+/*
+ * Arguments:
+ *
+ *  Returns:      0
+ *
+ *  Abstract:     Called when /proc/mounts is read
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	char *buf, *path, *tmp;
+
+	buf = (char *)Novfs_Malloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
+	if (buf) {
+		struct path my_path;
+		my_path.mnt = m;
+		my_path.dentry = m->mnt_root;
+		path = d_path(&my_path, buf, PATH_LENGTH_BUFFER);
+		if (path) {
+			if (!Novfs_CurrentMount
+			    || (Novfs_CurrentMount
+				&& strcmp(Novfs_CurrentMount, path))) {
+				DbgPrint("Novfs_show_options: %.*s %.*s %s\n",
+					 m->mnt_root->d_name.len,
+					 m->mnt_root->d_name.name,
+					 m->mnt_mountpoint->d_name.len,
+					 m->mnt_mountpoint->d_name.name, path);
+				tmp =
+				    (char *)Novfs_Malloc(PATH_LENGTH_BUFFER -
+							 (int)(path - buf),
+							 GFP_KERNEL);
+				if (tmp) {
+					strcpy(tmp, path);
+					path = Novfs_CurrentMount;
+					Novfs_CurrentMount = tmp;
+					Daemon_SetMountPoint
+					    (Novfs_CurrentMount);
+
+					if (path) {
+						kfree(path);
+					}
+				}
+			}
+		}
+		kfree(buf);
+	}
+	return (0);
+}
+
+/*++======================================================================*/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+int Novfs_statfs(struct dentry *de, struct kstatfs *buf)
+#else
+int Novfs_statfs(struct super_block *sb, struct kstatfs *buf)
+#endif
+/*
+ * Arguments:    sb - pointer to the super_block
+ *               buf - pointer to the statfs buffer
+ *
+ *  Returns:      0
+ *
+ *  Abstract:     Called when statfs(2) system called.
+ *
+ *  Notes:
+ *
+ *  Environment:  Superblock operation
+ *
+ *========================================================================*/
+{
+	uint64_t td, fd, te, fe;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+	struct super_block *sb = de->d_sb;
+#endif
+
+	DbgPrint("Novfs_statfs:\n");
+
+	td = fd = te = fe = 0;
+
+	Scope_Get_UserSpace(&td, &fd, &te, &fe);
+
+	DbgPrint("td=%llu\n", td);
+	DbgPrint("fd=%llu\n", fd);
+	DbgPrint("te=%llu\n", te);
+	DbgPrint("fe=%llu\n", fd);
+
+	buf->f_type = sb->s_magic;
+	buf->f_bsize = sb->s_blocksize;
+	buf->f_namelen = NW_MAX_PATH_LENGTH;
+	buf->f_blocks =
+	    (sector_t) (td +
+			(uint64_t) (sb->s_blocksize -
+				    1)) >> (uint64_t) sb->s_blocksize_bits;
+	buf->f_bfree = (sector_t) fd >> (uint64_t) sb->s_blocksize_bits;
+	buf->f_bavail = (sector_t) buf->f_bfree;
+	buf->f_files = (sector_t) te;
+	buf->f_ffree = (sector_t) fe;
+	buf->f_frsize = sb->s_blocksize;
+	if (te > 0xffffffff)
+		buf->f_files = 0xffffffff;
+
+	if (fe > 0xffffffff)
+		buf->f_ffree = 0xffffffff;
+
+	DbgPrint("f_type:    0x%x\n", buf->f_type);
+	DbgPrint("f_bsize:   %u\n", buf->f_bsize);
+	DbgPrint("f_namelen: %d\n", buf->f_namelen);
+	DbgPrint("f_blocks:  %llu\n", buf->f_blocks);
+	DbgPrint("f_bfree:   %llu\n", buf->f_bfree);
+	DbgPrint("f_bavail:  %llu\n", buf->f_bavail);
+	DbgPrint("f_files:   %llu\n", buf->f_files);
+	DbgPrint("f_ffree:   %llu\n", buf->f_ffree);
+	DbgPrint("f_frsize:  %u\n", buf->f_frsize);
+
+	return 0;
+}
+
+struct inode *Novfs_get_inode(struct super_block *sb, int mode, int dev,
+			      uid_t Uid, ino_t ino, struct qstr *name)
+{
+	struct inode *inode = new_inode(sb);
+
+	if (inode) {
+		InodeCount++;
+		inode->i_mode = mode;
+		inode->i_uid = Uid;
+		inode->i_gid = 0;
+		/* bug # 340510 tells us to comment this out... */
+//#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,18)
+//		inode->i_blksize = sb->s_blocksize;
+//#else
+//		inode->i_sb->s_blocksize = sb->s_blocksize;
+//#endif
+		inode->i_blkbits = sb->s_blocksize_bits;
+		inode->i_blocks = 0;
+		inode->i_rdev = 0;
+		inode->i_ino = (ino) ? ino : (ino_t)atomic_inc_return(&Novfs_Inode_Number);
+		if (PageCache) {
+			inode->i_mapping->a_ops = &Novfs_aops;
+		} else {
+			inode->i_mapping->a_ops = &Novfs_nocache_aops;
+		}
+		inode->i_mapping->backing_dev_info = &Novfs_backing_dev_info;
+		inode->i_atime.tv_sec = 0;
+		inode->i_atime.tv_nsec = 0;
+		inode->i_mtime = inode->i_ctime = inode->i_atime;
+
+		DbgPrint("Novfs_get_inode: Inode=0x%p I_ino=%d len=%d\n", inode,
+			 inode->i_ino, name->len);
+
+		if (NULL !=
+		    (inode->FSPRIVATE =
+		     Novfs_Malloc(sizeof(struct inode_data) + name->len,
+				  GFP_KERNEL))) {
+			struct inode_data *id;
+			id = inode->FSPRIVATE;
+
+			DbgPrint("Novfs_get_inode: FSPRIVATE 0x%p\n", id);
+
+			id->Scope = NULL;
+			id->Flags = 0;
+			id->Inode = inode;
+
+			id->cntDC = 1;
+
+			INIT_LIST_HEAD(&id->DirCache);
+			init_MUTEX(&id->DirCacheLock);
+
+			id->FileHandle = 0;
+			id->CacheFlag = 0;
+
+			down(&InodeList_lock);
+
+			list_add_tail(&id->IList, &InodeList);
+			up(&InodeList_lock);
+
+			id->Name[0] = '\0';
+
+			memcpy(id->Name, name->name, name->len);
+			id->Name[name->len] = '\0';
+
+			DbgPrint("Novfs_get_inode: name %s\n", id->Name);
+		}
+
+		insert_inode_hash(inode);
+
+		switch (mode & S_IFMT) {
+
+		case S_IFREG:
+			inode->i_op = &Novfs_file_inode_operations;
+			inode->i_fop = &Novfs_file_operations;
+			break;
+
+		case S_IFDIR:
+			inode->i_op = &Novfs_inode_operations;
+			inode->i_fop = &Novfs_dir_operations;
+//  Again bug #340510
+//#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,18)
+//			inode->i_blksize = 0;
+//#else
+//			inode->i_sb->s_blocksize = 0;
+//#endif
+			inode->i_blkbits = 0;
+			break;
+
+		default:
+			init_special_inode(inode, mode, dev);
+			break;
+		}
+
+		DbgPrint("Novfs_get_inode: size=%lld\n", inode->i_size);
+		DbgPrint("Novfs_get_inode: mode=0%o\n", inode->i_mode);
+		DbgPrint("Novfs_get_inode: i_sb->s_blocksize=%d\n",
+			 inode->i_sb->s_blocksize);
+		DbgPrint("Novfs_get_inode: i_blkbits=%d\n", inode->i_blkbits);
+		DbgPrint("Novfs_get_inode: i_blocks=%d\n", inode->i_blocks);
+		DbgPrint("Novfs_get_inode: i_bytes=%d\n", inode->i_bytes);
+	}
+
+	DbgPrint("Novfs_get_inode: 0x%p %d\n", inode, inode->i_ino);
+	return (inode);
+}
+
+int Novfs_fill_super(struct super_block *SB, void *Data, int Silent)
+{
+	struct inode *inode;
+	struct dentry *server, *tree;
+	struct qstr name;
+	struct entry_info info;
+
+	SB->s_blocksize = PAGE_CACHE_SIZE;
+	SB->s_blocksize_bits = PAGE_CACHE_SHIFT;
+	SB->s_maxbytes = 0xFFFFFFFFFFFFFFFFULL;	/* Max file size */
+	SB->s_op = &Novfs_ops;
+	SB->s_flags |= (MS_NODIRATIME | MS_NODEV | MS_POSIXACL);
+	SB->s_magic = NOVFS_MAGIC;
+
+	name.len = 1;
+	name.name = "/";
+
+	inode = Novfs_get_inode(SB, S_IFDIR | 0777, 0, 0, 0, &name);
+	if (!inode) {
+		return (-ENOMEM);
+	}
+
+	Novfs_root = d_alloc_root(inode);
+
+	if (!Novfs_root) {
+		iput(inode);
+		return (-ENOMEM);
+	}
+	Novfs_root->d_time = jiffies + (File_update_timeout * HZ);
+
+	inode->i_atime = inode->i_ctime = inode->i_mtime = CURRENT_TIME;
+
+	SB->s_root = Novfs_root;
+
+	DbgPrint("Novfs_fill_super: root 0x%p\n", Novfs_root);
+
+	if (Novfs_root) {
+		Novfs_root->d_op = &Novfs_dentry_operations;
+
+		name.name = SERVER_DIRECTORY_NAME;
+		name.len = strlen(SERVER_DIRECTORY_NAME);
+		name.hash = Novfs_internal_hash(&name);
+
+		inode = Novfs_get_inode(SB, S_IFDIR | 0777, 0, 0, 0, &name);
+		if (inode) {
+			info.mode = inode->i_mode;
+			info.namelength = 0;
+			inode->i_size = info.size = 0;
+			inode->i_uid = info.uid = 0;
+			inode->i_gid = info.gid = 0;
+			inode->i_atime = info.atime =
+			    inode->i_ctime = info.ctime =
+			    inode->i_mtime = info.mtime = CURRENT_TIME;
+
+			server = d_alloc(Novfs_root, &name);
+			if (server) {
+				server->d_op = &Novfs_dentry_operations;
+				server->d_time = 0xffffffff;
+				d_add(server, inode);
+				DbgPrint("Novfs_fill_super: d_add %s 0x%p\n",
+					 SERVER_DIRECTORY_NAME, server);
+				Novfs_add_inode_entry(Novfs_root->d_inode,
+						      &name, inode->i_ino,
+						      &info);
+			}
+		}
+
+		name.name = TREE_DIRECTORY_NAME;
+		name.len = strlen(TREE_DIRECTORY_NAME);
+		name.hash = Novfs_internal_hash(&name);
+
+		inode = Novfs_get_inode(SB, S_IFDIR | 0777, 0, 0, 0, &name);
+		if (inode) {
+			info.mode = inode->i_mode;
+			info.namelength = 0;
+			inode->i_size = info.size = 0;
+			inode->i_uid = info.uid = 0;
+			inode->i_gid = info.gid = 0;
+			inode->i_atime = info.atime =
+			    inode->i_ctime = info.ctime =
+			    inode->i_mtime = info.mtime = CURRENT_TIME;
+			tree = d_alloc(Novfs_root, &name);
+			if (tree) {
+				tree->d_op = &Novfs_dentry_operations;
+				tree->d_time = 0xffffffff;
+
+				d_add(tree, inode);
+				DbgPrint("Novfs_fill_super: d_add %s 0x%p\n",
+					 TREE_DIRECTORY_NAME, tree);
+				Novfs_add_inode_entry(Novfs_root->d_inode,
+						      &name, inode->i_ino,
+						      &info);
+			}
+		}
+	}
+
+	return (0);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+int Novfs_get_sb(struct file_system_type *Fstype, int Flags,
+		 const char *Dev_name, void *Data, struct vfsmount *Mnt)
+#else
+struct super_block *Novfs_get_sb(struct file_system_type *Fstype, int Flags,
+				 const char *Dev_name, void *Data)
+#endif
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+	int sb;
+#else
+	struct super_block *sb;
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+	sb = get_sb_nodev(Fstype, Flags, Data, Novfs_fill_super, Mnt);
+#else
+	sb = get_sb_nodev(Fstype, Flags, Data, Novfs_fill_super);
+#endif
+
+	DbgPrint("Novfs_get_sb: sb=0x%p Fstype=0x%x Dev_name=%s\n", sb, Fstype,
+		 Dev_name);
+
+	return (sb);
+}
+
+static void novfs_kill_sb(struct super_block *super)
+{
+	/* calling shrink_dcache_sb() fixes novell bugzilla #345179, but I'm
+	 * not so sure about it... */
+	shrink_dcache_sb(super);
+	kill_litter_super(super);
+}
+
+ssize_t Novfs_Control_read(struct file *file, char *buf, size_t nbytes,
+			   loff_t * ppos)
+{
+	ssize_t retval = 0;
+
+	DbgPrint("Novfs_Control_read: kernel_locked 0x%x\n", kernel_locked());
+
+	return retval;
+}
+
+ssize_t Novfs_Control_write(struct file * file, const char *buf, size_t nbytes,
+			    loff_t * ppos)
+{
+	ssize_t retval = 0;
+
+	DbgPrint("Novfs_Control_write: kernel_locked 0x%x\n", kernel_locked());
+	if (buf && nbytes) {
+	}
+
+	return (retval);
+}
+
+int Novfs_Control_ioctl(struct inode *inode, struct file *file,
+			unsigned int cmd, unsigned long arg)
+{
+	int retval = 0;
+
+	DbgPrint("Novfs_Control_ioctl: kernel_locked 0x%x\n", kernel_locked());
+
+	return (retval);
+}
+
+static struct file_system_type Novfs_fs_type = {
+	.name = "novfs",
+	.get_sb = Novfs_get_sb,
+	.kill_sb = novfs_kill_sb,
+	.owner = THIS_MODULE,
+};
+
+int __init init_novfs(void)
+{
+	int retCode;
+
+	lastDir[0] = 0;
+	lastTime = get_nanosecond_time();
+
+	inHAX = 0;
+	inHAXTime = get_nanosecond_time();
+
+	retCode = Init_Procfs_Interface();
+
+	init_profile();
+
+	if (!retCode) {
+		DbgPrint("init_novfs: %s %s %s\n", __DATE__, __TIME__,
+			 NOVFS_VERSION_STRING);
+		Init_Daemon_Queue();
+		Scope_Init();
+		retCode = register_filesystem(&Novfs_fs_type);
+		if (retCode) {
+			Uninit_Procfs_Interface();
+			Uninit_Daemon_Queue();
+			Scope_Uninit();
+		}
+	}
+	return (retCode);
+}
+
+void __exit exit_novfs(void)
+{
+	printk(KERN_INFO "exit_novfs\n");
+
+	Scope_Uninit();
+	printk(KERN_INFO "exit_novfs after Scope_Uninit\n");
+
+	Uninit_Daemon_Queue();
+	printk(KERN_INFO "exit_novfs after Uninit_Daemon_Queue\n");
+
+	uninit_profile();
+	printk(KERN_INFO "exit_novfs after uninit_profile\n");
+
+	Uninit_Procfs_Interface();
+	printk(KERN_INFO "exit_novfs Uninit_Procfs_Interface\n");
+
+	unregister_filesystem(&Novfs_fs_type);
+	printk(KERN_INFO "exit_novfs: Exit\n");
+
+	if (Novfs_CurrentMount) {
+		kfree(Novfs_CurrentMount);
+		Novfs_CurrentMount = NULL;
+	}
+}
+
+int Novfs_lock_inode_cache(struct inode *i)
+/*
+ *
+ *  Arguments:   struct inode *i - pointer to directory inode
+ *
+ *  Returns:     0 - locked
+ *              -1 - not locked
+ *
+ *  Abstract:    Locks the inode cache.
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	struct inode_data *id;
+	int retVal = 0;
+
+	DbgPrint("Novfs_lock_inode_cache: 0x%p\n", i);
+	if (i && (id = i->FSPRIVATE) && id->DirCache.next) {
+		down(&id->DirCacheLock);
+		retVal = 1;
+	}
+	DbgPrint("Novfs_lock_inode_cache: return %d\n", retVal);
+	return (retVal);
+}
+
+/*++======================================================================*/
+void Novfs_unlock_inode_cache(struct inode *i)
+/*
+ *  Arguments:   struct inode *i - pointer to directory inode
+ *
+ *  Returns:     nothing
+ *
+ *  Abstract:    Unlocks inode cache.
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	struct inode_data *id;
+
+	if (i && (id = i->FSPRIVATE) && id->DirCache.next) {
+		up(&id->DirCacheLock);
+	}
+}
+
+/*++======================================================================*/
+int Novfs_enumerate_inode_cache(struct inode *i, struct list_head **iteration,
+				ino_t * ino, struct entry_info *info)
+/*
+ *  Arguments:   struct inode *i - pointer to directory inode
+ *
+ *  Returns:     0 - item found
+ *              -1 - done
+ *
+ *  Abstract:    Unlocks inode cache.
+ *
+ *  Notes:       DirCacheLock should be held before calling this routine.
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	struct inode_data *id;
+	struct dir_cache *dc;
+	struct list_head *l = NULL;
+	int retVal = -1;
+
+	if (i && (id = i->FSPRIVATE) && id->DirCache.next) {
+		if ((NULL == iteration) || (NULL == *iteration)) {
+			l = id->DirCache.next;
+		} else {
+			l = *iteration;
+		}
+
+		if (l == &id->DirCache) {
+			l = NULL;
+		} else {
+			dc = list_entry(l, struct dir_cache, list);
+
+			*ino = dc->ino;
+			info->type = 0;
+			info->mode = dc->mode;
+			info->size = dc->size;
+			info->atime = dc->atime;
+			info->mtime = dc->mtime;
+			info->ctime = dc->ctime;
+			info->namelength = dc->nameLen;
+			memcpy(info->name, dc->name, dc->nameLen);
+			info->name[dc->nameLen] = '\0';
+			retVal = 0;
+
+			l = l->next;
+		}
+	}
+	*iteration = l;
+	return (retVal);
+}
+
+/*++======================================================================*/
+int Novfs_get_entry(struct inode *i, struct qstr *name, ino_t * ino,
+		    struct entry_info *info)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:       DirCacheLock should be held before calling this routine.
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	struct inode_data *id;
+	struct dir_cache *dc;
+	int retVal = -1;
+	char *n = "<NULL>";
+	int nl = 6;
+
+	if (i && (id = i->FSPRIVATE) && id->DirCache.next) {
+		if (name && name->len) {
+			n = (char *)name->name;
+			nl = name->len;
+		}
+
+		dc = Novfs_lookup_inode_cache(i, name, *ino);
+		if (dc) {
+			dc->flags |= ENTRY_VALID;
+			retVal = 0;
+			*ino = dc->ino;
+			info->type = 0;
+			info->mode = dc->mode;
+			info->size = dc->size;
+			info->atime = dc->atime;
+			info->mtime = dc->mtime;
+			info->ctime = dc->ctime;
+			info->namelength = dc->nameLen;
+			memcpy(info->name, dc->name, dc->nameLen);
+			info->name[dc->nameLen] = '\0';
+			retVal = 0;
+		}
+
+		DbgPrint("Novfs_get_entry:\n"
+			 "   inode: 0x%p\n"
+			 "   name:  %.*s\n" "   ino:   %d\n", i, nl, n, *ino);
+	}
+	DbgPrint("Novfs_get_entry: return %d\n", retVal);
+	return (retVal);
+}
+
+int Novfs_get_entry_by_pos(struct inode *i, loff_t pos, ino_t * ino,
+			   struct entry_info *info)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:       DirCacheLock should be held before calling this routine.
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	int retVal = -1;
+	loff_t count = 0;
+	loff_t i_pos = pos - 2;
+	struct list_head *inter = NULL;
+	while (!Novfs_enumerate_inode_cache(i, &inter, ino, info)) {
+		DbgPrint
+		    ("Novfs_dir_readdir : Novfs_get_entry_by_pos : info->name = %s\n",
+		     info->name);
+		if (count == i_pos) {
+			retVal = 0;
+			break;
+		} else
+			count++;
+	}
+
+	return retVal;
+}
+
+/*++======================================================================*/
+int Novfs_get_entry_time(struct inode *i, struct qstr *name, ino_t * ino,
+			 struct entry_info *info, u64 * EntryTime)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:       DirCacheLock should be held before calling this routine.
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	struct inode_data *id;
+	struct dir_cache *dc;
+	int retVal = -1;
+	char *n = "<NULL>";
+	int nl = 6;
+
+	if (i && (id = i->FSPRIVATE) && id->DirCache.next) {
+		if (name && name->len) {
+			n = (char *)name->name;
+			nl = name->len;
+		}
+		DbgPrint("Novfs_get_entry_time:\n"
+			 "   inode: 0x%p\n"
+			 "   name:  %.*s\n" "   ino:   %d\n", i, nl, n, *ino);
+
+		dc = Novfs_lookup_inode_cache(i, name, *ino);
+		if (dc) {
+			retVal = 0;
+			*ino = dc->ino;
+			info->type = 0;
+			info->mode = dc->mode;
+			info->size = dc->size;
+			info->atime = dc->atime;
+			info->mtime = dc->mtime;
+			info->ctime = dc->ctime;
+			info->namelength = dc->nameLen;
+			memcpy(info->name, dc->name, dc->nameLen);
+			info->name[dc->nameLen] = '\0';
+			if (EntryTime) {
+				*EntryTime = dc->jiffies;
+			}
+			retVal = 0;
+		}
+	}
+	DbgPrint("Novfs_get_entry_time: return %d\n", retVal);
+	return (retVal);
+}
+
+/*++======================================================================*/
+int Novfs_get_remove_entry(struct inode *i, ino_t * ino, struct entry_info *info)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:    This routine will return the first entry on the list
+ *               and then remove it.
+ *
+ *  Notes:       DirCacheLock should be held before calling this routine.
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	struct inode_data *id;
+	struct dir_cache *dc;
+	struct list_head *l = NULL;
+	int retVal = -1;
+
+	if (i && (id = i->FSPRIVATE) && id->DirCache.next) {
+		l = id->DirCache.next;
+
+		if (l != &id->DirCache) {
+			dc = list_entry(l, struct dir_cache, list);
+
+			*ino = dc->ino;
+			info->type = 0;
+			info->mode = dc->mode;
+			info->size = dc->size;
+			info->atime = dc->atime;
+			info->mtime = dc->mtime;
+			info->ctime = dc->ctime;
+			info->namelength = dc->nameLen;
+			memcpy(info->name, dc->name, dc->nameLen);
+			info->name[dc->nameLen] = '\0';
+			retVal = 0;
+
+			list_del(&dc->list);
+			kfree(dc);
+			DCCount--;
+
+			id->cntDC--;
+		}
+	}
+	return (retVal);
+}
+
+/*++======================================================================*/
+void Novfs_invalidate_inode_cache(struct inode *i)
+/*
+ *  Arguments:   struct inode *i - pointer to directory inode
+ *
+ *  Returns:     nothing
+ *
+ *  Abstract:    Marks all entries in the directory cache as invalid.
+ *
+ *  Notes:       DirCacheLock should be held before calling this routine.
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	struct inode_data *id;
+	struct dir_cache *dc;
+	struct list_head *l;
+
+	if (i && (id = i->FSPRIVATE) && id->DirCache.next) {
+		list_for_each(l, &id->DirCache) {
+			dc = list_entry(l, struct dir_cache, list);
+			dc->flags &= ~ENTRY_VALID;
+		}
+	}
+}
+
+/*++======================================================================*/
+static struct dir_cache *Novfs_lookup_inode_cache(struct inode *i, struct qstr *name, ino_t ino)
+/*
+ *  Arguments:   struct inode *i - pointer to directory inode
+ *               struct qstr *name - pointer to name
+ *               ino_t - inode number
+ *
+ *  Returns:     struct dir_cache entry if match
+ *               NULL - if there is no match.
+ *
+ *  Abstract:    Checks a inode directory to see if there are any enties
+ *               matching name or ino.  If name is specified then ino is
+ *               not used.  ino is use if name is not specified.
+ *
+ *  Notes:       DirCacheLock should be held before calling this routine.
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	struct inode_data *id;
+	struct dir_cache *dc;
+	struct dir_cache *retVal = NULL;
+	struct list_head *l;
+	char *n = "<NULL>";
+	int nl = 6;
+	int hash = 0;
+
+	if (i && (id = i->FSPRIVATE) && id->DirCache.next) {
+		if (name && name->name) {
+			nl = name->len;
+			n = (char *)name->name;
+			hash = name->hash;
+		}
+		DbgPrint("Novfs_lookup_inode_cache:\n"
+			 "   inode: 0x%p\n"
+			 "   name:  %.*s\n"
+			 "   hash:  0x%x\n"
+			 "   len:   %d\n"
+			 "   ino:   %d\n", i, nl, n, hash, nl, ino);
+
+		list_for_each(l, &id->DirCache) {
+			dc = list_entry(l, struct dir_cache, list);
+			if (name) {
+
+/*         DbgPrint("Novfs_lookup_inode_cache: 0x%p\n" \
+                  "   ino:   %d\n" \
+                  "   hash:  0x%x\n" \
+                  "   len:   %d\n" \
+                  "   name:  %.*s\n",
+            dc, dc->ino, dc->hash, dc->nameLen, dc->nameLen, dc->name);
+*/
+				if ((name->hash == dc->hash) &&
+				    (name->len == dc->nameLen) &&
+				    (0 ==
+				     memcmp(name->name, dc->name, name->len))) {
+					retVal = dc;
+					break;
+				}
+			} else {
+				if (ino == dc->ino) {
+					retVal = dc;
+					break;
+				}
+			}
+		}
+	}
+
+	DbgPrint("Novfs_lookup_inode_cache: return 0x%p\n", retVal);
+	return (retVal);
+}
+
+/*++======================================================================*/
+int Novfs_lookup_validate(struct inode *i, struct qstr *name, ino_t ino)
+/*
+ *  Arguments:   struct inode *i - pointer to directory inode
+ *               struct qstr *name - pointer to name
+ *               ino_t - inode number
+ *
+ *  Returns:     0 if found
+ *               !0 if not found
+ *
+ *  Abstract:    Checks a inode directory to see if there are any enties
+ *               matching name or ino.  If entry is found the valid bit
+ *               is set.
+ *
+ *  Notes:       DirCacheLock should be held before calling this routine.
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	struct inode_data *id;
+	struct dir_cache *dc;
+	int retVal = -1;
+	char *n = "<NULL>";
+	int nl = 6;
+
+	if (i && (id = i->FSPRIVATE) && id->DirCache.next) {
+		if (name && name->len) {
+			n = (char *)name->name;
+			nl = name->len;
+		}
+		DbgPrint("Novfs_update_entry:\n"
+			 "   inode: 0x%p\n"
+			 "   name:  %.*s\n" "   ino:   %d\n", i, nl, n, ino);
+
+		dc = Novfs_lookup_inode_cache(i, name, ino);
+		if (dc) {
+			dc->flags |= ENTRY_VALID;
+			retVal = 0;
+		}
+	}
+	return (retVal);
+}
+
+/*++======================================================================*/
+int Novfs_add_inode_entry(struct inode *i,
+			  struct qstr *name, ino_t ino, struct entry_info *info)
+/*
+ *  Arguments:
+ *
+ *  Returns:     -ENOMEM - alloc error.
+ *                0 - success.
+ *
+ *  Abstract:    Added entry to directory cache.
+ *
+ *  Notes:       DirCacheLock should be held before calling this routine.
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	struct inode_data *id;
+	struct dir_cache *new;
+	int retVal = -ENOMEM;
+	struct dir_cache *todel;
+	struct list_head *todeltmp;
+
+	//SClark
+	DbgPrint("Novfs_add_inode_entry:\n" "   i: %u\n", i);
+	if ((id = i->FSPRIVATE)) {
+		DbgPrint("   i->FSPRIVATE: %p\n", id);
+		if (id->DirCache.next)
+			DbgPrint("   id->DirCache.next: %p\n",
+				 id->DirCache.next);
+	}
+	//SClark
+
+	if (i && (id = i->FSPRIVATE) && id->DirCache.next) {
+		new = Novfs_Malloc(sizeof(struct dir_cache) + name->len, GFP_KERNEL);
+		if (new) {
+			id->cntDC++;
+
+			DCCount++;
+			DbgPrint("Novfs_add_inode_entry:\n"
+				 "   inode: 0x%p\n"
+				 "   id:    0x%p\n"
+				 "   DC:    0x%p\n"
+				 "   new:   0x%p\n"
+				 "   name:  %.*s\n"
+				 "   ino:   %d\n"
+				 "   size:  %lld\n"
+				 "   mode:  0x%x\n",
+				 i, id, &id->DirCache, new, name->len,
+				 name->name, ino, info->size, info->mode);
+
+			retVal = 0;
+			new->flags = ENTRY_VALID;
+			new->jiffies = get_jiffies_64();
+			new->size = info->size;
+			new->mode = info->mode;
+			new->atime = info->atime;
+			new->mtime = info->mtime;
+			new->ctime = info->ctime;
+			new->ino = ino;
+			new->hash = name->hash;
+			new->nameLen = name->len;
+			memcpy(new->name, name->name, name->len);
+			new->name[new->nameLen] = '\0';
+			list_add(&new->list, &id->DirCache);
+
+			if (id->cntDC > 20) {
+				todeltmp = id->DirCache.prev;
+				todel = list_entry(todeltmp, struct dir_cache, list);
+
+				list_del(&todel->list);
+
+				kfree(todel);
+
+				DCCount--;
+				id->cntDC--;
+			}
+		}
+	}
+	return (retVal);
+}
+
+/*++======================================================================*/
+int Novfs_update_entry(struct inode *i, struct qstr *name, ino_t ino,
+		       struct entry_info *info)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:       DirCacheLock should be held before calling this routine.
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	struct inode_data *id;
+	struct dir_cache *dc;
+	int retVal = -1;
+	char *n = "<NULL>";
+	int nl = 6;
+	char atime_buf[32];
+	char mtime_buf[32];
+	char ctime_buf[32];
+
+	if (i && (id = i->FSPRIVATE) && id->DirCache.next) {
+
+		if (name && name->len) {
+			n = (char *)name->name;
+			nl = name->len;
+		}
+		ctime_r(&info->atime.tv_sec, atime_buf);
+		ctime_r(&info->mtime.tv_sec, mtime_buf);
+		ctime_r(&info->ctime.tv_sec, ctime_buf);
+		DbgPrint("Novfs_update_entry:\n"
+			 "   inode: 0x%p\n"
+			 "   name:  %.*s\n"
+			 "   ino:   %d\n"
+			 "   size:  %lld\n"
+			 "   atime: %s\n"
+			 "   mtime: %s\n"
+			 "   ctime: %s\n",
+			 i, nl, n, ino, info->size, atime_buf, mtime_buf,
+			 ctime_buf);
+
+		dc = Novfs_lookup_inode_cache(i, name, ino);
+		if (dc) {
+			retVal = 0;
+			dc->flags = ENTRY_VALID;
+			dc->jiffies = get_jiffies_64();
+			dc->size = info->size;
+			dc->mode = info->mode;
+			dc->atime = info->atime;
+			dc->mtime = info->mtime;
+			dc->ctime = info->ctime;
+
+			ctime_r(&dc->atime.tv_sec, atime_buf);
+			ctime_r(&dc->mtime.tv_sec, mtime_buf);
+			ctime_r(&dc->ctime.tv_sec, ctime_buf);
+			DbgPrint("Novfs_update_entry entry: 0x%p\n"
+				 "   flags:   0x%x\n"
+				 "   jiffies: %lld\n"
+				 "   ino:     %d\n"
+				 "   size:    %lld\n"
+				 "   mode:    0%o\n"
+				 "   atime:   %s\n"
+				 "   mtime:   %s %d\n"
+				 "   ctime:   %s\n"
+				 "   hash:    0x%x\n"
+				 "   nameLen: %d\n"
+				 "   name:    %s\n",
+				 dc, dc->flags, dc->jiffies, dc->ino, dc->size,
+				 dc->mode, atime_buf, mtime_buf,
+				 dc->mtime.tv_nsec, ctime_buf, dc->hash,
+				 dc->nameLen, dc->name);
+		}
+	}
+	DbgPrint("Novfs_update_entry: return %d\n", retVal);
+	return (retVal);
+}
+
+/*++======================================================================*/
+void Novfs_remove_inode_entry(struct inode *i, struct qstr *name, ino_t ino)
+/*
+ *  Arguments:
+ *
+ *  Returns:     nothing
+ *
+ *  Abstract:    Removes entry from directory cache.  You can specify a name
+ *               or an inode number.
+ *
+ *  Notes:       DirCacheLock should be held before calling this routine.
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	struct inode_data *id;
+	struct dir_cache *dc;
+	char *n = "<NULL>";
+	int nl = 6;
+
+	if (i && (id = i->FSPRIVATE) && id->DirCache.next) {
+		dc = Novfs_lookup_inode_cache(i, name, ino);
+		if (dc) {
+			if (name && name->name) {
+				nl = name->len;
+				n = (char *)name->name;
+			}
+			DbgPrint("Novfs_remove_inode_entry:\n"
+				 "   inode: 0x%p\n"
+				 "   id:    0x%p\n"
+				 "   DC:    0x%p\n"
+				 "   name:  %.*s\n"
+				 "   ino:   %d\n"
+				 "   entry: 0x%p\n"
+				 "      name: %.*s\n"
+				 "      ino:  %d\n"
+				 "      next: 0x%p\n"
+				 "      prev: 0x%p\n",
+				 i, id, &id->DirCache, nl, n, ino, dc,
+				 dc->nameLen, dc->name, dc->ino, dc->list.next,
+				 dc->list.prev);
+			list_del(&dc->list);
+			kfree(dc);
+			DCCount--;
+
+			id->cntDC--;
+		}
+	}
+}
+
+/*++======================================================================*/
+void Novfs_free_invalid_entries(struct inode *i)
+/*
+ *  Arguments:   struct inode *i - pointer to directory inode.
+ *
+ *  Returns:     nothing
+ *
+ *  Abstract:    Frees all invalid entries in the directory cache.
+ *
+ *  Notes:       DirCacheLock should be held before calling this routine.
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	struct inode_data *id;
+	struct dir_cache *dc;
+	struct list_head *l;
+
+	if (i && (id = i->FSPRIVATE) && id->DirCache.next) {
+		list_for_each(l, &id->DirCache) {
+			dc = list_entry(l, struct dir_cache, list);
+			if (0 == (dc->flags & ENTRY_VALID)) {
+				DbgPrint("Novfs_free_invalid_entries:\n"
+					 "   inode: 0x%p\n"
+					 "   id:    0x%p\n"
+					 "   entry:    0x%p\n"
+					 "   name:  %.*s\n"
+					 "   ino:   %d\n",
+					 i, id, dc, dc->nameLen, dc->name,
+					 dc->ino);
+				l = l->prev;
+				list_del(&dc->list);
+				kfree(dc);
+				DCCount--;
+
+				id->cntDC--;
+			}
+		}
+	}
+}
+
+/*++======================================================================*/
+void Novfs_free_inode_cache(struct inode *i)
+/*
+ *  Arguments:   struct inode *i - pointer to directory inode.
+ *
+ *  Returns:     nothing
+ *
+ *  Abstract:    Frees all entries in the inode cache.
+ *
+ *  Notes:       DirCacheLock should be held before calling this routine.
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	struct inode_data *id;
+	struct dir_cache *dc;
+	struct list_head *l;
+
+	if (i && (id = i->FSPRIVATE) && id->DirCache.next) {
+		list_for_each(l, &id->DirCache) {
+			dc = list_entry(l, struct dir_cache, list);
+			l = l->prev;
+			list_del(&dc->list);
+			kfree(dc);
+			DCCount--;
+
+			id->cntDC--;
+		}
+	}
+}
+
+void Novfs_dump_inode(void *pf)
+{
+	struct inode *inode;
+	void (*pfunc) (char *Fmt, ...) = pf;
+	struct inode_data *id;
+	struct dir_cache *dc;
+	struct list_head *il, *l;
+	char atime_buf[32];
+	char mtime_buf[32];
+	char ctime_buf[32];
+	unsigned long icnt = 0, dccnt = 0;
+
+	down(&InodeList_lock);
+	list_for_each(il, &InodeList) {
+		id = list_entry(il, struct inode_data, IList);
+		inode = id->Inode;
+		if (inode) {
+			icnt++;
+
+			pfunc("Inode=0x%p I_ino=%d\n", inode, inode->i_ino);
+
+			pfunc("   atime=%s\n",
+			      ctime_r(&inode->i_atime.tv_sec, atime_buf));
+			pfunc("   ctime=%s\n",
+			      ctime_r(&inode->i_mtime.tv_sec, atime_buf));
+			pfunc("   mtime=%s\n",
+			      ctime_r(&inode->i_ctime.tv_sec, atime_buf));
+			pfunc("   size=%lld\n", inode->i_size);
+			pfunc("   mode=0%o\n", inode->i_mode);
+			pfunc("   count=0%o\n", atomic_read(&inode->i_count));
+		}
+
+		pfunc("   inode_data: 0x%p Name=%s Scope=0x%p\n", id, id->Name,
+		      id->Scope);
+
+		if (id->DirCache.next) {
+			list_for_each(l, &id->DirCache) {
+				dccnt++;
+				dc = list_entry(l, struct dir_cache, list);
+				ctime_r(&dc->atime.tv_sec, atime_buf);
+				ctime_r(&dc->mtime.tv_sec, mtime_buf);
+				ctime_r(&dc->ctime.tv_sec, ctime_buf);
+
+				pfunc("   Cache Entry: 0x%p\n"
+				      "      flags:   0x%x\n"
+				      "      jiffies: %llu\n"
+				      "      ino:     %u\n"
+				      "      size:    %llu\n"
+				      "      mode:    0%o\n"
+				      "      atime:   %s\n"
+				      "      mtime:   %s\n"
+				      "      ctime:   %s\n"
+				      "      hash:    0x%x\n"
+				      "      len:     %d\n"
+				      "      name:    %s\n",
+				      dc, dc->flags, dc->jiffies,
+				      dc->ino, dc->size, dc->mode,
+				      atime_buf, mtime_buf, ctime_buf,
+				      dc->hash, dc->nameLen, dc->name);
+			}
+		}
+	}
+	up(&InodeList_lock);
+
+	pfunc("Inodes: %d(%d) DirCache: %d(%d)\n", InodeCount, icnt, DCCount,
+	      dccnt);
+
+}
+
+module_init(init_novfs);
+module_exit(exit_novfs);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Novell Inc.");
+MODULE_DESCRIPTION("Novell NetWare Client for Linux");
+MODULE_VERSION(NOVFS_VERSION_STRING);
--- /dev/null
+++ b/fs/novfs/nwcapi.c
@@ -0,0 +1,2537 @@
+/*
+ * Novell NCP Redirector for Linux
+ * Author: James Turner/Richard Williams
+ *
+ * This file contains functions used to interface to the library interface of
+ * the daemon.
+ *
+ * Copyright (C) 2005 Novell, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/timer.h>
+#include <linux/poll.h>
+#include <linux/semaphore.h>
+#include <asm/uaccess.h>
+
+#include "nwcapi.h"
+#include "nwerror.h"
+#include "vfs.h"
+#include "commands.h"
+
+static void GetUserData(NwcScanConnInfo *connInfo, PXPLAT_CALL_REQUEST cmd, PXPLAT_CALL_REPLY reply);
+static void GetConnData(NwcGetConnInfo *connInfo, PXPLAT_CALL_REQUEST cmd, PXPLAT_CALL_REPLY reply);
+
+
+int NwOpenConnByName(PXPLAT pdata, HANDLE * Handle, session_t Session)
+{
+	PXPLAT_CALL_REQUEST cmd;
+	PXPLAT_CALL_REPLY reply;
+	PNwdCOpenConnByName openConn, connReply;
+	NwcOpenConnByName ocbn;
+	int retCode = 0;
+	unsigned long cmdlen, datalen, replylen, cpylen;
+	char *data;
+
+	cpylen = copy_from_user(&ocbn, pdata->reqData, sizeof(ocbn));
+	datalen = sizeof(*openConn) + strlen_user(ocbn.pName->pString) + strlen_user(ocbn.pServiceType);
+	cmdlen = datalen + sizeof(*cmd);
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
+	if (!cmd)
+		return -ENOMEM;
+	cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+	cmd->Command.SequenceNumber = 0;
+	cmd->Command.SessionId = Session;
+	cmd->NwcCommand = NWC_OPEN_CONN_BY_NAME;
+
+	cmd->dataLen = datalen;
+	openConn = (PNwdCOpenConnByName) cmd->data;
+
+	openConn->nameLen = strlen_user(ocbn.pName->pString);
+	openConn->serviceLen = strlen_user(ocbn.pServiceType);
+	openConn->uConnFlags = ocbn.uConnFlags;
+	openConn->ConnHandle = Uint32toHandle(ocbn.ConnHandle);
+	data = (char *)openConn;
+	data += sizeof(*openConn);
+	openConn->oName = sizeof(*openConn);
+
+	openConn->oServiceType = openConn->oName + openConn->nameLen;
+	cpylen = copy_from_user(data, ocbn.pName->pString, openConn->nameLen);
+	data += openConn->nameLen;
+	cpylen = copy_from_user(data, ocbn.pServiceType, openConn->serviceLen);
+
+	retCode = Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+					(void **)&reply, &replylen,
+					INTERRUPTIBLE);
+	if (reply) {
+		/*
+		 * we got reply data from the daemon
+		 */
+		connReply = (PNwdCOpenConnByName) reply->data;
+		retCode = reply->Reply.ErrorCode;
+		if (!retCode) {
+			/*
+			 * we got valid data.
+			 */
+			connReply = (PNwdCOpenConnByName) reply->data;
+			ocbn.RetConnHandle = HandletoUint32(connReply->newConnHandle);
+			*Handle = connReply->newConnHandle;
+
+			cpylen = copy_to_user(pdata->reqData, &ocbn, sizeof(ocbn));
+			DbgPrint("New Conn Handle = %X\n", connReply->newConnHandle);
+		}
+		kfree(reply);
+	}
+
+	kfree(cmd);
+
+	return retCode;
+
+}
+
+int NwOpenConnByAddr(PXPLAT pdata, HANDLE * Handle, session_t Session)
+{
+	PXPLAT_CALL_REQUEST cmd;
+	PXPLAT_CALL_REPLY reply;
+	PNwdCOpenConnByAddr openConn, connReply;
+	NwcOpenConnByAddr ocba;
+	NwcTranAddr tranAddr;
+	int retCode = 0;
+	unsigned long cmdlen, datalen, replylen, cpylen;
+	char addr[MAX_ADDRESS_LENGTH];
+
+	cpylen = copy_from_user(&ocba, pdata->reqData, sizeof(ocba));
+	datalen = sizeof(*openConn);
+	cmdlen = datalen + sizeof(*cmd);
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
+	if (!cmd)
+		return -ENOMEM;
+
+	cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+	cmd->Command.SequenceNumber = 0;
+	cmd->Command.SessionId = Session;
+	cmd->NwcCommand = NWC_OPEN_CONN_BY_ADDRESS;
+	cmd->dataLen = datalen;
+	openConn = (PNwdCOpenConnByAddr) cmd->data;
+
+	cpylen = copy_from_user(&tranAddr, ocba.pTranAddr, sizeof(tranAddr));
+
+	DbgPrint("NwOpenConnByAddr: tranAddr\n");
+	mydump(sizeof(tranAddr), &tranAddr);
+
+	openConn->TranAddr.uTransportType = tranAddr.uTransportType;
+	openConn->TranAddr.uAddressLength = tranAddr.uAddressLength;
+	memset(addr, 0xcc, sizeof(addr) - 1);
+
+	cpylen = copy_from_user(addr, tranAddr.puAddress, tranAddr.uAddressLength);
+
+	DbgPrint("NwOpenConnByAddr: addr\n");
+	mydump(sizeof(addr), addr);
+
+	openConn->TranAddr.oAddress = *(unsigned int*) (&addr[2]);
+
+	retCode = Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+					(void **)&reply, &replylen,
+					INTERRUPTIBLE);
+	if (reply) {
+		/*
+		 * we got reply data from the daemon
+		 */
+		connReply = (PNwdCOpenConnByAddr) reply->data;
+		retCode = reply->Reply.ErrorCode;
+		if (!retCode) {
+			/*
+			 * we got valid data.
+			 */
+			connReply = (PNwdCOpenConnByAddr) reply->data;
+			ocba.ConnHandle = HandletoUint32(connReply->ConnHandle);
+			*Handle = connReply->ConnHandle;
+			cpylen = copy_to_user(pdata->reqData, &ocba, sizeof(ocba));
+			DbgPrint("New Conn Handle = %X\n", connReply->ConnHandle);
+		}
+		kfree(reply);
+	}
+
+	kfree(cmd);
+	return retCode;
+}
+
+/*++======================================================================*/
+int NwOpenConnByRef(PXPLAT pdata, HANDLE * Handle, session_t Session)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	PXPLAT_CALL_REQUEST cmd;
+	PXPLAT_CALL_REPLY reply;
+	PNwdCOpenConnByRef openConn;
+	NwcOpenConnByReference ocbr;
+	int retCode = -ENOMEM;
+	unsigned long cmdlen, datalen, replylen, cpylen;
+
+	cpylen = copy_from_user(&ocbr, pdata->reqData, sizeof(ocbr));
+	datalen = sizeof(*openConn);
+	cmdlen = datalen + sizeof(*cmd);
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
+	if (!cmd)
+		return -ENOMEM;
+
+	cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+	cmd->Command.SequenceNumber = 0;
+	cmd->Command.SessionId = Session;
+	cmd->NwcCommand = NWC_OPEN_CONN_BY_REFERENCE;
+	cmd->dataLen = datalen;
+	openConn = (PNwdCOpenConnByRef) cmd->data;
+
+	openConn->uConnReference = (HANDLE) (unsigned long) ocbr.uConnReference;
+	openConn->uConnFlags = ocbr.uConnFlags;
+
+	retCode = Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+					(void **)&reply, &replylen,
+					INTERRUPTIBLE);
+	if (reply) {
+		/*
+		 * we got reply data from the daemon
+		 */
+		openConn = (PNwdCOpenConnByRef) reply->data;
+		retCode = reply->Reply.ErrorCode;
+		if (!retCode) {
+			/*
+			 * we got valid data.
+			 */
+			ocbr.ConnHandle = HandletoUint32(openConn->ConnHandle);
+			*Handle = openConn->ConnHandle;
+
+			cpylen = copy_to_user(pdata->reqData, &ocbr, sizeof(ocbr));
+			DbgPrint("New Conn Handle = %X\n", openConn->ConnHandle);
+		}
+		kfree(reply);
+	}
+
+	kfree(cmd);
+	return (retCode);
+
+}
+
+int NwRawSend(PXPLAT pdata, session_t Session)
+{
+	NwcRequest xRequest;
+	PNwcFrag frag = NULL;
+	PNwcFrag cFrag = NULL;
+	PNwcFrag reqFrag = NULL;
+	PXPLAT_CALL_REQUEST cmd;
+	PXPLAT_CALL_REPLY reply;
+	int retCode = -ENOMEM;
+	unsigned long cmdlen, datalen, replylen, cpylen, totalLen;
+	unsigned int x;
+	PNwdCNCPReq ncpData;
+	PNwdCNCPRep ncpReply;
+	unsigned char *reqData;
+	unsigned long actualReplyLength = 0;
+
+	DbgPrint("[XPLAT] Process Raw NCP Send\n");
+	cpylen = copy_from_user(&xRequest, pdata->reqData, sizeof(xRequest));
+
+	/*
+	 * Figure out the length of the request
+	 */
+	frag = kmalloc(xRequest.uNumReplyFrags * sizeof(NwcFrag), GFP_KERNEL);
+	DbgPrint("[XPLAT RawNCP] - Reply Frag Count 0x%X\n", xRequest.uNumReplyFrags);
+
+	if (!frag)
+		goto exit;
+
+	cpylen = copy_from_user(frag, xRequest.pReplyFrags, xRequest.uNumReplyFrags * sizeof(NwcFrag));
+	totalLen = 0;
+
+	cFrag = frag;
+	for (x = 0; x < xRequest.uNumReplyFrags; x++) {
+		DbgPrint("[XPLAT - RawNCP] - Frag Len = %d\n", cFrag->uLength);
+		totalLen += cFrag->uLength;
+		cFrag++;
+	}
+
+	DbgPrint("[XPLAT - RawNCP] - totalLen = %d\n", totalLen);
+	datalen = 0;
+	reqFrag = kmalloc(xRequest.uNumRequestFrags * sizeof(NwcFrag), GFP_KERNEL);
+	if (!reqFrag)
+		goto exit;
+
+	cpylen = copy_from_user(reqFrag, xRequest.pRequestFrags, xRequest.uNumRequestFrags * sizeof(NwcFrag));
+	cFrag = reqFrag;
+	for (x = 0; x < xRequest.uNumRequestFrags; x++) {
+		datalen += cFrag->uLength;
+		cFrag++;
+	}
+
+	/*
+	 * Allocate the cmd Request
+	 */
+	cmdlen = datalen + sizeof(*cmd) + sizeof(*ncpData);
+	DbgPrint("[XPLAT RawNCP] - Frag Count 0x%X\n", xRequest.uNumRequestFrags);
+	DbgPrint("[XPLAT RawNCP] - Total Command Data Len = %x\n", cmdlen);
+
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
+	if (!cmd)
+		goto exit;
+
+	cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+	cmd->Command.SequenceNumber = 0;
+	cmd->Command.SessionId = Session;
+	cmd->NwcCommand = NWC_RAW_NCP_REQUEST;
+
+	/*
+	 * build the NCP Request
+	 */
+	cmd->dataLen = cmdlen - sizeof(*cmd);
+	ncpData = (PNwdCNCPReq) cmd->data;
+	ncpData->replyLen = totalLen;
+	ncpData->requestLen = datalen;
+	ncpData->ConnHandle = (HANDLE) (unsigned long) xRequest.ConnHandle;
+	ncpData->function = xRequest.uFunction;
+
+	reqData = ncpData->data;
+	cFrag = reqFrag;
+
+	for (x = 0; x < xRequest.uNumRequestFrags; x++) {
+		cpylen =
+		    copy_from_user(reqData, cFrag->pData,
+				   cFrag->uLength);
+		reqData += cFrag->uLength;
+		cFrag++;
+	}
+
+	retCode = Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+					(void **)&reply, &replylen,
+					INTERRUPTIBLE);
+	DbgPrint("RawNCP - reply = %x\n", reply);
+	DbgPrint("RawNCP - retCode = %x\n", retCode);
+
+	if (reply) {
+		/*
+		 * we got reply data from the daemon
+		 */
+		ncpReply = (PNwdCNCPRep) reply->data;
+		retCode = reply->Reply.ErrorCode;
+
+		DbgPrint("RawNCP - Reply Frag Count 0x%X\n",
+			 xRequest.uNumReplyFrags);
+
+		/*
+		 * We need to copy the reply frags to the packet.
+		 */
+		reqData = ncpReply->data;
+		cFrag = frag;
+
+		totalLen = ncpReply->replyLen;
+		for (x = 0; x < xRequest.uNumReplyFrags; x++) {
+
+			DbgPrint("RawNCP - Copy Frag %d: 0x%X\n", x,
+				 cFrag->uLength);
+
+			datalen = min((unsigned long)cFrag->uLength, totalLen);
+
+			cpylen = copy_to_user(cFrag->pData, reqData, datalen);
+			totalLen -= datalen;
+			reqData += datalen;
+			actualReplyLength += datalen;
+
+			cFrag++;
+		}
+
+		kfree(reply);
+	} else {
+		retCode = -EIO;
+	}
+
+	kfree(cmd);
+
+	xRequest.uActualReplyLength = actualReplyLength;
+	cpylen = copy_to_user(pdata->reqData, &xRequest, sizeof(xRequest));
+
+exit:
+	kfree(reqFrag);
+	kfree(frag);
+	return retCode;
+}
+
+int NwConnClose(PXPLAT pdata, HANDLE * Handle, session_t Session)
+{
+	PXPLAT_CALL_REQUEST cmd;
+	PXPLAT_CALL_REPLY reply;
+	NwcCloseConn cc;
+	PNwdCCloseConn nwdClose;
+	int retCode = 0;
+	unsigned long cmdlen, datalen, replylen, cpylen;
+
+	cpylen = copy_from_user(&cc, pdata->reqData, sizeof(cc));
+
+	datalen = sizeof(*nwdClose);
+	cmdlen = datalen + sizeof(*cmd);
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
+	if (!cmd)
+		return -ENOMEM;
+
+	cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+	cmd->Command.SequenceNumber = 0;
+	cmd->Command.SessionId = Session;
+	cmd->NwcCommand = NWC_CLOSE_CONN;
+
+	nwdClose = (PNwdCCloseConn) cmd->data;
+	cmd->dataLen = sizeof(*nwdClose);
+	*Handle = nwdClose->ConnHandle = Uint32toHandle(cc.ConnHandle);
+
+	/*
+	 * send the request
+	 */
+	retCode = Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+					(void **)&reply, &replylen, 0);
+	if (reply) {
+		retCode = reply->Reply.ErrorCode;
+		kfree(reply);
+	}
+	kfree(cmd);
+	return retCode;
+}
+
+int NwSysConnClose(PXPLAT pdata, unsigned long *Handle, session_t Session)
+{
+	PXPLAT_CALL_REQUEST cmd;
+	PXPLAT_CALL_REPLY reply;
+	NwcCloseConn cc;
+	PNwdCCloseConn nwdClose;
+	unsigned int retCode = 0;
+	unsigned long cmdlen, datalen, replylen, cpylen;
+
+	cpylen = copy_from_user(&cc, pdata->reqData, sizeof(cc));
+
+	datalen = sizeof(*nwdClose);
+	cmdlen = datalen + sizeof(*cmd);
+	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	if (cmd) {
+		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+		cmd->Command.SequenceNumber = 0;
+		cmd->Command.SessionId = Session;
+		cmd->NwcCommand = NWC_SYS_CLOSE_CONN;
+
+		nwdClose = (PNwdCCloseConn) cmd->data;
+		cmd->dataLen = sizeof(*nwdClose);
+		nwdClose->ConnHandle = (HANDLE) (unsigned long) cc.ConnHandle;
+		*Handle = (unsigned long) cc.ConnHandle;
+
+		/*
+		 * send the request
+		 */
+		retCode =
+		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+					 (void **)&reply, &replylen, 0);
+		if (reply) {
+			retCode = reply->Reply.ErrorCode;
+			kfree(reply);
+		}
+		kfree(cmd);
+
+	}
+
+	return (retCode);
+
+}
+
+/*++======================================================================*/
+int NwLoginIdentity(PXPLAT pdata, struct schandle *Session)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	NwcLoginIdentity lgn, *plgn;
+	int retCode = -ENOMEM;
+	NclString server;
+	NclString username;
+	NclString password;
+	unsigned long cpylen;
+	NwcString nwcStr;
+
+	cpylen = copy_from_user(&lgn, pdata->reqData, sizeof(lgn));
+
+	DbgPrint("NwLoginIdentity:\n");
+	mydump(sizeof(lgn), &lgn);
+
+	cpylen = copy_from_user(&nwcStr, lgn.pDomainName, sizeof(nwcStr));
+	DbgPrint("NwLoginIdentity: DomainName\n");
+	mydump(sizeof(nwcStr), &nwcStr);
+
+	if ((server.buffer = Novfs_Malloc(nwcStr.DataLen, GFP_KERNEL))) {
+		server.type = nwcStr.DataType;
+		server.len = nwcStr.DataLen;
+		if (!copy_from_user
+		    ((void *)server.buffer, nwcStr.pBuffer, server.len)) {
+			DbgPrint("NwLoginIdentity: Server\n");
+			mydump(server.len, server.buffer);
+
+			cpylen =
+			    copy_from_user(&nwcStr, lgn.pObjectName,
+					   sizeof(nwcStr));
+			DbgPrint("NwLoginIdentity: ObjectName\n");
+			mydump(sizeof(nwcStr), &nwcStr);
+
+			if ((username.buffer =
+			     Novfs_Malloc(nwcStr.DataLen, GFP_KERNEL))) {
+				username.type = nwcStr.DataType;
+				username.len = nwcStr.DataLen;
+				if (!copy_from_user
+				    ((void *)username.buffer, nwcStr.pBuffer,
+				     username.len)) {
+					DbgPrint("NwLoginIdentity: User\n");
+					mydump(username.len, username.buffer);
+
+					cpylen =
+					    copy_from_user(&nwcStr,
+							   lgn.pPassword,
+							   sizeof(nwcStr));
+					DbgPrint("NwLoginIdentity: Password\n");
+					mydump(sizeof(nwcStr), &nwcStr);
+
+					if ((password.buffer =
+					     Novfs_Malloc(nwcStr.DataLen,
+							  GFP_KERNEL))) {
+						password.type = nwcStr.DataType;
+						password.len = nwcStr.DataLen;
+						if (!copy_from_user
+						    ((void *)password.buffer,
+						     nwcStr.pBuffer,
+						     password.len)) {
+							retCode =
+							    do_login(&server,
+								     &username,
+								     &password,
+								     (HANDLE *)&lgn.AuthenticationId,
+								     Session);
+							if (retCode) {
+								lgn.AuthenticationId = 0;
+							}
+
+							plgn =
+							    (NwcLoginIdentity *)
+							    pdata->reqData;
+							cpylen =
+							    copy_to_user(&plgn->
+									 AuthenticationId,
+									 &lgn.
+									 AuthenticationId,
+									 sizeof
+									 (plgn->
+									  AuthenticationId));
+
+						}
+						memset(password.buffer, 0,
+						       password.len);
+						kfree(password.buffer);
+					}
+				}
+				memset(username.buffer, 0, username.len);
+				kfree(username.buffer);
+			}
+		}
+		kfree(server.buffer);
+	}
+	return (retCode);
+}
+
+/*++======================================================================*/
+int NwAuthConnWithId(PXPLAT pdata, session_t Session)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	NwcAuthenticateWithId pauth;
+	PNwdCAuthenticateWithId pDauth;
+	PXPLAT_CALL_REQUEST cmd;
+	PXPLAT_CALL_REPLY reply;
+	int retCode = -ENOMEM;
+	unsigned long cmdlen, datalen, replylen, cpylen;
+
+	datalen = sizeof(*pDauth);
+	cmdlen = datalen + sizeof(*cmd);
+	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+
+	if (cmd) {
+		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+		cmd->Command.SequenceNumber = 0;
+		cmd->Command.SessionId = Session;
+		cmd->NwcCommand = NWC_AUTHENTICATE_CONN_WITH_ID;
+
+		cpylen = copy_from_user(&pauth, pdata->reqData, sizeof(pauth));
+
+		pDauth = (PNwdCAuthenticateWithId) cmd->data;
+		cmd->dataLen = datalen;
+		pDauth->AuthenticationId = pauth.AuthenticationId;
+		pDauth->ConnHandle = (HANDLE) (unsigned long) pauth.ConnHandle;
+
+		retCode =
+		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+					 (void **)&reply, &replylen,
+					 INTERRUPTIBLE);
+		if (reply) {
+			retCode = reply->Reply.ErrorCode;
+			kfree(reply);
+		}
+		kfree(cmd);
+	}
+	return (retCode);
+}
+
+/*++======================================================================*/
+int NwLicenseConn(PXPLAT pdata, session_t Session)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	PXPLAT_CALL_REQUEST cmd;
+	PXPLAT_CALL_REPLY reply;
+	NwcLicenseConn lisc;
+	PNwdCLicenseConn pDLisc;
+	int retCode = -ENOMEM;
+	unsigned long cmdlen, datalen, replylen, cpylen;
+
+	datalen = sizeof(*pDLisc);
+	cmdlen = datalen + sizeof(*cmd);
+	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+
+	if (cmd) {
+		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+		cmd->Command.SequenceNumber = 0;
+		cmd->Command.SessionId = Session;
+		cmd->NwcCommand = NWC_LICENSE_CONN;
+
+		cpylen = copy_from_user(&lisc, pdata->reqData, sizeof(lisc));
+
+		pDLisc = (PNwdCLicenseConn) cmd->data;
+		cmd->dataLen = datalen;
+		pDLisc->ConnHandle = (HANDLE) (unsigned long) lisc.ConnHandle;
+
+		retCode =
+		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+					 (void **)&reply, &replylen,
+					 INTERRUPTIBLE);
+		if (reply) {
+			retCode = reply->Reply.ErrorCode;
+			kfree(reply);
+		}
+		kfree(cmd);
+	}
+	return (retCode);
+}
+
+/*++======================================================================*/
+int NwLogoutIdentity(PXPLAT pdata, session_t Session)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	PXPLAT_CALL_REQUEST cmd;
+	PXPLAT_CALL_REPLY reply;
+	NwcLogoutIdentity logout;
+	PNwdCLogoutIdentity pDLogout;
+	int retCode = -ENOMEM;
+	unsigned long cmdlen, datalen, replylen, cpylen;
+
+	datalen = sizeof(*pDLogout);
+	cmdlen = datalen + sizeof(*cmd);
+	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+
+	if (cmd) {
+		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+		cmd->Command.SequenceNumber = 0;
+		cmd->Command.SessionId = Session;
+		cmd->NwcCommand = NWC_LOGOUT_IDENTITY;
+
+		cpylen =
+		    copy_from_user(&logout, pdata->reqData, sizeof(logout));
+
+		pDLogout = (PNwdCLogoutIdentity) cmd->data;
+		cmd->dataLen = datalen;
+		pDLogout->AuthenticationId = logout.AuthenticationId;
+
+		retCode =
+		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+					 (void **)&reply, &replylen,
+					 INTERRUPTIBLE);
+		if (reply) {
+			retCode = reply->Reply.ErrorCode;
+			kfree(reply);
+		}
+		kfree(cmd);
+	}
+	return (retCode);
+}
+
+/*++======================================================================*/
+int NwUnlicenseConn(PXPLAT pdata, session_t Session)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	PXPLAT_CALL_REQUEST cmd;
+	PXPLAT_CALL_REPLY reply;
+	PNwdCUnlicenseConn pUconn;
+	NwcUnlicenseConn ulc;
+	int retCode = -ENOMEM;
+	unsigned long cmdlen, datalen, replylen, cpylen;
+
+	cpylen = copy_from_user(&ulc, pdata->reqData, sizeof(ulc));
+	datalen = sizeof(*pUconn);
+	cmdlen = datalen + sizeof(*cmd);
+	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	if (cmd) {
+		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+		cmd->Command.SequenceNumber = 0;
+		cmd->Command.SessionId = Session;
+		cmd->NwcCommand = NWC_UNLICENSE_CONN;
+		cmd->dataLen = datalen;
+		pUconn = (PNwdCUnlicenseConn) cmd->data;
+
+		pUconn->ConnHandle = (HANDLE) (unsigned long) ulc.ConnHandle;
+		retCode =
+		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+					 (void **)&reply, &replylen,
+					 INTERRUPTIBLE);
+		if (reply) {
+			/*
+			 * we got reply data from the daemon
+			 */
+			retCode = reply->Reply.ErrorCode;
+			kfree(reply);
+		}
+
+		kfree(cmd);
+	}
+	return (retCode);
+
+}
+
+/*++======================================================================*/
+int NwUnAuthenticate(PXPLAT pdata, session_t Session)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	PXPLAT_CALL_REQUEST cmd;
+	PXPLAT_CALL_REPLY reply;
+	NwcUnauthenticate auth;
+	PNwdCUnauthenticate pDAuth;
+	int retCode = -ENOMEM;
+	unsigned long cmdlen, datalen, replylen, cpylen;
+
+	datalen = sizeof(*pDAuth);
+	cmdlen = datalen + sizeof(*cmd);
+	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+
+	if (cmd) {
+		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+		cmd->Command.SequenceNumber = 0;
+		cmd->Command.SessionId = Session;
+		cmd->NwcCommand = NWC_UNAUTHENTICATE_CONN;
+
+		cpylen = copy_from_user(&auth, pdata->reqData, sizeof(auth));
+
+		pDAuth = (PNwdCUnauthenticate) cmd->data;
+		cmd->dataLen = datalen;
+		pDAuth->AuthenticationId = auth.AuthenticationId;
+		pDAuth->ConnHandle = (HANDLE) (unsigned long) auth.ConnHandle;
+
+		retCode =
+		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+					 (void **)&reply, &replylen,
+					 INTERRUPTIBLE);
+		if (reply) {
+			retCode = reply->Reply.ErrorCode;
+			kfree(reply);
+		}
+		kfree(cmd);
+	}
+	return (retCode);
+
+}
+
+/*++======================================================================*/
+int NwGetConnInfo(PXPLAT pdata, session_t Session)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	PXPLAT_CALL_REQUEST cmd;
+	PXPLAT_CALL_REPLY reply;
+	NwcGetConnInfo connInfo;
+	PNwdCGetConnInfo pDConnInfo;
+	int retCode = -ENOMEM;
+	unsigned long cmdlen, replylen, cpylen;
+
+	cmdlen = sizeof(*cmd) + sizeof(*pDConnInfo);
+	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	cpylen =
+	    copy_from_user(&connInfo, pdata->reqData, sizeof(NwcGetConnInfo));
+
+	if (cmd) {
+		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+		cmd->Command.SequenceNumber = 0;
+		cmd->Command.SessionId = Session;
+		cmd->NwcCommand = NWC_GET_CONN_INFO;
+
+		pDConnInfo = (PNwdCGetConnInfo) cmd->data;
+
+		pDConnInfo->ConnHandle = (HANDLE) (unsigned long) connInfo.ConnHandle;
+		pDConnInfo->uInfoLevel = connInfo.uInfoLevel;
+		pDConnInfo->uInfoLength = connInfo.uInfoLength;
+		cmd->dataLen = sizeof(*pDConnInfo);
+
+		retCode =
+		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+					 (void **)&reply, &replylen,
+					 INTERRUPTIBLE);
+		if (reply) {
+			retCode = reply->Reply.ErrorCode;
+			if (!retCode) {
+				GetConnData(&connInfo, cmd, reply);
+			}
+
+			kfree(reply);
+		}
+		kfree(cmd);
+
+	}
+
+	return (retCode);
+
+}
+
+/*++======================================================================*/
+int NwSetConnInfo(PXPLAT pdata, session_t Session)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	PXPLAT_CALL_REQUEST cmd;
+	PXPLAT_CALL_REPLY reply;
+	NwcSetConnInfo connInfo;
+	PNwdCSetConnInfo pDConnInfo;
+	int retCode = -ENOMEM;
+	unsigned long cmdlen, replylen, cpylen;
+
+	cmdlen = sizeof(*cmd) + sizeof(*pDConnInfo);
+	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	cpylen =
+	    copy_from_user(&connInfo, pdata->reqData, sizeof(NwcSetConnInfo));
+
+	if (cmd) {
+		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+		cmd->Command.SequenceNumber = 0;
+		cmd->Command.SessionId = Session;
+		cmd->NwcCommand = NWC_SET_CONN_INFO;
+
+		pDConnInfo = (PNwdCSetConnInfo) cmd->data;
+
+		pDConnInfo->ConnHandle = (HANDLE) (unsigned long) connInfo.ConnHandle;
+		pDConnInfo->uInfoLevel = connInfo.uInfoLevel;
+		pDConnInfo->uInfoLength = connInfo.uInfoLength;
+		cmd->dataLen = sizeof(*pDConnInfo);
+
+		retCode =
+		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+					 (void **)&reply, &replylen,
+					 INTERRUPTIBLE);
+		if (reply) {
+			retCode = reply->Reply.ErrorCode;
+			kfree(reply);
+		}
+		kfree(cmd);
+
+	}
+
+	return (retCode);
+
+}
+
+/*++======================================================================*/
+int NwGetIdentityInfo(PXPLAT pdata, session_t Session)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	PXPLAT_CALL_REQUEST cmd;
+	PXPLAT_CALL_REPLY reply;
+	NwcGetIdentityInfo qidInfo, *gId;
+	PNwdCGetIdentityInfo idInfo;
+	NwcString xferStr;
+	char *str;
+	int retCode = -ENOMEM;
+	unsigned long cmdlen, replylen, cpylen;
+
+	cmdlen = sizeof(*cmd) + sizeof(*idInfo);
+	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	cpylen = copy_from_user(&qidInfo, pdata->reqData, sizeof(qidInfo));
+
+	if (cmd) {
+		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+		cmd->Command.SequenceNumber = 0;
+		cmd->Command.SessionId = Session;
+		cmd->NwcCommand = NWC_GET_IDENTITY_INFO;
+
+		idInfo = (PNwdCGetIdentityInfo) cmd->data;
+
+		idInfo->AuthenticationId = qidInfo.AuthenticationId;
+		cmd->dataLen = sizeof(*idInfo);
+
+		retCode =
+		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+					 (void **)&reply, &replylen,
+					 INTERRUPTIBLE);
+		if (reply) {
+			retCode = reply->Reply.ErrorCode;
+
+			if (!reply->Reply.ErrorCode) {
+				/*
+				 * Save the return info to the user structure.
+				 */
+				gId = pdata->reqData;
+				idInfo = (PNwdCGetIdentityInfo) reply->data;
+				cpylen =
+				    copy_to_user(&gId->AuthenticationId,
+						 &idInfo->AuthenticationId,
+						 sizeof(idInfo->
+							AuthenticationId));
+				cpylen =
+				    copy_to_user(&gId->AuthType,
+						 &idInfo->AuthType,
+						 sizeof(idInfo->AuthType));
+				cpylen =
+				    copy_to_user(&gId->IdentityFlags,
+						 &idInfo->IdentityFlags,
+						 sizeof(idInfo->IdentityFlags));
+				cpylen =
+				    copy_to_user(&gId->NameType,
+						 &idInfo->NameType,
+						 sizeof(idInfo->NameType));
+				cpylen =
+				    copy_to_user(&gId->ObjectType,
+						 &idInfo->ObjectType,
+						 sizeof(idInfo->ObjectType));
+
+				cpylen =
+				    copy_from_user(&xferStr, gId->pDomainName,
+						   sizeof(NwcString));
+				str =
+				    (char *)((char *)reply->data +
+					     idInfo->pDomainNameOffset);
+				cpylen =
+				    copy_to_user(xferStr.pBuffer, str,
+						 idInfo->domainLen);
+				xferStr.DataType = NWC_STRING_TYPE_ASCII;
+				xferStr.DataLen = idInfo->domainLen;
+				cpylen =
+				    copy_to_user(gId->pDomainName, &xferStr,
+						 sizeof(NwcString));
+
+				cpylen =
+				    copy_from_user(&xferStr, gId->pObjectName,
+						   sizeof(NwcString));
+				str =
+				    (char *)((char *)reply->data +
+					     idInfo->pObjectNameOffset);
+				cpylen =
+				    copy_to_user(xferStr.pBuffer, str,
+						 idInfo->objectLen);
+				xferStr.DataLen = idInfo->objectLen - 1;
+				xferStr.DataType = NWC_STRING_TYPE_ASCII;
+				cpylen =
+				    copy_to_user(gId->pObjectName, &xferStr,
+						 sizeof(NwcString));
+			}
+
+			kfree(reply);
+		}
+		kfree(cmd);
+
+	}
+
+	return (retCode);
+}
+
+/*++======================================================================*/
+int NwScanConnInfo(PXPLAT pdata, session_t Session)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	PXPLAT_CALL_REQUEST cmd;
+	PXPLAT_CALL_REPLY reply;
+	NwcScanConnInfo connInfo, *rInfo;
+	PNwdCScanConnInfo pDConnInfo;
+	int retCode = -ENOMEM;
+	unsigned long cmdlen, replylen, cpylen;
+	unsigned char *localData;
+
+	cpylen =
+	    copy_from_user(&connInfo, pdata->reqData, sizeof(NwcScanConnInfo));
+
+	cmdlen = sizeof(*cmd) + sizeof(*pDConnInfo) + connInfo.uScanInfoLen;
+	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+
+	if (cmd) {
+		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+		cmd->Command.SequenceNumber = 0;
+		cmd->Command.SessionId = Session;
+		cmd->NwcCommand = NWC_SCAN_CONN_INFO;
+
+		pDConnInfo = (PNwdCScanConnInfo) cmd->data;
+
+		DbgPrint("NwScanConnInfo: Input Data\n");
+		DbgPrint("connInfo.uScanIndex = 0x%X\n", connInfo.uScanIndex);
+		DbgPrint("connInfo.uConnectionReference = 0x%X\n",
+			 connInfo.uConnectionReference);
+		DbgPrint("connInfo.uScanInfoLevel = 0x%X\n",
+			 connInfo.uScanInfoLevel);
+		DbgPrint("connInfo.uScanInfoLen = 0x%X\n",
+			 connInfo.uScanInfoLen);
+		DbgPrint("connInfo.uReturnInfoLength = 0x%X\n",
+			 connInfo.uReturnInfoLength);
+		DbgPrint("connInfo.uReturnInfoLevel = 0x%X\n",
+			 connInfo.uReturnInfoLevel);
+		DbgPrint("connInfo.uScanFlags = 0x%X\n", connInfo.uScanFlags);
+
+		pDConnInfo->uScanIndex = connInfo.uScanIndex;
+		pDConnInfo->uConnectionReference =
+		    connInfo.uConnectionReference;
+		pDConnInfo->uScanInfoLevel = connInfo.uScanInfoLevel;
+		pDConnInfo->uScanInfoLen = connInfo.uScanInfoLen;
+		pDConnInfo->uReturnInfoLength = connInfo.uReturnInfoLength;
+		pDConnInfo->uReturnInfoLevel = connInfo.uReturnInfoLevel;
+		pDConnInfo->uScanFlags = connInfo.uScanFlags;
+
+		if (pDConnInfo->uScanInfoLen) {
+			localData = (unsigned char *) pDConnInfo;
+			pDConnInfo->uScanConnInfoOffset = sizeof(*pDConnInfo);
+			localData += pDConnInfo->uScanConnInfoOffset;
+			cpylen =
+			    copy_from_user(localData, connInfo.pScanConnInfo,
+					   connInfo.uScanInfoLen);
+		} else {
+			pDConnInfo->uScanConnInfoOffset = 0;
+		}
+
+		cmd->dataLen = sizeof(*pDConnInfo);
+
+		retCode =
+		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+					 (void **)&reply, &replylen,
+					 INTERRUPTIBLE);
+		if (reply) {
+			DbgPrint("NwScanConnInfo: Reply recieved\n");
+			DbgPrint("   NextIndex = %x\n", connInfo.uScanIndex);
+			DbgPrint("   ErrorCode = %x\n", reply->Reply.ErrorCode);
+			DbgPrint("   data = %x\n", reply->data);
+
+			pDConnInfo = (PNwdCScanConnInfo) reply->data;
+			retCode = (unsigned long) reply->Reply.ErrorCode;
+			if (!retCode) {
+				GetUserData(&connInfo, cmd, reply);
+				rInfo = (NwcScanConnInfo *) pdata->repData;
+				cpylen =
+				    copy_to_user(pdata->repData,
+						 &pDConnInfo->uScanIndex,
+						 sizeof(pDConnInfo->
+							uScanIndex));
+				cpylen =
+				    copy_to_user(&rInfo->uConnectionReference,
+						 &pDConnInfo->
+						 uConnectionReference,
+						 sizeof(pDConnInfo->
+							uConnectionReference));
+			} else {
+				unsigned long x;
+
+				x = 0;
+				rInfo = (NwcScanConnInfo *) pdata->reqData;
+				cpylen =
+				    copy_to_user(&rInfo->uConnectionReference,
+						 &x,
+						 sizeof(rInfo->
+							uConnectionReference));
+			}
+
+			kfree(reply);
+		} else {
+			retCode = -EIO;
+		}
+		kfree(cmd);
+
+	}
+
+	return (retCode);
+}
+
+/*++======================================================================*/
+static void GetUserData(NwcScanConnInfo * connInfo, PXPLAT_CALL_REQUEST cmd, PXPLAT_CALL_REPLY reply)
+/*
+ *  Abstract:  Copies the user data out of the scan conn info call.
+ *
+ *========================================================================*/
+{
+	unsigned long uLevel;
+	PNwdCScanConnInfo pDConnInfo;
+
+	unsigned char *srcData = NULL;
+	unsigned long dataLen = 0, cpylen;
+
+	pDConnInfo = (PNwdCScanConnInfo) reply->data;
+	uLevel = pDConnInfo->uReturnInfoLevel;
+	DbgPrint
+	    ("[GetUserData] uLevel = %d, reply = 0x%p, reply->data = 0x%X\n",
+	     uLevel, reply, reply->data);
+
+	switch (uLevel) {
+	case NWC_CONN_INFO_RETURN_ALL:
+	case NWC_CONN_INFO_NDS_STATE:
+	case NWC_CONN_INFO_MAX_PACKET_SIZE:
+	case NWC_CONN_INFO_LICENSE_STATE:
+	case NWC_CONN_INFO_PUBLIC_STATE:
+	case NWC_CONN_INFO_SERVICE_TYPE:
+	case NWC_CONN_INFO_DISTANCE:
+	case NWC_CONN_INFO_SERVER_VERSION:
+	case NWC_CONN_INFO_AUTH_ID:
+	case NWC_CONN_INFO_SUSPENDED:
+	case NWC_CONN_INFO_WORKGROUP_ID:
+	case NWC_CONN_INFO_SECURITY_STATE:
+	case NWC_CONN_INFO_CONN_NUMBER:
+	case NWC_CONN_INFO_USER_ID:
+	case NWC_CONN_INFO_BCAST_STATE:
+	case NWC_CONN_INFO_CONN_REF:
+	case NWC_CONN_INFO_AUTH_STATE:
+	case NWC_CONN_INFO_TREE_NAME:
+	case NWC_CONN_INFO_SERVER_NAME:
+	case NWC_CONN_INFO_VERSION:
+		srcData = (unsigned char *) pDConnInfo;
+		srcData += pDConnInfo->uReturnConnInfoOffset;
+		dataLen = pDConnInfo->uReturnInfoLength;
+		break;
+
+	case NWC_CONN_INFO_TRAN_ADDR:
+		{
+			unsigned char *dstData = connInfo->pReturnConnInfo;
+			NwcTranAddr tranAddr;
+
+			srcData = (unsigned char *) reply->data;
+			dataLen = reply->dataLen;
+
+			DbgPrint
+			    ("GetUserData NWC_CONN_INFO_TRAN_ADDR 0x%p -> 0x%p :: 0x%X\n",
+			     srcData, connInfo->pReturnConnInfo, dataLen);
+
+			cpylen =
+			    copy_from_user(&tranAddr, dstData,
+					   sizeof(tranAddr));
+
+			srcData +=
+			    ((PNwdCScanConnInfo) srcData)->
+			    uReturnConnInfoOffset;
+
+			tranAddr.uTransportType =
+			    ((PNwdTranAddr) srcData)->uTransportType;
+			tranAddr.uAddressLength =
+			    ((PNwdTranAddr) srcData)->uAddressLength;
+
+			cpylen =
+			    copy_to_user(dstData, &tranAddr, sizeof(tranAddr));
+			cpylen =
+			    copy_to_user(tranAddr.puAddress,
+					 ((PNwdTranAddr) srcData)->Buffer,
+					 ((PNwdTranAddr) srcData)->
+					 uAddressLength);
+			dataLen = 0;
+			break;
+		}
+	case NWC_CONN_INFO_RETURN_NONE:
+	case NWC_CONN_INFO_TREE_NAME_UNICODE:
+	case NWC_CONN_INFO_SERVER_NAME_UNICODE:
+	case NWC_CONN_INFO_LOCAL_TRAN_ADDR:
+	case NWC_CONN_INFO_ALTERNATE_ADDR:
+	case NWC_CONN_INFO_SERVER_GUID:
+	default:
+		break;
+	}
+
+	if (srcData && dataLen) {
+		DbgPrint("Copy Data in GetUserData 0x%p -> 0x%p :: 0x%X\n",
+			 srcData, connInfo->pReturnConnInfo, dataLen);
+		cpylen =
+		    copy_to_user(connInfo->pReturnConnInfo, srcData, dataLen);
+	}
+
+	return;
+}
+
+/*++======================================================================*/
+static void GetConnData(NwcGetConnInfo * connInfo, PXPLAT_CALL_REQUEST cmd, PXPLAT_CALL_REPLY reply)
+/*
+ *  Abstract:  Copies the user data out of the scan conn info call.
+ *
+ *========================================================================*/
+{
+	unsigned long uLevel;
+	PNwdCGetConnInfo pDConnInfo;
+
+	unsigned char *srcData = NULL;
+	unsigned long dataLen = 0, cpylen;
+
+	pDConnInfo = (PNwdCGetConnInfo) cmd->data;
+	uLevel = pDConnInfo->uInfoLevel;
+
+	switch (uLevel) {
+	case NWC_CONN_INFO_RETURN_ALL:
+		srcData = (unsigned char *) reply->data;
+		dataLen = reply->dataLen;
+		break;
+
+	case NWC_CONN_INFO_RETURN_NONE:
+		dataLen = 0;
+		break;
+
+	case NWC_CONN_INFO_TRAN_ADDR:
+		{
+			unsigned char *dstData = connInfo->pConnInfo;
+			NwcTranAddr tranAddr;
+
+			srcData = (unsigned char *) reply->data;
+
+			cpylen =
+			    copy_from_user(&tranAddr, dstData,
+					   sizeof(tranAddr));
+			tranAddr.uTransportType =
+			    ((PNwdTranAddr) srcData)->uTransportType;
+			tranAddr.uAddressLength =
+			    ((PNwdTranAddr) srcData)->uAddressLength;
+
+			cpylen =
+			    copy_to_user(dstData, &tranAddr, sizeof(tranAddr));
+			cpylen =
+			    copy_to_user(tranAddr.puAddress,
+					 ((PNwdTranAddr) srcData)->Buffer,
+					 ((PNwdTranAddr) srcData)->
+					 uAddressLength);
+			dataLen = 0;
+			break;
+		}
+	case NWC_CONN_INFO_NDS_STATE:
+	case NWC_CONN_INFO_MAX_PACKET_SIZE:
+	case NWC_CONN_INFO_LICENSE_STATE:
+	case NWC_CONN_INFO_PUBLIC_STATE:
+	case NWC_CONN_INFO_SERVICE_TYPE:
+	case NWC_CONN_INFO_DISTANCE:
+	case NWC_CONN_INFO_SERVER_VERSION:
+	case NWC_CONN_INFO_AUTH_ID:
+	case NWC_CONN_INFO_SUSPENDED:
+	case NWC_CONN_INFO_WORKGROUP_ID:
+	case NWC_CONN_INFO_SECURITY_STATE:
+	case NWC_CONN_INFO_CONN_NUMBER:
+	case NWC_CONN_INFO_USER_ID:
+	case NWC_CONN_INFO_BCAST_STATE:
+	case NWC_CONN_INFO_CONN_REF:
+	case NWC_CONN_INFO_AUTH_STATE:
+	case NWC_CONN_INFO_VERSION:
+	case NWC_CONN_INFO_SERVER_NAME:
+	case NWC_CONN_INFO_TREE_NAME:
+		srcData = (unsigned char *) reply->data;
+		dataLen = reply->dataLen;
+		break;
+
+	case NWC_CONN_INFO_TREE_NAME_UNICODE:
+	case NWC_CONN_INFO_SERVER_NAME_UNICODE:
+		break;
+
+	case NWC_CONN_INFO_LOCAL_TRAN_ADDR:
+		break;
+
+	case NWC_CONN_INFO_ALTERNATE_ADDR:
+		break;
+
+	case NWC_CONN_INFO_SERVER_GUID:
+		break;
+
+	default:
+		break;
+	}
+
+	if (srcData && dataLen) {
+		cpylen =
+		    copy_to_user(connInfo->pConnInfo, srcData,
+				 connInfo->uInfoLength);
+	}
+
+	return;
+}
+
+/*++======================================================================*/
+int NwGetDaemonVersion(PXPLAT pdata, session_t Session)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	PXPLAT_CALL_REQUEST cmd;
+	PXPLAT_CALL_REPLY reply;
+	PNwdCGetRequesterVersion pDVersion;
+	int retCode = -ENOMEM;
+	unsigned long cmdlen, datalen, replylen, cpylen;
+
+	datalen = sizeof(*pDVersion);
+	cmdlen = datalen + sizeof(*cmd);
+	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+
+	if (cmd) {
+		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+		cmd->Command.SequenceNumber = 0;
+		cmd->Command.SessionId = Session;
+		cmd->NwcCommand = NWC_GET_REQUESTER_VERSION;
+		cmdlen = sizeof(*cmd);
+		retCode =
+		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+					 (void **)&reply, &replylen,
+					 INTERRUPTIBLE);
+		if (reply) {
+			retCode = reply->Reply.ErrorCode;
+			pDVersion = (PNwdCGetRequesterVersion) reply->data;
+			cpylen =
+			    copy_to_user(pDVersion, pdata->reqData,
+					 sizeof(*pDVersion));
+			kfree(reply);
+		}
+		kfree(cmd);
+	}
+	return (retCode);
+
+}
+
+/*++======================================================================*/
+int NwcGetPreferredDSTree(PXPLAT pdata, session_t Session)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	PXPLAT_CALL_REQUEST cmd;
+	PXPLAT_CALL_REPLY reply;
+	PNwdCGetPreferredDsTree pDGetTree;
+	NwcGetPreferredDsTree xplatCall, *p;
+	int retCode = -ENOMEM;
+	unsigned long cmdlen, datalen, replylen, cpylen;
+	unsigned char *dPtr;
+
+	cpylen =
+	    copy_from_user(&xplatCall, pdata->reqData,
+			   sizeof(NwcGetPreferredDsTree));
+	datalen = sizeof(*pDGetTree) + xplatCall.uTreeLength;
+	cmdlen = datalen + sizeof(*cmd);
+	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+
+	if (cmd) {
+		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+		cmd->Command.SequenceNumber = 0;
+		cmd->Command.SessionId = Session;
+		cmd->NwcCommand = NWC_GET_PREFERRED_DS_TREE;
+		cmdlen = sizeof(*cmd);
+
+		retCode =
+		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+					 (void **)&reply, &replylen,
+					 INTERRUPTIBLE);
+		if (reply) {
+			retCode = reply->Reply.ErrorCode;
+			if (!retCode) {
+				pDGetTree =
+				    (PNwdCGetPreferredDsTree) reply->data;
+				dPtr =
+				    reply->data + pDGetTree->DsTreeNameOffset;
+				p = (NwcGetPreferredDsTree *) pdata->reqData;
+
+				DbgPrint
+				    ("NwcGetPreferredDSTree: Reply recieved\n");
+				DbgPrint("   TreeLen = %x\n",
+					 pDGetTree->uTreeLength);
+				DbgPrint("   TreeName = %s\n", dPtr);
+
+				cpylen =
+				    copy_to_user(p, &pDGetTree->uTreeLength, 4);
+				cpylen =
+				    copy_to_user(xplatCall.pDsTreeName, dPtr,
+						 pDGetTree->uTreeLength);
+			}
+			kfree(reply);
+		}
+		kfree(cmd);
+	}
+	return (retCode);
+
+}
+
+/*++======================================================================*/
+int NwcSetPreferredDSTree(PXPLAT pdata, session_t Session)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	PXPLAT_CALL_REQUEST cmd;
+	PXPLAT_CALL_REPLY reply;
+	PNwdCSetPreferredDsTree pDSetTree;
+	NwcSetPreferredDsTree xplatCall;
+	int retCode = -ENOMEM;
+	unsigned long cmdlen, datalen, replylen, cpylen;
+	unsigned char *dPtr;
+
+	cpylen =
+	    copy_from_user(&xplatCall, pdata->reqData,
+			   sizeof(NwcSetPreferredDsTree));
+	datalen = sizeof(*pDSetTree) + xplatCall.uTreeLength;
+	cmdlen = datalen + sizeof(*cmd);
+	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+
+	if (cmd) {
+		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+		cmd->Command.SequenceNumber = 0;
+		cmd->Command.SessionId = Session;
+		cmd->NwcCommand = NWC_SET_PREFERRED_DS_TREE;
+
+		pDSetTree = (PNwdCSetPreferredDsTree) cmd->data;
+		pDSetTree->DsTreeNameOffset = sizeof(*pDSetTree);
+		pDSetTree->uTreeLength = xplatCall.uTreeLength;
+
+		dPtr = cmd->data + sizeof(*pDSetTree);
+		cpylen =
+		    copy_from_user(dPtr, xplatCall.pDsTreeName,
+				   xplatCall.uTreeLength);
+
+		retCode =
+		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+					 (void **)&reply, &replylen,
+					 INTERRUPTIBLE);
+		if (reply) {
+			retCode = reply->Reply.ErrorCode;
+			kfree(reply);
+		}
+		kfree(cmd);
+	}
+	return (retCode);
+
+}
+
+/*++======================================================================*/
+int NwcSetDefaultNameCtx(PXPLAT pdata, session_t Session)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	PXPLAT_CALL_REQUEST cmd;
+	PXPLAT_CALL_REPLY reply;
+	NwcSetDefaultNameContext xplatCall;
+	PNwdCSetDefaultNameContext pDSet;
+	int retCode = -ENOMEM;
+	unsigned long cmdlen, datalen, replylen, cpylen;
+	unsigned char *dPtr;
+
+	cpylen =
+	    copy_from_user(&xplatCall, pdata->reqData,
+			   sizeof(NwcSetDefaultNameContext));
+	datalen =
+	    sizeof(*pDSet) + xplatCall.uTreeLength + xplatCall.uNameLength;
+	cmdlen = datalen + sizeof(*cmd);
+	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+
+	if (cmd) {
+		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+		cmd->Command.SequenceNumber = 0;
+		cmd->Command.SessionId = Session;
+		cmd->NwcCommand = NWC_SET_DEFAULT_NAME_CONTEXT;
+		cmd->dataLen =
+		    sizeof(NwdCSetDefaultNameContext) + xplatCall.uTreeLength +
+		    xplatCall.uNameLength;
+
+		pDSet = (PNwdCSetDefaultNameContext) cmd->data;
+		dPtr = cmd->data;
+
+		pDSet->TreeOffset = sizeof(NwdCSetDefaultNameContext);
+		pDSet->uTreeLength = xplatCall.uTreeLength;
+		pDSet->NameContextOffset =
+		    pDSet->TreeOffset + xplatCall.uTreeLength;
+		pDSet->uNameLength = xplatCall.uNameLength;
+
+//sgled      cpylen = copy_from_user(dPtr+pDSet->TreeOffset, xplatCall.pTreeName, xplatCall.uTreeLength);
+		cpylen = copy_from_user(dPtr + pDSet->TreeOffset, xplatCall.pDsTreeName, xplatCall.uTreeLength);	//sgled
+		cpylen =
+		    copy_from_user(dPtr + pDSet->NameContextOffset,
+				   xplatCall.pNameContext,
+				   xplatCall.uNameLength);
+
+		retCode =
+		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+					 (void **)&reply, &replylen,
+					 INTERRUPTIBLE);
+		if (reply) {
+			retCode = reply->Reply.ErrorCode;
+			kfree(reply);
+		}
+		kfree(cmd);
+	}
+	return (retCode);
+
+}
+
+/*++======================================================================*/
+int NwcGetDefaultNameCtx(PXPLAT pdata, session_t Session)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	PXPLAT_CALL_REQUEST cmd;
+	PXPLAT_CALL_REPLY reply;
+	NwcGetDefaultNameContext xplatCall;
+	PNwdCGetDefaultNameContext pGet;
+	char *dPtr;
+	int retCode = -ENOMEM;
+	unsigned long cmdlen, replylen, cpylen;
+
+	cpylen =
+	    copy_from_user(&xplatCall, pdata->reqData,
+			   sizeof(NwcGetDefaultNameContext));
+	cmdlen =
+	    sizeof(*cmd) + sizeof(NwdCGetDefaultNameContext) +
+	    xplatCall.uTreeLength;
+	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+
+	if (cmd) {
+		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+		cmd->Command.SequenceNumber = 0;
+		cmd->Command.SessionId = Session;
+		cmd->NwcCommand = NWC_GET_DEFAULT_NAME_CONTEXT;
+		cmd->dataLen =
+		    sizeof(NwdCGetDefaultNameContext) + xplatCall.uTreeLength;
+
+		pGet = (PNwdCGetDefaultNameContext) cmd->data;
+		dPtr = cmd->data;
+
+		pGet->TreeOffset = sizeof(NwdCGetDefaultNameContext);
+		pGet->uTreeLength = xplatCall.uTreeLength;
+
+//sgled      cpylen = copy_from_user( dPtr + pGet->TreeOffset, xplatCall.pTreeName, xplatCall.uTreeLength);
+		cpylen = copy_from_user(dPtr + pGet->TreeOffset, xplatCall.pDsTreeName, xplatCall.uTreeLength);	//sgled
+		dPtr[pGet->TreeOffset + pGet->uTreeLength] = 0;
+
+		retCode =
+		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+					 (void **)&reply, &replylen,
+					 INTERRUPTIBLE);
+		if (reply) {
+			retCode = reply->Reply.ErrorCode;
+			if (!retCode) {
+				pGet = (PNwdCGetDefaultNameContext) reply->data;
+
+				DbgPrint
+				    ("NwcGetDefaultNameCtx: retCode=0x%x uNameLength1=%d uNameLength2=%d\n",
+				     retCode, pGet->uNameLength,
+				     xplatCall.uNameLength);
+				if (xplatCall.uNameLength < pGet->uNameLength) {
+					pGet->uNameLength =
+					    xplatCall.uNameLength;
+					retCode = NWE_BUFFER_OVERFLOW;
+				}
+				dPtr = (char *)pGet + pGet->NameContextOffset;
+				cpylen =
+				    copy_to_user(xplatCall.pNameContext, dPtr,
+						 pGet->uNameLength);
+			}
+
+			kfree(reply);
+		}
+		kfree(cmd);
+	}
+	return (retCode);
+
+}
+
+int NwQueryFeature(PXPLAT pdata, session_t Session)
+{
+	NwcQueryFeature xpCall;
+	int status = 0;
+	unsigned long cpylen;
+
+	cpylen =
+	    copy_from_user(&xpCall, pdata->reqData, sizeof(NwcQueryFeature));
+	switch (xpCall.Feature) {
+	case NWC_FEAT_NDS:
+	case NWC_FEAT_NDS_MTREE:
+	case NWC_FEAT_PRN_CAPTURE:
+	case NWC_FEAT_NDS_RESOLVE:
+
+		status = NWE_REQUESTER_FAILURE;
+
+	}
+	return (status);
+}
+
+/*++======================================================================*/
+int NwcGetTreeMonitoredConn(PXPLAT pdata, session_t Session)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	PXPLAT_CALL_REQUEST cmd;
+	PXPLAT_CALL_REPLY reply;
+	NwcGetTreeMonitoredConnRef xplatCall, *p;
+	PNwdCGetTreeMonitoredConnRef pDConnRef;
+	char *dPtr;
+	unsigned long status = -ENOMEM, cmdlen, datalen, replylen, cpylen;
+
+	cpylen =
+	    copy_from_user(&xplatCall, pdata->reqData,
+			   sizeof(NwcGetTreeMonitoredConnRef));
+	datalen = sizeof(*pDConnRef) + xplatCall.pTreeName->DataLen;
+	cmdlen = datalen + sizeof(*cmd);
+	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+
+	if (cmd) {
+		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+		cmd->Command.SequenceNumber = 0;
+		cmd->Command.SessionId = Session;
+		cmd->NwcCommand = NWC_GET_TREE_MONITORED_CONN_REF;
+
+		pDConnRef = (PNwdCGetTreeMonitoredConnRef) cmd->data;
+		pDConnRef->TreeName.boffset = sizeof(*pDConnRef);
+		pDConnRef->TreeName.len = xplatCall.pTreeName->DataLen;
+		pDConnRef->TreeName.type = xplatCall.pTreeName->DataType;
+
+		dPtr = cmd->data + sizeof(*pDConnRef);
+		cpylen =
+		    copy_from_user(dPtr, xplatCall.pTreeName->pBuffer,
+				   pDConnRef->TreeName.len);
+		status =
+		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+					 (void **)&reply, &replylen,
+					 INTERRUPTIBLE);
+		if (reply) {
+			pDConnRef = (PNwdCGetTreeMonitoredConnRef) reply->data;
+			dPtr = reply->data + pDConnRef->TreeName.boffset;
+			p = (NwcGetTreeMonitoredConnRef *) pdata->reqData;
+			cpylen =
+			    copy_to_user(&p->uConnReference,
+					 &pDConnRef->uConnReference, 4);
+
+			status = reply->Reply.ErrorCode;
+			kfree(reply);
+		}
+		kfree(cmd);
+
+	}
+
+	return (status);
+}
+
+/*++======================================================================*/
+int NwcEnumIdentities(PXPLAT pdata, session_t Session)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract:
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	PXPLAT_CALL_REQUEST cmd;
+	PXPLAT_CALL_REPLY reply;
+	NwcEnumerateIdentities xplatCall, *eId;
+	PNwdCEnumerateIdentities pEnum;
+	NwcString xferStr;
+	char *str;
+	unsigned long status = -ENOMEM, cmdlen, datalen, replylen, cpylen;
+
+	cpylen =
+	    copy_from_user(&xplatCall, pdata->reqData,
+			   sizeof(NwcEnumerateIdentities));
+	datalen = sizeof(*pEnum);
+	cmdlen = datalen + sizeof(*cmd);
+	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+
+	if (cmd) {
+		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+		cmd->Command.SequenceNumber = 0;
+		cmd->Command.SessionId = Session;
+		cmd->NwcCommand = NWC_ENUMERATE_IDENTITIES;
+
+		DbgPrint("NwcEnumIdentities: Send Request\n");
+		DbgPrint("   iterator = %x\n", xplatCall.Iterator);
+		DbgPrint("   cmdlen = %d\n", cmdlen);
+
+		pEnum = (PNwdCEnumerateIdentities) cmd->data;
+		pEnum->Iterator = xplatCall.Iterator;
+		status =
+		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+					 (void **)&reply, &replylen,
+					 INTERRUPTIBLE);
+		if (reply) {
+			status = reply->Reply.ErrorCode;
+
+			eId = pdata->repData;
+			pEnum = (PNwdCEnumerateIdentities) reply->data;
+			cpylen =
+			    copy_to_user(&eId->Iterator, &pEnum->Iterator,
+					 sizeof(pEnum->Iterator));
+			DbgPrint("[XPLAT NWCAPI] Found AuthId 0x%X\n",
+				 pEnum->AuthenticationId);
+			cpylen =
+			    copy_to_user(&eId->AuthenticationId,
+					 &pEnum->AuthenticationId,
+					 sizeof(pEnum->AuthenticationId));
+			cpylen =
+			    copy_to_user(&eId->AuthType, &pEnum->AuthType,
+					 sizeof(pEnum->AuthType));
+			cpylen =
+			    copy_to_user(&eId->IdentityFlags,
+					 &pEnum->IdentityFlags,
+					 sizeof(pEnum->IdentityFlags));
+			cpylen =
+			    copy_to_user(&eId->NameType, &pEnum->NameType,
+					 sizeof(pEnum->NameType));
+			cpylen =
+			    copy_to_user(&eId->ObjectType, &pEnum->ObjectType,
+					 sizeof(pEnum->ObjectType));
+
+			if (!status) {
+				cpylen =
+				    copy_from_user(&xferStr, eId->pDomainName,
+						   sizeof(NwcString));
+				str =
+				    (char *)((char *)reply->data +
+					     pEnum->domainNameOffset);
+				DbgPrint("[XPLAT NWCAPI] Found Domain %s\n",
+					 str);
+				cpylen =
+				    copy_to_user(xferStr.pBuffer, str,
+						 pEnum->domainNameLen);
+				xferStr.DataType = NWC_STRING_TYPE_ASCII;
+				xferStr.DataLen = pEnum->domainNameLen - 1;
+				cpylen =
+				    copy_to_user(eId->pDomainName, &xferStr,
+						 sizeof(NwcString));
+
+				cpylen =
+				    copy_from_user(&xferStr, eId->pObjectName,
+						   sizeof(NwcString));
+				str =
+				    (char *)((char *)reply->data +
+					     pEnum->objectNameOffset);
+				DbgPrint("[XPLAT NWCAPI] Found User %s\n", str);
+				cpylen =
+				    copy_to_user(xferStr.pBuffer, str,
+						 pEnum->objectNameLen);
+				xferStr.DataType = NWC_STRING_TYPE_ASCII;
+				xferStr.DataLen = pEnum->objectNameLen - 1;
+				cpylen =
+				    copy_to_user(eId->pObjectName, &xferStr,
+						 sizeof(NwcString));
+			}
+
+			kfree(reply);
+
+		}
+		kfree(cmd);
+
+	}
+	return (status);
+}
+
+/*++======================================================================*/
+int NwcChangeAuthKey(PXPLAT pdata, session_t Session)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract: Change the password on the server
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	PXPLAT_CALL_REQUEST cmd;
+	PXPLAT_CALL_REPLY reply;
+	NwcChangeKey xplatCall;
+	PNwdCChangeKey pNewKey;
+	NwcString xferStr;
+	char *str;
+	unsigned long status = -ENOMEM, cmdlen, datalen, replylen, cpylen;
+
+	cpylen =
+	    copy_from_user(&xplatCall, pdata->reqData, sizeof(NwcChangeKey));
+
+	datalen =
+	    sizeof(NwdCChangeKey) + xplatCall.pDomainName->DataLen +
+	    xplatCall.pObjectName->DataLen + xplatCall.pNewPassword->DataLen +
+	    xplatCall.pVerifyPassword->DataLen;
+
+	cmdlen = sizeof(*cmd) + datalen;
+	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+
+	if (cmd) {
+		pNewKey = (PNwdCChangeKey) cmd->data;
+		cmd->dataLen = datalen;
+		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+		cmd->Command.SequenceNumber = 0;
+		cmd->Command.SessionId = Session;
+		cmd->NwcCommand = NWC_CHANGE_KEY;
+
+		pNewKey->NameType = xplatCall.NameType;
+		pNewKey->ObjectType = xplatCall.ObjectType;
+		pNewKey->AuthType = xplatCall.AuthType;
+		str = (char *)pNewKey;
+
+		/*
+		 * Get the tree name
+		 */
+		str += sizeof(*pNewKey);
+		cpylen =
+		    copy_from_user(&xferStr, xplatCall.pDomainName,
+				   sizeof(NwcString));
+		pNewKey->domainNameOffset = sizeof(*pNewKey);
+		cpylen = copy_from_user(str, xferStr.pBuffer, xferStr.DataLen);
+		pNewKey->domainNameLen = xferStr.DataLen;
+
+		/*
+		 * Get the User Name
+		 */
+		str += pNewKey->domainNameLen;
+		cpylen =
+		    copy_from_user(&xferStr, xplatCall.pObjectName,
+				   sizeof(NwcString));
+		pNewKey->objectNameOffset =
+		    pNewKey->domainNameOffset + pNewKey->domainNameLen;
+		cpylen = copy_from_user(str, xferStr.pBuffer, xferStr.DataLen);
+		pNewKey->objectNameLen = xferStr.DataLen;
+
+		/*
+		 * Get the New Password
+		 */
+		str += pNewKey->objectNameLen;
+		cpylen =
+		    copy_from_user(&xferStr, xplatCall.pNewPassword,
+				   sizeof(NwcString));
+		pNewKey->newPasswordOffset =
+		    pNewKey->objectNameOffset + pNewKey->objectNameLen;
+		cpylen = copy_from_user(str, xferStr.pBuffer, xferStr.DataLen);
+		pNewKey->newPasswordLen = xferStr.DataLen;
+
+		/*
+		 * Get the Verify Password
+		 */
+		str += pNewKey->newPasswordLen;
+		cpylen =
+		    copy_from_user(&xferStr, xplatCall.pVerifyPassword,
+				   sizeof(NwcString));
+		pNewKey->verifyPasswordOffset =
+		    pNewKey->newPasswordOffset + pNewKey->newPasswordLen;
+		cpylen = copy_from_user(str, xferStr.pBuffer, xferStr.DataLen);
+		pNewKey->verifyPasswordLen = xferStr.DataLen;
+
+		status =
+		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+					 (void **)&reply, &replylen,
+					 INTERRUPTIBLE);
+		if (reply) {
+			status = reply->Reply.ErrorCode;
+			kfree(reply);
+		}
+		memset(cmd, 0, cmdlen);
+
+		kfree(cmd);
+	}
+
+	return (status);
+}
+
+/*++======================================================================*/
+int NwcSetPrimaryConn(PXPLAT pdata, session_t Session)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract: Set the primary connection Id
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	PXPLAT_CALL_REQUEST cmd;
+	PXPLAT_CALL_REPLY reply;
+	NwcSetPrimaryConnection xplatCall;
+	PNwdCSetPrimaryConnection pConn;
+	unsigned long status = -ENOMEM, cmdlen, datalen, replylen, cpylen;
+
+	cpylen =
+	    copy_from_user(&xplatCall, pdata->reqData,
+			   sizeof(NwcSetPrimaryConnection));
+
+	datalen = sizeof(NwdCSetPrimaryConnection);
+	cmdlen = sizeof(*cmd) + datalen;
+	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	if (cmd) {
+		pConn = (PNwdCSetPrimaryConnection) cmd->data;
+		cmd->dataLen = datalen;
+		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+		cmd->Command.SequenceNumber = 0;
+		cmd->Command.SessionId = Session;
+		cmd->NwcCommand = NWC_SET_PRIMARY_CONN;
+		pConn->ConnHandle = (HANDLE) (unsigned long) xplatCall.ConnHandle;
+		status =
+		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+					 (void **)&reply, &replylen,
+					 INTERRUPTIBLE);
+
+		if (reply) {
+			status = reply->Reply.ErrorCode;
+			kfree(reply);
+		}
+
+		kfree(cmd);
+	}
+
+	return (status);
+}
+
+/*++======================================================================*/
+int NwcGetPrimaryConn(PXPLAT pdata, session_t Session)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract: Get the Primary connection
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	XPLAT_CALL_REQUEST cmd;
+	PXPLAT_CALL_REPLY reply;
+	unsigned long status = -ENOMEM, cmdlen, replylen, cpylen;
+
+	cmdlen = (unsigned long) (&((PXPLAT_CALL_REQUEST) 0)->data);
+
+	cmd.dataLen = 0;
+	cmd.Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+	cmd.Command.SequenceNumber = 0;
+	cmd.Command.SessionId = Session;
+	cmd.NwcCommand = NWC_GET_PRIMARY_CONN;
+
+	status =
+	    Queue_Daemon_Command((void *)&cmd, cmdlen, NULL, 0, (void **)&reply,
+				 &replylen, INTERRUPTIBLE);
+
+	if (reply) {
+		status = reply->Reply.ErrorCode;
+		if (!status) {
+			cpylen =
+			    copy_to_user(pdata->repData, reply->data,
+					 sizeof(unsigned long));
+		}
+
+		kfree(reply);
+	}
+
+	return (status);
+}
+
+/*++======================================================================*/
+int NwcSetMapDrive(PXPLAT pdata, session_t Session)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract: Get the Primary connection
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+
+	PXPLAT_CALL_REQUEST cmd;
+	PXPLAT_CALL_REPLY reply;
+	unsigned long status = 0, datalen, cmdlen, replylen, cpylen;
+	NwcMapDriveEx symInfo;
+
+	DbgPrint("Call to NwcSetMapDrive\n");
+	cpylen = copy_from_user(&symInfo, pdata->reqData, sizeof(symInfo));
+	cmdlen = sizeof(*cmd);
+	datalen =
+	    sizeof(symInfo) + symInfo.dirPathOffsetLength +
+	    symInfo.linkOffsetLength;
+
+	DbgPrint(" cmdlen = %d\n", cmdlen);
+	DbgPrint(" dataLen = %d\n", datalen);
+	DbgPrint(" symInfo.dirPathOffsetLength = %d\n",
+		 symInfo.dirPathOffsetLength);
+	DbgPrint(" symInfo.linkOffsetLength = %d\n", symInfo.linkOffsetLength);
+	DbgPrint(" pdata->datalen = %d\n", pdata->reqLen);
+
+	mydump(sizeof(symInfo), &symInfo);
+
+	cmdlen += datalen;
+
+	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	if (cmd) {
+		cmd->dataLen = datalen;
+		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+		cmd->Command.SequenceNumber = 0;
+		cmd->Command.SessionId = Session;
+		cmd->NwcCommand = NWC_MAP_DRIVE;
+
+		cpylen = copy_from_user(cmd->data, pdata->reqData, datalen);
+		status =
+		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+					 (void **)&reply, &replylen,
+					 INTERRUPTIBLE);
+
+		if (reply) {
+			status = reply->Reply.ErrorCode;
+			kfree(reply);
+		}
+		kfree(cmd);
+	}
+	return (status);
+
+}
+
+/*++======================================================================*/
+int NwcUnMapDrive(PXPLAT pdata, session_t Session)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract: Get the Primary connection
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	PXPLAT_CALL_REQUEST cmd;
+	PXPLAT_CALL_REPLY reply;
+	unsigned long status = 0, datalen, cmdlen, replylen, cpylen;
+	NwcUnmapDriveEx symInfo;
+
+	DbgPrint("Call to NwcUnMapDrive\n");
+
+	cpylen = copy_from_user(&symInfo, pdata->reqData, sizeof(symInfo));
+	cmdlen = sizeof(*cmd);
+	datalen = sizeof(symInfo) + symInfo.linkLen;
+
+	cmdlen += datalen;
+	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	if (cmd) {
+		cmd->dataLen = datalen;
+		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+		cmd->Command.SequenceNumber = 0;
+		cmd->Command.SessionId = Session;
+		cmd->NwcCommand = NWC_UNMAP_DRIVE;
+
+		cpylen = copy_from_user(cmd->data, pdata->reqData, datalen);
+		status =
+		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+					 (void **)&reply, &replylen,
+					 INTERRUPTIBLE);
+
+		if (reply) {
+			status = reply->Reply.ErrorCode;
+			kfree(reply);
+		}
+		kfree(cmd);
+	}
+
+	return (status);
+}
+
+/*++======================================================================*/
+int NwcEnumerateDrives(PXPLAT pdata, session_t Session)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract: Get the Primary connection
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	PXPLAT_CALL_REQUEST cmd;
+	PXPLAT_CALL_REPLY reply;
+	unsigned long status = 0, cmdlen, replylen, cpylen;
+	unsigned long offset;
+	char *cp;
+
+	DbgPrint("Call to NwcEnumerateDrives\n");
+
+	cmdlen = sizeof(*cmd);
+	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	if (cmd) {
+		cmd->dataLen = 0;
+		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+		cmd->Command.SequenceNumber = 0;
+		cmd->Command.SessionId = Session;
+		cmd->NwcCommand = NWC_ENUMERATE_DRIVES;
+		status =
+		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+					 (void **)&reply, &replylen,
+					 INTERRUPTIBLE);
+
+		if (reply) {
+			status = reply->Reply.ErrorCode;
+			DbgPrint("Status Code = 0x%X\n", status);
+			if (!status) {
+				offset =
+				    sizeof(((PNwcGetMappedDrives) pdata->
+					    repData)->MapBuffLen);
+				cp = reply->data;
+				replylen =
+				    ((PNwcGetMappedDrives) pdata->repData)->
+				    MapBuffLen;
+				cpylen =
+				    copy_to_user(pdata->repData, cp, offset);
+				cp += offset;
+				cpylen =
+				    copy_to_user(((PNwcGetMappedDrives) pdata->
+						  repData)->MapBuffer, cp,
+						 min(replylen - offset,
+						     reply->dataLen - offset));
+			}
+
+			kfree(reply);
+		}
+		kfree(cmd);
+	}
+
+	return (status);
+}
+
+/*++======================================================================*/
+int NwcGetBroadcastMessage(PXPLAT pdata, session_t Session)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract: Get the Primary connection
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	PXPLAT_CALL_REQUEST cmd;
+	PXPLAT_CALL_REPLY reply;
+	unsigned long cmdlen, replylen;
+	int status = 0x8866, cpylen;
+	NwcGetBroadcastNotification msg;
+	PNwdCGetBroadcastNotification dmsg;
+
+	cmdlen = sizeof(*cmd) + sizeof(*dmsg);
+	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	if (cmd) {
+
+		cpylen = copy_from_user(&msg, pdata->reqData, sizeof(msg));
+		cmd->dataLen = sizeof(*dmsg);
+		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+		cmd->Command.SequenceNumber = 0;
+		cmd->Command.SessionId = Session;
+
+		cmd->NwcCommand = NWC_GET_BROADCAST_MESSAGE;
+		dmsg = (PNwdCGetBroadcastNotification) cmd->data;
+		dmsg->uConnReference = (HANDLE) (unsigned long) msg.uConnReference;
+
+		status =
+		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+					 (void **)&reply, &replylen,
+					 INTERRUPTIBLE);
+
+		if (reply) {
+			status = reply->Reply.ErrorCode;
+
+			if (!status) {
+				char *cp = pdata->repData;
+
+				dmsg =
+				    (PNwdCGetBroadcastNotification) reply->data;
+				if (pdata->repLen < dmsg->messageLen) {
+					dmsg->messageLen = pdata->repLen;
+				}
+				msg.messageLen = dmsg->messageLen;
+				cpylen = offsetof(NwcGetBroadcastNotification, message);
+				cp += cpylen;
+				cpylen = copy_to_user(pdata->repData, &msg, cpylen);
+				cpylen = copy_to_user(cp, dmsg->message, msg.messageLen);
+			} else {
+				msg.messageLen = 0;
+				msg.message[0] = 0;
+				cpylen = offsetof(NwcGetBroadcastNotification, message);
+				cpylen = copy_to_user(pdata->repData, &msg, sizeof(msg));
+			}
+
+			kfree(reply);
+		}
+		kfree(cmd);
+	}
+	return (status);
+}
+
+int NwdSetKeyValue(PXPLAT pdata, session_t Session)
+{
+	PXPLAT_CALL_REQUEST cmd;
+	PXPLAT_CALL_REPLY reply;
+	NwcSetKey xplatCall;
+	PNwdCSetKey pNewKey;
+	NwcString cstrObjectName, cstrPassword;
+	char *str;
+	unsigned long status = -ENOMEM, cmdlen, datalen, replylen, cpylen;
+
+	cpylen = copy_from_user(&xplatCall, pdata->reqData, sizeof(NwcSetKey));
+	cpylen =
+	    copy_from_user(&cstrObjectName, xplatCall.pObjectName,
+			   sizeof(NwcString));
+	cpylen =
+	    copy_from_user(&cstrPassword, xplatCall.pNewPassword,
+			   sizeof(NwcString));
+
+	datalen =
+	    sizeof(NwdCSetKey) + cstrObjectName.DataLen + cstrPassword.DataLen;
+
+	cmdlen = sizeof(*cmd) + datalen;
+	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+
+	if (cmd) {
+		pNewKey = (PNwdCSetKey) cmd->data;
+		cmd->dataLen = datalen;
+		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+		cmd->Command.SequenceNumber = 0;
+		cmd->Command.SessionId = Session;
+		cmd->NwcCommand = NWC_SET_KEY;
+
+		pNewKey->ObjectType = xplatCall.ObjectType;
+		pNewKey->AuthenticationId = xplatCall.AuthenticationId;
+		pNewKey->ConnHandle = (HANDLE) (unsigned long) xplatCall.ConnHandle;
+		str = (char *)pNewKey;
+
+		/*
+		 * Get the User Name
+		 */
+		str += sizeof(NwdCSetKey);
+		cpylen =
+		    copy_from_user(str, cstrObjectName.pBuffer,
+				   cstrObjectName.DataLen);
+
+		str += pNewKey->objectNameLen = cstrObjectName.DataLen;
+		pNewKey->objectNameOffset = sizeof(NwdCSetKey);
+
+		/*
+		 * Get the Verify Password
+		 */
+		cpylen =
+		    copy_from_user(str, cstrPassword.pBuffer,
+				   cstrPassword.DataLen);
+
+		pNewKey->newPasswordLen = cstrPassword.DataLen;
+		pNewKey->newPasswordOffset =
+		    pNewKey->objectNameOffset + pNewKey->objectNameLen;
+
+		status =
+		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+					 (void **)&reply, &replylen,
+					 INTERRUPTIBLE);
+		if (reply) {
+			status = reply->Reply.ErrorCode;
+			kfree(reply);
+		}
+		memset(cmd, 0, cmdlen);
+		kfree(cmd);
+	}
+
+	return (status);
+}
+
+/*++======================================================================*/
+int NwdVerifyKeyValue(PXPLAT pdata, session_t Session)
+/*
+ *  Arguments:
+ *
+ *  Returns:
+ *
+ *  Abstract: Change the password on the server
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	PXPLAT_CALL_REQUEST cmd;
+	PXPLAT_CALL_REPLY reply;
+	NwcVerifyKey xplatCall;
+	PNwdCVerifyKey pNewKey;
+	NwcString xferStr;
+	char *str;
+	unsigned long status = -ENOMEM, cmdlen, datalen, replylen, cpylen;
+
+	cpylen =
+	    copy_from_user(&xplatCall, pdata->reqData, sizeof(NwcVerifyKey));
+
+	datalen =
+	    sizeof(NwdCVerifyKey) + xplatCall.pDomainName->DataLen +
+	    xplatCall.pObjectName->DataLen + xplatCall.pVerifyPassword->DataLen;
+
+	cmdlen = sizeof(*cmd) + datalen;
+	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+
+	if (cmd) {
+		pNewKey = (PNwdCVerifyKey) cmd->data;
+		cmd->dataLen = datalen;
+		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+		cmd->Command.SequenceNumber = 0;
+		cmd->Command.SessionId = Session;
+		cmd->NwcCommand = NWC_VERIFY_KEY;
+
+		pNewKey->NameType = xplatCall.NameType;
+		pNewKey->ObjectType = xplatCall.ObjectType;
+		pNewKey->AuthType = xplatCall.AuthType;
+		str = (char *)pNewKey;
+
+		/*
+		 * Get the tree name
+		 */
+		str += sizeof(*pNewKey);
+		cpylen =
+		    copy_from_user(&xferStr, xplatCall.pDomainName,
+				   sizeof(NwcString));
+		pNewKey->domainNameOffset = sizeof(*pNewKey);
+		cpylen = copy_from_user(str, xferStr.pBuffer, xferStr.DataLen);
+		pNewKey->domainNameLen = xferStr.DataLen;
+
+		/*
+		 * Get the User Name
+		 */
+		str += pNewKey->domainNameLen;
+		cpylen =
+		    copy_from_user(&xferStr, xplatCall.pObjectName,
+				   sizeof(NwcString));
+		pNewKey->objectNameOffset =
+		    pNewKey->domainNameOffset + pNewKey->domainNameLen;
+		cpylen = copy_from_user(str, xferStr.pBuffer, xferStr.DataLen);
+		pNewKey->objectNameLen = xferStr.DataLen;
+
+		/*
+		 * Get the Verify Password
+		 */
+		str += pNewKey->objectNameLen;
+		cpylen =
+		    copy_from_user(&xferStr, xplatCall.pVerifyPassword,
+				   sizeof(NwcString));
+		pNewKey->verifyPasswordOffset =
+		    pNewKey->objectNameOffset + pNewKey->objectNameLen;
+		cpylen = copy_from_user(str, xferStr.pBuffer, xferStr.DataLen);
+		pNewKey->verifyPasswordLen = xferStr.DataLen;
+
+		status =
+		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+					 (void **)&reply, &replylen,
+					 INTERRUPTIBLE);
+		if (reply) {
+			status = reply->Reply.ErrorCode;
+			kfree(reply);
+		}
+		memset(cmd, 0, cmdlen);
+		kfree(cmd);
+	}
+
+	return (status);
+}
--- /dev/null
+++ b/fs/novfs/nwcapi.h
@@ -0,0 +1,2213 @@
+/*
+ * NetWare Redirector for Linux
+ * Author: Sheffer Clark
+ *
+ * This file contains all typedefs and constants for the NetWare Client APIs.
+ *
+ * Copyright (C) 2005 Novell, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+#ifndef __NWCLNX_H__
+#define __NWCLNX_H__
+
+#if 0                          //sgled hack
+#else //sgled hack (up to endif)
+
+#define NW_MAX_TREE_NAME_LEN              33
+#define NW_MAX_SERVICE_TYPE_LEN           49
+/* Transport Type - (nuint32 value) */
+#define NWC_TRAN_TYPE_IPX                 0x0001
+#define NWC_TRAN_TYPE_DDP                 0x0003
+#define NWC_TRAN_TYPE_ASP                 0x0004
+#define NWC_TRAN_TYPE_UDP                 0x0008
+#define NWC_TRAN_TYPE_TCP                 0x0009
+#define NWC_TRAN_TYPE_UDP6                0x000A
+#define NWC_TRAN_TYPE_TCP6                0x000B
+#define NWC_TRAN_TYPE_WILD                0x8000
+
+//
+// DeviceIoControl requests for the NetWare Redirector
+//
+// Macro definition for defining DeviceIoControl function control codes.
+// The function codes 0 - 2047 are reserved for Microsoft.
+// Function codes 2048 - 4096 are reserved for customers.
+// The NetWare Redirector will use codes beginning at 3600.
+//
+// METHOD_NEITHER User buffers will be passed directly from the application
+// to the file system.  The redirector is responsible for either probing
+// and locking the buffers or using a try - except around access of the
+// buffers.
+
+#define  BASE_REQ_NUM                  0x4a541000
+
+// Connection functions
+#define  NWC_OPEN_CONN_BY_NAME         (BASE_REQ_NUM + 0)
+#define  NWC_OPEN_CONN_BY_ADDRESS      (BASE_REQ_NUM + 1)
+#define  NWC_OPEN_CONN_BY_REFERENCE    (BASE_REQ_NUM + 2)
+#define  NWC_CLOSE_CONN                (BASE_REQ_NUM + 3)
+#define  NWC_SYS_CLOSE_CONN            (BASE_REQ_NUM + 4)
+#define  NWC_GET_CONN_INFO             (BASE_REQ_NUM + 5)
+#define  NWC_SET_CONN_INFO             (BASE_REQ_NUM + 6)
+#define  NWC_SCAN_CONN_INFO            (BASE_REQ_NUM + 7)
+#define  NWC_MAKE_CONN_PERMANENT       (BASE_REQ_NUM + 8)
+#define  NWC_LICENSE_CONN              (BASE_REQ_NUM + 9)
+#define  NWC_UNLICENSE_CONN            (BASE_REQ_NUM + 10)
+#define  NWC_GET_NUM_CONNS             (BASE_REQ_NUM + 11)
+#define  NWC_GET_PREFERRED_SERVER      (BASE_REQ_NUM + 12)
+#define  NWC_SET_PREFERRED_SERVER      (BASE_REQ_NUM + 13)
+#define  NWC_GET_PRIMARY_CONN          (BASE_REQ_NUM + 14)
+#define  NWC_SET_PRIMARY_CONN          (BASE_REQ_NUM + 15)
+
+// Authentication functions
+#define  NWC_CHANGE_KEY                (BASE_REQ_NUM + 20)
+#define  NWC_ENUMERATE_IDENTITIES      (BASE_REQ_NUM + 21)
+#define  NWC_GET_IDENTITY_INFO         (BASE_REQ_NUM + 22)
+#define  NWC_LOGIN_IDENTITY            (BASE_REQ_NUM + 23)
+#define  NWC_LOGOUT_IDENTITY           (BASE_REQ_NUM + 24)
+#define  NWC_SET_KEY                   (BASE_REQ_NUM + 25)
+#define  NWC_VERIFY_KEY                (BASE_REQ_NUM + 26)
+#define  NWC_AUTHENTICATE_CONN_WITH_ID (BASE_REQ_NUM + 27)
+#define  NWC_UNAUTHENTICATE_CONN       (BASE_REQ_NUM + 28)
+
+// Directory Services functions
+#define  NWC_GET_DEFAULT_NAME_CONTEXT  (BASE_REQ_NUM + 30)
+#define  NWC_SET_DEFAULT_NAME_CONTEXT  (BASE_REQ_NUM + 31)
+#define  NWC_GET_PREFERRED_DS_TREE     (BASE_REQ_NUM + 32)
+#define  NWC_SET_PREFERRED_DS_TREE     (BASE_REQ_NUM + 33)
+#define  NWC_GET_TREE_MONITORED_CONN_REF  (BASE_REQ_NUM + 34)
+#define  NWC_NDS_RESOLVE_NAME_TO_ID    (BASE_REQ_NUM + 35)
+
+// NCP Request functions
+#define  NWC_FRAGMENT_REQUEST          (BASE_REQ_NUM + 40)
+#define  NWC_NCP_ORDERED_REQUEST_ALL   (BASE_REQ_NUM + 41)
+#define  NWC_RAW_NCP_REQUEST           (BASE_REQ_NUM + 42)
+#define  NWC_RAW_NCP_REQUEST_ALL       (BASE_REQ_NUM + 43)
+
+// File Handle Conversion functions
+#define  NWC_CONVERT_LOCAL_HANDLE      (BASE_REQ_NUM + 50)
+#define  NWC_CONVERT_NETWARE_HANDLE    (BASE_REQ_NUM + 51)
+
+// Misc. functions
+#define  NWC_MAP_DRIVE                 (BASE_REQ_NUM + 60)
+#define  NWC_UNMAP_DRIVE               (BASE_REQ_NUM + 61)
+#define  NWC_ENUMERATE_DRIVES          (BASE_REQ_NUM + 62)
+
+#define  NWC_GET_REQUESTER_VERSION     (BASE_REQ_NUM + 63)
+#define  NWC_QUERY_FEATURE             (BASE_REQ_NUM + 64)
+
+#define  NWC_GET_CONFIGURED_NSPS       (BASE_REQ_NUM + 65)
+
+#define  NWC_GET_MOUNT_PATH            (BASE_REQ_NUM + 66)
+
+#define  NWC_GET_BROADCAST_MESSAGE     (BASE_REQ_NUM + 67)
+
+#endif //sgled hack -------------------------------
+
+#define IOC_XPLAT    0x4a540002
+
+typedef struct _XPLAT_ {
+	int xfunction;
+	unsigned long reqLen;
+	void *reqData;
+	unsigned long repLen;
+	void *repData;
+
+} XPLAT, *PXPLAT;
+
+#if 0
+N_EXTERN_LIBRARY(NWRCODE)
+    NWCLnxReq
+    (nuint32 request, nptr pInBuf, nuint32 inLen, nptr pOutBuf, nuint32 outLen);
+#endif
+//
+// Network Name Format Type
+//
+
+#define  NWC_NAME_FORMAT_NDS              0x0001
+#define  NWC_NAME_FORMAT_BIND             0x0002
+#define  NWC_NAME_FORMAT_BDP              0x0004
+#define  NWC_NAME_FORMAT_NDS_TREE         0x0008
+#define  NWC_NAME_FORMAT_WILD             0x8000
+
+//
+// API String Types
+//
+
+#define  NWC_STRING_TYPE_ASCII            0x0001	// multi-byte, not really ascii
+#define  NWC_STRING_TYPE_UNICODE          0x0002
+#define  NWC_STRING_TYPE_UTF8             0x0003
+
+//
+// Open Connection Flags
+//
+
+#define  NWC_OPEN_LICENSED                0x0001
+#define  NWC_OPEN_UNLICENSED              0x0002
+#define  NWC_OPEN_PRIVATE                 0x0004
+#define  NWC_OPEN_PUBLIC                  0x0008
+#define  NWC_OPEN_EXISTING_HANDLE         0x0010
+#define  NWC_OPEN_NO_HANDLE               0x0020
+#define  NWC_OPEN_PERMANENT               0x0040
+#define  NWC_OPEN_DISCONNECTED            0x0080
+#define  NWC_OPEN_NEAREST                 0x0100
+#define  NWC_OPEN_IGNORE_CACHE            0x0200
+
+//
+// Close Connection Flags
+//
+
+#define  NWC_CLOSE_TEMPORARY              0x0000
+#define  NWC_CLOSE_PERMANENT              0x0001
+
+//
+// Connection Information Levels
+//
+
+#define  NWC_CONN_INFO_RETURN_ALL            0xFFFF
+#define  NWC_CONN_INFO_RETURN_NONE           0x0000
+#define  NWC_CONN_INFO_VERSION               0x0001
+#define  NWC_CONN_INFO_AUTH_STATE            0x0002
+#define  NWC_CONN_INFO_BCAST_STATE           0x0003
+#define  NWC_CONN_INFO_CONN_REF              0x0004
+#define  NWC_CONN_INFO_TREE_NAME             0x0005
+#define  NWC_CONN_INFO_WORKGROUP_ID          0x0006
+#define  NWC_CONN_INFO_SECURITY_STATE        0x0007
+#define  NWC_CONN_INFO_CONN_NUMBER           0x0008
+#define  NWC_CONN_INFO_USER_ID               0x0009
+#define  NWC_CONN_INFO_SERVER_NAME           0x000A
+#define  NWC_CONN_INFO_TRAN_ADDR             0x000B
+#define  NWC_CONN_INFO_NDS_STATE             0x000C
+#define  NWC_CONN_INFO_MAX_PACKET_SIZE       0x000D
+#define  NWC_CONN_INFO_LICENSE_STATE         0x000E
+#define  NWC_CONN_INFO_PUBLIC_STATE          0x000F
+#define  NWC_CONN_INFO_SERVICE_TYPE          0x0010
+#define  NWC_CONN_INFO_DISTANCE              0x0011
+#define  NWC_CONN_INFO_SERVER_VERSION        0x0012
+#define  NWC_CONN_INFO_AUTH_ID               0x0013
+#define  NWC_CONN_INFO_SUSPENDED             0x0014
+#define  NWC_CONN_INFO_TREE_NAME_UNICODE     0x0015
+#define  NWC_CONN_INFO_SERVER_NAME_UNICODE   0x0016
+#define  NWC_CONN_INFO_LOCAL_TRAN_ADDR       0x0017
+#define  NWC_CONN_INFO_ALTERNATE_ADDR        0x0018
+#define  NWC_CONN_INFO_SERVER_GUID           0x0019
+
+#define  NWC_CONN_INFO_MAX_LEVEL             0x0014
+
+//
+// Information Versions
+//
+
+#define  NWC_INFO_VERSION_1               0x0001
+#define  NWC_INFO_VERSION_2               0x0002
+
+//
+// Authentication State
+//
+
+#define  NWC_AUTH_TYPE_NONE               0x0000
+#define  NWC_AUTH_TYPE_BINDERY            0x0001
+#define  NWC_AUTH_TYPE_NDS                0x0002
+#define  NWC_AUTH_TYPE_PNW                0x0003
+
+#define  NWC_AUTH_STATE_NONE              0x0000
+#define  NWC_AUTH_STATE_BINDERY           0x0001
+#define  NWC_AUTH_STATE_NDS               0x0002
+#define  NWC_AUTH_STATE_PNW               0x0003
+
+//
+// Authentication Flags
+//
+
+#define  NWC_AUTH_PRIVATE                 0x00000004
+#define  NWC_AUTH_PUBLIC                  0x00000008
+
+//
+// Broadcast State
+//
+
+#define  NWC_BCAST_PERMIT_ALL             0x0000
+#define  NWC_BCAST_PERMIT_SYSTEM          0x0001
+#define  NWC_BCAST_PERMIT_NONE            0x0002
+#define  NWC_BCAST_PERMIT_SYSTEM_POLLED   0x0003
+#define  NWC_BCAST_PERMIT_ALL_POLLED      0x0004
+
+//
+// Broadcast State
+//
+
+#define  NWC_NDS_NOT_CAPABLE              0x0000
+#define  NWC_NDS_CAPABLE                  0x0001
+
+//
+// License State
+//
+
+#define  NWC_NOT_LICENSED                 0x0000
+#define  NWC_CONNECTION_LICENSED          0x0001
+#define  NWC_HANDLE_LICENSED              0x0002
+
+//
+// Public State
+//
+
+#define  NWC_CONN_PUBLIC                  0x0000
+#define  NWC_CONN_PRIVATE                 0x0001
+
+//
+// Scan Connection Information Flags used
+// for finding connections by specific criteria
+//
+
+#define  NWC_MATCH_NOT_EQUALS             0x0000
+#define  NWC_MATCH_EQUALS                 0x0001
+#define  NWC_RETURN_PUBLIC                0x0002
+#define  NWC_RETURN_PRIVATE               0x0004
+#define  NWC_RETURN_LICENSED              0x0008
+#define  NWC_RETURN_UNLICENSED            0x0010
+
+//
+// Authentication Types
+//
+
+#define  NWC_AUTHENT_BIND                 0x0001
+#define  NWC_AUTHENT_NDS                  0x0002
+#define  NWC_AUTHENT_PNW                  0x0003
+
+//
+// Disconnected info
+//
+
+#define  NWC_SUSPENDED                    0x0001
+
+//
+// Maximum object lengths
+//
+
+#define  MAX_DEVICE_LENGTH                16
+#define  MAX_NETWORK_NAME_LENGTH          1024
+#define  MAX_OBJECT_NAME_LENGTH           48
+#define  MAX_PASSWORD_LENGTH              128
+#define  MAX_SERVER_NAME_LENGTH           48
+#define  MAX_SERVICE_TYPE_LENGTH          48
+#define  MAX_TREE_NAME_LENGTH             32
+#define  MAX_ADDRESS_LENGTH               32
+#define  MAX_NAME_SERVICE_PROVIDERS       10
+
+//
+// Flags for the GetBroadcastMessage API
+//
+
+#define  MESSAGE_GET_NEXT_MESSAGE         1
+#define  MESSAGE_RECEIVED_FOR_CONNECTION  2
+
+//
+// This constant must always be equal to the last device
+//
+
+#define  DEVICE_LAST_DEVICE               0x00000003
+
+//
+// Defined feature set provided by requester
+//
+
+#ifndef  NWC_FEAT_PRIV_CONN
+#define  NWC_FEAT_PRIV_CONN               1
+#define  NWC_FEAT_REQ_AUTH                2
+#define  NWC_FEAT_SECURITY                3
+#define  NWC_FEAT_NDS                     4
+#define  NWC_FEAT_NDS_MTREE               5
+#define  NWC_FEAT_PRN_CAPTURE             6
+#define  NWC_FEAT_NDS_RESOLVE             7
+#endif
+
+//===[ Type definitions ]==================================================
+
+//
+// Connection Handle returned from all OpenConnByXXXX calls
+//
+
+typedef u32 NW_CONN_HANDLE, *PNW_CONN_HANDLE;
+
+//
+// Authentication Id returned from the NwcCreateAuthenticationId call
+//
+
+typedef u32 AUTHEN_ID, *PAUTHEN_ID;
+
+//
+// Structure for defining what a transport
+// address looks like
+//
+
+typedef struct tagNwcTranAddr {
+	u32 uTransportType;
+	u32 uAddressLength;
+	unsigned char *puAddress;
+
+} NwcTranAddr, *PNwcTranAddr;
+
+//
+// Structure for defining what a new transport
+// address looks like
+//
+
+typedef struct tagNwcTranAddrEx {
+	u32 uTransportType;
+	u32 uAddressLength;
+	unsigned char buBuffer[MAX_ADDRESS_LENGTH];
+
+} NwcTranAddrEx, *PNwcTranAddrEx;
+
+typedef struct tagNwcReferral {
+	u32 uAddrCnt;
+	PNwcTranAddrEx pAddrs;
+
+} NwcReferral, *PNwcReferral;
+
+typedef struct tagNwcServerVersion {
+	u32 uMajorVersion;
+	u16 uMinorVersion;
+	u16 uRevision;
+
+} NwcServerVersion, *PNwcServerVersion;
+
+typedef struct tagNwcConnString {
+	char *pString;
+	u32 uStringType;
+	u32 uNameFormatType;
+
+} NwcConnString, *PNwcConnString;
+
+//#if defined(NTYPES_H)
+//typedef NWCString    NwcString, *PNwcString;
+//#else
+typedef struct tagNwcString {
+	u32 DataType;
+	u32 BuffSize;
+	u32 DataLen;
+	void *pBuffer;
+	u32 CodePage;
+	u32 CountryCode;
+
+} NwcString, *PNwcString;
+//#endif
+
+//
+// Structure used in NDS Resolve name
+//
+
+#define  RESOLVE_INFO_SVC_V1_00     0x00FE0001
+
+typedef struct tagNwcResolveInfo {
+	u32 uResolveInfoVersion;
+	u32 luFlags;
+	u32 luReqFlags;
+	u32 luReqScope;
+	u32 luResolveType;
+	u32 luRepFlags;
+	u32 luResolvedOffset;
+	u32 luDerefNameLen;
+	u16 *pDerefName;
+} NwcResolveInfo, *PNwcResolveInfo;
+
+//
+// Definition of a fragment for the Raw NCP requests
+//
+
+typedef struct tagNwcFrag {
+	void *pData;
+	u32 uLength;
+
+} NwcFrag, *PNwcFrag;
+
+//
+// Current connection information available for
+// enumeration using GetConnInfo and ScanConnInfo
+//
+
+#define NW_INFO_BUFFER_SIZE   NW_MAX_TREE_NAME_LEN + \
+                              NW_MAX_TREE_NAME_LEN + \
+                              NW_MAX_SERVICE_TYPE_LEN
+
+typedef struct tagNwcConnInfo {
+	u32 uInfoVersion;
+	u32 uAuthenticationState;
+	u32 uBroadcastState;
+	u32 uConnectionReference;
+	u32 TreeNameOffset;
+	u32 uSecurityState;
+	u32 uConnectionNumber;
+	u32 uUserId;
+	u32 ServerNameOffset;
+	u32 uNdsState;
+	u32 uMaxPacketSize;
+	u32 uLicenseState;
+	u32 uPublicState;
+	u32 bcastState;
+	u32 ServiceTypeOffset;
+	u32 uDistance;
+	u32 uAuthId;
+	u32 uDisconnected;
+	NwcServerVersion serverVersion;
+	NwcTranAddrEx tranAddress;
+	unsigned char buBuffer[NW_INFO_BUFFER_SIZE];
+
+} NwcConnInfo, *PNwcConnInfo;
+
+//
+// Get Browse Connection References
+//
+
+typedef struct _GetBrowseConnectionsRec {
+
+	u32 recordSize;
+	u32 numConnectionsReturned;
+	u32 numConnectionsAvailable;
+	u32 connReferences[1];
+
+} GetBrowseConnectionRec, *PGetBrowseConnectionRec;
+
+//++=======================================================================
+//  API Name:        NwcClearBroadcastMessage
+//
+//  Arguments In:    NONE
+//
+//  Arguments Out:   NONE
+//
+//  Returns:         STATUS_SUCCESS
+//
+//  Abstract:        This API is clears the broadcast message buffer.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+//++=======================================================================
+//  API Name:        NwcCloseConn
+//
+//  Arguments In:    ConnHandle - The handle to a connection that is
+//                   no longer needed.
+//
+//  Arguments Out:   NONE
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//                   NWE_CONN_INVALID
+//                   NWE_INVALID_OWNER
+//                   NWE_RESOURCE_LOCK
+//
+//  Abstract:        This API is used by an application that opened the
+//                   connection using one of the open connection calls
+//                   is finished using the connection.  After it is closed,
+//                   the handle may no longer be used to access the
+//                   connection.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcCloseConn {
+	NW_CONN_HANDLE ConnHandle;
+
+} NwcCloseConn, *PNwcCloseConn;
+
+//++=======================================================================
+//  API Name:        NwcConvertLocalFileHandle
+//
+//  Arguments In:    NONE
+//
+//  Arguments Out:   uConnReference - The connection reference associated
+//                   with the returned NetWare file handle.
+//
+//                   pNetWareFileHandle - The six byte NetWare file handle
+//                   associated with the given local file handle.
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//                   NWE_RESOURCE_NOT_OWNED
+//
+//  Abstract:        This API is used to return the NetWare handle that
+//                   has been associated to a local file handle.
+//                   In addition to returning the NetWare file handle,
+//                   this API also returns the connection reference to
+//                   the connection that owns the file.
+//
+//  Notes:           This API does not create a new NetWare handle, it
+//                   only returns the existing handle associated to the
+//                   local handle.
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcConvertLocalHandle {
+	u32 uConnReference;
+	unsigned char NetWareHandle[6];
+
+} NwcConvertLocalHandle, *PNwcConvertLocalHandle;
+
+//++=======================================================================
+//  API Name:        NwcConvertNetWareHandle
+//
+//  Arguments In:    ConnHandle - The connection associated with the
+//                   NetWare file handle to convert.
+//
+//                   uAccessMode - The access rights to be used when
+//                   allocating the local file handle.
+//
+//                   pNetWareHandle - The NetWare handle that will be
+//                   bound to the new local handle being created.
+//
+//                   uFileSize - The current file size of the NetWare
+//                   file associated with the given NetWare file handle.
+//
+//  Arguments Out:   NONE
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//                   NWE_RESOURCE_NOT_OWNED
+//
+//  Abstract:        This API is used to convert a NetWare file handle
+//                   to a local file handle.
+//
+//                   The local handle must have been created previously
+//                   by doing a local open to \Special\$Special.net.
+//
+//                   Then an Ioctl to this function must be issued using the
+//                   handle returned from the special net open.
+//
+//  Notes:           After making this call, the NetWare file handle
+//                   should not be closed using the NetWare library
+//                   call, instead it should be closed using the local
+//                   operating system's close call.
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+typedef struct tagNwcConvertNetWareHandle {
+	NW_CONN_HANDLE ConnHandle;
+	u32 uAccessMode;
+	unsigned char NetWareHandle[6];
+	u32 uFileSize;
+} NwcConvertNetWareHandle, *PNwcConvertNetWareHandle;
+
+//++=======================================================================
+//  API Name:        NwcFragmentRequest
+//
+//  Arguments In:    ConnHandle
+//                      The connection handle the request is being
+//                      directed to.
+//
+//                   uFunction
+//                      The NCP function to be called, should be 104
+//                      for NDS fragger/defragger requests.
+//
+//                   uSubFunction
+//                      The NCP subfunction to be called, should be
+//                      2 for NDS fragger/defragger requests.
+//
+//                   uVerb
+//                      The actual operation to be completed on the
+//                      server backend.
+//
+//                   flags
+//                      Currently not implemented.  Reserved for
+//                      future use.
+//
+//                   uNumRequestFrags
+//                      The number of fragments that the request packet
+//                      has been broken into.
+//
+//                   pRequestFrags
+//                      List of fragments that make up the request packet.
+//                      Each fragment includes the length of the fragment
+//                      data and a pointer to the data.
+//
+//                   uNumReplyFrags
+//                      The number of fragments the reply packet has been
+//                      broken into.
+//
+//  Arguments Out:   pReplyFrags
+//                      List of fragments that make up the reply packet.
+//                      Each fragment includes the length of the fragment
+//                      data and a pointer to the data.
+//
+//                   uActualReplyLength
+//                      Total size of the reply packet after any header
+//                      and tail information is removed.
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//                   NWE_CONN_INVALID
+//
+//  Abstract:        API for sending large NCP/NDS packets that are
+//                   larger than the max MTU size for the underlying
+//                   network.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+typedef struct tagNwcFragmentRequest {
+	NW_CONN_HANDLE ConnHandle;
+	u32 uFunction;
+	u32 uSubFunction;
+	u32 uVerb;
+	u32 flags;
+	u32 uNumRequestFrags;
+	PNwcFrag pRequestFrags;
+	u32 uNumReplyFrags;
+	PNwcFrag pReplyFrags;
+	u32 uActualReplyLength;
+} NwcFragmentRequest, *PNwcFragmentRequest;
+
+//++=======================================================================
+//  API Name:        NwcGetBroadcastMessage
+//
+//  Arguments In:    uMessageFlags - Not currently used.
+//
+//                   uConnReference - connection reference for
+//                   pending message.
+//
+//                   messageLen - length of message buffer.
+//
+//                   message - message buffer
+//
+//  Arguments Out:   messageLen - length of the message
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//                   NWE_NO_MORE_ENTRIES
+//
+//  Abstract:        This API is used for notifying a caller of pending
+//                   broadcast messages on the server.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+/* jlt
+typedef  struct   tagNwcGetBroadcastMessage
+{
+   u32               uMessageFlags;
+   u32               uConnReference;
+   u32               messageLen;
+   unsigned char                message[255];
+
+} NwcGetBroadcastMessage, *PNwcGetBroadcastMessage;
+*/
+
+//++=======================================================================
+//  API Name:        NwcGetConnInfo
+//
+//  Arguments In:    ConnHandle - Connection handle for the connection to
+//                   get information on.
+//                   uInfoLevel - Specifies what information should be
+//                   returned.
+//                   uInfoLen - Length of the ConnInfo buffer.
+//
+//  Arguments Out:   pConnInfo - A pointer to a buffer to return connection
+//                   information in.  If the caller is requesting all
+//                   information the pointer will be to a structure of
+//                   type NwcConnInfo.  If the caller is requesting just
+//                   a single piece of information, the pointer is the
+//                   type of information being requested.
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//                   NWE_CONN_INVALID
+//                   NWE_INVALID_OWNER
+//                   NWE_RESOURCE_LOCK
+//                   NWE_STRING_TRANSLATION
+//
+//  Abstract:        This API returns connection information for the specified
+//                   connection.  The requester can receive one piece of
+//                   information or the whole information structure.
+//                   Some of the entries in the NwcConnInfo structure are
+//                   pointers.  The requester is responsible for supplying
+//                   valid pointers for any info specified to be returned.
+//                   If the requester does not want a piece of information
+//                   returned, a NULL pointer should be placed in the field.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcGetConnInfo {
+	NW_CONN_HANDLE ConnHandle;
+	u32 uInfoLevel;
+	u32 uInfoLength;
+	void *pConnInfo;
+
+} NwcGetConnInfo, *PNwcGetConnInfo;
+
+//++=======================================================================
+//  API Name:        NwcGetDefaultNameContext
+//
+//  Arguments In::   uTreeLength - Length of tree string.
+//
+//                   pDsTreeName - Pointer to tree string (multi-byte)
+//
+//                   pNameLength - On input, this is the length of the
+//                   name context buffer. On output, this is the actual
+//                   length of the name context string.
+//
+//  Arguments Out:   pNameContext - The buffer to copy the default name
+//                   context into (multi-byte).
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//                   NWE_BUFFER_OVERFLOW
+//                   NWE_OBJECT_NOT_FOUND
+//                   NWE_PARAM_INVALID
+//                   NWE_RESOURCE_LOCK
+//
+//  Abstract:        This API returns the default name context that
+//                   was previously set either by configuration or
+//                   by calling NwcSetDefaultNameContext.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcGetDefaultNameContext {
+	u32 uTreeLength;
+	unsigned char *pDsTreeName;
+	u32 uNameLength;
+// unsigned short *pNameContext;
+	unsigned char *pNameContext;
+
+} NwcGetDefaultNameContext, *PNwcGetDefaultNameContext;
+
+//++=======================================================================
+//  API Name:        NwcGetTreeMonitoredConnReference
+//
+//  Arguments In:    NONE
+//
+//  Arguments Out:   uConnReference - The connection reference associated
+//                   with the monitored connection.
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//                   NWE_OBJECT_NOT_FOUND
+//                   NWE_RESOURCE_LOCK
+//
+//  Abstract:        This call returns a connection reference to a
+//                   connection that is monitored.  This connection
+//                   reference may be used to open the connection.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcGetTreeMonitoredConnRef {
+	PNwcString pTreeName;
+	u32 uConnReference;
+
+} NwcGetTreeMonitoredConnRef, *PNwcGetTreeMonitoredConnRef;
+
+//++=======================================================================
+//  API Name:        NwcGetNumberConns
+//
+//  Arguments In:    NONE
+//
+//  Arguments Out:   uMaxConns - The maximum number of connections
+//                   supported by the redirector.  -1 for dynamic.
+//
+//                   uPublicConns - The current number of public
+//                   connections.
+//
+//                   uTasksPrivateConns - The current number of private
+//                   connections that are owned by the calling process.
+//
+//                   uOtherPrivateConns - The current number of private
+//                   connections that are not owned by the calling
+//                   process.
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//                   NWE_RESOURCE_LOCK
+//
+//  Abstract:        This API returns the current number of connections
+//                   as well as the maximum number of supported
+//                   connections.  If the requester/redirector supports
+//                   a dynamic connection table, -1 will be returned
+//                   in the uMaxConns field.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcGetNumberConns {
+	u32 uMaxConns;
+	u32 uPublicConns;
+	u32 uTasksPrivateConns;
+	u32 uOtherPrivateConns;
+
+} NwcGetNumberConns, *PNwcGetNumberConns;
+
+//++=======================================================================
+//  API Name:        NwcGetPreferredServer
+//
+//  Arguments In:    uServerNameLength - On input, this is the length
+//                   in bytes of the server buffer.  On output, this is
+//                   the actual length of the server name string in bytes.
+//
+//  Arguments Out:   pServerName - The buffer to copy the preferred server
+//                   name into.
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//                   NWE_BUFFER_OVERFLOW
+//                   NWE_OBJECT_NOT_FOUND
+//                   NWE_PARAM_INVALID
+//                   NWE_RESOURCE_LOCK
+//
+//  Abstract:        This API returns the configured preferred bindery
+//                   server previously set either by configuration or
+//                   by calling NwcSetPreferredServer.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcGetPreferredServer {
+	u32 uServerNameLength;
+	char *pServerName;
+
+} NwcGetPreferredServer, *PNwcGetPreferredServer;
+
+//++=======================================================================
+//  API Name:        NwcGetPreferredDsTree
+//
+//  Arguments In:    uTreeLength - On input, this is the length in bytes
+//                   of the DS tree name buffer.  On output, this is the
+//                   actual length of the DS tree name string in bytes.
+//
+//  Arguments Out:   pDsTreeName - The buffer to copy the DS tree name into.
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//                   NWE_BUFFER_OVERFLOW
+//                   NWE_PARAM_INVALID
+//                   NWE_DS_PREFERRED_NOT_FOUND
+//                   NWE_RESOURCE_LOCK
+//
+//  Abstract:        This API returns the preferred DS tree name that was
+//                   previously set either by configuration or
+//                   by calling NwcSetPreferredDsTree.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+typedef struct tagNwcGetPreferredDsTree {
+	u32 uTreeLength;
+	unsigned char *pDsTreeName;
+} NwcGetPreferredDsTree, *PNwcGetPreferredDsTree;
+
+//++=======================================================================
+//  API Name:        NwcGetPrimaryConnection
+//
+//  Arguments In:    NONE
+//
+//  Arguments Out:   uConnReference - Reference to the primary connection.
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//                   NWE_CONN_PRIMARY_NOT_SET
+//
+//  Abstract:        This API returns the reference to the current primary
+//                   connection in the redirector.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcGetPrimaryConnection {
+	u32 uConnReference;
+
+} NwcGetPrimaryConnection, *PNwcGetPrimaryConnection;
+
+//++=======================================================================
+//  API Name:        NwcGetRequesterVersion
+//
+//  Arguments In:    NONE
+//
+//  Arguments Out:   uMajorVersion
+//                   uMinorVersion
+//                   uRevision
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//
+//  Abstract:        This API returns the major version, minor version and
+//                   revision of the requester/redirector.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcGetRequesterVersion {
+	u32 uMajorVersion;
+	u32 uMinorVersion;
+	u32 uRevision;
+
+} NwcGetRequesterVersion, *PNwcGetRequesterVersion;
+
+//++=======================================================================
+//  API Name:        NwcLicenseConn
+//
+//  Arguments In:    ConnHandle - An open connection handle that is in
+//                   an unlicensed state.
+//
+//  Arguments Out:   NONE
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//                   NWE_CONN_INVALID
+//                   NWE_HANDLE_ALREADY_LICENSED
+//
+//
+//  Abstract:        This API changes a connections state to licensed.
+//                   The licensed count will be incremented, and if
+//                   necessary, the license NCP will be sent.
+//                   If this handle is already in a licensed state,
+//                   an error will be returned.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcLicenseConn {
+	NW_CONN_HANDLE ConnHandle;
+
+} NwcLicenseConn, *PNwcLicenseConn;
+
+//++=======================================================================
+//  API Name:        NwcMakeConnPermanent
+//
+//  Arguments In:    ConnHandle - An open connection handle associated
+//                   with the connection to be made permanent.
+//
+//  Arguments Out:   NONE
+//
+//  Returns:         NWE_ACCESS_VIOLATION
+//                   NWE_CONN_INVALID
+//                   NWE_INVALID_OWNER
+//
+//  Abstract:        This API is used to keep the connection from being
+//                   destroyed until a NwcSysCloseConn request is made
+//                   on the connection.  This allows the connection to
+//                   remain after all processes that have the
+//                   connection open terminate.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcMakeConnPermanent {
+	NW_CONN_HANDLE ConnHandle;
+
+} NwcMakeConnPermanent, *PNwcMakeConnPermanent;
+
+//++=======================================================================
+//  API Name:        NwcMapDrive
+//
+//  Arguments In:    ConnHandle - The connection handle of the server
+//                   to where the drive is to be mapped.
+//
+//                   LocalUID - Local user ID
+//
+//                   LocalPathLen - Length of local/link directory path string,
+//                   including nul terminator.
+//
+//                   LocalPathOffset - Offset of local directory path that will
+//                   be mapped to NetWare directory path.
+//
+//                   NetWarePathLen - Offset of NetWare directory path,
+//                   including nul terminator.
+//
+//                   NetWarePathOffset - Offset of NetWare directory path in
+//                   structure.
+//
+//  Arguments Out:   NONE
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//                   NWE_CONN_INVALID
+//                   NWE_INSUFFICIENT_RESOURCES
+//                   NWE_STRING_TRANSLATION
+//
+//  Abstract:        This API maps the target drive to the specified
+//                   directory.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcMapDrive {
+	NW_CONN_HANDLE ConnHandle;
+	u32 LocalUID;
+	u32 LinkPathLen;
+	u32 LinkPathOffset;
+	u32 DestPathLen;
+	u32 DestPathOffset;
+
+} NwcMapDrive, *PNwcMapDrive;
+
+//++=======================================================================
+//  API Name:        NwcUnmapDrive
+//
+//  Arguments In:    LinkPathLen - Length of local/link path string,
+//                   including nul terminator.
+//
+//                   LinkPath - Local/link path in structure
+//                   to be unmapped
+//
+//  Arguments Out:   NONE
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//                   NWE_PARAM_INVALID
+//
+//  Abstract:        This API deletes a network drive mapping.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcUnmapDrive {
+	u32 LinkPathLen;
+	unsigned char LinkPath[1];
+
+} NwcUnmapDrive, *PNwcUnmapDrive;
+
+//++=======================================================================
+//  API Name:        NWCGetMappedDrives
+//
+//  Arguments In:
+//  Arguments Out:
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//                   NWE_BUFFER_OVERFLOW
+//
+//  Abstract:        This API returns the NetWare mapped drive info
+//                   per user.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcMapDriveElem {
+	u32 ElemLen;		// Lenght of drive element
+	u32 ConnRefernce;	// Connection reference
+	u32 LinkPathLen;	// Local/link dir path, length includes nul
+	unsigned char LinkPath[1];	// LinkPath[LinkPathLen]
+// u32               DirPathLen;       // NetWare dir path, length includes nul (vol:path)
+// unsigned char                DirPath[DirPathLen]; // NetWarePath[DirPathLen]
+} NwcMapDriveElem, *PNwcMapDriveElem;
+
+typedef struct tagNwcMapDriveBuff {
+	u32 MapCount;		// Number of mapped drives
+	NwcMapDriveElem MapDriveElem[1];	// MapDriveElem[MapCount]
+
+} NwcMapDriveBuff, *PNwcMapDriveBuff;
+
+typedef struct tagNwcGetMappedDrives {
+	u32 MapBuffLen;		// Buffer length (actual buffer size returned)
+	PNwcMapDriveBuff MapBuffer;	// Pointer to map buffer
+
+} NwcGetMappedDrives, *PNwcGetMappedDrives;
+
+//++=======================================================================
+//  API Name:        NwcGetMountPath
+//
+//  Arguments In:    MountPathLen - Length of mount path buffer
+//                   including nul terminator.
+//
+//  Arguments Out:   MountPath - Pointer to mount path buffer
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//                   NWE_BUFFER_OVERFLOW
+//
+//  Abstract:        This API returns the mount point of the NOVFS file
+//                   system.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcGetMountPath {
+	u32 MountPathLen;
+	unsigned char *pMountPath;
+
+} NwcGetMountPath, *PNwcGetMountPath;
+
+//++=======================================================================
+//  API Name:        NwcMonitorConn
+//
+//  Arguments In:    ConnHandle - The handle associated with the connection
+//                   that is to be marked as the monitored connection.
+//
+//  Arguments Out:   NONE
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//                   NWE_RESOURCE_LOCK
+//                   NWE_CONN_INVALID
+//
+//
+//  Abstract:        This call marks the connection associated with the
+//                   connection handle as monitored.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcMonitorConn {
+	NW_CONN_HANDLE ConnHandle;
+
+} NwcMonitorConn, *PNwcMonitorConn;
+
+//++=======================================================================
+//  API Name:        NwcOpenConnByAddr
+//
+//  Arguments In:    pServiceType - The type of service required.
+//
+//                   uConnFlags - Specifies whether this connection
+//                   should be public or private.
+//
+//                   pTranAddress - Specifies the transport address of
+//                   the service to open a connection on.
+//                   a connection to.
+//
+//  Arguments Out:   ConnHandle - The new connection handle returned.
+//                   This handle may in turn be used for all requests
+//                   directed to this connection.
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//                   NWE_INSUFFICIENT_RESOURCES
+//                   NWE_TRAN_INVALID_TYPE
+//                   NWE_RESOURCE_LOCK
+//                   NWE_UNSUPPORTED_TRAN_TYPE
+//
+//  Abstract:        This API will create a service connection to
+//                   the service specified by the transport address.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcOpenConnByAddr {
+	char *pServiceType;
+	u32 uConnFlags;
+	PNwcTranAddr pTranAddr;
+	NW_CONN_HANDLE ConnHandle;
+
+} NwcOpenConnByAddr, *PNwcOpenConnByAddr;
+
+//++=======================================================================
+//  API Name:        NwcOpenConnByName
+//
+//  Arguments In:    ConnHandle - The connection to use when resolving
+//                   a name.  For instance, if the name is a bindery name
+//                   the requester will scan the bindery of the given
+//                   connection to retrieve the service's address.  This
+//                   value can also be NULL if the caller doesn't care
+//                   which connection is used to resolve the address.
+//
+//                   pName - A pointer to the name of the service trying
+//                   to be connected to.  This string is NULL terminated,
+//                   contains no wild cards, and is a maximum of 512
+//                   characters long.
+//
+//                   pServiceType - The type of service required.
+//
+//                   uConnFlags - Specifies whether this connection
+//                   should be public or private.
+//
+//                   uTranType - Specifies the preferred or required
+//                   transport type to be used.
+//                   NWC_TRAN_TYPE_WILD may be ORed with the other values
+//                   or used alone.  When ORed with another value, the
+//                   wild value indicates an unmarked alternative is
+//                   acceptable.  When used alone, the current preferred
+//                   transport is used.
+//
+//  Arguments Out:   ConnHandle - The new connection handle returned.
+//                   This handle may in turn be used for all requests
+//                   directed to this connection.
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//                   NWE_BUFFER_OVERFLOW
+//                   NWE_INSUFFICIENT_RESOURCES
+//                   NWE_INVALID_STRING_TYPE
+//                   NWE_RESOURCE_LOCK
+//                   NWE_STRING_TRANSLATION
+//                   NWE_TRAN_INVALID_TYPE
+//                   NWE_UNSUPPORTED_TRAN_TYPE
+//
+//  Abstract:        This API will resolve the given name to a network
+//                   address then create a service connection to the
+//                   specified service.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcOpenConnByName {
+	NW_CONN_HANDLE ConnHandle;
+	PNwcConnString pName;
+	char *pServiceType;
+	u32 uConnFlags;
+	u32 uTranType;
+	NW_CONN_HANDLE RetConnHandle;
+
+} NwcOpenConnByName, *PNwcOpenConnByName;
+
+//++=======================================================================
+//  API Name:        NwcOpenConnByReference
+//
+//  Arguments In:    uConnReference - A reference handle which identifies
+//                   a valid connection that the caller wants to obtain
+//                   a connection handle to.  A reference handle can be
+//                   used to get information about the connection without
+//                   actually getting a handle to it.  A connection handle
+//                   must be used to make actual requests to that
+//                   connection.
+//
+//                   uConnFlags - Currently unused.
+//
+//  Arguments Out:   ConnHandle - The new connection handle returned.
+//                   This handle may in turn be used for all requests
+//                   directed to this connection.
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//                   NWE_CONN_INVALID
+//
+//  Abstract:        This API will open the connection associated with
+//                   the given connection reference.  The connection
+//                   reference can be obtained by calling the
+//                   NwcScanConnInfo API.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcOpenConnByReference {
+	u32 uConnReference;
+	u32 uConnFlags;
+	NW_CONN_HANDLE ConnHandle;
+
+} NwcOpenConnByReference, *PNwcOpenConnByReference;
+
+//++=======================================================================
+//  API Name:        NwcRawRequest
+//
+//  Arguments In:    ConnHandle - The connection handle of the connection
+//                   that the request is being directed to.
+//
+//                   uFunction - The NCP function that is being called.
+//
+//                   uNumRequestFrags - The number of fragments that the
+//                   request packet has been broken into.
+//
+//                   pRequestFrags - List of fragments that make up the
+//                   request packet.  Each fragment includes the length
+//                   of the fragment data and a pointer to the data.
+//
+//                   uNumReplyFrags - The number of fragments the reply
+//                   packet has been broken into.
+//
+//  Arguments Out:   pReplyFrags - List of fragments that make up the
+//                   request packet.  Each fragment includes the length
+//                   of the fragment data and a pointer to the data.
+//
+//                   uActualReplyLength - Total size of the reply packet
+//                   after any header and tail information is removed.
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//                   NWE_CONN_INVALID
+//
+//  Abstract:        API for sending raw NCP packets directly to a server.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcRequest {
+	NW_CONN_HANDLE ConnHandle;
+	u32 uFunction;
+	u32 uNumRequestFrags;
+	PNwcFrag pRequestFrags;
+	u32 uNumReplyFrags;
+	PNwcFrag pReplyFrags;
+	u32 uActualReplyLength;
+
+} NwcRequest, *PNwcRequest;
+
+//++=======================================================================
+//  API Name:        NwcRawRequestAll
+//
+//  Arguments In:    uFunction - The NCP function that is being called.
+//
+//                   uNumRequestFrags - The number of fragments that the
+//                   request packet has been broken into.
+//
+//                   pRequestFrags - List of fragments that make up the
+//                   request packet.  Each fragment includes the length
+//                   of the fragment data and a pointer to the data.
+//
+//  Arguments Out:   NONE
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//                   NWE_CONN_INVALID
+//
+//  Abstract:        API for sending the given NCP request to all valid
+//                   connections.  If there is a private connection that
+//                   is not owned by the caller of this function, that
+//                   connection will not be included.  Also, if the
+//                   caller has both a private and a public connection
+//                   to the same server, only the private connection
+//                   will receive the request.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcRequestAll {
+	u32 uFunction;
+	u32 uNumRequestFrags;
+	PNwcFrag pRequestFrags;
+
+} NwcRequestAll, *PNwcRequestAll;
+
+//++=======================================================================
+//  API Name:        NwcScanConnInfo
+//
+//  Arguments In:    uScanIndex - The index to be used on the next
+//                   iteration of the scan.  This value should be initially
+//                   set to zero.  The output of this parameter will be
+//                   used in subsequent calls to this function.
+//
+//                   uScanInfoLevel - Describes the composition of the
+//                   pScanConnInfo pointer.  If this parameter contains
+//                   NWC_CONN_INFO_RETURN_ALL, information for all
+//                   connections will be returned.
+//
+//                   uScanInfoLen - Lenght of pScanConnInfo buffer
+//
+//                   pScanConnInfo - This parameter is a pointer to
+//                   data that describes one piece of connection
+//                   information.  The type of this data depends on
+//                   which level of information is being scanned for.
+//                   For instance, if the scan is being used to find all
+//                   connections with a particular authentication state,
+//                   pScanConnInfo would be a "pnuint" since
+//                   authentication state is described as nuint in the
+//                   NwcConnInfo structure.
+//
+//                   uScanFlag - This parameter tells whether to return
+//                   connection information for connections that match
+//                   the scan criteria or that do not match the scan
+//                   criteria.  If the caller wants to find all the
+//                   connections that are not in the "NOVELL_INC" DS
+//                   tree, he would use the call as described below in
+//                   the description except the uScanFlag parameter would
+//                   have  the value of NWC_MATCH_NOT_EQUALS.  This flag
+//                   is also used to tell the requester whether to
+//                   return private or public, licensed or unlicensed
+//                   connections.
+//
+//                   uReturnInfoLevel - Specifies what information
+//                   should be returned.
+//
+//                   uReturnInfoLength - The size in bytes of pConnInfo.
+//
+//  Arguments Out:   uConnectionReference - Connection reference
+//                   associated with the information that is being
+//                   returned.
+//
+//                   pReturnConnInfo - A pointer to the NwcConnInfo
+//                   structure defined above.  In some of the
+//                   structures within the union, there are pointers to
+//                   data to be returned.  It is the responsibility of
+//                   the caller to provide pointers to valid memory
+//                   to copy this data into.
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//                   NWE_RESOURCE_LOCK
+//                   NWE_CONN_INVALID
+//                   NWE_INVALID_LEVEL
+//                   NWE_STRING_TRANSLATION
+//                   NWE_INVALID_MATCH_DATA
+//                   NWE_MATCH_FAILED
+//                   NWE_BUFFER_OVERFLOW
+//                   NWE_NO_MORE_ENTRIES
+//
+//  Abstract:        This API is used to return connection information
+//                   for multiple connections.  It will return one
+//                   piece or the full structure of connection information
+//                   for one connection at a time.  This call is designed
+//                   to scan for connections based on any piece of
+//                   connection information as described in the
+//                   NwcConnInfo structure.  For instance, if the caller
+//                   wants to scan for all connections in the DS tree
+//                   "NOVELL_INC", the call would be made with the
+//                   following paramters:
+//
+//                      uScanLevelInfo = NWC_CONN_INFO_TREE_NAME
+//                      pScanConnInfo = "NOVELL_INC"
+//                      uScanFlag = NWC_MATCH_EQUALS |
+//                                  NWC_RETURN_PUBLIC |
+//                                  NWC_RETURN_LICENSED
+//
+//                   The scan flag is used to tell if the scan is
+//                   supposed to return connections that match or don't
+//                   match.  This design doesn't allow any other
+//                   conditions for this flag (such as greater than or
+//                   less than).
+//
+//                   If the caller specifies the uReturnInfoLevel =
+//                   NWC_CONN_INFO_RETURN_ALL, the full NwcConnInfo
+//                   structure is returned.  The caller must supply
+//                   data for any pointers in the NwcConnInfo structure
+//                   (these include tree name, workgroup id, server name
+//                   and transport address).  However if the caller
+//                   doesn't want to get a particular piece of info
+//                   that is expecting a pointer to some data, a NULL
+//                   pointer may be used to indicate to the requester
+//                   that it should not return that piece of information.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcScanConnInfo {
+	u32 uScanIndex;
+	u32 uScanInfoLevel;
+	u32 uScanInfoLen;
+	void *pScanConnInfo;
+	u32 uScanFlags;
+	u32 uReturnInfoLevel;
+	u32 uReturnInfoLength;
+	u32 uConnectionReference;
+	void *pReturnConnInfo;
+
+} NwcScanConnInfo, *PNwcScanConnInfo;
+
+//++=======================================================================
+//  API Name:        NwcSetConnInfo
+//
+//  Arguments In:    ConnHandle - Connection handle for the connection to
+//                   set information on.
+//
+//                   uInfoLevel - Specifies what information should be set.
+//
+//                   uInfoLen - Length in bytes of the information being set.
+//
+//                   pConnInfo - Connection information to set.
+//
+//  Arguments Out:   NONE
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//                   NWE_RESOURCE_LOCK
+//                   NWE_CONN_INVALID
+//                   NWE_INVALID_LEVEL
+//
+//
+//  Abstract:        This API sets information in the connection associated
+//                   with the connection handle.
+//
+//  Notes:           At this time the only setable information levels are:
+//                      NWC_CONN_INFO_AUTH_STATE
+//                      NWC_CONN_INFO_BCAST_STATE
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcSetConnInfo {
+	NW_CONN_HANDLE ConnHandle;
+	u32 uInfoLevel;
+	u32 uInfoLength;
+	void *pConnInfo;
+
+} NwcSetConnInfo, *PNwcSetConnInfo;
+
+//++=======================================================================
+//  API Name:        NwcSetDefaultNameContext
+//
+//  Arguments In::   uTreeLength - Length of tree string.
+//
+//                   pDsTreeName - The tree string (multi-byte).
+//
+//                   uNameLength - The length in bytes of the name
+//                   context string.
+//
+//                   pNameContext - The string to be used as the default
+//                   name context (multi-byte).
+//
+//  Arguments Out:   NONE
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//                   NWE_PARAM_INVALID
+//                   NWE_RESOURCE_LOCK
+//                   NWE_STRING_TRANSLATION
+//
+//  Abstract:        This API sets the default name context.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcSetDefaultNameContext {
+	u32 uTreeLength;
+	unsigned char *pDsTreeName;
+	u32 uNameLength;
+// unsined short *pNameContext;
+	unsigned char *pNameContext;
+
+} NwcSetDefaultNameContext, *PNwcSetDefaultNameContext;
+
+//++=======================================================================
+//  API Name:        NwcSetPreferredDsTree
+//
+//  Arguments In:    uTreeLength - The length in bytes of the DS tree name.
+//
+//                   pDsTreeName - The string to be used as the preferred
+//                   DS tree name.
+//
+//  Arguments Out:   NONE
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//                   NWE_INSUFFICIENT_RESOURCES
+//                   NWE_RESOURCE_LOCK
+//
+//  Abstract:        This API sets the preferred DS tree name.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcSetPreferredDsTree {
+	u32 uTreeLength;
+	unsigned char *pDsTreeName;
+
+} NwcSetPreferredDsTree, *PNwcSetPreferredDsTree;
+
+//++=======================================================================
+//  API Name:        NwcSetPreferredServer
+//
+//  Arguments In:    uServerNameLength - The length in bytes of the
+//                   preferred server string.
+//
+//                   pServerName - a pointer to an ASCIIZ string of the
+//                   preferred bindery server.
+//
+//  Arguments Out:   NONE
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//                   NWE_INSUFFICIENT_RESOURCES
+//                   NWE_RESOURCE_LOCK
+//
+//  Abstract:        This API sets the preferred server name.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcSetPreferredServer {
+	u32 uServerNameLength;
+	char *pServerName;
+
+} NwcSetPreferredServer, *PNwcSetPreferredServer;
+
+//++=======================================================================
+//  API Name:        NwcSetPrimaryConnection
+//
+//  Arguments In:    ConnHandle - Connection handle associated to the
+//                   connection reference which the caller wishes to set
+//                   as primary.
+//
+//  Arguments Out:   NONE
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//                   NWE_CONN_PRIMARY_NOT_SET
+//
+//  Abstract:        This API sets the primary connection according to
+//                   the connection handle passed in by the caller.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcSetPrimaryConnection {
+	NW_CONN_HANDLE ConnHandle;
+
+} NwcSetPrimaryConnection, *PNwcSetPrimaryConnection;
+
+//++=======================================================================
+//  API Name:        NwcSysCloseConn
+//
+//  Arguments In:    ConnHandle - The handle to a connection that is
+//                   to be destroyed.
+//
+//  Arguments Out:   NONE
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//                   NWE_CONN_INVALID
+//
+//  Abstract:        This API is similiar to the NwcCloseConn API, except
+//                   that it forces all handles to the connection closed
+//                   and destroys the service connection.  This is a system
+//                   level request that will cause all processes that are
+//                   accessing this connection to lose access to the
+//                   resources associated to the connection.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcSysCloseConn {
+	NW_CONN_HANDLE ConnHandle;
+
+} NwcSysCloseConn, *PNwcSysCloseConn;
+
+//++=======================================================================
+//  API Name:        NwcUnlicenseConn
+//
+//  Arguments In:    ConnHandle - Open connection handle that will be
+//                   accessing the connection in an unlicensed manner.
+//
+//  Arguments Out:   NONE
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//                   NWE_CONN_INVALID
+//                   NWE_HANDLE_ALREADY_UNLICENSED
+//
+//  Abstract:        This API is used to change the state of a connection
+//                   handle from licensed to unlicensed.  If all handles
+//                   to the connection have been changed to the unlicensed
+//                   state, the unlicensed NCP is sent to the server.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcUnlicenseConn {
+	NW_CONN_HANDLE ConnHandle;
+
+} NwcUnlicenseConn, *PNwcUnlicenseConn;
+
+//++=======================================================================
+//  API Name:        NwcQueryFeature
+//
+//  Arguments In:    Feature - The number associated with a particular
+//                   feature that the caller wants to know if the requester
+//                   is supporting
+//
+//  Arguments Out:
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_REQUESTER_FAILURE
+//                   NWE_ACCESS_VIOLATION
+//
+//  Abstract:
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcQueryFeature {
+	u32 Feature;
+
+} NwcQueryFeature, *PNwcQueryFeature;
+
+//++=======================================================================
+//  API Name:        NWCChangePassword
+//
+//  Arguments In:
+//
+//  Arguments Out:
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//
+//  Abstract:
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcChangeKey {
+	PNwcString pDomainName;
+	u32 AuthType;
+	PNwcString pObjectName;
+	u32 NameType;
+	u16 ObjectType;
+	PNwcString pVerifyPassword;
+	PNwcString pNewPassword;
+
+} NwcChangeKey, *PNwcChangeKey;
+
+//++=======================================================================
+//  API Name:        NWCEnumerateIdentities            `
+//
+//  Arguments In:
+//
+//  Arguments Out:
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//
+//  Abstract:
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcEnumerateIdentities {
+	u32 Iterator;
+	PNwcString pDomainName;
+	u32 AuthType;
+	PNwcString pObjectName;
+	u32 NameType;
+	u16 ObjectType;
+	u32 IdentityFlags;
+	AUTHEN_ID AuthenticationId;
+
+} NwcEnumerateIdentities, *PNwcEnumerateIdentities;
+
+//++=======================================================================
+//  API Name:        NWCGetIdentityInfo
+//
+//  Arguments In:
+//
+//  Arguments Out:
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//
+//  Abstract:
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcGetIdentityInfo {
+	AUTHEN_ID AuthenticationId;
+	PNwcString pDomainName;
+	u32 AuthType;
+	PNwcString pObjectName;
+	u32 NameType;
+	u16 ObjectType;
+	u32 IdentityFlags;
+
+} NwcGetIdentityInfo, *PNwcGetIdentityInfo;
+
+//++=======================================================================
+//  API Name:        NWCLoginIdentity
+//
+//  Arguments In:
+//
+//  Arguments Out:
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//
+//  Abstract:
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcLoginIdentity {
+	PNwcString pDomainName;
+	u32 AuthType;
+	PNwcString pObjectName;
+	u32 NameType;
+	u16 ObjectType;
+	u32 IdentityFlags;
+	PNwcString pPassword;
+	AUTHEN_ID AuthenticationId;
+
+} NwcLoginIdentity, *PNwcLoginIdentity;
+
+//++=======================================================================
+//  API Name:        NWCLogoutIdentity
+////
+
+//  Arguments In:
+//
+//  Arguments Out:
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//
+//  Abstract:
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcLogoutIdentity {
+	AUTHEN_ID AuthenticationId;
+
+} NwcLogoutIdentity, *PNwcLogoutIdentity;
+
+//++=======================================================================
+//  API Name:        NWCSetPassword
+//
+//  Arguments In:
+//
+//  Arguments Out:
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//
+//  Abstract:
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcSetKey {
+	NW_CONN_HANDLE ConnHandle;
+	AUTHEN_ID AuthenticationId;
+	PNwcString pObjectName;
+	u16 ObjectType;
+	PNwcString pNewPassword;
+
+} NwcSetKey, *PNwcSetKey;
+
+//++=======================================================================
+//  API Name:        NWCVerifyPassword
+//
+//  Arguments In:
+//
+//  Arguments Out:
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//
+//  Abstract:
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//++=======================================================================
+
+typedef struct tagNwcVerifyKey {
+	PNwcString pDomainName;
+	u32 AuthType;
+	PNwcString pObjectName;
+	u32 NameType;
+	u16 ObjectType;
+	PNwcString pVerifyPassword;
+
+} NwcVerifyKey, *PNwcVerifyKey;
+
+//++=======================================================================
+//  API Name:        NwcAuthenticateWithId
+//
+//  Arguments In:    ConnHandle - The connection to be authenticated
+//
+//                   AuthenticationId - the authentication Id associated
+//                   to the information necessary to authenticate this
+//                   connection.
+//
+//  Arguments Out:   NONE
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//
+//  Abstract:        This API is used to authenticate a connection using
+//                   an authentication ID that has already been created.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcAuthenticateWithId {
+	NW_CONN_HANDLE ConnHandle;
+	AUTHEN_ID AuthenticationId;
+
+} NwcAuthenticateWithId, *PNwcAuthenticateWithId;
+
+//++=======================================================================
+//  API Name:        NwcUnauthenticate
+//
+//  Arguments In:    ConnHandle - The connection to unauthenticate.
+//
+//  Arguments Out:   NONE
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//                   NWE_CONN_INVALID
+//                   NWE_INVALID_OWNER
+//                   NWE_RESOURCE_LOCK
+//
+//  Abstract:        This API removes the authentication for the specified
+//                   connection.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcUnauthenticate {
+	NW_CONN_HANDLE ConnHandle;
+	AUTHEN_ID AuthenticationId;
+
+} NwcUnauthenticate, *PNwcUnauthenticate;
+
+//++=======================================================================
+//  API Name:        NwcGetCfgNameServiceProviders
+//
+//  Arguments In:
+//
+//  Arguments Out:
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//
+//  Abstract:
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct {
+	u32 providerCount;
+	u32 providers[MAX_NAME_SERVICE_PROVIDERS];
+
+} NwcGetCfgNameServiceProviders, *PNwcGetCfgNameServiceProviders;
+
+//++=======================================================================
+//  API Name:        NwcNdsResolveNameToId
+//
+//  Arguments In:    connHandle
+//                      Specifies connection to use to resolve name with.
+//
+//                   pName
+//                      Points to the name of the NDS entry to resolve.
+//
+//                   uReqTranType
+//                      Specifies the preferred or required transport to
+//                      be used.
+//
+//                   pResolveInfo
+//                      Points to the NwcNdsResolveInfo structure
+//                      containing information on how the entry is to be
+//                      resolved.
+//
+//  Arguments Out:   pResolveInfo
+//                      Points to the NwcNdsResolveInfo structure
+//                      containing return information on the resolved
+//                      entry.
+//
+//                   pluEntryId
+//                      Points to the resolved name's entry ID.
+//
+//                   pReferral
+//                      Points to the NwcReferral structure which describes
+//                      network addresses that can be used to locate other
+//                      NDS partitions that contain the entry name.
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_CONN_INVALID,
+//                   NWE_BUFFER_OVERFLOW,
+//                   NWE_TRAN_INVALID_TYPE,
+//                   NWE_ACCESS_VIOLATION,
+//                   NWE_UNSUPPORTED_TRAN_TYPE,
+//                   Nds error code
+//
+//  Abstract:        This API resolves a NDS entry name.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcNdsResolveNameToId {
+	NW_CONN_HANDLE connHandle;
+	PNwcString pName;
+	u32 uReqTranType;
+	PNwcResolveInfo pResolveInfo;
+	u32 entryId;
+	PNwcReferral pReferral;
+
+} NwcNdsResolveNameToId, *PNwcNdsResolveNameToId;
+
+//++=======================================================================
+//  API Name:        NwcOrderedRequest
+//
+//  Arguments In:    uFunction - The NCP function that is being called.
+//
+//                   uNumRequestFrags - The number of fragments that the
+//                   request packet has been broken into.
+//
+//                   pRequestFrags - List of fragments that make up the
+//                   request packet.  Each fragment includes the length
+//                   of the fragment data and a pointer to the data.
+//
+//                   uInverseReqCode - The NCP function that will be called
+//                   if the request fails.
+//
+//                   uNumInverseFrags - The number of fragments the inverse
+//                   request packet has been broken into.
+//
+//                   pReplyFrags - List of fragments that make up the
+//                   inverse request packet.  Each fragment includes the length
+//                   of the fragment data and a pointer to the data.
+//
+//  Returns:         STATUS_SUCCESS
+//                   NWE_ACCESS_VIOLATION
+//                   NWE_CONN_INVALID
+//
+//  Abstract:        API for sending raw NCP packets directly to a server.
+//
+//  Notes:
+//
+//  Environment:     PASSIVE_LEVEL, LINUX
+//
+//=======================================================================--
+
+typedef struct tagNwcOrderedRequest {
+	u32 uReqCode;
+	u32 uNumRequestFrags;
+	PNwcFrag pRequestFrags;
+	u32 uInverseReqCode;
+	u32 uNumInverseFrags;
+	PNwcFrag pInverseFrags;
+
+} NwcOrderedRequest, *PNwcOrderedRequest;
+
+#if 1				//sgled
+typedef struct tagNwcUnmapDriveEx {
+//         unsigned long      connHdl;
+	unsigned int linkLen;
+	char linkData[1];
+
+} NwcUnmapDriveEx, *PNwcUnmapDriveEx;
+
+typedef struct tagNwcMapDriveEx {
+	NW_CONN_HANDLE ConnHandle;
+	unsigned int localUid;
+	unsigned int linkOffsetLength;
+	unsigned int linkOffset;
+	unsigned int dirPathOffsetLength;
+	unsigned int dirPathOffset;
+} NwcMapDriveEx, *PNwcMapDriveEx;
+
+typedef struct tagNwcGetBroadcastNotification {
+	u32 uMessageFlags;
+	u32 uConnReference;
+	u32 messageLen;
+	char message[1];
+} NwcGetBroadcastNotification, *PNwcGetBroadcastNotification;
+
+#endif
+#endif /* __NWCLNX_H__ */
--- /dev/null
+++ b/fs/novfs/nwerror.h
@@ -0,0 +1,658 @@
+/*
+ * NetWare Redirector for Linux
+ * Author: Tom Buckley
+ *
+ * This file contains all return error codes.
+ *
+ * Copyright (C) 2005 Novell, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+#ifndef __NOVFS_ERROR_H
+#define __NOVFS_ERROR_H
+
+
+/*
+ * Network errors
+ * Decimal values at end of line are 32768 lower than actual
+ */
+
+#define SHELL_ERROR			0x8800
+#define VLM_ERROR			0x8800
+#define ALREADY_ATTACHED		0x8800	// 0    - Attach attempted to server with valid, existing connection
+#define INVALID_CONNECTION		0x8801	// 1    - Request attempted with invalid or non-attached connection handle
+#define DRIVE_IN_USE			0x8802	// 2    - OS/2 only (NOT USED)
+#define CANT_ADD_CDS			0x8803	// 3    - Map drive attempted but unable to add new current directory structure
+#define DRIVE_CANNOT_MAP		0x8803
+#define BAD_DRIVE_BASE			0x8804	// 4    - Map drive attempted with invalid path specification
+#define NET_READ_ERROR			0x8805	// 5    - Attempt to receive from the selected transport failed
+#define NET_RECV_ERROR			0x8805	// 5
+#define UNKNOWN_NET_ERROR		0x8806	// 6    - Network send attempted with an un-specific network error
+#define SERVER_INVALID_SLOT		0x8807	// 7    - Server request attempted with invalid server connection slot
+#define BAD_SERVER_SLOT			0x8807	// 7
+#define NO_SERVER_SLOTS			0x8808	// 8    - Attach attempted to server with no connection slots available
+#define NET_WRITE_ERROR			0x8809	// 9    - Attempt to send on the selected transport failed
+#define CONNECTION_IN_ERROR_STATE	0x8809	// Client-32
+#define NET_SEND_ERROR			0x8809	// 9
+#define SERVER_NO_ROUTE			0x880A	// 10 - Attempted to find route to server where no route exists
+#define BAD_LOCAL_TARGET		0x880B	// 11 - OS/2 only
+#define TOO_MANY_REQ_FRAGS		0x880C	// 12 - Attempted request with too many request fragments specified
+#define CONNECT_LIST_OVERFLOW		0x880D	// 13
+#define BUFFER_OVERFLOW			0x880E	// 14 - Attempt to receive more data than the reply buffer had room for
+#define MORE_DATA_ERROR			0x880E	// Client-32
+#define NO_CONN_TO_SERVER		0x880F	// 15
+#define NO_CONNECTION_TO_SERVER		0x880F	// 15 - Attempt to get connection for a server not connected
+#define NO_ROUTER_FOUND			0x8810	// 16 - OS/2 only
+#define BAD_FUNC_ERROR			0x8811	// 17
+#define INVALID_SHELL_CALL		0x8811	// 17 - Attempted function call to non- existent or illegal function
+#define SCAN_COMPLETE			0x8812
+#define LIP_RESIZE_ERROR		0x8812	// Client-32
+#define UNSUPPORTED_NAME_FORMAT_TYPE	0x8813
+#define INVALID_DIR_HANDLE		0x8813	// Client-32
+#define HANDLE_ALREADY_LICENSED		0x8814
+#define OUT_OF_CLIENT_MEMORY		0x8814	// Client-32
+#define HANDLE_ALREADY_UNLICENSED	0x8815
+#define PATH_NOT_OURS			0x8815	// Client-32
+#define INVALID_NCP_PACKET_LENGTH	0x8816
+#define PATH_IS_PRINT_DEVICE		0x8816	// Client-32
+#define SETTING_UP_TIMEOUT		0x8817
+#define PATH_IS_EXCLUDED_DEVICE		0x8817	// Client-32
+#define SETTING_SIGNALS			0x8818
+#define PATH_IS_INVALID			0x8818	// Client-32
+#define SERVER_CONNECTION_LOST		0x8819
+#define NOT_SAME_DEVICE			0x8819	// Client-32
+#define OUT_OF_HEAP_SPACE		0x881A
+#define INVALID_SERVICE_REQUEST		0x881B
+#define INVALID_SEARCH_HANDLE		0x881B	// Client-32
+#define INVALID_TASK_NUMBER		0x881C
+#define INVALID_DEVICE_HANDLE		0x881C	// Client-32
+#define INVALID_MESSAGE_LENGTH		0x881D
+#define INVALID_SEM_HANDLE		0x881D	// Client-32
+#define EA_SCAN_DONE			0x881E
+#define INVALID_CFG_HANDLE		0x881E	// Client-32
+#define BAD_CONNECTION_NUMBER		0x881F
+#define INVALID_MOD_HANDLE		0x881F	// Client-32
+#define ASYN_FIRST_PASS			0x8820
+#define INVALID_DEVICE_INDEX		0x8821
+#define INVALID_CONN_HANDLE		0x8822
+#define INVALID_QUEUE_ID		0x8823
+#define INVALID_PDEVICE_HANDLE		0x8824
+#define INVALID_JOB_HANDLE		0x8825
+#define INVALID_ELEMENT_ID		0x8826
+#define ALIAS_NOT_FOUND			0x8827
+#define RESOURCE_SUSPENDED		0x8828
+#define INVALID_QUEUE_SPECIFIED		0x8829
+#define DEVICE_ALREADY_OPEN		0x882A
+#define JOB_ALREADY_OPEN		0x882B
+#define QUEUE_NAME_ID_MISMATCH		0x882C
+#define JOB_ALREADY_STARTED		0x882D
+#define SPECT_DAA_TYPE_NOT_SUPPORTED	0x882E
+#define INVALID_ENVIR_HANDLE		0x882F
+#define NOT_SAME_CONNECTION		0x8830	// 48 - Internal server request attempted accross different server connections
+#define PRIMARY_CONNECTION_NOT_SET	0x8831	// 49 - Attempt to retrieve default connection with no primary connection set
+#define NO_PRIMARY_SET			0x8831	// 49
+#define KEYWORD_NOT_FOUND		0x8832	// Client-32
+#define PRINT_CAPTURE_NOT_IN_PROGRESS	0x8832	// Client-32
+#define NO_CAPTURE_SET			0x8832	// 50
+#define NO_CAPTURE_IN_PROGRESS		0x8832	// 50 - Capture information requested on port with no capture in progress
+#define BAD_BUFFER_LENGTH		0x8833	// 51
+#define INVALID_BUFFER_LENGTH		0x8833	// 51 - Used to indicate length which caller requested on a GetDNC or SetDNC was too large
+#define NO_USER_NAME			0x8834	// 52
+#define NO_NETWARE_PRINT_SPOOLER	0x8835	// 53 - Capture requested without having the local print spooler installed
+#define INVALID_PARAMETER		0x8836	// 54 - Attempted function with an invalid function parameter specified
+#define CONFIG_FILE_OPEN_FAILED		0x8837	// 55 - OS/2 only
+#define NO_CONFIG_FILE			0x8838	// 56 - OS/2 only
+#define CONFIG_FILE_READ_FAILED		0x8839	// 57 - OS/2 only
+#define CONFIG_LINE_TOO_LONG		0x883A	// 58 - OS/2 only
+#define CONFIG_LINES_IGNORED		0x883B	// 59 - OS/2 only
+#define NOT_MY_RESOURCE			0x883C	// 60 - Attempted request made with a parameter using foriegn resource
+#define DAEMON_INSTALLED		0x883D	// 61 - OS/2 only
+#define SPOOLER_INSTALLED		0x883E	// 62 - Attempted load of print spooler with print spooler already installed
+#define CONN_TABLE_FULL			0x883F	// 63
+#define CONNECTION_TABLE_FULL		0x883F	// 63 - Attempted to allocate a connection handle with no more local connection table entries
+#define CONFIG_SECTION_NOT_FOUND	0x8840	// 64 - OS/2 only
+#define BAD_TRAN_TYPE			0x8841	// 65
+#define INVALID_TRANSPORT_TYPE		0x8841	// 65 - Attempted function on a connection with an invalid transport selected
+#define TDS_TAG_IN_USE			0x8842	// 66 - OS/2 only
+#define TDS_OUT_OF_MEMORY		0x8843	// 67 - OS/2 only
+#define TDS_INVALID_TAG			0x8844	// 68 - Attempted TDS function with invalid tag
+#define TDS_WRITE_TRUNCATED		0x8845	// 69 - Attempted TDS write with buffer that exceeded buffer
+#define NO_CONNECTION_TO_DS		0x8846	// Client-32
+#define NO_DIRECTORY_SERVICE_CONNECTION	0x8846	// 70
+#define SERVICE_BUSY			0x8846	// 70 - Attempted request made to partially asynchronous function in busy state
+#define NO_SERVER_ERROR			0x8847	// 71 - Attempted connect failed to find any servers responding
+#define BAD_VLM_ERROR			0x8848	// 72 - Attempted function call to non-existant or not-loaded overlay
+#define NETWORK_DRIVE_IN_USE		0x8849	// 73 - Attempted map to network drive that was already mapped
+#define LOCAL_DRIVE_IN_USE		0x884A	// 74 - Attempted map to local drive that was in use
+#define NO_DRIVES_AVAILABLE		0x884B	// 75 - Attempted map to next available drive when none were available
+#define DEVICE_NOT_REDIRECTED		0x884C	// 76 - The device is not redirected
+#define NO_MORE_SFT_ENTRIES		0x884D	// 77 - Maximum number of files was reached
+#define UNLOAD_ERROR			0x884E	// 78 - Attempted unload failed
+#define IN_USE_ERROR			0x884F	// 79 - Attempted re-use of already in use connection entry
+#define TOO_MANY_REP_FRAGS		0x8850	// 80 - Attempted request with too many reply fragments specified
+#define TABLE_FULL			0x8851	// 81 - Attempted to add a name into the name table after it was full
+#ifndef SOCKET_NOT_OPEN
+#define SOCKET_NOT_OPEN			0x8852	// 82 - Listen was posted on unopened socket
+#endif
+#define MEM_MGR_ERROR			0x8853	// 83 - Attempted enhanced memory operation failed
+#define SFT3_ERROR			0x8854	// 84 - An SFT3 switch occured mid-transfer
+#define PREFERRED_NOT_FOUND		0x8855	// 85 - the preferred directory server was not established but another directory server was returned
+#define DEVICE_NOT_RECOGNIZED		0x8856	// 86 - used to determine if the device is not used by VISE so pass it on to the next redirector, if any.
+#define BAD_NET_TYPE			0x8857	// 87 - the network type (Bind/NDS) does not match the server version
+#define ERROR_OPENING_FILE		0x8858	// 88 - generic open failure error, invalid path, access denied, etc..
+#define NO_PREFERRED_SPECIFIED		0x8859	// 89 - no preferred name specified
+#define ERROR_OPENING_SOCKET		0x885A	// 90 - error opening a socket
+#define REQUESTER_FAILURE		0x885A	// Client-32
+#define RESOURCE_ACCESS_DENIED		0x885B	// Client-32
+#define SIGNATURE_LEVEL_CONFLICT	0x8861
+#define NO_LOCK_FOUND			0x8862	// OS/2 - process lock on conn handle failed, process ID not recognized
+#define LOCK_TABLE_FULL			0x8863	// OS/2 - process lock on conn handle failed, process lock table full
+#define INVALID_MATCH_DATA		0x8864
+#define MATCH_FAILED			0x8865
+#define NO_MORE_ENTRIES			0x8866
+#define INSUFFICIENT_RESOURCES		0x8867
+#define STRING_TRANSLATION		0x8868
+#define STRING_TRANSLATION_NEEDED	0x8868	// Client-32
+#define ACCESS_VIOLATION		0x8869
+#define NOT_AUTHENTICATED		0x886A
+#define INVALID_LEVEL			0x886B
+#define RESOURCE_LOCK_ERROR		0x886C
+#define INVALID_NAME_FORMAT		0x886D
+#define OBJECT_EXISTS			0x886E
+#define OBJECT_NOT_FOUND		0x886F
+#define UNSUPPORTED_TRAN_TYPE		0x8870
+#define INVALID_STRING_TYPE		0x8871
+#define INVALID_OWNER			0x8872
+#define UNSUPPORTED_AUTHENTICATOR	0x8873
+#define IO_PENDING			0x8874
+#define INVALID_DRIVE_NUM		0x8875
+#define SHELL_FAILURE			0x88FF
+#define VLM_FAILURE			0x88FF
+
+#define SVC_ALREADY_REGISTERED		0x8880	// Client-32
+#define SVC_REGISTRY_FULL		0x8881	// Client-32
+#define SVC_NOT_REGISTERED		0x8882	// Client-32
+#define OUT_OF_RESOURCES		0x8883	// Client-32
+#define RESOLVE_SVC_FAILED		0x8884	// Client-32
+#define CONNECT_FAILED			0x8885	// Client-32
+#define PROTOCOL_NOT_BOUND		0x8886	// Client-32
+#define AUTHENTICATION_FAILED		0x8887	// Client-32
+#define INVALID_AUTHEN_HANDLE		0x8888	// Client-32
+#define AUTHEN_HANDLE_ALREADY_EXISTS	0x8889	// Client-32
+
+#define DIFF_OBJECT_ALREADY_AUTHEN	0x8890	// Client-32
+#define REQUEST_NOT_SERVICEABLE		0x8891	// Client-32
+#define AUTO_RECONNECT_SO_REBUILD	0x8892	// Client-32
+#define AUTO_RECONNECT_RETRY_REQUEST	0x8893	// Client-32
+#define ASYNC_REQUEST_IN_USE		0x8894	// Client-32
+#define ASYNC_REQUEST_CANCELED		0x8895	// Client-32
+#define SESS_SVC_ALREADY_REGISTERED	0x8896	// Client-32
+#define SESS_SVC_NOT_REGISTERED		0x8897	// Client-32
+#define PREVIOUSLY_AUTHENTICATED	0x8899	// Client-32
+#define RESOLVE_SVC_PARTIAL		0x889A	// Client-32
+#define NO_DEFAULT_SPECIFIED		0x889B	// Client-32
+#define HOOK_REQUEST_NOT_HANDLED	0x889C	// Client-32
+#define HOOK_REQUEST_BUSY		0x889D	// Client-32
+#define HOOK_REQUEST_QUEUED		0x889D	// Client-32
+#define AUTO_RECONNECT_SO_IGNORE	0x889E	// Client-32
+#define ASYNC_REQUEST_NOT_IN_USE	0x889F	// Client-32
+#define AUTO_RECONNECT_FAILURE		0x88A0	// Client-32
+#define NET_ERROR_ABORT_APPLICATION	0x88A1	// Client-32
+#define NET_ERROR_SUSPEND_APPLICATION	0x88A2	// Client-32
+#define NET_ERROR_ABORTED_PROCESS_GROUP	0x88A3	// Client-32
+#define NET_ERROR_PASSWORD_HAS_EXPIRED	0x88A5	// Client-32
+#define NET_ERROR_NETWORK_INACTIVE	0x88A6	// Client-32
+#define REPLY_TRUNCATED			0x88E6	// 230 NLM
+#define UTF8_CONVERSION_FAILED		0x88F0	// NWCALLS
+
+/*
+ * Server Errors
+ */
+
+#define ERR_INSUFFICIENT_SPACE		0x8901	// 001
+#define NLM_INVALID_CONNECTION		0x890A	// 010
+#define ERR_TIMEOUT			0x8910	// 016 - nlm connection timeout
+#define ERR_NO_MORE_ENTRY		0x8914	// 020
+#define ERR_BUFFER_TOO_SMALL		0x8977	// 119
+#define ERR_VOLUME_FLAG_NOT_SET		0x8978	// 120 the service requested, not avail. on the selected vol.
+#define ERR_NO_ITEMS_FOUND		0x8979	// 121
+#define ERR_CONN_ALREADY_TEMP		0x897A	// 122
+#define ERR_CONN_ALREADY_LOGGED_IN	0x897B	// 123
+#define ERR_CONN_NOT_AUTHENTICATED	0x897C	// 124
+#define ERR_CONN_NOT_LOGGED_IN		0x897D	// 125
+#define NCP_BOUNDARY_CHECK_FAILED	0x897E	// 126
+#define ERR_LOCK_WAITING		0x897F	// 127
+#define ERR_LOCK_FAIL			0x8980	// 128
+#define FILE_IN_USE_ERROR		0x8980	// 128
+#define NO_MORE_FILE_HANDLES		0x8981	// 129
+#define NO_OPEN_PRIVILEGES		0x8982	// 130
+#define IO_ERROR_NETWORK_DISK		0x8983	// 131
+#define ERR_AUDITING_HARD_IO_ERROR	0x8983	// 131
+#define NO_CREATE_PRIVILEGES		0x8984	// 132
+#define ERR_AUDITING_NOT_SUPV		0x8984	// 132
+#define NO_CREATE_DELETE_PRIVILEGES	0x8985	// 133
+#define CREATE_FILE_EXISTS_READ_ONLY	0x8986	// 134
+#define WILD_CARDS_IN_CREATE_FILE_NAME	0x8987	// 135
+#define CREATE_FILENAME_ERROR		0x8987	// 135
+#define INVALID_FILE_HANDLE		0x8988	// 136
+#define NO_SEARCH_PRIVILEGES		0x8989	// 137
+#define NO_DELETE_PRIVILEGES		0x898A	// 138
+#define NO_RENAME_PRIVILEGES		0x898B	// 139
+#define NO_MODIFY_PRIVILEGES		0x898C	// 140
+#define SOME_FILES_AFFECTED_IN_USE	0x898D	// 141
+#define NO_FILES_AFFECTED_IN_USE	0x898E	// 142
+#define SOME_FILES_AFFECTED_READ_ONLY	0x898F	// 143
+#define NO_FILES_AFFECTED_READ_ONLY	0x8990	// 144
+#define SOME_FILES_RENAMED_NAME_EXISTS	0x8991	// 145
+#define NO_FILES_RENAMED_NAME_EXISTS	0x8992	// 146
+#define NO_READ_PRIVILEGES		0x8993	// 147
+#define NO_WRITE_PRIVILEGES_OR_READONLY	0x8994	// 148
+#define FILE_DETACHED			0x8995	// 149
+#define SERVER_OUT_OF_MEMORY		0x8996	// 150
+#define ERR_TARGET_NOT_A_SUBDIRECTORY	0x8996	// 150 can be changed later (note written by server people).
+#define NO_DISK_SPACE_FOR_SPOOL_FILE	0x8997	// 151
+#define ERR_AUDITING_NOT_ENABLED	0x8997	// 151
+#define VOLUME_DOES_NOT_EXIST		0x8998	// 152
+#define DIRECTORY_FULL			0x8999	// 153
+#define RENAMING_ACROSS_VOLUMES		0x899A	// 154
+#define BAD_DIRECTORY_HANDLE		0x899B	// 155
+#define INVALID_PATH			0x899C	// 156
+#define NO_MORE_TRUSTEES		0x899C	// 156
+#define NO_MORE_DIRECTORY_HANDLES	0x899D	// 157
+#define INVALID_FILENAME		0x899E	// 158
+#define DIRECTORY_ACTIVE		0x899F	// 159
+#define DIRECTORY_NOT_EMPTY		0x89A0	// 160
+#define DIRECTORY_IO_ERROR		0x89A1	// 161
+#define READ_FILE_WITH_RECORD_LOCKED	0x89A2	// 162
+#define ERR_TRANSACTION_RESTARTED	0x89A3	// 163
+#define ERR_RENAME_DIR_INVALID		0x89A4	// 164
+#define ERR_INVALID_OPENCREATE_MODE	0x89A5	// 165
+#define ERR_ALREADY_IN_USE		0x89A6	// 166
+#define ERR_AUDITING_ACTIVE		0x89A6	// 166
+#define ERR_INVALID_RESOURCE_TAG	0x89A7	// 167
+#define ERR_ACCESS_DENIED		0x89A8	// 168
+#define ERR_AUDITING_NO_RIGHTS		0x89A8	// 168
+#define ERR_LINK_IN_PATH		0x89A9	// 169
+#define INVALID_DATA_TYPE		0x89AA	// 170
+#define INVALID_DATA_STREAM		0x89BE	// 190
+#define INVALID_NAME_SPACE		0x89BF	// 191
+#define NO_ACCOUNTING_PRIVILEGES	0x89C0	// 192
+#define LOGIN_DENIED_NO_ACCOUNT_BALANCE	0x89C1	// 193
+#define LOGIN_DENIED_NO_CREDIT		0x89C2	// 194
+#define ERR_AUDITING_RECORD_SIZE	0x89C2	// 194
+#define ERR_TOO_MANY_HOLDS		0x89C3	// 195
+#define ACCOUNTING_DISABLED		0x89C4	// 196
+#define INTRUDER_DETECTION_LOCK		0x89C5	// 197
+#define NO_CONSOLE_OPERATOR		0x89C6	// 198
+#define NO_CONSOLE_PRIVILEGES		0x89C6	// 198
+#define ERR_Q_IO_FAILURE		0x89D0	// 208
+#define ERR_NO_QUEUE			0x89D1	// 209
+#define ERR_NO_Q_SERVER			0x89D2	// 210
+#define ERR_NO_Q_RIGHTS			0x89D3	// 211
+#define ERR_Q_FULL			0x89D4	// 212
+#define ERR_NO_Q_JOB			0x89D5	// 213
+#define ERR_NO_Q_JOB_RIGHTS		0x89D6	// 214
+#define ERR_Q_IN_SERVICE		0x89D7	// 215
+#define PASSWORD_NOT_UNIQUE		0x89D7	// 215
+#define ERR_Q_NOT_ACTIVE		0x89D8	// 216
+#define PASSWORD_TOO_SHORT		0x89D8	// 216
+#define ERR_Q_STN_NOT_SERVER		0x89D9	// 217
+#define LOGIN_DENIED_NO_CONNECTION	0x89D9	// 217
+#define ERR_MAXIMUM_LOGINS_EXCEEDED	0x89D9	// 217
+#define ERR_Q_HALTED			0x89DA	// 218
+#define UNAUTHORIZED_LOGIN_TIME		0x89DA	// 218
+#define UNAUTHORIZED_LOGIN_STATION	0x89DB	// 219
+#define ERR_Q_MAX_SERVERS		0x89DB	// 219
+#define ACCOUNT_DISABLED		0x89DC	// 220
+#define PASSWORD_HAS_EXPIRED_NO_GRACE	0x89DE	// 222
+#define PASSWORD_HAS_EXPIRED		0x89DF	// 223
+#define E_NO_MORE_USERS			0x89E7	// 231
+#define NOT_ITEM_PROPERTY		0x89E8	// 232
+#define WRITE_PROPERTY_TO_GROUP		0x89E8	// 232
+#define MEMBER_ALREADY_EXISTS		0x89E9	// 233
+#define NO_SUCH_MEMBER			0x89EA	// 234
+#define NOT_GROUP_PROPERTY		0x89EB	// 235
+#define NO_SUCH_SEGMENT			0x89EC	// 236
+#define PROPERTY_ALREADY_EXISTS		0x89ED	// 237
+#define OBJECT_ALREADY_EXISTS		0x89EE	// 238
+#define INVALID_NAME			0x89EF	// 239
+#define WILD_CARD_NOT_ALLOWED		0x89F0	// 240
+#define INVALID_BINDERY_SECURITY	0x89F1	// 241
+#define NO_OBJECT_READ_PRIVILEGE	0x89F2	// 242
+#define NO_OBJECT_RENAME_PRIVILEGE	0x89F3	// 243
+#define NO_OBJECT_DELETE_PRIVILEGE	0x89F4	// 244
+#define NO_OBJECT_CREATE_PRIVILEGE	0x89F5	// 245
+#define NO_PROPERTY_DELETE_PRIVILEGE	0x89F6	// 246
+#define NO_PROPERTY_CREATE_PRIVILEGE	0x89F7	// 247
+#define NO_PROPERTY_WRITE_PRIVILEGE	0x89F8	// 248
+#define NO_FREE_CONNECTION_SLOTS	0x89F9	// 249
+#define NO_PROPERTY_READ_PRIVILEGE	0x89F9	// 249
+#define NO_MORE_SERVER_SLOTS		0x89FA	// 250
+#define TEMP_REMAP_ERROR		0x89FA	// 250
+#define INVALID_PARAMETERS		0x89FB	// 251
+#define NO_SUCH_PROPERTY		0x89FB	// 251
+#define ERR_NCP_NOT_SUPPORTED		0x89FB	// 251
+#define INTERNET_PACKET_REQT_CANCELED	0x89FC	// 252
+#define UNKNOWN_FILE_SERVER		0x89FC	// 252
+#define MESSAGE_QUEUE_FULL		0x89FC	// 252
+#define NO_SUCH_OBJECT			0x89FC	// 252
+#define LOCK_COLLISION			0x89FD	// 253
+#define BAD_STATION_NUMBER		0x89FD	// 253
+#define INVALID_PACKET_LENGTH		0x89FD	// 253
+#define UNKNOWN_REQUEST			0x89FD	// 253
+#define BINDERY_LOCKED			0x89FE	// 254
+#define TRUSTEE_NOT_FOUND		0x89FE	// 254
+#define DIRECTORY_LOCKED		0x89FE	// 254
+#define INVALID_SEMAPHORE_NAME_LENGTH	0x89FE	// 254
+#define PACKET_NOT_DELIVERABLE		0x89FE	// 254
+#define SERVER_BINDERY_LOCKED		0x89FE	// 254
+#define SOCKET_TABLE_FULL		0x89FE	// 254
+#define SPOOL_DIRECTORY_ERROR		0x89FE	// 254
+#define SUPERVISOR_HAS_DISABLED_LOGIN	0x89FE	// 254
+#define TIMEOUT_FAILURE			0x89FE	// 254
+#define BAD_PRINTER_ERROR		0x89FF	// 255
+#define BAD_RECORD_OFFSET		0x89FF	// 255
+#define CLOSE_FCB_ERROR			0x89FF	// 255
+#define FILE_EXTENSION_ERROR		0x89FF	// 255
+#define FILE_NAME_ERROR			0x89FF	// 255
+#define HARDWARE_FAILURE		0x89FF	// 255
+#define INVALID_DRIVE_NUMBER		0x89FF	// 255
+#define DOS_INVALID_DRIVE		0x000F	// 255
+#define INVALID_INITIAL_SEMAPHORE_VALUE	0x89FF	// 255
+#define INVALID_SEMAPHORE_HANDLE	0x89FF	// 255
+#define IO_BOUND_ERROR			0x89FF	// 255
+#define NO_FILES_FOUND_ERROR		0x89FF	// 255
+#define NO_RESPONSE_FROM_SERVER		0x89FF	// 255
+#define NO_SUCH_OBJECT_OR_BAD_PASSWORD	0x89FF	// 255
+#define PATH_NOT_LOCATABLE		0x89FF	// 255
+#define QUEUE_FULL_ERROR		0x89FF	// 255
+#define REQUEST_NOT_OUTSTANDING		0x89FF	// 255
+#ifndef SOCKET_ALREADY_OPEN
+#define SOCKET_ALREADY_OPEN		0x89FF	// 255
+#endif
+#define LOCK_ERROR			0x89FF	// 255
+#ifndef FAILURE
+#define FAILURE				0x89FF	// 255 Generic Failure
+#endif
+
+#if 0
+#define NOT_SAME_LOCAL_DRIVE		0x89F6
+#define TARGET_DRIVE_NOT_LOCAL	0x89F7
+#define ALREADY_ATTACHED_TO_SERVER	0x89F8	// 248
+#define NOT_ATTACHED_TO_SERVER	0x89F8
+#endif
+
+/*
+ * Network errors
+ * Decimal values at end of line are 32768 lower than actual
+ */
+#define NWE_ALREADY_ATTACHED		0x8800	// 0    - Attach attempted to server with valid, existing connection
+#define NWE_CONN_INVALID		0x8801	// 1    - Request attempted with invalid or non-attached connection handle
+#define NWE_DRIVE_IN_USE		0x8802	// 2    - OS/2 only (NOT USED)
+#define NWE_DRIVE_CANNOT_MAP		0x8803	// 3    - Map drive attempted but unable to add new current directory structure
+#define NWE_DRIVE_BAD_PATH		0x8804	// 4    - Map drive attempted with invalid path specification
+#define NWE_NET_RECEIVE			0x8805	// 5    - Attempt to receive from the selected transport failed
+#define NWE_NET_UNKNOWN			0x8806	// 6    - Network send attempted with an un-specific network error
+#define NWE_SERVER_BAD_SLOT		0x8807	// 7    - Server request attempted with invalid server connection slot
+#define NWE_SERVER_NO_SLOTS		0x8808	// 8    - Attach attempted to server with no connection slots available
+#define NWE_NET_SEND			0x8809	// 9    - Attempt to send on the selected transport failed
+#define NWE_SERVER_NO_ROUTE		0x880A	// 10 - Attempted to find route to server where no route exists
+#define NWE_BAD_LOCAL_TARGET		0x880B	// 11 - OS/2 only
+#define NWE_REQ_TOO_MANY_REQ_FRAGS	0x880C	// 12 - Attempted request with too many request fragments specified
+#define NWE_CONN_LIST_OVERFLOW		0x880D	// 13
+#define NWE_BUFFER_OVERFLOW		0x880E	// 14 - Attempt to receive more data than the reply buffer had room for
+#define NWE_SERVER_NO_CONN		0x880F	// 15 - Attempt to get connection for a server not connected
+#define NWE_NO_ROUTER_FOUND		0x8810	// 16 - OS/2 only
+#define NWE_FUNCTION_INVALID		0x8811	// 17 - Attempted function call to non- existent or illegal function
+#define NWE_SCAN_COMPLETE		0x8812
+#define NWE_UNSUPPORTED_NAME_FORMAT_TYP	0x8813
+#define NWE_HANDLE_ALREADY_LICENSED	0x8814
+#define NWE_HANDLE_ALREADY_UNLICENSED	0x8815
+#define NWE_INVALID_NCP_PACKET_LENGTH	0x8816
+#define NWE_SETTING_UP_TIMEOUT		0x8817
+#define NWE_SETTING_SIGNALS		0x8818
+#define NWE_SERVER_CONNECTION_LOST	0x8819
+#define NWE_OUT_OF_HEAP_SPACE		0x881A
+#define NWE_INVALID_SERVICE_REQUEST	0x881B
+#define NWE_INVALID_TASK_NUMBER		0x881C
+#define NWE_INVALID_MESSAGE_LENGTH	0x881D
+#define NWE_EA_SCAN_DONE		0x881E
+#define NWE_BAD_CONNECTION_NUMBER	0x881F
+#define NWE_MULT_TREES_NOT_SUPPORTED	0x8820	// 32 - Attempt to open a connection to a DS tree other than the default tree
+#define NWE_CONN_NOT_SAME		0x8830	// 48 - Internal server request attempted across different server connections
+#define NWE_CONN_PRIMARY_NOT_SET	0x8831	// 49 - Attempt to retrieve default connection with no primary connection set
+#define NWE_PRN_CAPTURE_NOT_IN_PROGRESS	0x8832	// 50 - Capture information requested on port with no capture in progress
+#define NWE_BUFFER_INVALID_LEN		0x8833	// 51 - Used to indicate length which caller requested on a GetDNC or SetDNC was too large
+#define NWE_USER_NO_NAME		0x8834	// 52
+#define NWE_PRN_NO_LOCAL_SPOOLER	0x8835	// 53 - Capture requested without having the local print spooler installed
+#define NWE_PARAM_INVALID		0x8836	// 54 - Attempted function with an invalid function parameter specified
+#define NWE_CFG_OPEN_FAILED		0x8837	// 55 - OS/2 only
+#define NWE_CFG_NO_FILE			0x8838	// 56 - OS/2 only
+#define NWE_CFG_READ_FAILED		0x8839	// 57 - OS/2 only
+#define NWE_CFG_LINE_TOO_LONG		0x883A	// 58 - OS/2 only
+#define NWE_CFG_LINES_IGNORED		0x883B	// 59 - OS/2 only
+#define NWE_RESOURCE_NOT_OWNED		0x883C	// 60 - Attempted request made with a parameter using foriegn resource
+#define NWE_DAEMON_INSTALLED		0x883D	// 61 - OS/2 only
+#define NWE_PRN_SPOOLER_INSTALLED	0x883E	// 62 - Attempted load of print spooler with print spooler already installed
+#define NWE_CONN_TABLE_FULL		0x883F	// 63 - Attempted to allocate a connection handle with no more local connection table entries
+#define NWE_CFG_SECTION_NOT_FOUND	0x8840	// 64 - OS/2 only
+#define NWE_TRAN_INVALID_TYPE		0x8841	// 65 - Attempted function on a connection with an invalid transport selected
+#define NWE_TDS_TAG_IN_USE		0x8842	// 66 - OS/2 only
+#define NWE_TDS_OUT_OF_MEMORY		0x8843	// 67 - OS/2 only
+#define NWE_TDS_INVALID_TAG		0x8844	// 68 - Attempted TDS function with invalid tag
+#define NWE_TDS_WRITE_TRUNCATED		0x8845	// 69 - Attempted TDS write with buffer that exceeded buffer
+#define NWE_DS_NO_CONN			0x8846	// 70
+#define NWE_SERVICE_BUSY		0x8846	// 70 - Attempted request made to partially asynchronous function in busy state
+#define NWE_SERVER_NOT_FOUND		0x8847	// 71 - Attempted connect failed to find any servers responding
+#define NWE_VLM_INVALID			0x8848	// 72 - Attempted function call to non-existant or not-loaded overlay
+#define NWE_DRIVE_ALREADY_MAPPED	0x8849	// 73 - Attempted map to network drive that was already mapped
+#define NWE_DRIVE_LOCAL_IN_USE		0x884A	// 74 - Attempted map to local drive that was in use
+#define NWE_DRIVE_NONE_AVAILABLE	0x884B	// 75 - Attempted map to next available drive when none were available
+#define NWE_DEVICE_NOT_REDIRECTED	0x884C	// 76 - The device is not redirected
+#define NWE_FILE_MAX_REACHED		0x884D	// 77 - Maximum number of files was reached
+#define NWE_UNLOAD_FAILED		0x884E	// 78 - Attempted unload failed
+#define NWE_CONN_IN_USE			0x884F	// 79 - Attempted re-use of already in use connection entry
+#define NWE_REQ_TOO_MANY_REP_FRAGS	0x8850	// 80 - Attempted request with too many reply fragments specified
+#define NWE_NAME_TABLE_FULL		0x8851	// 81 - Attempted to add a name into the name table after it was full
+#define NWE_SOCKET_NOT_OPEN		0x8852	// 82 - Listen was posted on unopened socket
+#define NWE_MEMORY_MGR_ERROR		0x8853	// 83 - Attempted enhanced memory operation failed
+#define NWE_SFT3_ERROR			0x8854	// 84 - An SFT3 switch occured mid-transfer
+#define NWE_DS_PREFERRED_NOT_FOUND	0x8855	// 85 - the preferred directory server was not established but another directory server was returned
+#define NWE_DEVICE_NOT_RECOGNIZED	0x8856	// 86 - used to determine if the device is not used by VISE so pass it on to the next redirector, if any.
+#define NWE_NET_INVALID_TYPE		0x8857	// 87 - the network type (Bind/NDS) does not match the server version
+#define NWE_FILE_OPEN_FAILED		0x8858	// 88 - generic open failure error, invalid path, access denied, etc..
+#define NWE_DS_PREFERRED_NOT_SPECIFIED	0x8859	// 89 - no preferred name specified
+#define NWE_SOCKET_OPEN_FAILED		0x885A	// 90 - error opening a socket
+#define NWE_SIGNATURE_LEVEL_CONFLICT	0x8861
+#define NWE_NO_LOCK_FOUND		0x8862	// OS/2 - process lock on conn handle failed, process ID not recognized
+#define NWE_LOCK_TABLE_FULL		0x8863	// OS/2 - process lock on conn handle failed, process lock table full
+#define NWE_INVALID_MATCH_DATA		0x8864
+#define NWE_MATCH_FAILED		0x8865
+#define NWE_NO_MORE_ENTRIES		0x8866
+#define NWE_INSUFFICIENT_RESOURCES	0x8867
+#define NWE_STRING_TRANSLATION		0x8868
+#define NWE_ACCESS_VIOLATION		0x8869
+#define NWE_NOT_AUTHENTICATED		0x886A
+#define NWE_INVALID_LEVEL		0x886B
+#define NWE_RESOURCE_LOCK		0x886C
+#define NWE_INVALID_NAME_FORMAT		0x886D
+#define NWE_OBJECT_EXISTS		0x886E
+#define NWE_OBJECT_NOT_FOUND		0x886F
+#define NWE_UNSUPPORTED_TRAN_TYPE	0x8870
+#define NWE_INVALID_STRING_TYPE		0x8871
+#define NWE_INVALID_OWNER		0x8872
+#define NWE_UNSUPPORTED_AUTHENTICATOR	0x8873
+#define NWE_IO_PENDING			0x8874
+#define NWE_INVALID_DRIVE_NUMBER	0x8875
+#define NWE_REPLY_TRUNCATED		0x88e6	// 230 NLM
+#define NWE_REQUESTER_FAILURE		0x88FF
+
+/*
+ * Server Errors
+ */
+#define NWE_INSUFFICIENT_SPACE		0x8901	// 001
+#define NWE_INVALID_CONNECTION		0x890a	// 010 - nlm invalid connection
+#define NWE_TIMEOUT			0x8910	// 016 - nlm connection timeout
+#define NWE_NO_MORE_ENTRY		0x8914	// 020
+#define NWE_BUFFER_TOO_SMALL		0x8977	// 119
+#define NWE_VOL_FLAG_NOT_SET		0x8978	// 120 the service requested, not avail. on the selected vol.
+#define NWE_NO_ITEMS_FOUND		0x8979	// 121
+#define NWE_CONN_ALREADY_TEMP		0x897a	// 122
+#define NWE_CONN_ALREADY_LOGGED_IN	0x897b	// 123
+#define NWE_CONN_NOT_AUTHENTICATED	0x897c	// 124
+#define NWE_CONN_NOT_LOGGED_IN		0x897d	// 125
+#define NWE_NCP_BOUNDARY_CHECK_FAILED	0x897e	// 126
+#define NWE_LOCK_WAITING		0x897f	// 127
+#define NWE_LOCK_FAIL			0x8980	// 128
+#define NWE_FILE_IN_USE			0x8980	// 128
+#define NWE_FILE_NO_HANDLES		0x8981	// 129
+#define NWE_FILE_NO_OPEN_PRIV		0x8982	// 130
+#define NWE_DISK_IO_ERROR		0x8983	// 131
+#define NWE_AUDITING_HARD_IO_ERROR	0x8983	// 131
+#define NWE_FILE_NO_CREATE_PRIV		0x8984	// 132
+#define NWE_AUDITING_NOT_SUPV		0x8984	// 132
+#define NWE_FILE_NO_CREATE_DEL_PRIV	0x8985	// 133
+#define NWE_FILE_EXISTS_READ_ONLY	0x8986	// 134
+#define NWE_FILE_WILD_CARDS_IN_NAME	0x8987	// 135
+#define NWE_FILE_INVALID_HANDLE		0x8988	// 136
+#define NWE_FILE_NO_SRCH_PRIV		0x8989	// 137
+#define NWE_FILE_NO_DEL_PRIV		0x898A	// 138
+#define NWE_FILE_NO_RENAME_PRIV		0x898B	// 139
+#define NWE_FILE_NO_MOD_PRIV		0x898C	// 140
+#define NWE_FILE_SOME_IN_USE		0x898D	// 141
+#define NWE_FILE_NONE_IN_USE		0x898E	// 142
+#define NWE_FILE_SOME_READ_ONLY		0x898F	// 143
+#define NWE_FILE_NONE_READ_ONLY		0x8990	// 144
+#define NWE_FILE_SOME_RENAMED_EXIST	0x8991	// 145
+#define NWE_FILE_NONE_RENAMED_EXIST	0x8992	// 146
+#define NWE_FILE_NO_READ_PRIV		0x8993	// 147
+#define NWE_FILE_NO_WRITE_PRIV		0x8994	// 148
+#define NWE_FILE_READ_ONLY		0x8994	// 148
+#define NWE_FILE_DETACHED		0x8995	// 149
+#define NWE_SERVER_OUT_OF_MEMORY	0x8996	// 150
+#define NWE_DIR_TARGET_INVALID		0x8996	// 150
+#define NWE_DISK_NO_SPOOL_SPACE		0x8997	// 151
+#define NWE_AUDITING_NOT_ENABLED	0x8997	// 151
+#define NWE_VOL_INVALID			0x8998	// 152
+#define NWE_DIR_FULL			0x8999	// 153
+#define NWE_VOL_RENAMING_ACROSS		0x899A	// 154
+#define NWE_DIRHANDLE_INVALID		0x899B	// 155
+#define NWE_PATH_INVALID		0x899C	// 156
+#define NWE_TRUSTEES_NO_MORE		0x899C	// 156
+#define NWE_DIRHANDLE_NO_MORE		0x899D	// 157
+#define NWE_FILE_NAME_INVALID		0x899E	// 158
+#define NWE_DIR_ACTIVE			0x899F	// 159
+#define NWE_DIR_NOT_EMPTY		0x89A0	// 160
+#define NWE_DIR_IO_ERROR		0x89A1	// 161
+#define NWE_FILE_IO_LOCKED		0x89A2	// 162
+#define NWE_TTS_RANSACTION_RESTARTED	0x89A3	// 163
+#define NWE_TTS_TRANSACTION_RESTARTED	0x89A3	// 163
+#define NWE_DIR_RENAME_INVALID		0x89A4	// 164
+#define NWE_FILE_OPENCREAT_MODE_INVALID	0x89A5	// 165
+#define NWE_ALREADY_IN_USE		0x89A6	// 166
+#define NWE_AUDITING_ACTIVE		0x89A6	// 166
+#define NWE_RESOURCE_TAG_INVALID	0x89A7	// 167
+#define NWE_ACCESS_DENIED		0x89A8	// 168
+#define NWE_AUDITING_NO_RIGHTS		0x89A8	// 168
+#define NWE_LINK_IN_PATH		0x89A9	// 169
+#define NWE_INVALID_DATA_TYPE_FLAG	0x89AA	// 170 (legacy vol with UTF8)
+#define NWE_DATA_STREAM_INVALID		0x89BE	// 190
+#define NWE_NAME_SPACE_INVALID		0x89BF	// 191
+#define NWE_ACCTING_NO_PRIV		0x89C0	// 192
+#define NWE_ACCTING_NO_BALANCE		0x89C1	// 193
+#define NWE_ACCTING_NO_CREDIT		0x89C2	// 194
+#define NWE_AUDITING_RECORD_SIZE	0x89C2	// 194
+#define NWE_ACCTING_TOO_MANY_HOLDS	0x89C3	// 195
+#define NWE_ACCTING_DISABLED		0x89C4	// 196
+#define NWE_LOGIN_LOCKOUT		0x89C5	// 197
+#define NWE_CONSOLE_NO_PRIV		0x89C6	// 198
+#define NWE_Q_IO_FAILURE		0x89D0	// 208
+#define NWE_Q_NONE			0x89D1	// 209
+#define NWE_Q_NO_SERVER			0x89D2	// 210
+#define NWE_Q_NO_RIGHTS			0x89D3	// 211
+#define NWE_Q_FULL			0x89D4	// 212
+#define NWE_Q_NO_JOB			0x89D5	// 213
+#define NWE_Q_NO_JOB_RIGHTS		0x89D6	// 214
+#define NWE_PASSWORD_UNENCRYPTED	0x89D6	// 214
+#define NWE_Q_IN_SERVICE		0x89D7	// 215
+#define NWE_PASSWORD_NOT_UNIQUE		0x89D7	// 215
+#define NWE_Q_NOT_ACTIVE		0x89D8	// 216
+#define NWE_PASSWORD_TOO_SHORT		0x89D8	// 216
+#define NWE_Q_STN_NOT_SERVER		0x89D9	// 217
+#define NWE_LOGIN_NO_CONN		0x89D9	// 217
+#define NWE_LOGIN_MAX_EXCEEDED		0x89D9	// 217
+#define NWE_Q_HALTED			0x89DA	// 218
+#define NWE_LOGIN_UNAUTHORIZED_TIME	0x89DA	// 218
+#define NWE_LOGIN_UNAUTHORIZED_STATION	0x89DB	// 219
+#define NWE_Q_MAX_SERVERS		0x89DB	// 219
+#define NWE_ACCT_DISABLED		0x89DC	// 220
+#define NWE_PASSWORD_INVALID		0x89DE	// 222
+#define NWE_PASSWORD_EXPIRED		0x89DF	// 223
+#define NWE_LOGIN_NO_CONN_AVAIL		0x89E0	// 224
+#define NWE_E_NO_MORE_USERS		0x89E7	// 231
+#define NWE_BIND_NOT_ITEM_PROP		0x89E8	// 232
+#define NWE_BIND_WRITE_TO_GROUP_PROP	0x89E8	// 232
+#define NWE_BIND_MEMBER_ALREADY_EXISTS	0x89E9	// 233
+#define NWE_BIND_NO_SUCH_MEMBER		0x89EA	// 234
+#define NWE_BIND_NOT_GROUP_PROP		0x89EB	// 235
+#define NWE_BIND_NO_SUCH_SEGMENT	0x89EC	// 236
+#define NWE_BIND_PROP_ALREADY_EXISTS	0x89ED	// 237
+#define NWE_BIND_OBJ_ALREADY_EXISTS	0x89EE	// 238
+#define NWE_BIND_NAME_INVALID		0x89EF	// 239
+#define NWE_BIND_WILDCARD_INVALID	0x89F0	// 240
+#define NWE_BIND_SECURITY_INVALID	0x89F1	// 241
+#define NWE_BIND_OBJ_NO_READ_PRIV	0x89F2	// 242
+#define NWE_BIND_OBJ_NO_RENAME_PRIV	0x89F3	// 243
+#define NWE_BIND_OBJ_NO_DELETE_PRIV	0x89F4	// 244
+#define NWE_BIND_OBJ_NO_CREATE_PRIV	0x89F5	// 245
+#define NWE_BIND_PROP_NO_DELETE_PRIV	0x89F6	// 246
+#define NWE_BIND_PROP_NO_CREATE_PRIV	0x89F7	// 247
+#define NWE_BIND_PROP_NO_WRITE_PRIV	0x89F8	// 248
+#define NWE_BIND_PROP_NO_READ_PRIV	0x89F9	// 249
+#define NWE_NO_FREE_CONN_SLOTS		0x89F9	// 249
+#define NWE_NO_MORE_SERVER_SLOTS	0x89FA	// 250
+#define NWE_TEMP_REMAP_ERROR		0x89FA	// 250
+#define NWE_PARAMETERS_INVALID		0x89FB	// 251
+#define NWE_BIND_NO_SUCH_PROP		0x89FB	// 251
+#define NWE_NCP_NOT_SUPPORTED		0x89FB	// 251
+#define NWE_INET_PACKET_REQ_CANCELED	0x89FC	// 252
+#define NWE_SERVER_UNKNOWN		0x89FC	// 252
+#define NWE_MSG_Q_FULL			0x89FC	// 252
+#define NWE_BIND_NO_SUCH_OBJ		0x89FC	// 252
+#define NWE_LOCK_COLLISION		0x89FD	// 253
+#define NWE_CONN_NUM_INVALID		0x89FD	// 253
+#define NWE_PACKET_LEN_INVALID		0x89FD	// 253
+#define NWE_UNKNOWN_REQ			0x89FD	// 253
+#define NWE_BIND_LOCKED			0x89FE	// 254
+#define NWE_TRUSTEE_NOT_FOUND		0x89FE	// 254
+#define NWE_DIR_LOCKED			0x89FE	// 254
+#define NWE_SEM_INVALID_NAME_LEN	0x89FE	// 254
+#define NWE_PACKET_NOT_DELIVERABLE	0x89FE	// 254
+#define NWE_SOCKET_TABLE_FULL		0x89FE	// 254
+#define NWE_SPOOL_DIR_ERROR		0x89FE	// 254
+#define NWE_LOGIN_DISABLED_BY_SUPER	0x89FE	// 254
+#define NWE_TIMEOUT_FAILURE		0x89FE	// 254
+#define NWE_FILE_EXT			0x89FF	// 255
+#define NWE_FILE_NAME			0x89FF	// 255
+#define NWE_HARD_FAILURE		0x89FF	// 255
+#define NWE_FCB_CLOSE			0x89FF	// 255
+#define NWE_IO_BOUND			0x89FF	// 255
+#define NWE_BAD_SPOOL_PRINTER		0x89FF	// 255
+#define NWE_BAD_RECORD_OFFSET		0x89FF	// 255
+#define NWE_DRIVE_INVALID_NUM		0x89FF	// 255
+#define NWE_SEM_INVALID_INIT_VAL	0x89FF	// 255
+#define NWE_SEM_INVALID_HANDLE		0x89FF	// 255
+#define NWE_NO_FILES_FOUND_ERROR	0x89FF	// 255
+#define NWE_NO_RESPONSE_FROM_SERVER	0x89FF	// 255
+#define NWE_NO_OBJ_OR_BAD_PASSWORD	0x89FF	// 255
+#define NWE_PATH_NOT_LOCATABLE		0x89FF	// 255
+#define NWE_Q_FULL_ERROR		0x89FF	// 255
+#define NWE_REQ_NOT_OUTSTANDING		0x89FF	// 255
+#define NWE_SOCKET_ALREADY_OPEN		0x89FF	// 255
+#define NWE_LOCK_ERROR			0x89FF	// 255
+#define NWE_FAILURE			0x89FF	// 255 Generic Failure
+
+#endif	/* __NOVFS_ERROR_H */
--- /dev/null
+++ b/fs/novfs/proc.c
@@ -0,0 +1,152 @@
+/*
+ * Novell NCP Redirector for Linux
+ * Author: James Turner
+ *
+ * This module contains functions that create the interface to the proc
+ * filesystem.
+ *
+ * Copyright (C) 2005 Novell, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/proc_fs.h>
+#include <linux/smp_lock.h>
+
+#include "vfs.h"
+
+struct proc_dir_entry *Novfs_Procfs_dir;
+static struct proc_dir_entry *Novfs_Control;
+static struct proc_dir_entry *Novfs_Library;
+static struct proc_dir_entry *Novfs_Version;
+
+static struct file_operations Daemon_proc_fops;
+static struct file_operations Library_proc_fops;
+
+/*===[ Code ]=============================================================*/
+
+static int Novfs_Get_Version(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	char *buf, tbuf[48];
+	int len = 0, i;
+
+	if (!off) {
+		buf = page + off;
+		*start = buf;
+		len = sprintf(buf, "Novfs Version=%s\n", NOVFS_VERSION_STRING);
+		i = Daemon_getversion(tbuf, sizeof(tbuf));
+		if ((i > 0) && i < (count - len)) {
+			len += sprintf(buf + len, "Novfsd Version=%s\n", tbuf);
+		}
+
+		if (Novfs_CurrentMount) {
+			i = strlen(Novfs_CurrentMount);
+			if ((i > 0) && i < (count - len)) {
+				len +=
+				    sprintf(buf + len, "Novfs mount=%s\n",
+					    Novfs_CurrentMount);
+			}
+		}
+		DbgPrint("Novfs_Get_Version:\n%s\n", buf);
+	}
+	*eof = 1;
+	return (len);
+}
+
+int Init_Procfs_Interface(void)
+{
+	int retCode = 0;
+
+	Novfs_Procfs_dir = proc_mkdir(MODULE_NAME, NULL);
+	if (Novfs_Procfs_dir) {
+		Novfs_Procfs_dir->owner = THIS_MODULE;
+
+		Novfs_Control = create_proc_entry("Control", 0600, Novfs_Procfs_dir);
+
+		if (Novfs_Control) {
+			Novfs_Control->owner = THIS_MODULE;
+			Novfs_Control->size = 0;
+			memcpy(&Daemon_proc_fops, Novfs_Control->proc_fops,
+			       sizeof(struct file_operations));
+
+			/*
+			 * Setup our functions
+			 */
+			Daemon_proc_fops.owner = THIS_MODULE;
+			Daemon_proc_fops.open = Daemon_Open_Control;
+			Daemon_proc_fops.release = Daemon_Close_Control;
+			Daemon_proc_fops.read = Daemon_Send_Command;
+			Daemon_proc_fops.write = Daemon_Receive_Reply;
+			Daemon_proc_fops.ioctl = Daemon_ioctl;
+
+			Novfs_Control->proc_fops = &Daemon_proc_fops;
+		} else {
+			remove_proc_entry(MODULE_NAME, NULL);
+			return (-ENOENT);
+		}
+
+		Novfs_Library = create_proc_entry("Library", 0666, Novfs_Procfs_dir);
+		if (Novfs_Library) {
+			Novfs_Library->owner = THIS_MODULE;
+			Novfs_Library->size = 0;
+
+			/*
+			 * Setup our file functions
+			 */
+			memcpy(&Library_proc_fops, Novfs_Library->proc_fops,
+			       sizeof(struct file_operations));
+			Library_proc_fops.owner = THIS_MODULE;
+			Library_proc_fops.open = Daemon_Library_open;
+			Library_proc_fops.release = Daemon_Library_close;
+			Library_proc_fops.read = Daemon_Library_read;
+			Library_proc_fops.write = Daemon_Library_write;
+			Library_proc_fops.llseek = Daemon_Library_llseek;
+			Library_proc_fops.ioctl = Daemon_Library_ioctl;
+			Novfs_Library->proc_fops = &Library_proc_fops;
+		} else {
+			remove_proc_entry("Control", Novfs_Procfs_dir);
+			remove_proc_entry(MODULE_NAME, NULL);
+			return (-ENOENT);
+		}
+
+		Novfs_Version =
+		    create_proc_read_entry("Version", 0444, Novfs_Procfs_dir,
+					   Novfs_Get_Version, NULL);
+		if (Novfs_Version) {
+			Novfs_Version->owner = THIS_MODULE;
+			Novfs_Version->size = 0;
+		} else {
+			remove_proc_entry("Library", Novfs_Procfs_dir);
+			remove_proc_entry("Control", Novfs_Procfs_dir);
+			remove_proc_entry(MODULE_NAME, NULL);
+			retCode = -ENOENT;
+		}
+	} else {
+		retCode = -ENOENT;
+	}
+	return (retCode);
+}
+
+void Uninit_Procfs_Interface(void)
+{
+
+	DbgPrint("Uninit_Procfs_Interface remove_proc_entry(Version, NULL)\n");
+	remove_proc_entry("Version", Novfs_Procfs_dir);
+
+	DbgPrint("Uninit_Procfs_Interface remove_proc_entry(Control, NULL)\n");
+	remove_proc_entry("Control", Novfs_Procfs_dir);
+
+	DbgPrint("Uninit_Procfs_Interface remove_proc_entry(Library, NULL)\n");
+	remove_proc_entry("Library", Novfs_Procfs_dir);
+
+	DbgPrint("Uninit_Procfs_Interface remove_proc_entry(%s, NULL)\n",
+		 MODULE_NAME);
+	remove_proc_entry(MODULE_NAME, NULL);
+
+	DbgPrint("Uninit_Procfs_Interface done\n");
+}
--- /dev/null
+++ b/fs/novfs/profile.c
@@ -0,0 +1,687 @@
+/*
+ * Novell NCP Redirector for Linux
+ * Author: James Turner
+ *
+ * This file contains a debugging code for the novfs VFS.
+ *
+ * Copyright (C) 2005 Novell, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <linux/sched.h>
+#include <linux/vmalloc.h>
+#include <linux/time.h>
+#include <linux/profile.h>
+#include <linux/notifier.h>
+#include <asm/uaccess.h>
+
+#include "vfs.h"
+
+/*===[ Manifest constants ]===============================================*/
+#define DBGBUFFERSIZE (1024*1024*32)
+
+/*===[ Type definitions ]=================================================*/
+struct local_rtc_time {
+	int tm_sec;
+	int tm_min;
+	int tm_hour;
+	int tm_mday;
+	int tm_mon;
+	int tm_year;
+	int tm_wday;
+	int tm_yday;
+	int tm_isdst;
+};
+
+static char *DbgPrintBuffer = NULL;
+static char DbgPrintOn = 0;
+static char DbgSyslogOn = 0;
+static char DbgProfileOn = 0;
+
+static unsigned long DbgPrintBufferOffset = 0;
+static unsigned long DbgPrintBufferReadOffset = 0;
+static unsigned long DbgPrintBufferSize = DBGBUFFERSIZE;
+
+static struct file_operations Dbg_proc_file_operations;
+static struct file_operations dentry_proc_file_ops;
+static struct file_operations inode_proc_file_ops;
+
+static struct proc_dir_entry *dbg_dir = NULL;
+static struct proc_dir_entry *dbg_file = NULL;
+static struct proc_dir_entry *dentry_file = NULL;
+static struct proc_dir_entry *inode_file = NULL;
+
+static DECLARE_MUTEX(LocalPrint_lock);
+
+static ssize_t User_proc_write_DbgBuffer(struct file *file, const char __user *buf, size_t nbytes, loff_t *ppos)
+{
+	ssize_t retval = nbytes;
+	unsigned char *lbuf;
+	unsigned char *p;
+	int i;
+
+	lbuf = kmalloc(nbytes + 1, GFP_KERNEL);
+	if (lbuf) {
+		if (copy_from_user(lbuf, buf, nbytes))
+			return -EFAULT;
+
+		lbuf[nbytes] = 0;
+		DbgPrint("User_proc_write_DbgBuffer: %s\n", lbuf);
+
+		for (i = 0; lbuf[i] && lbuf[i] != '\n'; i++)
+			;
+
+		if ('\n' == lbuf[i])
+			lbuf[i] = '\0';
+
+		if (!strcmp("on", lbuf)) {
+			DbgPrintBufferOffset = DbgPrintBufferReadOffset = 0;
+			DbgPrintOn = 1;
+		} else if (!strcmp("off", lbuf)) {
+			DbgPrintOn = 0;
+		} else if (!strcmp("reset", lbuf)) {
+			DbgPrintBufferOffset = DbgPrintBufferReadOffset = 0;
+		} else if (NULL != (p = strchr(lbuf, ' '))) {
+			*p++ = '\0';
+			if (!strcmp("syslog", lbuf)) {
+
+				if (!strcmp("on", p)) {
+					DbgSyslogOn = 1;
+				} else if (!strcmp("off", p)) {
+					DbgSyslogOn = 0;
+				}
+			} else if (!strcmp("novfsd", lbuf)) {
+				Daemon_SendDebugCmd(p);
+			} else if (!strcmp("file_update_timeout", lbuf)) {
+				File_update_timeout =
+				    simple_strtoul(p, NULL, 0);
+			} else if (!strcmp("cache", lbuf)) {
+				if (!strcmp("on", p)) {
+					PageCache = 1;
+				} else if (!strcmp("off", p)) {
+					PageCache = 0;
+				}
+			} else if (!strcmp("profile", lbuf)) {
+				if (!strcmp("on", p)) {
+					DbgProfileOn = 1;
+				} else if (!strcmp("off", p)) {
+					DbgProfileOn = 0;
+				}
+			}
+		}
+		kfree(lbuf);
+	}
+
+	return (retval);
+}
+
+static ssize_t User_proc_read_DbgBuffer(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
+{
+	ssize_t retval = 0;
+	size_t count;
+
+	if (0 != (count = DbgPrintBufferOffset - DbgPrintBufferReadOffset)) {
+
+		if (count > nbytes) {
+			count = nbytes;
+		}
+
+		count -=
+		    copy_to_user(buf, &DbgPrintBuffer[DbgPrintBufferReadOffset],
+				 count);
+
+		if (count == 0) {
+			if (retval == 0)
+				retval = -EFAULT;
+		} else {
+			DbgPrintBufferReadOffset += count;
+			if (DbgPrintBufferReadOffset >= DbgPrintBufferOffset) {
+				DbgPrintBufferOffset =
+				    DbgPrintBufferReadOffset = 0;
+			}
+			retval = count;
+		}
+	}
+
+	return retval;
+}
+
+static int proc_read_DbgBuffer(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	int len;
+
+	printk(KERN_ALERT "proc_read_DbgBuffer: off=%ld count=%d DbgPrintBufferOffset=%lu DbgPrintBufferReadOffset=%lu\n", off, count, DbgPrintBufferOffset, DbgPrintBufferReadOffset);
+
+	len = DbgPrintBufferOffset - DbgPrintBufferReadOffset;
+
+	if ((int)(DbgPrintBufferOffset - DbgPrintBufferReadOffset) > count)
+		len = count;
+
+	if (len) {
+		memcpy(page, &DbgPrintBuffer[DbgPrintBufferReadOffset], len);
+		DbgPrintBufferReadOffset += len;
+	}
+
+	if (DbgPrintBufferReadOffset >= DbgPrintBufferOffset)
+		DbgPrintBufferOffset = DbgPrintBufferReadOffset = 0;
+
+	printk(KERN_ALERT "proc_read_DbgBuffer: return %d\n", len);
+
+	return len;
+}
+
+#define DBG_BUFFER_SIZE (2*1024)
+
+static int LocalPrint(char *Fmt, ...)
+{
+	int len = 0;
+	va_list args;
+
+	if (DbgPrintBuffer) {
+		va_start(args, Fmt);
+		len += vsnprintf(DbgPrintBuffer + DbgPrintBufferOffset,
+				 DbgPrintBufferSize - DbgPrintBufferOffset,
+				 Fmt, args);
+		DbgPrintBufferOffset += len;
+	}
+
+	return (len);
+}
+
+int DbgPrint(char *Fmt, ...)
+{
+	char *buf;
+	int len = 0;
+	unsigned long offset;
+	va_list args;
+
+	if ((DbgPrintBuffer && DbgPrintOn) || DbgSyslogOn) {
+		buf = kmalloc(DBG_BUFFER_SIZE, GFP_KERNEL);
+
+		if (buf) {
+			va_start(args, Fmt);
+			len = sprintf(buf, "[%d] ", current->pid);
+
+			len +=
+			    vsnprintf(buf + len, DBG_BUFFER_SIZE - len, Fmt,
+				      args);
+			if (-1 == len) {
+				len = DBG_BUFFER_SIZE - 1;
+				buf[len] = '\0';
+			}
+			/*
+			   len = sprintf(&DbgPrintBuffer[offset], "[%llu] ", ts);
+			   len += vsprintf(&DbgPrintBuffer[offset+len], Fmt, args);
+			 */
+
+			if (len) {
+				if (DbgSyslogOn) {
+					printk("<6>%s", buf);
+				}
+
+				if (DbgPrintBuffer && DbgPrintOn) {
+					if ((DbgPrintBufferOffset + len) >
+					    DbgPrintBufferSize) {
+						offset = DbgPrintBufferOffset;
+						DbgPrintBufferOffset = 0;
+						memset(&DbgPrintBuffer[offset],
+						       0,
+						       DbgPrintBufferSize -
+						       offset);
+					}
+
+					mb();
+
+					if ((DbgPrintBufferOffset + len) <
+					    DbgPrintBufferSize) {
+						DbgPrintBufferOffset += len;
+						offset =
+						    DbgPrintBufferOffset - len;
+						memcpy(&DbgPrintBuffer[offset],
+						       buf, len + 1);
+					}
+				}
+			}
+			kfree(buf);
+		}
+	}
+
+	return (len);
+}
+
+static void doline(unsigned char *b, unsigned char *e, unsigned char *l)
+{
+	unsigned char c;
+
+	*b++ = ' ';
+
+	while (l < e) {
+		c = *l++;
+		if ((c < ' ') || (c > '~')) {
+			c = '.';
+		}
+		*b++ = c;
+		*b = '\0';
+	}
+}
+
+void mydump(int size, void *dumpptr)
+{
+	unsigned char *ptr = (unsigned char *)dumpptr;
+	unsigned char *line = NULL, buf[100], *bptr = buf;
+	int i;
+
+	if (DbgPrintBuffer || DbgSyslogOn) {
+		if (size) {
+			for (i = 0; i < size; i++) {
+				if (0 == (i % 16)) {
+					if (line) {
+						doline(bptr, ptr, line);
+						DbgPrint("%s\n", buf);
+						bptr = buf;
+					}
+					bptr += sprintf(bptr, "0x%p: ", ptr);
+					line = ptr;
+				}
+				bptr += sprintf(bptr, "%02x ", *ptr++);
+			}
+			doline(bptr, ptr, line);
+			DbgPrint("%s\n", buf);
+		}
+	}
+}
+
+#define FEBRUARY	2
+#define	STARTOFTIME	1970
+#define SECDAY		86400L
+#define SECYR		(SECDAY * 365)
+#define	leapyear(year)		((year) % 4 == 0)
+#define	days_in_year(a) 	(leapyear(a) ? 366 : 365)
+#define	days_in_month(a) 	(month_days[(a) - 1])
+
+static int month_days[12] = {
+	31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
+};
+
+/*
+ * This only works for the Gregorian calendar - i.e. after 1752 (in the UK)
+ */
+static void Novfs_GregorianDay(struct local_rtc_time *tm)
+{
+	int leapsToDate;
+	int lastYear;
+	int day;
+	int MonthOffset[] =
+	    { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 };
+
+	lastYear = tm->tm_year - 1;
+
+	/*
+	 * Number of leap corrections to apply up to end of last year
+	 */
+	leapsToDate = lastYear / 4 - lastYear / 100 + lastYear / 400;
+
+	/*
+	 * This year is a leap year if it is divisible by 4 except when it is
+	 * divisible by 100 unless it is divisible by 400
+	 *
+	 * e.g. 1904 was a leap year, 1900 was not, 1996 is, and 2000 will be
+	 */
+	if ((tm->tm_year % 4 == 0) &&
+	    ((tm->tm_year % 100 != 0) || (tm->tm_year % 400 == 0)) &&
+	    (tm->tm_mon > 2)) {
+		/*
+		 * We are past Feb. 29 in a leap year
+		 */
+		day = 1;
+	} else {
+		day = 0;
+	}
+
+	day += lastYear * 365 + leapsToDate + MonthOffset[tm->tm_mon - 1] +
+	    tm->tm_mday;
+
+	tm->tm_wday = day % 7;
+}
+
+static void private_to_tm(int tim, struct local_rtc_time *tm)
+{
+	register int i;
+	register long hms, day;
+
+	day = tim / SECDAY;
+	hms = tim % SECDAY;
+
+	/* Hours, minutes, seconds are easy */
+	tm->tm_hour = hms / 3600;
+	tm->tm_min = (hms % 3600) / 60;
+	tm->tm_sec = (hms % 3600) % 60;
+
+	/* Number of years in days */
+	for (i = STARTOFTIME; day >= days_in_year(i); i++)
+		day -= days_in_year(i);
+	tm->tm_year = i;
+
+	/* Number of months in days left */
+	if (leapyear(tm->tm_year))
+		days_in_month(FEBRUARY) = 29;
+	for (i = 1; day >= days_in_month(i); i++)
+		day -= days_in_month(i);
+	days_in_month(FEBRUARY) = 28;
+	tm->tm_mon = i;
+
+	/* Days are what is left over (+1) from all that. */
+	tm->tm_mday = day + 1;
+
+	/*
+	 * Determine the day of week
+	 */
+	Novfs_GregorianDay(tm);
+}
+
+char *ctime_r(time_t * clock, char *buf)
+{
+	struct local_rtc_time tm;
+	static char *DAYOFWEEK[] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
+	static char *MONTHOFYEAR[] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
+
+	private_to_tm(*clock, &tm);
+
+	sprintf(buf, "%s %s %d %d:%02d:%02d %d", DAYOFWEEK[tm.tm_wday],
+		MONTHOFYEAR[tm.tm_mon - 1], tm.tm_mday, tm.tm_hour, tm.tm_min,
+		tm.tm_sec, tm.tm_year);
+	return (buf);
+}
+
+static void profile_dump_dt(struct dentry *parent, void *pf)
+{
+	void (*pfunc) (char *Fmt, ...) = pf;
+	struct l {
+		struct l *next;
+		struct dentry *dentry;
+	} *l, *n, *start;
+	struct list_head *p;
+	struct dentry *d;
+	char *buf, *path, *sd;
+	char inode_number[16];
+
+	buf = kmalloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
+	if (!buf)
+		return;
+
+	if (parent) {
+		pfunc("starting 0x%p %.*s\n", parent, parent->d_name.len,
+		      parent->d_name.name);
+		if (parent->d_subdirs.next == &parent->d_subdirs) {
+			pfunc("No children...\n");
+		} else {
+			start = kmalloc(sizeof(*start), GFP_KERNEL);
+			if (start) {
+				start->next = NULL;
+				start->dentry = parent;
+				l = start;
+				while (l) {
+					p = l->dentry->d_subdirs.next;
+					while (p != &l->dentry->d_subdirs) {
+						d = list_entry(p, struct dentry,
+							       D_CHILD);
+						p = p->next;
+
+						if (d->d_subdirs.next != &d->d_subdirs) {
+							n = kmalloc(sizeof(*n), GFP_KERNEL);
+							if (n) {
+								n->next = l->next;
+								l->next = n;
+								n->dentry = d;
+							}
+						} else {
+							path = Scope_dget_path(d, buf, PATH_LENGTH_BUFFER, 1);
+							if (path) {
+								pfunc("1-0x%p %s\n"
+								     "   d_name:    %.*s\n"
+								     "   d_parent:  0x%p\n"
+								     "   d_count:   %d\n"
+								     "   d_flags:   0x%x\n"
+								     "   d_subdirs: 0x%p\n"
+								     "   d_inode:   0x%p\n",
+								     d, path,
+								     d->d_name.len,
+								     d->d_name.name,
+								     d->d_parent,
+								     atomic_read(&d->d_count),
+								     d->d_flags,
+								     d->d_subdirs.
+								     next,
+								     d->d_inode);
+							}
+						}
+					}
+					l = l->next;
+				}
+				l = start;
+				while (l) {
+					d = l->dentry;
+					path = Scope_dget_path(d, buf, PATH_LENGTH_BUFFER, 1);
+					if (path) {
+						sd = " (None)";
+						if (&d->d_subdirs != d->d_subdirs.next)
+							sd = "";
+						inode_number[0] = '\0';
+						if (d->d_inode) {
+							sprintf(inode_number,
+								" (%lu)",
+								d->d_inode->
+								i_ino);
+						}
+						pfunc("0x%p %s\n"
+						      "   d_parent:  0x%p\n"
+						      "   d_count:   %d\n"
+						      "   d_flags:   0x%x\n"
+						      "   d_subdirs: 0x%p%s\n"
+						      "   d_inode:   0x%p%s\n",
+						      d, path, d->d_parent,
+						      atomic_read(&d->d_count),
+						      d->d_flags,
+						      d->d_subdirs.next, sd,
+						      d->d_inode, inode_number);
+					}
+
+					n = l;
+					l = l->next;
+					kfree(n);
+				}
+			}
+		}
+	}
+
+	kfree(buf);
+
+}
+
+static ssize_t profile_common_read(char __user *buf, size_t len, loff_t *off)
+{
+	ssize_t retval = 0;
+	size_t count;
+	unsigned long offset = *off;
+
+	if (0 != (count = DbgPrintBufferOffset - offset)) {
+		if (count > len) {
+			count = len;
+		}
+
+		count -= copy_to_user(buf, &DbgPrintBuffer[offset], count);
+
+		if (count == 0) {
+			retval = -EFAULT;
+		} else {
+			*off += (loff_t) count;
+			retval = count;
+		}
+	}
+	return retval;
+
+}
+
+static ssize_t profile_inode_read(struct file * file, char __user *buf, size_t len, loff_t *off)
+{
+	ssize_t retval = 0;
+	unsigned long offset = *off;
+	static char save_DbgPrintOn;
+
+	if (offset == 0) {
+		down(&LocalPrint_lock);
+		save_DbgPrintOn = DbgPrintOn;
+		DbgPrintOn = 0;
+
+		DbgPrintBufferOffset = DbgPrintBufferReadOffset = 0;
+		Novfs_dump_inode(LocalPrint);
+	}
+
+	retval = profile_common_read(buf, len, off);
+
+	if (0 == retval) {
+		DbgPrintOn = save_DbgPrintOn;
+		DbgPrintBufferOffset = DbgPrintBufferReadOffset = 0;
+
+		up(&LocalPrint_lock);
+	}
+
+	return retval;
+
+}
+
+static ssize_t profile_dentry_read(struct file *file, char __user *buf, size_t len, loff_t * off)
+{
+	ssize_t retval = 0;
+	unsigned long offset = *off;
+	static char save_DbgPrintOn;
+
+	if (offset == 0) {
+		down(&LocalPrint_lock);
+		save_DbgPrintOn = DbgPrintOn;
+		DbgPrintOn = 0;
+		DbgPrintBufferOffset = DbgPrintBufferReadOffset = 0;
+		profile_dump_dt(Novfs_root, LocalPrint);
+	}
+
+	retval = profile_common_read(buf, len, off);
+
+	if (0 == retval) {
+		DbgPrintBufferOffset = DbgPrintBufferReadOffset = 0;
+		DbgPrintOn = save_DbgPrintOn;
+
+		up(&LocalPrint_lock);
+	}
+
+	return retval;
+
+}
+
+uint64_t get_nanosecond_time(void)
+{
+	struct timespec ts;
+	uint64_t retVal;
+
+	ts = current_kernel_time();
+
+	retVal = (uint64_t) NSEC_PER_SEC;
+	retVal *= (uint64_t) ts.tv_sec;
+	retVal += (uint64_t) ts.tv_nsec;
+
+	return (retVal);
+}
+
+int init_profile(void)
+{
+	int retCode = 0;
+
+	if (Novfs_Procfs_dir) {
+		dbg_dir = Novfs_Procfs_dir;
+	} else {
+		dbg_dir = proc_mkdir(MODULE_NAME, NULL);
+	}
+
+	if (dbg_dir) {
+		dbg_dir->owner = THIS_MODULE;
+		dbg_file = create_proc_read_entry("Debug",
+						  0600,
+						  dbg_dir,
+						  proc_read_DbgBuffer, NULL);
+		if (dbg_file) {
+			dbg_file->owner = THIS_MODULE;
+			dbg_file->size = DBGBUFFERSIZE;
+			memcpy(&Dbg_proc_file_operations, dbg_file->proc_fops,
+			       sizeof(struct file_operations));
+			Dbg_proc_file_operations.read = User_proc_read_DbgBuffer;
+			Dbg_proc_file_operations.write = User_proc_write_DbgBuffer;
+			dbg_file->proc_fops = &Dbg_proc_file_operations;
+		} else {
+			remove_proc_entry(MODULE_NAME, NULL);
+			vfree(DbgPrintBuffer);
+			DbgPrintBuffer = NULL;
+		}
+	}
+
+	if (DbgPrintBuffer) {
+		if (dbg_dir) {
+			inode_file = create_proc_entry("inode", 0600, dbg_dir);
+			if (inode_file) {
+				inode_file->owner = THIS_MODULE;
+				inode_file->size = 0;
+				memcpy(&inode_proc_file_ops,
+				       inode_file->proc_fops,
+				       sizeof(struct file_operations));
+				inode_proc_file_ops.owner = THIS_MODULE;
+				inode_proc_file_ops.read = profile_inode_read;
+				inode_file->proc_fops = &inode_proc_file_ops;
+			}
+
+			dentry_file = create_proc_entry("dentry",
+							0600, dbg_dir);
+			if (dentry_file) {
+				dentry_file->owner = THIS_MODULE;
+				dentry_file->size = 0;
+				memcpy(&dentry_proc_file_ops,
+				       dentry_file->proc_fops,
+				       sizeof(struct file_operations));
+				dentry_proc_file_ops.owner = THIS_MODULE;
+				dentry_proc_file_ops.read = profile_dentry_read;
+				dentry_file->proc_fops = &dentry_proc_file_ops;
+			}
+		} else {
+			vfree(DbgPrintBuffer);
+			DbgPrintBuffer = NULL;
+		}
+	}
+	return (retCode);
+}
+
+void uninit_profile(void)
+{
+	if (dbg_file) {
+		DbgPrint("Calling remove_proc_entry(Debug, NULL)\n");
+		remove_proc_entry("Debug", dbg_dir);
+	}
+	if (inode_file) {
+		DbgPrint("Calling remove_proc_entry(inode, NULL)\n");
+		remove_proc_entry("inode", dbg_dir);
+	}
+	if (dentry_file) {
+		DbgPrint("Calling remove_proc_entry(dentry, NULL)\n");
+		remove_proc_entry("dentry", dbg_dir);
+	}
+	if (dbg_dir && (dbg_dir != Novfs_Procfs_dir)) {
+		DbgPrint("Calling remove_proc_entry(%s, NULL)\n", MODULE_NAME);
+		remove_proc_entry(MODULE_NAME, NULL);
+	}
+}
+
+
--- /dev/null
+++ b/fs/novfs/scope.c
@@ -0,0 +1,675 @@
+/*
+ * Novell NCP Redirector for Linux
+ * Author:           James Turner
+ *
+ * This file contains functions used to scope users.
+ *
+ * Copyright (C) 2005 Novell, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kthread.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/sched.h>
+#include <linux/personality.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/synclink.h>
+#include <linux/smp_lock.h>
+#include <linux/semaphore.h>
+#include <linux/security.h>
+#include <linux/syscalls.h>
+
+#include "vfs.h"
+
+#define SHUTDOWN_INTERVAL     5
+#define CLEANUP_INTERVAL      10
+#define MAX_USERNAME_LENGTH   32
+
+struct scope_list {
+	struct list_head entry;
+	struct schandle ScopeId;
+	struct schandle SessionId;
+	pid_t ScopePid;
+	struct task_struct *ScopeTask;
+	unsigned int ScopeHash;
+	uid_t ScopeUid;
+	u64 ScopeUSize;
+	u64 ScopeUFree;
+	u64 ScopeUTEnties;
+	u64 ScopeUAEnties;
+	int ScopeUserNameLength;
+	unsigned char ScopeUserName[MAX_USERNAME_LENGTH];
+};
+
+static struct list_head Scope_List;
+static struct semaphore Scope_Lock;
+static struct semaphore Scope_Thread_Delay;
+static int Scope_Thread_Terminate;
+static struct timer_list Scope_Timer;
+static unsigned int Scope_Hash_Val = 1;
+
+static struct scope_list *Scope_Search4Scope(struct schandle *Id, bool Session,
+					     bool Locked)
+{
+	struct scope_list *scope;
+	struct scope_list *rscope = NULL;
+	struct schandle *cur_scope;
+	struct list_head *sl;
+	int offset;
+
+	DbgPrint("Scope_Search4Scope: 0x%p:%p 0x%x 0x%x\n",
+		 Id->hTypeId, Id->hId, Session, Locked);
+
+	if (Session)
+		offset = offsetof(struct scope_list, SessionId);
+	else
+		offset = offsetof(struct scope_list, ScopeId);
+
+	if (!Locked)
+		down(&Scope_Lock);
+
+	sl = Scope_List.next;
+	DbgPrint("Scope_Search4Scope: 0x%p\n", sl);
+	while (sl != &Scope_List) {
+		scope = list_entry(sl, struct scope_list, entry);
+
+		cur_scope = (session_t *) ((char *)scope + offset);
+		if (SC_EQUAL(Id, cur_scope)) {
+			rscope = scope;
+			break;
+		}
+
+		sl = sl->next;
+	}
+
+	if (!Locked)
+		up(&Scope_Lock);
+
+	DbgPrint("Scope_Search4Scope: return 0x%p\n", rscope);
+	return rscope;
+}
+
+static struct scope_list *Scope_Find_Scope(bool Create)
+{
+	struct scope_list *scope = NULL;
+	struct scope_list *pscope = NULL;
+	struct task_struct *task;
+	struct schandle scopeId;
+	int addscope = 0;
+
+	task = current;
+
+	DbgPrint("Scope_Find_Scope: %d %d %d %d\n", task->uid, task->euid,
+		 task->suid, task->fsuid);
+
+	/* scopeId = task->euid; */
+	UID_TO_SCHANDLE(scopeId, task->euid);
+
+	scope = Scope_Search4Scope(&scopeId, 0, 0);
+	if (scope || (!Create))
+		return scope;
+
+	scope = kmalloc(sizeof(*pscope), GFP_KERNEL);
+	if (!scope)
+		return NULL;
+	scope->ScopeId = scopeId;
+	SC_INITIALIZE(scope->SessionId);
+	scope->ScopePid = task->pid;
+	scope->ScopeTask = task;
+	scope->ScopeHash = 0;
+	scope->ScopeUid = task->euid;
+	scope->ScopeUserName[0] = '\0';
+
+	if (!Daemon_CreateSessionId(&scope->SessionId)) {
+		DbgPrint("Scope_Find_Scope2: %d %d %d %d\n", task->uid,
+			 task->euid, task->suid, task->fsuid);
+		memset(scope->ScopeUserName, 0, sizeof(scope->ScopeUserName));
+		scope->ScopeUserNameLength = 0;
+		Daemon_getpwuid(task->euid, sizeof(scope->ScopeUserName),
+				scope->ScopeUserName);
+		scope->ScopeUserNameLength = strlen(scope->ScopeUserName);
+		addscope = 1;
+	}
+
+	scope->ScopeHash = Scope_Hash_Val++;
+	DbgPrint("Scope_Find_Scope: Adding 0x%p\n"
+		 "   ScopeId:             0x%p:%p\n"
+		 "   SessionId:           0x%p:%p\n"
+		 "   ScopePid:            %d\n"
+		 "   ScopeTask:           0x%p\n"
+		 "   ScopeHash:           %u\n"
+		 "   ScopeUid:            %u\n"
+		 "   ScopeUserNameLength: %u\n"
+		 "   ScopeUserName:       %s\n",
+		 scope,
+		 scope->ScopeId.hTypeId, scope->ScopeId.hId,
+		 scope->SessionId.hTypeId, scope->SessionId.hId,
+		 scope->ScopePid,
+		 scope->ScopeTask,
+		 scope->ScopeHash,
+		 scope->ScopeUid,
+		 scope->ScopeUserNameLength,
+		 scope->ScopeUserName);
+
+	if (SC_PRESENT(scope->SessionId)) {
+		down(&Scope_Lock);
+		pscope = Scope_Search4Scope(&scopeId, 0, 1);
+		if (!pscope)
+			list_add(&scope->entry, &Scope_List);
+		up(&Scope_Lock);
+
+		if (pscope) {
+			printk(KERN_ERR "Scope_Find_Scope scope not added "
+			       "because it was already there...\n");
+			Daemon_DestroySessionId(&scope->SessionId);
+			kfree(scope);
+			scope = pscope;
+			addscope = 0;
+		}
+	} else {
+		kfree(scope);
+		scope = NULL;
+	}
+
+	if (addscope)
+		Novfs_Add_to_Root(scope->ScopeUserName);
+
+	return scope;
+}
+
+static int Scope_Validate_Scope(struct scope_list *Scope)
+{
+	struct scope_list *s;
+	struct list_head *sl;
+	int retVal = 0;
+
+	DbgPrint("Scope_Validate_Scope: 0x%p\n", Scope);
+
+	down(&Scope_Lock);
+
+	sl = Scope_List.next;
+	while (sl != &Scope_List) {
+		s = list_entry(sl, struct scope_list, entry);
+
+		if (s == Scope) {
+			retVal = 1;
+			break;
+		}
+
+		sl = sl->next;
+	}
+
+	up(&Scope_Lock);
+
+	return retVal;
+}
+
+/* FIXME void stuff */
+uid_t Scope_Get_Uid(void *foo)
+{
+	struct scope_list *scope = foo;
+	uid_t uid = 0;
+
+	if (!scope)
+		scope = Scope_Find_Scope(1);
+
+	if (scope && Scope_Validate_Scope(scope))
+		uid = scope->ScopeUid;
+
+	return uid;
+}
+
+char *Scope_Get_UserName(void)
+{
+	char *name = NULL;
+	struct scope_list *Scope;
+
+	Scope = Scope_Find_Scope(1);
+
+	if (Scope && Scope_Validate_Scope(Scope))
+		name = Scope->ScopeUserName;
+
+	return name;
+}
+
+/* FIXME the void * needs to get fixed... */
+session_t Scope_Get_SessionId(void *foo)
+{
+	session_t sessionId;
+	struct scope_list *Scope = foo;
+
+	DbgPrint("Scope_Get_SessionId: 0x%p\n", Scope);
+	SC_INITIALIZE(sessionId);
+	if (!Scope)
+		Scope = Scope_Find_Scope(1);
+
+	if (Scope && Scope_Validate_Scope(Scope))
+		sessionId = Scope->SessionId;
+
+	DbgPrint("Scope_Get_SessionId: return 0x%p:%p\n", sessionId.hTypeId,
+		 sessionId.hId);
+	return sessionId;
+}
+
+struct scope_list *Scope_Get_ScopefromName(struct qstr *name)
+{
+	struct scope_list *scope;
+	struct scope_list *rscope = NULL;
+	struct list_head *sl;
+
+	DbgPrint("Scope_Get_ScopefromName: %.*s\n", name->len, name->name);
+
+	down(&Scope_Lock);
+
+	sl = Scope_List.next;
+	while (sl != &Scope_List) {
+		scope = list_entry(sl, struct scope_list, entry);
+
+		if ((name->len == scope->ScopeUserNameLength) &&
+		    (strncmp(scope->ScopeUserName, name->name, name->len) == 0)) {
+			rscope = scope;
+			break;
+		}
+		sl = sl->next;
+	}
+
+	up(&Scope_Lock);
+
+	return rscope;
+}
+
+int Scope_Set_UserSpace(u64 *TotalSize, u64 *Free,
+			u64 *TotalEnties, u64 *FreeEnties)
+{
+	struct scope_list *scope;
+	int retVal = 0;
+
+	scope = Scope_Find_Scope(1);
+
+	if (scope) {
+		if (TotalSize)
+			scope->ScopeUSize = *TotalSize;
+		if (Free)
+			scope->ScopeUFree = *Free;
+		if (TotalEnties)
+			scope->ScopeUTEnties = *TotalEnties;
+		if (FreeEnties)
+			scope->ScopeUAEnties = *FreeEnties;
+	}
+
+	return retVal;
+}
+
+int Scope_Get_UserSpace(u64 *TotalSize, u64 *Free,
+			u64 *TotalEnties, u64 *FreeEnties)
+{
+	struct scope_list *scope;
+	int retVal = 0;
+
+	u64 td, fd, te, fe;
+
+	scope = Scope_Find_Scope(1);
+
+	td = fd = te = fe = 0;
+	if (scope) {
+
+		retVal = Daemon_Get_UserSpace(&scope->SessionId,
+					      &td, &fd, &te, &fe);
+
+		scope->ScopeUSize = td;
+		scope->ScopeUFree = fd;
+		scope->ScopeUTEnties = te;
+		scope->ScopeUAEnties = fe;
+	}
+
+	if (TotalSize)
+		*TotalSize = td;
+	if (Free)
+		*Free = fd;
+	if (TotalEnties)
+		*TotalEnties = te;
+	if (FreeEnties)
+		*FreeEnties = fe;
+
+	return retVal;
+}
+
+struct scope_list *Scope_Get_ScopefromPath(struct dentry *dentry)
+{
+	struct scope_list *scope = NULL;
+	char *buf, *path, *cp;
+	struct qstr name;
+
+	buf = kmalloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
+	if (buf) {
+		path = Scope_dget_path(dentry, buf, PATH_LENGTH_BUFFER, 0);
+		if (path) {
+			DbgPrint("Scope_Get_ScopefromPath: %s\n", path);
+
+			if (*path == '/')
+				path++;
+
+			cp = path;
+			if (*cp) {
+				while (*cp && (*cp != '/'))
+					cp++;
+
+				*cp = '\0';
+				name.hash = 0;
+				name.len = (int)(cp - path);
+				name.name = path;
+				scope = Scope_Get_ScopefromName(&name);
+			}
+		}
+		kfree(buf);
+	}
+
+	return scope;
+}
+
+static char *add_to_list(char *name, char *list, char *endoflist)
+{
+	while (*name && (list < endoflist))
+		*list++ = *name++;
+
+	if (list < endoflist)
+		*list++ = '\0';
+
+	return list;
+}
+
+char *Scope_Get_ScopeUsers(void)
+{
+	struct scope_list *scope;
+	struct list_head *sl;
+	int asize = 8 * MAX_USERNAME_LENGTH;
+	char *list, *cp, *ep;
+
+	DbgPrint("Scope_Get_ScopeUsers\n");
+
+	do {			/* Copy list until done or out of memory */
+		list = kmalloc(asize, GFP_KERNEL);
+
+		DbgPrint("Scope_Get_ScopeUsers list=0x%p\n", list);
+		if (list) {
+			cp = list;
+			ep = cp + asize;
+
+			/*
+			 * Add the tree and server entries
+			 */
+			cp = add_to_list(TREE_DIRECTORY_NAME, cp, ep);
+			cp = add_to_list(SERVER_DIRECTORY_NAME, cp, ep);
+
+			down(&Scope_Lock);
+
+			sl = Scope_List.next;
+			while ((sl != &Scope_List) && (cp < ep)) {
+				scope = list_entry(sl, struct scope_list, entry);
+
+				DbgPrint("Scope_Get_ScopeUsers found 0x%p %s\n",
+					 scope, scope->ScopeUserName);
+
+				cp = add_to_list(scope->ScopeUserName, cp, ep);
+
+				sl = sl->next;
+			}
+
+			up(&Scope_Lock);
+
+			if (cp < ep) {
+				*cp++ = '\0';
+				asize = 0;
+			} else {	/* Allocation was to small, up size */
+				asize *= 4;
+				kfree(list);
+				list = NULL;
+			}
+		} else {	/* if allocation fails return an empty list */
+
+			break;
+		}
+	} while (!list);	/* list was to small try again */
+
+	return list;
+}
+
+void *Scope_Lookup(void)
+{
+	return Scope_Find_Scope(1);
+}
+
+static void Scope_Timer_Function(unsigned long context)
+{
+	up(&Scope_Thread_Delay);
+}
+
+static int Scope_Cleanup_Thread(void *Args)
+{
+	struct scope_list *scope;
+	struct scope_list *rscope;
+	struct list_head *sl, cleanup;
+	struct task_struct *task;
+
+	DbgPrint("Scope_Cleanup_Thread: %d\n", current->pid);
+
+	/*
+	 * Setup and start que timer
+	 */
+	init_timer(&Scope_Timer);
+
+	while (0 == Scope_Thread_Terminate) {
+		DbgPrint("Scope_Cleanup_Thread: looping\n");
+		if (Scope_Thread_Terminate)
+			break;
+
+		/*
+		 * Check scope list for any terminated processes
+		 */
+		down(&Scope_Lock);
+
+		sl = Scope_List.next;
+		INIT_LIST_HEAD(&cleanup);
+
+		while (sl != &Scope_List) {
+			scope = list_entry(sl, struct scope_list, entry);
+			sl = sl->next;
+
+			rscope = NULL;
+			rcu_read_lock();
+			for_each_process(task) {
+				if ((task->uid == scope->ScopeUid)
+				    || (task->euid == scope->ScopeUid)) {
+					rscope = scope;
+					break;
+				}
+			}
+			rcu_read_unlock();
+
+			if (!rscope) {
+				list_move(&scope->entry, &cleanup);
+				DbgPrint("Scope_Cleanup_Thread: Scope=0x%p\n",
+					 rscope);
+			}
+		}
+
+		up(&Scope_Lock);
+
+		sl = cleanup.next;
+		while (sl != &cleanup) {
+			scope = list_entry(sl, struct scope_list, entry);
+			sl = sl->next;
+
+			DbgPrint("Scope_Cleanup_Thread: Removing 0x%p\n"
+				 "   ScopeId:       0x%p:%p\n"
+				 "   SessionId:     0x%p:%p\n"
+				 "   ScopePid:      %d\n"
+				 "   ScopeTask:     0x%p\n"
+				 "   ScopeHash:     %u\n"
+				 "   ScopeUid:      %u\n"
+				 "   ScopeUserName: %s\n",
+				 scope,
+				 scope->ScopeId,
+				 scope->SessionId,
+				 scope->ScopePid,
+				 scope->ScopeTask,
+				 scope->ScopeHash,
+				 scope->ScopeUid, scope->ScopeUserName);
+			if (!Scope_Search4Scope(&scope->SessionId, 1, 0)) {
+				Novfs_Remove_from_Root(scope->ScopeUserName);
+				Daemon_DestroySessionId(&scope->SessionId);
+			}
+			kfree(scope);
+		}
+
+		Scope_Timer.expires = jiffies + HZ * CLEANUP_INTERVAL;
+		Scope_Timer.data = (unsigned long)0;
+		Scope_Timer.function = Scope_Timer_Function;
+		add_timer(&Scope_Timer);
+		DbgPrint("Scope_Cleanup_Thread: sleeping\n");
+
+		if (down_interruptible(&Scope_Thread_Delay))
+			break;
+
+		del_timer(&Scope_Timer);
+	}
+	Scope_Thread_Terminate = 0;
+
+	printk(KERN_INFO "Scope_Cleanup_Thread: Exit\n");
+	DbgPrint("Scope_Cleanup_Thread: Exit\n");
+	return 0;
+}
+
+void Scope_Cleanup(void)
+{
+	struct scope_list *scope;
+	struct list_head *sl;
+
+	DbgPrint("Scope_Cleanup:\n");
+
+	/*
+	 * Check scope list for any terminated processes
+	 */
+	down(&Scope_Lock);
+
+	sl = Scope_List.next;
+
+	while (sl != &Scope_List) {
+		scope = list_entry(sl, struct scope_list, entry);
+		sl = sl->next;
+
+		list_del(&scope->entry);
+
+		DbgPrint("Scope_Cleanup: Removing 0x%p\n"
+			 "   ScopeId:       0x%p:%p\n"
+			 "   SessionId:     0x%p:%p\n"
+			 "   ScopePid:      %d\n"
+			 "   ScopeTask:     0x%p\n"
+			 "   ScopeHash:     %u\n"
+			 "   ScopeUid:      %u\n"
+			 "   ScopeUserName: %s\n",
+			 scope,
+			 scope->ScopeId,
+			 scope->SessionId,
+			 scope->ScopePid,
+			 scope->ScopeTask,
+			 scope->ScopeHash,
+			 scope->ScopeUid, scope->ScopeUserName);
+		if (!Scope_Search4Scope(&scope->SessionId, 1, 1)) {
+			Novfs_Remove_from_Root(scope->ScopeUserName);
+			Daemon_DestroySessionId(&scope->SessionId);
+		}
+		kfree(scope);
+	}
+
+	up(&Scope_Lock);
+
+}
+
+/*
+ *  Arguments:   struct dentry *dentry - starting entry
+ *               char *Buf - pointer to memory buffer
+ *               unsigned int Buflen - size of memory buffer
+ *
+ *  Returns:     pointer to path.
+ *
+ *  Abstract:    Walks the dentry chain building a path.
+ */
+char *Scope_dget_path(struct dentry *dentry, char *Buf, unsigned int Buflen,
+		int Flags)
+{
+	char *retval = &Buf[Buflen];
+	struct dentry *p = dentry;
+	int len;
+
+	*(--retval) = '\0';
+	Buflen--;
+
+	do {
+		if (Buflen > p->d_name.len) {
+			retval -= p->d_name.len;
+			Buflen -= p->d_name.len;
+			memcpy(retval, p->d_name.name, p->d_name.len);
+			*(--retval) = '/';
+			Buflen--;
+			p = p->d_parent;
+		} else {
+			retval = NULL;
+			break;
+		}
+	} while (!IS_ROOT(p));
+
+	if (IS_ROOT(dentry))
+		retval++;
+
+	if (Flags) {
+		len = strlen(p->d_sb->s_type->name);
+		if (Buflen - len > 0) {
+			retval -= len;
+			Buflen -= len;
+			memcpy(retval, p->d_sb->s_type->name, len);
+			*(--retval) = '/';
+			Buflen--;
+		}
+	}
+
+	return retval;
+}
+
+void Scope_Init(void)
+{
+	INIT_LIST_HEAD(&Scope_List);
+	init_MUTEX(&Scope_Lock);
+	init_MUTEX_LOCKED(&Scope_Thread_Delay);
+
+	kthread_run(Scope_Cleanup_Thread, NULL, "novfs_ST");
+}
+
+void Scope_Uninit(void)
+{
+	unsigned long expires = jiffies + HZ * SHUTDOWN_INTERVAL;
+
+	printk(KERN_INFO "Scope_Uninit: Start\n");
+
+	Scope_Thread_Terminate = 1;
+
+	up(&Scope_Thread_Delay);
+
+	mb();
+	while (Scope_Thread_Terminate && (jiffies < expires))
+		yield();
+
+	/* down(&Scope_Thread_Delay); */
+	printk(KERN_INFO "Scope_Uninit: Exit\n");
+
+}
+
+
--- /dev/null
+++ b/fs/novfs/vfs.h
@@ -0,0 +1,436 @@
+/*
+ * Novell NCP Redirector for Linux
+ * Author: James Turner
+ *
+ * Include file for novfs.
+ *
+ * Copyright (C) 2005 Novell, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+#ifndef __NOVFS_H
+#define __NOVFS_H
+
+#ifndef __STDC_VERSION__
+#define __STDC_VERSION__ 0L
+#endif
+
+#include <linux/version.h>
+#include <linux/namei.h>
+#include <linux/string.h>
+
+#include "nwcapi.h"
+
+typedef void *HANDLE;
+
+struct schandle {
+	void *hTypeId;
+	void *hId;
+};
+
+static inline void copy_schandle(struct schandle *dest, struct schandle *source)
+{
+	memcpy(dest, source, sizeof(struct schandle));
+}
+#define copy_session_id	copy_schandle
+
+typedef struct schandle session_t;
+
+#include "commands.h"
+
+#define SC_PRESENT(X)		((X.hTypeId != NULL) || (X.hId != NULL)) ? 1 : 0
+#define SC_EQUAL(X, Y)		((X->hTypeId == Y->hTypeId) && (X->hId == Y->hId)) ? 1 : 0
+#define SC_INITIALIZE(X)	{X.hTypeId = X.hId = NULL;}
+
+#define UID_TO_SCHANDLE(hSC, uid)	\
+		{ \
+			hSC.hTypeId = NULL; \
+			hSC.hId = (HANDLE)(unsigned long)(uid); \
+		}
+
+
+
+/*===[ Manifest constants ]===============================================*/
+#define NOVFS_MAGIC		0x4e574653
+#define MODULE_NAME		"novfs"
+
+#define TREE_DIRECTORY_NAME	".Trees"
+#define SERVER_DIRECTORY_NAME	".Servers"
+
+#define PATH_LENGTH_BUFFER	PATH_MAX
+#define NW_MAX_PATH_LENGTH	255
+
+#define XA_BUFFER		(8 * 1024)
+
+#define IOC_LOGIN		0x4a540000
+#define IOC_LOGOUT		0x4a540001
+#define IOC_XPLAT		0x4a540002
+#define IOC_SESSION		0x4a540003
+#define IOC_DEBUGPRINT		0x4a540004
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,15)
+#define D_CHILD d_u.d_child
+#define AS_TREE_LOCK(l)   read_lock_irq(l)
+#define AS_TREE_UNLOCK(l) read_unlock_irq(l)
+#else
+#define D_CHILD d_child
+#define AS_TREE_LOCK(l)   spin_lock_irq(l)
+#define AS_TREE_UNLOCK(l) spin_unlock_irq(l)
+#endif
+
+/*
+ * NetWare file attributes
+ */
+
+#define NW_ATTRIBUTE_NORMAL		0x00
+#define NW_ATTRIBUTE_READ_ONLY		0x01
+#define NW_ATTRIBUTE_HIDDEN		0x02
+#define NW_ATTRIBUTE_SYSTEM		0x04
+#define NW_ATTRIBUTE_EXECUTE_ONLY	0x08
+#define NW_ATTRIBUTE_DIRECTORY		0x10
+#define NW_ATTRIBUTE_ARCHIVE		0x20
+#define NW_ATTRIBUTE_EXECUTE		0x40
+#define NW_ATTRIBUTE_SHAREABLE		0x80
+
+/*
+ * Define READ/WRITE flag for struct data_list
+ */
+#define DLREAD		0
+#define DLWRITE		1
+
+/*
+ * Define list type
+ */
+#define USER_LIST	1
+#define SERVER_LIST	2
+#define VOLUME_LIST	3
+
+/*
+ * Define flags used in for inodes
+ */
+#define USER_INODE	1
+#define UPDATE_INODE	2
+
+/*
+ * Define flags for directory cache flags
+ */
+#define ENTRY_VALID	0x00000001
+
+#ifdef INTENT_MAGIC
+#define NDOPENFLAGS intent.it_flags
+#else
+#define NDOPENFLAGS intent.open.flags
+#endif
+
+/*
+ * daemon_command_t flags values
+ */
+#define INTERRUPTIBLE	1
+
+#ifndef NOVFS_VFS_MAJOR
+#define NOVFS_VFS_MAJOR		0
+#endif
+
+#ifndef NOVFS_VFS_MINOR
+#define NOVFS_VFS_MINOR		0
+#endif
+
+#ifndef NOVFS_VFS_SUB
+#define NOVFS_VFS_SUB		0
+#endif
+
+#ifndef NOVFS_VFS_RELEASE
+#define NOVFS_VFS_RELEASE	0
+#endif
+
+#define VALUE_TO_STR( value ) #value
+#define DEFINE_TO_STR(value) VALUE_TO_STR(value)
+
+#define NOVFS_VERSION_STRING \
+         DEFINE_TO_STR(NOVFS_VFS_MAJOR)"." \
+         DEFINE_TO_STR(NOVFS_VFS_MINOR)"." \
+         DEFINE_TO_STR(NOVFS_VFS_SUB)"-" \
+         DEFINE_TO_STR(NOVFS_VFS_RELEASE) \
+         "\0"
+
+struct entry_info {
+	int type;
+	umode_t mode;
+	uid_t uid;
+	gid_t gid;
+	loff_t size;
+	struct timespec atime;
+	struct timespec mtime;
+	struct timespec ctime;
+	int namelength;
+	unsigned char name[1];
+};
+
+struct novfs_string {
+	int length;
+	unsigned char *data;
+};
+
+struct login {
+	struct novfs_string Server;
+	struct novfs_string UserName;
+	struct novfs_string Password;
+};
+
+struct logout {
+	struct novfs_string Server;
+};
+
+struct dir_cache {
+	struct list_head list;
+	int flags;
+	u64 jiffies;
+	ino_t ino;
+	loff_t size;
+	umode_t mode;
+	struct timespec atime;
+	struct timespec mtime;
+	struct timespec ctime;
+	unsigned long hash;
+	int nameLen;
+	char name[1];
+};
+
+struct data_list {
+	void *page;
+	void *offset;
+	int len;
+	int rwflag;
+};
+
+
+extern char *ctime_r(time_t * clock, char *buf);
+
+static inline u32 HandletoUint32(HANDLE h)
+/*
+ *
+ *  Arguments:   HANDLE h - handle value
+ *
+ *  Returns:     u32 - u32 value
+ *
+ *  Abstract:    Converts a HANDLE to a u32 type.
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	return (u32) ((unsigned long) h);
+}
+
+/*++======================================================================*/
+static inline HANDLE Uint32toHandle(u32 ui32)
+/*
+ *
+ *  Arguments:   u32 ui32
+ *
+ *  Returns:     HANDLE - Handle type.
+ *
+ *  Abstract:    Converts a u32 to a HANDLE type.
+ *
+ *  Notes:
+ *
+ *  Environment:
+ *
+ *========================================================================*/
+{
+	return ((HANDLE) (unsigned long) ui32);
+}
+
+/* Global variables */
+
+extern int Novfs_Version_Major;
+extern int Novfs_Version_Minor;
+extern int Novfs_Version_Sub;
+extern int Novfs_Version_Release;
+extern struct dentry *Novfs_root;
+extern struct proc_dir_entry *Novfs_Procfs_dir;
+extern unsigned long File_update_timeout;
+extern int PageCache;
+extern char *Novfs_CurrentMount;
+extern struct dentry_operations Novfs_dentry_operations;
+extern int MaxIoSize;
+
+
+/* Global functions */
+extern int Novfs_Remove_from_Root(char *);
+extern void Novfs_dump_inode(void *pf);
+
+extern void mydump(int size, void *dumpptr);
+
+extern int Queue_Daemon_Command(void *request, unsigned long reqlen, void *data,
+				int dlen, void **reply, unsigned long * replen,
+				int interruptible);
+
+extern int Init_Procfs_Interface(void);
+extern void Uninit_Procfs_Interface(void);
+
+/*
+ * daemon.c functions
+ */
+extern void Init_Daemon_Queue(void);
+extern void Uninit_Daemon_Queue(void);
+extern int do_login(NclString * Server, NclString * Username, NclString * Password, HANDLE * lgnId, struct schandle *Session);
+extern int do_logout(struct qstr *Server, struct schandle *Session);
+extern int Daemon_SetMountPoint(char *Path);
+extern int Daemon_CreateSessionId(struct schandle *SessionId);
+extern int Daemon_DestroySessionId(struct schandle *SessionId);
+extern int Daemon_getpwuid(uid_t uid, int unamelen, char *uname);
+extern int Daemon_Get_UserSpace(struct schandle *session_id, u64 *TotalSize,
+				u64 *TotalFree, u64 *TotalDirectoryEnties,
+				u64 *FreeDirectoryEnties);
+extern int Daemon_SendDebugCmd(char *Command);
+extern ssize_t Daemon_Receive_Reply(struct file *file, const char __user *buf, size_t nbytes, loff_t *ppos);
+extern ssize_t Daemon_Send_Command(struct file *file, char __user *buf, size_t len, loff_t *off);
+extern int Daemon_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg);
+extern int Daemon_Library_close(struct inode *inode, struct file *file);
+extern int Daemon_Library_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg);
+extern int Daemon_Library_open(struct inode *inode, struct file *file);
+extern ssize_t Daemon_Library_write(struct file *file, const char __user *buf, size_t len, loff_t * off);
+extern ssize_t Daemon_Library_read(struct file *file, char __user *buf, size_t len, loff_t * off);
+extern loff_t Daemon_Library_llseek(struct file *file, loff_t offset, int origin);
+extern int Daemon_Open_Control(struct inode *Inode, struct file *File);
+extern int Daemon_Close_Control(struct inode *Inode, struct file *File);
+extern int Daemon_getversion(char *Buf, int Length);
+
+
+/*
+ * file.c functions
+ */
+extern int Novfs_get_alltrees(struct dentry *parent);
+extern int Novfs_Get_Connected_Server_List(unsigned char **ServerList, struct schandle *SessionId);
+extern int Novfs_Get_Server_Volume_List(struct qstr *Server, unsigned char **VolumeList, struct schandle *SessionId);
+extern int Novfs_Get_File_Info(unsigned char *Path, struct entry_info *Info, struct schandle *SessionId);
+extern int Novfs_GetX_File_Info(char *Path, const char *Name, char *buffer, ssize_t buffer_size, ssize_t *dataLen, struct schandle *SessionId);
+extern int Novfs_ListX_File_Info(char *Path, char *buffer, ssize_t buffer_size, ssize_t * dataLen, struct schandle *SessionId);
+extern int Novfs_SetX_File_Info(char *Path, const char *Name, const void *Value,
+				unsigned long valueLen,
+				unsigned long *bytesWritten, int flags,
+				struct schandle *SessionId);
+
+extern int Novfs_Get_Directory_ListEx(unsigned char *Path, HANDLE *EnumHandle,
+				      int *Count, struct entry_info **Info,
+				      struct schandle *SessionId);
+extern int Novfs_Open_File(unsigned char *Path, int Flags, struct entry_info *info,
+			   HANDLE * Handle, session_t SessionId);
+extern int Novfs_Create(unsigned char *Path, int DirectoryFlag,
+			session_t SessionId);
+extern int Novfs_Close_File(HANDLE Handle, session_t SessionId);
+extern int Novfs_Read_File(HANDLE Handle, unsigned char *Buffer, size_t * Bytes,
+			   loff_t * Offset, session_t SessionId);
+extern int Novfs_Read_Pages(HANDLE Handle, struct data_list *dlist, int DList_Cnt,
+			    size_t * Bytes, loff_t * Offset,
+			    session_t SessionId);
+extern int Novfs_Write_File(HANDLE Handle, unsigned char *Buffer,
+			    size_t * Bytes, loff_t * Offset,
+			    session_t SessionId);
+extern int Novfs_Write_Page(HANDLE Handle, struct page *Page,
+			    session_t SessionId);
+extern int Novfs_Write_Pages(HANDLE Handle, struct data_list *dlist, int DList_Cnt,
+			     size_t Bytes, loff_t Offset, session_t SessionId);
+extern int Novfs_Delete(unsigned char *Path, int DirectoryFlag,
+			session_t SessionId);
+extern int Novfs_Truncate_File(unsigned char *Path, int PathLen,
+			       session_t SessionId);
+extern int Novfs_Truncate_File_Ex(HANDLE Handle, loff_t Offset,
+				  session_t SessionId);
+extern int Novfs_Rename_File(int DirectoryFlag, unsigned char *OldName,
+			     int OldLen, unsigned char *NewName, int NewLen,
+			     session_t SessionId);
+extern int Novfs_Set_Attr(unsigned char *Path, struct iattr *Attr,
+			  session_t SessionId);
+extern int Novfs_Get_File_Cache_Flag(unsigned char * Path, session_t SessionId);
+extern int Novfs_Set_File_Lock(session_t SessionId, HANDLE fhandle,
+			       unsigned char fl_type, loff_t fl_start,
+			       loff_t len);
+
+extern struct inode *Novfs_get_inode(struct super_block *sb, int mode, int dev, uid_t uid, ino_t ino, struct qstr *name);
+extern int Novfs_Read_Stream(HANDLE ConnHandle, unsigned char * Handle,
+			     unsigned char * Buffer, size_t * Bytes, loff_t * Offset,
+			     int User, session_t SessionId);
+extern int Novfs_Write_Stream(HANDLE ConnHandle, unsigned char * Handle,
+			      unsigned char * Buffer, size_t * Bytes, loff_t * Offset,
+			      session_t SessionId);
+extern int Novfs_Close_Stream(HANDLE ConnHandle, unsigned char * Handle,
+			      session_t SessionId);
+
+extern int Novfs_Add_to_Root(char *);
+
+
+/*
+ * scope.c functions
+ */
+extern void Scope_Init(void);
+extern void Scope_Uninit(void);
+extern void *Scope_Lookup(void);
+extern uid_t Scope_Get_Uid(void *);
+extern session_t Scope_Get_SessionId(void *Scope);
+//extern session_t Scope_Get_SessionId(PSCOPE_LIST Scope);
+extern char *Scope_Get_ScopeUsers(void);
+extern int Scope_Set_UserSpace(u64 *TotalSize, u64 *Free,
+			       u64 *TotalEnties, u64 *FreeEnties);
+extern int Scope_Get_UserSpace(u64 *TotalSize, u64 *Free,
+			       u64 *TotalEnties, u64 *FreeEnties);
+extern char *Scope_dget_path(struct dentry *Dentry, char *Buf,
+			     unsigned int Buflen, int Flags);
+extern char *Scope_Get_UserName(void);
+extern void Scope_Cleanup(void);
+
+/*
+ * profile.c functions
+ */
+extern u64 get_nanosecond_time(void);
+static inline void *Novfs_Malloc(size_t size, int flags) { return kmalloc(size, flags); }
+extern int DbgPrint(char *Fmt, ...);
+extern int init_profile(void);
+extern void uninit_profile(void);
+
+/*
+ * nwcapi.c functions
+ */
+extern int NwAuthConnWithId(PXPLAT pdata, session_t Session);
+extern int NwConnClose(PXPLAT pdata, HANDLE * Handle, session_t Session);
+extern int NwGetConnInfo(PXPLAT pdata, session_t Session);
+extern int NwSetConnInfo(PXPLAT pdata, session_t Session);
+extern int NwGetDaemonVersion(PXPLAT pdata, session_t Session);
+extern int NwGetIdentityInfo(PXPLAT pdata, session_t Session);
+extern int NwLicenseConn(PXPLAT pdata, session_t Session);
+extern int NwLoginIdentity(PXPLAT pdata, struct schandle *Session);
+extern int NwLogoutIdentity(PXPLAT pdata, session_t Session);
+extern int NwOpenConnByAddr(PXPLAT pdata, HANDLE * Handle, session_t Session);
+extern int NwOpenConnByName(PXPLAT pdata, HANDLE * Handle, session_t Session);
+extern int NwOpenConnByRef(PXPLAT pdata, HANDLE * Handle, session_t Session);
+extern int NwQueryFeature(PXPLAT pdata, session_t Session);
+extern int NwRawSend(PXPLAT pdata, session_t Session);
+extern int NwScanConnInfo(PXPLAT pdata, session_t Session);
+extern int NwSysConnClose(PXPLAT pdata, unsigned long * Handle, session_t Session);
+extern int NwUnAuthenticate(PXPLAT pdata, session_t Session);
+extern int NwUnlicenseConn(PXPLAT pdata, session_t Session);
+extern int NwcChangeAuthKey(PXPLAT pdata, session_t Session);
+extern int NwcEnumIdentities(PXPLAT pdata, session_t Session);
+extern int NwcGetDefaultNameCtx(PXPLAT pdata, session_t Session);
+extern int NwcGetPreferredDSTree(PXPLAT pdata, session_t Session);
+extern int NwcGetTreeMonitoredConn(PXPLAT pdata, session_t Session);
+extern int NwcSetDefaultNameCtx(PXPLAT pdata, session_t Session);
+extern int NwcSetPreferredDSTree(PXPLAT pdata, session_t Session);
+extern int NwcSetPrimaryConn(PXPLAT pdata, session_t Session);
+extern int NwcGetPrimaryConn(PXPLAT pdata, session_t Session);
+extern int NwcSetMapDrive(PXPLAT pdata, session_t Session);
+extern int NwcUnMapDrive(PXPLAT pdata, session_t Session);
+extern int NwcEnumerateDrives(PXPLAT pdata, session_t Session);
+extern int NwcGetBroadcastMessage(PXPLAT pdata, session_t Session);
+extern int NwdSetKeyValue(PXPLAT pdata, session_t Session);
+extern int NwdVerifyKeyValue(PXPLAT pdata, session_t Session);
+
+
+#endif	/* __NOVFS_H */
+
