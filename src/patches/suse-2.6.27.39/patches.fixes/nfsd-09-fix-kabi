From: NeilBrown <neilb@suse.de
Subject: Fix kabi breakage in previous nfsd patch series
Patch-mainline: not needed
References: bnc#498708

Adding 'thread_wait' to struct cache_req breaks the kabi.
We don't really need this field.  It seemed like a good idea
in terms of generality but:
1/ we don't need the set/not-set test in cache.c because there
   is only one user and it always sets a value
2/ we don't really need the two different values - As long as we have
   some small time limit, it isn't critical what the value is.  The
   two possibilities were mainly provided as a basis for discussion of
   what would be ideal.
   So just set to 3 seconds timeout for any request at any time.

Signed-off-by: Neil Brown <neilb@suse.de>

---
 include/linux/sunrpc/cache.h |    3 ---
 net/sunrpc/cache.c           |   12 +++++-------
 net/sunrpc/svc_xprt.c        |    9 ---------
 3 files changed, 5 insertions(+), 19 deletions(-)

--- linux-2.6.27-working.orig/include/linux/sunrpc/cache.h
+++ linux-2.6.27-working/include/linux/sunrpc/cache.h
@@ -112,9 +112,6 @@ struct cache_detail {
  */
 struct cache_req {
 	struct cache_deferred_req *(*defer)(struct cache_req *req);
-	int thread_wait;  /* How long (jiffies) we can block the
-			   * current thread to wait for updates.
-			   */
 };
 /* this must be embedded in a deferred_request that is being
  * delayed awaiting cache-fill
--- linux-2.6.27-working.orig/net/sunrpc/cache.c
+++ linux-2.6.27-working/net/sunrpc/cache.c
@@ -584,12 +584,10 @@ static int cache_defer_req(struct cache_
 		if (net_random()&1)
 			return 0;
 	}
-	if (req->thread_wait) {
-		dreq = &sleeper.handle;
-		init_waitqueue_head(&sleeper.wait);
-		dreq->revisit = cache_restart_thread;
-	} else
-		dreq = req->defer(req);
+
+	dreq = &sleeper.handle;
+	init_waitqueue_head(&sleeper.wait);
+	dreq->revisit = cache_restart_thread;
 
  retry:
 	if (dreq == NULL)
@@ -631,7 +629,7 @@ static int cache_defer_req(struct cache_
 			sleeper.wait,
 			!test_bit(CACHE_PENDING, &item->flags)
 			|| list_empty(&sleeper.handle.hash),
-			req->thread_wait);
+			3*HZ);
 		spin_lock(&cache_defer_lock);
 		if (!list_empty(&sleeper.handle.hash)) {
 			list_del_init(&sleeper.handle.recent);
--- linux-2.6.27-working.orig/net/sunrpc/svc_xprt.c
+++ linux-2.6.27-working/net/sunrpc/svc_xprt.c
@@ -594,10 +594,6 @@ int svc_recv(struct svc_rqst *rqstp, lon
 
 	spin_lock_bh(&pool->sp_lock);
 
-	/* Normally we will wait up to 5 seconds for any required
-	 * cache information to be provided.
-	 */
-	rqstp->rq_chandle.thread_wait = 5*HZ;
 	xprt = svc_xprt_dequeue(pool);
 	if (xprt) {
 		rqstp->rq_xprt = xprt;
@@ -605,11 +601,6 @@ int svc_recv(struct svc_rqst *rqstp, lon
 		rqstp->rq_reserved = serv->sv_max_mesg;
 		atomic_add(rqstp->rq_reserved, &xprt->xpt_reserved);
 
-		/* As there is a shortage of threads and this request
-		 * had to be queue, don't allow the thread to wait so
-		 * long for cache updates.
-		 */
-		rqstp->rq_chandle.thread_wait = 1*HZ;
 	} else {
 		/* No data pending. Go to sleep */
 		svc_thread_enqueue(pool, rqstp);
