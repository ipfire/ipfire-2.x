From: Jeff Mahoney <jeffm@suse.com>
Subject: reiserfs: use reiserfs_error()

 This patch makes many paths that are currently using warnings to handle
 the error.

Signed-off-by: Jeff Mahoney <jeffm@suse.com>

--

 fs/reiserfs/bitmap.c          |   56 +++++++++++++++++++++---------------------
 fs/reiserfs/inode.c           |   45 +++++++++++++++------------------
 fs/reiserfs/lbalance.c        |   20 +++++++--------
 fs/reiserfs/namei.c           |   24 +++++++++---------
 fs/reiserfs/objectid.c        |    4 +--
 fs/reiserfs/stree.c           |   26 +++++++++----------
 fs/reiserfs/super.c           |   15 +++++------
 fs/reiserfs/tail_conversion.c |    6 ++--
 fs/reiserfs/xattr.c           |   21 +++++++--------
 9 files changed, 107 insertions(+), 110 deletions(-)

--- a/fs/reiserfs/bitmap.c
+++ b/fs/reiserfs/bitmap.c
@@ -64,9 +64,9 @@ int is_reusable(struct super_block *s, b
 	unsigned int bmap_count = reiserfs_bmap_count(s);
 
 	if (block == 0 || block >= SB_BLOCK_COUNT(s)) {
-		reiserfs_warning(s, "vs-4010",
-				 "block number is out of range %lu (%u)",
-				 block, SB_BLOCK_COUNT(s));
+		reiserfs_error(s, "vs-4010",
+			       "block number is out of range %lu (%u)",
+			       block, SB_BLOCK_COUNT(s));
 		return 0;
 	}
 
@@ -79,30 +79,30 @@ int is_reusable(struct super_block *s, b
 		b_blocknr_t bmap1 = REISERFS_SB(s)->s_sbh->b_blocknr + 1;
 		if (block >= bmap1 &&
 		    block <= bmap1 + bmap_count) {
-			reiserfs_warning(s, "vs-4019", "bitmap block %lu(%u) "
-					 "can't be freed or reused",
-					 block, bmap_count);
+			reiserfs_error(s, "vs-4019", "bitmap block %lu(%u) "
+				       "can't be freed or reused",
+				       block, bmap_count);
 			return 0;
 		}
 	} else {
 		if (offset == 0) {
-			reiserfs_warning(s, "vs-4020", "bitmap block %lu(%u) "
-					 "can't be freed or reused",
-					 block, bmap_count);
+			reiserfs_error(s, "vs-4020", "bitmap block %lu(%u) "
+				       "can't be freed or reused",
+				       block, bmap_count);
 			return 0;
 		}
 	}
 
 	if (bmap >= bmap_count) {
-		reiserfs_warning(s, "vs-4030", "bitmap for requested block "
-				 "is out of range: block=%lu, bitmap_nr=%u",
-				 block, bmap);
+		reiserfs_error(s, "vs-4030", "bitmap for requested block "
+			       "is out of range: block=%lu, bitmap_nr=%u",
+			       block, bmap);
 		return 0;
 	}
 
 	if (bit_value == 0 && block == SB_ROOT_BLOCK(s)) {
-		reiserfs_warning(s, "vs-4050", "this is root block (%u), "
-				 "it must be busy", SB_ROOT_BLOCK(s));
+		reiserfs_error(s, "vs-4050", "this is root block (%u), "
+			       "it must be busy", SB_ROOT_BLOCK(s));
 		return 0;
 	}
 
@@ -153,8 +153,8 @@ static int scan_bitmap_block(struct reis
 /* - I mean `a window of zero bits' as in description of this function - Zam. */
 
 	if (!bi) {
-		reiserfs_warning(s, "jdm-4055", "NULL bitmap info pointer "
-				 "for bitmap %d", bmap_n);
+		reiserfs_error(s, "jdm-4055", "NULL bitmap info pointer "
+			       "for bitmap %d", bmap_n);
 		return 0;
 	}
 
@@ -399,8 +399,8 @@ static void _reiserfs_free_block(struct 
 	get_bit_address(s, block, &nr, &offset);
 
 	if (nr >= reiserfs_bmap_count(s)) {
-		reiserfs_warning(s, "vs-4075", "block %lu is out of range",
-				 block);
+		reiserfs_error(s, "vs-4075", "block %lu is out of range",
+			       block);
 		return;
 	}
 
@@ -412,8 +412,8 @@ static void _reiserfs_free_block(struct 
 
 	/* clear bit for the given block in bit map */
 	if (!reiserfs_test_and_clear_le_bit(offset, bmbh->b_data)) {
-		reiserfs_warning(s, "vs-4080",
-				 "block %lu: bit already cleared", block);
+		reiserfs_error(s, "vs-4080",
+			       "block %lu: bit already cleared", block);
 	}
 	apbi[nr].free_count++;
 	journal_mark_dirty(th, s, bmbh);
@@ -440,7 +440,7 @@ void reiserfs_free_block(struct reiserfs
 		return;
 
 	if (block > sb_block_count(REISERFS_SB(s)->s_rs)) {
-		reiserfs_panic(th->t_super, "bitmap-4072",
+		reiserfs_error(th->t_super, "bitmap-4072",
 			       "Trying to free block outside file system "
 			       "boundaries (%lu > %lu)",
 			       block, sb_block_count(REISERFS_SB(s)->s_rs));
@@ -472,8 +472,8 @@ static void __discard_prealloc(struct re
 	BUG_ON(!th->t_trans_id);
 #ifdef CONFIG_REISERFS_CHECK
 	if (ei->i_prealloc_count < 0)
-		reiserfs_warning(th->t_super, "zam-4001",
-				 "inode has negative prealloc blocks count.");
+		reiserfs_error(th->t_super, "zam-4001",
+			       "inode has negative prealloc blocks count.");
 #endif
 	while (ei->i_prealloc_count > 0) {
 		reiserfs_free_prealloc_block(th, inode, ei->i_prealloc_block);
@@ -509,9 +509,9 @@ void reiserfs_discard_all_prealloc(struc
 				i_prealloc_list);
 #ifdef CONFIG_REISERFS_CHECK
 		if (!ei->i_prealloc_count) {
-			reiserfs_warning(th->t_super, "zam-4001",
-					 "inode is in prealloc list but has "
-					 "no preallocated blocks.");
+			reiserfs_error(th->t_super, "zam-4001",
+				       "inode is in prealloc list but has "
+				       "no preallocated blocks.");
 		}
 #endif
 		__discard_prealloc(th, ei);
@@ -1214,7 +1214,9 @@ void reiserfs_cache_bitmap_metadata(stru
 	unsigned long *cur = (unsigned long *)(bh->b_data + bh->b_size);
 
 	/* The first bit must ALWAYS be 1 */
-	BUG_ON(!reiserfs_test_le_bit(0, (unsigned long *)bh->b_data));
+	if (!reiserfs_test_le_bit(0, (unsigned long *)bh->b_data))
+		reiserfs_error(sb, "reiserfs-2025", "bitmap block %lu is "
+			       "corrupted: first bit must be 1", bh->b_blocknr);
 
 	info->free_count = 0;
 
--- a/fs/reiserfs/inode.c
+++ b/fs/reiserfs/inode.c
@@ -841,12 +841,12 @@ int reiserfs_get_block(struct inode *ino
 							  tail_offset);
 				if (retval) {
 					if (retval != -ENOSPC)
-						reiserfs_warning(inode->i_sb,
-							 "clm-6004",
-							 "convert tail failed "
-							 "inode %lu, error %d",
-								 inode->i_ino,
-								 retval);
+						reiserfs_error(inode->i_sb,
+							"clm-6004",
+							"convert tail failed "
+							"inode %lu, error %d",
+							inode->i_ino,
+							retval);
 					if (allocated_block_nr) {
 						/* the bitmap, the super, and the stat data == 3 */
 						if (!th)
@@ -1332,10 +1332,9 @@ void reiserfs_update_sd_size(struct reis
 		/* look for the object's stat data */
 		retval = search_item(inode->i_sb, &key, &path);
 		if (retval == IO_ERROR) {
-			reiserfs_warning(inode->i_sb, "vs-13050",
-					 "i/o failure occurred trying to "
-					 "update %K stat data",
-					 &key);
+			reiserfs_error(inode->i_sb, "vs-13050",
+				       "i/o failure occurred trying to "
+				       "update %K stat data", &key);
 			return;
 		}
 		if (retval == ITEM_NOT_FOUND) {
@@ -1424,9 +1423,9 @@ void reiserfs_read_locked_inode(struct i
 	/* look for the object's stat data */
 	retval = search_item(inode->i_sb, &key, &path_to_sd);
 	if (retval == IO_ERROR) {
-		reiserfs_warning(inode->i_sb, "vs-13070",
-				 "i/o failure occurred trying to find "
-				 "stat data of %K", &key);
+		reiserfs_error(inode->i_sb, "vs-13070",
+			       "i/o failure occurred trying to find "
+			       "stat data of %K", &key);
 		reiserfs_make_bad_inode(inode);
 		return;
 	}
@@ -1687,8 +1686,8 @@ static int reiserfs_new_directory(struct
 	/* look for place in the tree for new item */
 	retval = search_item(sb, &key, path);
 	if (retval == IO_ERROR) {
-		reiserfs_warning(sb, "vs-13080",
-				 "i/o failure occurred creating new directory");
+		reiserfs_error(sb, "vs-13080",
+			       "i/o failure occurred creating new directory");
 		return -EIO;
 	}
 	if (retval == ITEM_FOUND) {
@@ -1727,8 +1726,8 @@ static int reiserfs_new_symlink(struct r
 	/* look for place in the tree for new item */
 	retval = search_item(sb, &key, path);
 	if (retval == IO_ERROR) {
-		reiserfs_warning(sb, "vs-13080",
-				 "i/o failure occurred creating new symlink");
+		reiserfs_error(sb, "vs-13080",
+			       "i/o failure occurred creating new symlink");
 		return -EIO;
 	}
 	if (retval == ITEM_FOUND) {
@@ -2048,10 +2047,8 @@ static int grab_tail_page(struct inode *
 		 ** I've screwed up the code to find the buffer, or the code to
 		 ** call prepare_write
 		 */
-		reiserfs_warning(p_s_inode->i_sb, "clm-6000",
-				 "error reading block %lu on dev %s",
-				 bh->b_blocknr,
-				 reiserfs_bdevname(p_s_inode->i_sb));
+		reiserfs_error(p_s_inode->i_sb, "clm-6000",
+			       "error reading block %lu", bh->b_blocknr);
 		error = -EIO;
 		goto unlock;
 	}
@@ -2093,9 +2090,9 @@ int reiserfs_truncate_file(struct inode 
 			// and get_block_create_0 could not find a block to read in,
 			// which is ok.
 			if (error != -ENOENT)
-				reiserfs_warning(p_s_inode->i_sb, "clm-6001",
-						 "grab_tail_page failed %d",
-						 error);
+				reiserfs_error(p_s_inode->i_sb, "clm-6001",
+					       "grab_tail_page failed %d",
+					       error);
 			page = NULL;
 			bh = NULL;
 		}
--- a/fs/reiserfs/lbalance.c
+++ b/fs/reiserfs/lbalance.c
@@ -1291,17 +1291,17 @@ void leaf_paste_entries(struct buffer_in
 			prev = (i != 0) ? deh_location(&(deh[i - 1])) : 0;
 
 			if (prev && prev <= deh_location(&(deh[i])))
-				reiserfs_warning(NULL, "vs-10240",
-						 "directory item (%h) "
-						 "corrupted (prev %a, "
-						 "cur(%d) %a)",
-						 ih, deh + i - 1, i, deh + i);
+				reiserfs_error(sb_from_bi(bi), "vs-10240",
+					       "directory item (%h) "
+					       "corrupted (prev %a, "
+					       "cur(%d) %a)",
+					       ih, deh + i - 1, i, deh + i);
 			if (next && next >= deh_location(&(deh[i])))
-				reiserfs_warning(NULL, "vs-10250",
-						 "directory item (%h) "
-						 "corrupted (cur(%d) %a, "
-						 "next %a)",
-						 ih, i, deh + i, deh + i + 1);
+				reiserfs_error(sb_from_bi(bi), "vs-10250",
+					       "directory item (%h) "
+					       "corrupted (cur(%d) %a, "
+					       "next %a)",
+					       ih, i, deh + i, deh + i + 1);
 		}
 	}
 #endif
--- a/fs/reiserfs/namei.c
+++ b/fs/reiserfs/namei.c
@@ -120,8 +120,8 @@ int search_by_entry_key(struct super_blo
 	switch (retval) {
 	case ITEM_NOT_FOUND:
 		if (!PATH_LAST_POSITION(path)) {
-			reiserfs_warning(sb, "vs-7000", "search_by_key "
-					 "returned item position == 0");
+			reiserfs_error(sb, "vs-7000", "search_by_key "
+				       "returned item position == 0");
 			pathrelse(path);
 			return IO_ERROR;
 		}
@@ -135,7 +135,7 @@ int search_by_entry_key(struct super_blo
 
 	default:
 		pathrelse(path);
-		reiserfs_warning(sb, "vs-7002", "no path to here");
+		reiserfs_error(sb, "vs-7002", "no path to here");
 		return IO_ERROR;
 	}
 
@@ -298,7 +298,7 @@ static int reiserfs_find_entry(struct in
 		    search_by_entry_key(dir->i_sb, &key_to_search,
 					path_to_entry, de);
 		if (retval == IO_ERROR) {
-			reiserfs_warning(dir->i_sb, "zam-7001", "io error");
+			reiserfs_error(dir->i_sb, "zam-7001", "io error");
 			return IO_ERROR;
 		}
 
@@ -490,9 +490,9 @@ static int reiserfs_add_entry(struct rei
 		}
 
 		if (retval != NAME_FOUND) {
-			reiserfs_warning(dir->i_sb, "zam-7002",
-					 "reiserfs_find_entry() returned "
-					 "unexpected value (%d)", retval);
+			reiserfs_error(dir->i_sb, "zam-7002",
+				       "reiserfs_find_entry() returned "
+				       "unexpected value (%d)", retval);
 		}
 
 		return -EEXIST;
@@ -902,9 +902,9 @@ static int reiserfs_rmdir(struct inode *
 		goto end_rmdir;
 
 	if (inode->i_nlink != 2 && inode->i_nlink != 1)
-		reiserfs_warning(inode->i_sb, "reiserfs-7040",
-				 "empty directory has nlink != 2 (%d)",
-				 inode->i_nlink);
+		reiserfs_error(inode->i_sb, "reiserfs-7040",
+			       "empty directory has nlink != 2 (%d)",
+			       inode->i_nlink);
 
 	clear_nlink(inode);
 	inode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME_SEC;
@@ -1495,8 +1495,8 @@ static int reiserfs_rename(struct inode 
 	if (reiserfs_cut_from_item
 	    (&th, &old_entry_path, &(old_de.de_entry_key), old_dir, NULL,
 	     0) < 0)
-		reiserfs_warning(old_dir->i_sb, "vs-7060",
-				 "couldn't not cut old name. Fsck later?");
+		reiserfs_error(old_dir->i_sb, "vs-7060",
+			       "couldn't not cut old name. Fsck later?");
 
 	old_dir->i_size -= DEH_SIZE + old_de.de_entrylen;
 
--- a/fs/reiserfs/objectid.c
+++ b/fs/reiserfs/objectid.c
@@ -159,8 +159,8 @@ void reiserfs_release_objectid(struct re
 		i += 2;
 	}
 
-	reiserfs_warning(s, "vs-15011", "tried to free free object id (%lu)",
-			 (long unsigned)objectid_to_release);
+	reiserfs_error(s, "vs-15011", "tried to free free object id (%lu)",
+		       (long unsigned)objectid_to_release);
 }
 
 int reiserfs_convert_objectid_map_v1(struct super_block *s)
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -720,9 +720,9 @@ int search_by_key(struct super_block *p_
 		// make sure, that the node contents look like a node of
 		// certain level
 		if (!is_tree_node(p_s_bh, expected_level)) {
-			reiserfs_warning(p_s_sb, "vs-5150",
-					 "invalid format found in block %ld. "
-					 "Fsck?", p_s_bh->b_blocknr);
+			reiserfs_error(p_s_sb, "vs-5150",
+				       "invalid format found in block %ld. "
+				       "Fsck?", p_s_bh->b_blocknr);
 			pathrelse(p_s_search_path);
 			return IO_ERROR;
 		}
@@ -1336,9 +1336,9 @@ void reiserfs_delete_solid_item(struct r
 	while (1) {
 		retval = search_item(th->t_super, &cpu_key, &path);
 		if (retval == IO_ERROR) {
-			reiserfs_warning(th->t_super, "vs-5350",
-					 "i/o failure occurred trying "
-					 "to delete %K", &cpu_key);
+			reiserfs_error(th->t_super, "vs-5350",
+				       "i/o failure occurred trying "
+				       "to delete %K", &cpu_key);
 			break;
 		}
 		if (retval != ITEM_FOUND) {
@@ -1737,7 +1737,7 @@ static void truncate_directory(struct re
 {
 	BUG_ON(!th->t_trans_id);
 	if (inode->i_nlink)
-		reiserfs_warning(inode->i_sb, "vs-5655", "link count != 0");
+		reiserfs_error(inode->i_sb, "vs-5655", "link count != 0");
 
 	set_le_key_k_offset(KEY_FORMAT_3_5, INODE_PKEY(inode), DOT_OFFSET);
 	set_le_key_k_type(KEY_FORMAT_3_5, INODE_PKEY(inode), TYPE_DIRENTRY);
@@ -1790,16 +1790,16 @@ int reiserfs_do_truncate(struct reiserfs
 	    search_for_position_by_key(p_s_inode->i_sb, &s_item_key,
 				       &s_search_path);
 	if (retval == IO_ERROR) {
-		reiserfs_warning(p_s_inode->i_sb, "vs-5657",
-				 "i/o failure occurred trying to truncate %K",
-				 &s_item_key);
+		reiserfs_error(p_s_inode->i_sb, "vs-5657",
+			       "i/o failure occurred trying to truncate %K",
+			       &s_item_key);
 		err = -EIO;
 		goto out;
 	}
 	if (retval == POSITION_FOUND || retval == FILE_NOT_FOUND) {
-		reiserfs_warning(p_s_inode->i_sb, "PAP-5660",
-				 "wrong result %d of search for %K", retval,
-				 &s_item_key);
+		reiserfs_error(p_s_inode->i_sb, "PAP-5660",
+			       "wrong result %d of search for %K", retval,
+			       &s_item_key);
 
 		err = -EIO;
 		goto out;
--- a/fs/reiserfs/super.c
+++ b/fs/reiserfs/super.c
@@ -193,9 +193,8 @@ static int finish_unfinished(struct supe
 	while (!retval) {
 		retval = search_item(s, &max_cpu_key, &path);
 		if (retval != ITEM_NOT_FOUND) {
-			reiserfs_warning(s, "vs-2140",
-					 "search_by_key returned %d",
-					 retval);
+			reiserfs_error(s, "vs-2140",
+				       "search_by_key returned %d", retval);
 			break;
 		}
 
@@ -376,9 +375,9 @@ void add_save_link(struct reiserfs_trans
 	retval = search_item(inode->i_sb, &key, &path);
 	if (retval != ITEM_NOT_FOUND) {
 		if (retval != -ENOSPC)
-			reiserfs_warning(inode->i_sb, "vs-2100",
-					 "search_by_key (%K) returned %d", &key,
-					 retval);
+			reiserfs_error(inode->i_sb, "vs-2100",
+				       "search_by_key (%K) returned %d", &key,
+				       retval);
 		pathrelse(&path);
 		return;
 	}
@@ -391,8 +390,8 @@ void add_save_link(struct reiserfs_trans
 	    reiserfs_insert_item(th, &path, &key, &ih, NULL, (char *)&link);
 	if (retval) {
 		if (retval != -ENOSPC)
-			reiserfs_warning(inode->i_sb, "vs-2120",
-					 "insert_item returned %d", retval);
+			reiserfs_error(inode->i_sb, "vs-2120",
+				       "insert_item returned %d", retval);
 	} else {
 		if (truncate)
 			REISERFS_I(inode)->i_flags |=
--- a/fs/reiserfs/tail_conversion.c
+++ b/fs/reiserfs/tail_conversion.c
@@ -48,9 +48,9 @@ int direct2indirect(struct reiserfs_tran
 
 	// FIXME: we could avoid this 
 	if (search_for_position_by_key(sb, &end_key, path) == POSITION_FOUND) {
-		reiserfs_warning(sb, "PAP-14030",
-				 "pasted or inserted byte exists in "
-				 "the tree %K. Use fsck to repair.", &end_key);
+		reiserfs_error(sb, "PAP-14030",
+			       "pasted or inserted byte exists in "
+			       "the tree %K. Use fsck to repair.", &end_key);
 		pathrelse(path);
 		return -EIO;
 	}
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -259,8 +259,8 @@ static int __xattr_readdir(struct inode 
 		ih = de.de_ih;
 
 		if (!is_direntry_le_ih(ih)) {
-			reiserfs_warning(inode->i_sb, "jdm-20000",
-					 "not direntry %h", ih);
+			reiserfs_error(inode->i_sb, "jdm-20000",
+				       "not direntry %h", ih);
 			break;
 		}
 		copy_item_head(&tmp_ih, ih);
@@ -653,15 +653,14 @@ __reiserfs_xattr_del(struct dentry *xadi
 		goto out_file;
 
 	if (!is_reiserfs_priv_object(dentry->d_inode)) {
-		reiserfs_warning(dir->i_sb, "jdm-20003",
-				 "OID %08x [%.*s/%.*s] doesn't have "
-				 "priv flag set [parent is %sset].",
-				 le32_to_cpu(INODE_PKEY(dentry->d_inode)->
-					     k_objectid), xadir->d_name.len,
-				 xadir->d_name.name, namelen, name,
-				 is_reiserfs_priv_object(xadir->
-							 d_inode) ? "" :
-				 "not ");
+		reiserfs_error(dir->i_sb, "jdm-20003",
+			       "OID %08x [%.*s/%.*s] doesn't have "
+			       "priv flag set [parent is %sset].",
+			       le32_to_cpu(INODE_PKEY(dentry->d_inode)->
+					   k_objectid), xadir->d_name.len,
+			       xadir->d_name.name, namelen, name,
+			       is_reiserfs_priv_object(xadir->d_inode) ? "" :
+			       "not ");
 		dput(dentry);
 		return -EIO;
 	}
