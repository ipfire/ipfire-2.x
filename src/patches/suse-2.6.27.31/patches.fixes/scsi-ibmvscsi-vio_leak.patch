Subject: Correct VIO bus/device CMO accounting problems
From: Robert Jennings <rcj@linux.vnet.ibm.com>
References: 468304 - LTC51205

This corrects three entitlement accounting issues that are all small in
scope but at least two of them are critical.

In the VIO bus code the wrappers for dma alloc_coherent and free_coherent
calls are rounding to IOMMU_PAGE_SIZE.  Taking a look at the underlying
calls, the actual mapping is promoted to PAGE_SIZE.  Changing the
rounding in these two functions fixes under reporting the entitlement
used.  Without this change, the system could run out of entitlement before
it believes it has and incur mapping failures at the firmware level.

Also in the VIO bus code, the wrapper for dma map_sg is not exiting in
an error path where it should.  Rather than fall through to code for the
success case, this patch adds the return that is needed in the error path.

The ibmvscsi client driver is not unmapping the scsi command after
encountering a dma mapping error while trying to map an indirect
scattergather list.  This leads to a leak of dma entitlement that could
result in the device failing future dma operations.

Signed-off-by: Robert Jennings <rcj@linux.vnet.ibm.com>
Signed-off-by: Olaf Hering <olh@suse.de>

--
 arch/powerpc/kernel/vio.c        |    7 ++++---
 drivers/scsi/ibmvscsi/ibmvfc.c   |    4 +++-
 drivers/scsi/ibmvscsi/ibmvscsi.c |    1 +
 3 files changed, 8 insertions(+), 4 deletions(-)

--- a/arch/powerpc/kernel/vio.c
+++ b/arch/powerpc/kernel/vio.c
@@ -492,14 +492,14 @@ static void *vio_dma_iommu_alloc_coheren
 	struct vio_dev *viodev = to_vio_dev(dev);
 	void *ret;
 
-	if (vio_cmo_alloc(viodev, roundup(size, IOMMU_PAGE_SIZE))) {
+	if (vio_cmo_alloc(viodev, roundup(size, PAGE_SIZE))) {
 		atomic_inc(&viodev->cmo.allocs_failed);
 		return NULL;
 	}
 
 	ret = dma_iommu_ops.alloc_coherent(dev, size, dma_handle, flag);
 	if (unlikely(ret == NULL)) {
-		vio_cmo_dealloc(viodev, roundup(size, IOMMU_PAGE_SIZE));
+		vio_cmo_dealloc(viodev, roundup(size, PAGE_SIZE));
 		atomic_inc(&viodev->cmo.allocs_failed);
 	}
 
@@ -513,7 +513,7 @@ static void vio_dma_iommu_free_coherent(
 
 	dma_iommu_ops.free_coherent(dev, size, vaddr, dma_handle);
 
-	vio_cmo_dealloc(viodev, roundup(size, IOMMU_PAGE_SIZE));
+	vio_cmo_dealloc(viodev, roundup(size, PAGE_SIZE));
 }
 
 static dma_addr_t vio_dma_iommu_map_single(struct device *dev, void *vaddr,
@@ -572,6 +572,7 @@ static int vio_dma_iommu_map_sg(struct d
 	if (unlikely(!ret)) {
 		vio_cmo_dealloc(viodev, alloc_size);
 		atomic_inc(&viodev->cmo.allocs_failed);
+		return ret;
 	}
 
 	for (sgl = sglist, count = 0; count < ret; count++, sgl++)
--- a/drivers/scsi/ibmvscsi/ibmvfc.c
+++ b/drivers/scsi/ibmvscsi/ibmvfc.c
@@ -1323,7 +1323,9 @@ static int ibmvfc_map_sg_data(struct scs
 					       &evt->ext_list_token);
 
 		if (!evt->ext_list) {
-			scmd_printk(KERN_ERR, scmd, "Can't allocate memory for scatterlist\n");
+			scsi_dma_unmap(scmd);
+			if (vhost->log_level > IBMVFC_DEFAULT_LOG_LEVEL)
+				scmd_printk(KERN_ERR, scmd, "Can't allocate memory for scatterlist\n");
 			return -ENOMEM;
 		}
 	}
--- a/drivers/scsi/ibmvscsi/ibmvscsi.c
+++ b/drivers/scsi/ibmvscsi/ibmvscsi.c
@@ -435,6 +435,7 @@ static int map_sg_data(struct scsi_cmnd 
 				sdev_printk(KERN_ERR, cmd->device,
 				            "Can't allocate memory "
 				            "for indirect table\n");
+			scsi_dma_unmap(cmd);
 			return 0;
 		}
 	}
