From: Thomas Renninger <trenn@stravinsky.suse.de>
Subject: Serve ThinkPad IGD devices backlight functionality through thinkpad_acpi
References: fate #302883

In future IDG devices will be handled by the dri subsystem.
But this code is very young and complex, better workaround this in
thinkpad_acpi driver for now.

If in a later service pack the IGD parts get backported, this patch must
be reverted.

Signed-off-by: Thomas Renninger <trenn@suse.de>
---
 drivers/acpi/video_detect.c  |   15 +++++++++++++++
 drivers/misc/thinkpad_acpi.c |   40 ++++++++++++++++++++++++++++++++++++----
 include/linux/acpi.h         |    2 ++
 3 files changed, 53 insertions(+), 4 deletions(-)

--- a/drivers/acpi/video_detect.c
+++ b/drivers/acpi/video_detect.c
@@ -99,6 +99,21 @@ long acpi_is_video_device(struct acpi_de
 				    ACPI_UINT32_MAX, acpi_backlight_cap_match,
 				    &video_caps, NULL);
 
+	/* IGD detection is not perfect. It should use the same method as done
+	 * to identify an IGD device in the dri parts or video.ko
+	 */
+
+	/*
+	 * ThinkPads do need the IGD implementation, we detect ThinkPad IGD
+	 * devices here and specially workaround it in thinkpad_acpi as the
+	 * IGD parts are too experimental yet
+	*/
+	if (dmi_name_in_vendors("LENOVO") &&
+	    ACPI_SUCCESS(acpi_get_handle(device->handle, "DRDY", &h_dummy))) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found IGD device\n"));
+		video_caps |= ACPI_VIDEO_IGD;
+	}
+
 	return video_caps;
 }
 EXPORT_SYMBOL(acpi_is_video_device);
--- a/drivers/misc/thinkpad_acpi.c
+++ b/drivers/misc/thinkpad_acpi.c
@@ -240,6 +240,7 @@ static struct {
 	u32 light_status:1;
 	u32 bright_16levels:1;
 	u32 bright_acpimode:1;
+	u32 bright_igdmode:1;
 	u32 wan:1;
 	u32 fan_ctrl_status_undef:1;
 	u32 input_device_registered:1;
@@ -2359,6 +2360,9 @@ err_exit:
 	return (res < 0)? res : 1;
 }
 
+static struct backlight_device *ibm_backlight_device;
+static int brightness_update_status(struct backlight_device *bd);
+
 static void hotkey_notify(struct ibm_struct *ibm, u32 event)
 {
 	u32 hkey;
@@ -2397,6 +2401,28 @@ static void hotkey_notify(struct ibm_str
 		case 1:
 			/* 0x1000-0x1FFF: key presses */
 			scancode = hkey & 0xfff;
+			if (tp_features.bright_igdmode) {
+				/* ToDo:
+				 * Is there an already defined key?
+				 */
+				if (hkey == 0x1011) {
+					if (ibm_backlight_device->
+					    props.brightness > 0) {
+						ibm_backlight_device->
+							props.brightness--;
+					}
+				} else if (hkey == 0x1010) {
+					if (ibm_backlight_device->
+					    props.brightness <
+					    ibm_backlight_device->
+					    props.max_brightness) {
+						ibm_backlight_device->
+							props.brightness++;
+					}
+				}
+				brightness_update_status(ibm_backlight_device);
+			}
+
 			if (scancode > 0 && scancode < 0x21) {
 				scancode--;
 				if (!(hotkey_source_mask & (1 << scancode))) {
@@ -4767,7 +4793,6 @@ enum {
 	TP_EC_BACKLIGHT_MAPSW = 0x20,
 };
 
-static struct backlight_device *ibm_backlight_device;
 static int brightness_mode;
 static unsigned int brightness_enable = 2; /* 2 = auto, 0 = no, 1 = yes */
 
@@ -4906,7 +4931,7 @@ static struct backlight_ops ibm_backligh
 static int __init brightness_init(struct ibm_init_struct *iibm)
 {
 	int b;
-
+	long acpi_video_support;
 	vdbg_printk(TPACPI_DBG_INIT, "initializing brightness subdriver\n");
 
 	mutex_init(&brightness_mutex);
@@ -4918,8 +4943,9 @@ static int __init brightness_init(struct
 	 */
 	b = tpacpi_check_std_acpi_brightness_support();
 	if (b > 0) {
-
-		if (acpi_video_backlight_support()) {
+		acpi_video_support = acpi_video_backlight_support();
+		if (acpi_video_support &&
+		    !(acpi_video_support & ACPI_VIDEO_IGD)) {
 			if (brightness_enable > 1) {
 				printk(TPACPI_NOTICE
 				       "Standard ACPI backlight interface "
@@ -4937,6 +4963,12 @@ static int __init brightness_init(struct
 				       "available, thinkpad_acpi driver "
 				       "will take over control\n");
 			}
+			if (acpi_video_support & ACPI_VIDEO_IGD) {
+				printk(TPACPI_NOTICE, "IGD device"
+				       " detected - take over backlight"
+				       " switching\n");
+				tp_features.bright_igdmode = 1;
+			}
 		}
 	}
 
--- a/include/linux/acpi.h
+++ b/include/linux/acpi.h
@@ -214,6 +214,8 @@ extern bool wmi_has_guid(const char *gui
 #define ACPI_VIDEO_BACKLIGHT_DMI_VIDEO			0x0200
 #define ACPI_VIDEO_OUTPUT_SWITCHING_DMI_VENDOR		0x0400
 #define ACPI_VIDEO_OUTPUT_SWITCHING_DMI_VIDEO		0x0800
+/* Do not use the IGD define, this is a SUSE only ThinkPad workaround hack! */
+#define ACPI_VIDEO_IGD					0x1000
 
 #if defined(CONFIG_ACPI_VIDEO) || defined(CONFIG_ACPI_VIDEO_MODULE)
 
