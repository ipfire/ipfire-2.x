From: jbeulich@novell.com
Subject: conditionalize driverlink additions to Solarflare driver
Patch-mainline: obsolete
References: FATE#303479

At once converted the EFX_TRACE() invocations after vetoed RX/TX
callbacks to ...LOG() ones, which is consistent with Solarflare's
current code according to David Riddoch (2008-09-12).

Index: head-2008-09-01/drivers/net/sfc/Kconfig
===================================================================
--- head-2008-09-01.orig/drivers/net/sfc/Kconfig	2008-07-17 16:18:07.000000000 +0200
+++ head-2008-09-01/drivers/net/sfc/Kconfig	2008-09-12 14:01:48.000000000 +0200
@@ -13,8 +13,12 @@ config SFC
 	  To compile this driver as a module, choose M here.  The module
 	  will be called sfc.
 
+config SFC_DRIVERLINK
+	bool
+
 config SFC_RESOURCE
 	depends on SFC && X86
+	select SFC_DRIVERLINK
 	tristate "Solarflare Solarstorm SFC4000 resource driver"
 	help
 	  This module provides the SFC resource manager driver.
Index: head-2008-09-01/drivers/net/sfc/Makefile
===================================================================
--- head-2008-09-01.orig/drivers/net/sfc/Makefile	2008-07-17 16:18:07.000000000 +0200
+++ head-2008-09-01/drivers/net/sfc/Makefile	2008-09-12 12:22:05.000000000 +0200
@@ -1,7 +1,7 @@
 sfc-y			+= efx.o falcon.o tx.o rx.o falcon_xmac.o \
 			   selftest.o ethtool.o xfp_phy.o \
-			   mdio_10g.o tenxpress.o boards.o sfe4001.o \
-			   driverlink.o
+			   mdio_10g.o tenxpress.o boards.o sfe4001.o
+sfc-$(CONFIG_SFC_DRIVERLINK) += driverlink.o
 obj-$(CONFIG_SFC)	+= sfc.o
 
 obj-$(CONFIG_SFC_RESOURCE) += sfc_resource/
Index: head-2008-09-01/drivers/net/sfc/driverlink.c
===================================================================
--- head-2008-09-01.orig/drivers/net/sfc/driverlink.c	2008-08-18 10:16:46.000000000 +0200
+++ head-2008-09-01/drivers/net/sfc/driverlink.c	2008-09-12 13:57:29.000000000 +0200
@@ -14,7 +14,6 @@
 #include <linux/rtnetlink.h>
 #include "net_driver.h"
 #include "efx.h"
-#include "driverlink_api.h"
 #include "driverlink.h"
 
 /* Protects @efx_driverlink_lock and @efx_driver_list */
Index: head-2008-09-01/drivers/net/sfc/driverlink.h
===================================================================
--- head-2008-09-01.orig/drivers/net/sfc/driverlink.h	2008-08-18 10:16:46.000000000 +0200
+++ head-2008-09-01/drivers/net/sfc/driverlink.h	2008-09-12 16:14:04.000000000 +0200
@@ -15,6 +15,10 @@
 struct efx_dl_device;
 struct efx_nic;
 
+#ifdef CONFIG_SFC_DRIVERLINK
+
+#include "driverlink_api.h"
+
 /* Efx callback devices
  *
  * A list of the devices that own each callback. The partner to
@@ -40,4 +44,23 @@ extern void efx_dl_unregister_nic(struct
 extern void efx_dl_reset_suspend(struct efx_nic *efx);
 extern void efx_dl_reset_resume(struct efx_nic *efx, int ok);
 
+#define EFX_DL_LOG EFX_LOG
+
+#else /* CONFIG_SFC_DRIVERLINK */
+
+enum efx_veto { EFX_ALLOW_PACKET = 0 };
+
+static inline int efx_nop_callback(struct efx_nic *efx) { return 0; }
+#define EFX_DL_CALLBACK(port, name, ...) efx_nop_callback(port)
+
+static inline int efx_dl_register_nic(struct efx_nic *efx) { return 0; }
+static inline void efx_dl_unregister_nic(struct efx_nic *efx) {}
+
+static inline void efx_dl_reset_suspend(struct efx_nic *efx) {}
+static inline void efx_dl_reset_resume(struct efx_nic *efx, int ok) {}
+
+#define EFX_DL_LOG(efx, fmt, args...) ((void)(efx))
+
+#endif /* CONFIG_SFC_DRIVERLINK */
+
 #endif /* EFX_DRIVERLINK_H */
Index: head-2008-09-01/drivers/net/sfc/efx.c
===================================================================
--- head-2008-09-01.orig/drivers/net/sfc/efx.c	2008-08-18 10:16:46.000000000 +0200
+++ head-2008-09-01/drivers/net/sfc/efx.c	2008-09-12 12:42:32.000000000 +0200
@@ -1596,6 +1596,7 @@ static void efx_unregister_netdev(struct
  * Device reset and suspend
  *
  **************************************************************************/
+#ifdef CONFIG_SFC_DRIVERLINK
 /* Serialise access to the driverlink callbacks, by quiescing event processing
  * (without flushing the descriptor queues), and acquiring the rtnl_lock */
 void efx_suspend(struct efx_nic *efx)
@@ -1613,6 +1614,7 @@ void efx_resume(struct efx_nic *efx)
 	efx_start_all(efx);
 	rtnl_unlock();
 }
+#endif
 
 /* The final hardware and software finalisation before reset. */
 static int efx_reset_down(struct efx_nic *efx, struct ethtool_cmd *ecmd)
@@ -1899,9 +1901,11 @@ static int efx_init_struct(struct efx_ni
 	mutex_init(&efx->mac_lock);
 	efx->phy_op = &efx_dummy_phy_operations;
 	efx->mii.dev = net_dev;
+#ifdef CONFIG_SFC_DRIVERLINK
 	INIT_LIST_HEAD(&efx->dl_node);
 	INIT_LIST_HEAD(&efx->dl_device_list);
 	efx->dl_cb = efx_default_callbacks;
+#endif
 	INIT_WORK(&efx->reconfigure_work, efx_reconfigure_work);
 	atomic_set(&efx->netif_stop_count, 1);
 
Index: head-2008-09-01/drivers/net/sfc/falcon.c
===================================================================
--- head-2008-09-01.orig/drivers/net/sfc/falcon.c	2008-08-18 10:16:46.000000000 +0200
+++ head-2008-09-01/drivers/net/sfc/falcon.c	2008-09-12 13:51:32.000000000 +0200
@@ -36,12 +36,17 @@
 
 /**
  * struct falcon_nic_data - Falcon NIC state
+ * @next_buffer_table: First available buffer table id
  * @resources: Resource information for driverlink client
  * @pci_dev2: The secondary PCI device if present
  * @i2c_data: Operations and state for I2C bit-bashing algorithm
  */
 struct falcon_nic_data {
+#ifndef CONFIG_SFC_DRIVERLINK
+	unsigned next_buffer_table;
+#else
 	struct efx_dl_falcon_resources resources;
+#endif
 	struct pci_dev *pci_dev2;
 	struct i2c_algo_bit_data i2c_data;
 };
@@ -322,8 +327,13 @@ static int falcon_alloc_special_buffer(s
 	memset(buffer->addr, 0xff, len);
 
 	/* Select new buffer ID */
+#ifndef CONFIG_SFC_DRIVERLINK
+	buffer->index = nic_data->next_buffer_table;
+	nic_data->next_buffer_table += buffer->entries;
+#else
 	buffer->index = nic_data->resources.buffer_table_min;
 	nic_data->resources.buffer_table_min += buffer->entries;
+#endif
 
 	EFX_LOG(efx, "allocating special buffers %d-%d at %llx+%x "
 		"(virt %p phys %lx)\n", buffer->index,
@@ -2382,6 +2392,7 @@ static int falcon_probe_nvconfig(struct 
  * should live. */
 static int falcon_dimension_resources(struct efx_nic *efx)
 {
+#ifdef CONFIG_SFC_DRIVERLINK
 	unsigned internal_dcs_entries;
 	struct falcon_nic_data *nic_data = efx->nic_data;
 	struct efx_dl_falcon_resources *res = &nic_data->resources;
@@ -2426,6 +2437,7 @@ static int falcon_dimension_resources(st
 
 	if (EFX_INT_MODE_USE_MSI(efx))
 		res->flags |= EFX_DL_FALCON_USE_MSI;
+#endif
 
 	return 0;
 }
@@ -2551,7 +2563,9 @@ int falcon_probe_nic(struct efx_nic *efx
 	return 0;
 
  fail6:
+#ifdef CONFIG_SFC_DRIVERLINK
 	efx->dl_info = NULL;
+#endif
  fail5:
 	falcon_free_buffer(efx, &efx->irq_status);
  fail4:
@@ -2742,7 +2756,9 @@ void falcon_remove_nic(struct efx_nic *e
 	/* Tear down the private nic state */
 	kfree(efx->nic_data);
 	efx->nic_data = NULL;
+#ifdef CONFIG_SFC_DRIVERLINK
 	efx->dl_info = NULL;
+#endif
 }
 
 void falcon_update_nic_stats(struct efx_nic *efx)
Index: head-2008-09-01/drivers/net/sfc/net_driver.h
===================================================================
--- head-2008-09-01.orig/drivers/net/sfc/net_driver.h	2008-08-18 10:16:46.000000000 +0200
+++ head-2008-09-01/drivers/net/sfc/net_driver.h	2008-09-12 13:57:19.000000000 +0200
@@ -30,7 +30,6 @@
 
 #include "enum.h"
 #include "bitfield.h"
-#include "driverlink_api.h"
 #include "driverlink.h"
 
 #define EFX_MAX_LRO_DESCRIPTORS 8
@@ -762,11 +761,13 @@ struct efx_nic {
 	void *loopback_selftest;
 
 	const char *silicon_rev;
+#ifdef CONFIG_SFC_DRIVERLINK
 	struct efx_dl_device_info *dl_info;
 	struct list_head dl_node;
 	struct list_head dl_device_list;
 	struct efx_dl_callbacks dl_cb;
 	struct efx_dl_cb_devices dl_cb_dev;
+#endif
 };
 
 static inline int efx_dev_registered(struct efx_nic *efx)
Index: head-2008-09-01/drivers/net/sfc/rx.c
===================================================================
--- head-2008-09-01.orig/drivers/net/sfc/rx.c	2008-08-18 10:16:46.000000000 +0200
+++ head-2008-09-01/drivers/net/sfc/rx.c	2008-09-12 16:13:49.000000000 +0200
@@ -559,8 +559,8 @@ static inline void efx_rx_packet_lro(str
 	 * an obvious interface to this, so veto packets before LRO */
 	veto = EFX_DL_CALLBACK(efx, rx_packet, rx_buf->data, rx_buf->len);
 	if (unlikely(veto)) {
-		EFX_TRACE(efx, "LRO RX vetoed by driverlink %s driver\n",
-			  efx->dl_cb_dev.rx_packet->driver->name);
+		EFX_DL_LOG(efx, "LRO RX vetoed by driverlink %s driver\n",
+			   efx->dl_cb_dev.rx_packet->driver->name);
 		/* Free the buffer now */
 		efx_free_rx_buffer(efx, rx_buf);
 		return;
@@ -741,8 +741,8 @@ void __efx_rx_packet(struct efx_channel 
 	/* Allow callback to veto the packet */
 	veto = EFX_DL_CALLBACK(efx, rx_packet, rx_buf->data, rx_buf->len);
 	if (unlikely(veto)) {
-		EFX_LOG(efx, "RX vetoed by driverlink %s driver\n",
-			efx->dl_cb_dev.rx_packet->driver->name);
+		EFX_DL_LOG(efx, "RX vetoed by driverlink %s driver\n",
+			   efx->dl_cb_dev.rx_packet->driver->name);
 		/* Free the buffer now */
 		efx_free_rx_buffer(efx, rx_buf);
 		goto done;
Index: head-2008-09-01/drivers/net/sfc/tx.c
===================================================================
--- head-2008-09-01.orig/drivers/net/sfc/tx.c	2008-08-18 10:16:46.000000000 +0200
+++ head-2008-09-01/drivers/net/sfc/tx.c	2008-09-12 16:13:34.000000000 +0200
@@ -374,9 +374,9 @@ int efx_hard_start_xmit(struct sk_buff *
 	/* See if driverlink wants to veto the packet. */
 	veto = EFX_DL_CALLBACK(efx, tx_packet, skb);
 	if (unlikely(veto)) {
-		EFX_TRACE(efx, "TX queue %d packet vetoed by "
-			  "driverlink %s driver\n", tx_queue->queue,
-			  efx->dl_cb_dev.tx_packet->driver->name);
+		EFX_DL_LOG(efx, "TX queue %d packet vetoed by "
+			   "driverlink %s driver\n", tx_queue->queue,
+			   efx->dl_cb_dev.tx_packet->driver->name);
 		/* Free the skb; nothing else will do it */
 		dev_kfree_skb_any(skb);
 		return NETDEV_TX_OK;
