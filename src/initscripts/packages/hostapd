#!/bin/sh
###############################################################################
#                                                                             #
# IPFire.org - A linux based firewall                                         #
# Copyright (C) 2007-2022  IPFire Team  <info@ipfire.org>                     #
#                                                                             #
# This program is free software: you can redistribute it and/or modify        #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation, either version 3 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# This program is distributed in the hope that it will be useful,             #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU General Public License for more details.                                #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with this program.  If not, see <http://www.gnu.org/licenses/>.       #
#                                                                             #
###############################################################################

. /etc/sysconfig/rc
. ${rc_functions}

declare -A HT_CAPS=(
	# LDPC Coding Capability
	[0x0001]="[LDPC]"
	# 40 MHz Channel Width
	[0x0002]="[HT40+][HT40-]"
	# SM Power Save
	# [0x0004] - not supported by hostapd
	# Greenfield
	[0x0008]="[GF]"
	# Short Guard Interval (SGI) for 20 MHz
	[0x0010]="[SHORT-GI-20]"
	# Short Guard Interval (SGI) for 40 MHz
	[0x0020]="[SHORT-GI-40]"
	# TX STBC support
	[0x0040]="[TX-STBC]"
	# RX STBC support (1 stream)
	[0x0080]="[RX-STBC1]"
	# HT-delayed Block Ack
	[0x0100]="[DELAYED-BA]"
	# Max A-MSDU length (7935 vs. 3839 bytes)
	[0x0200]="[MAX-AMSDU-7935]"
	# DSSS/CCK Mode in 40 MHz
	[0x0400]="[DSSS_CCK-40]"
	# PSMP support
	# [0x0800] - not supported by hostapd
	# 40 MHz Intolerant
	[0x1000]="[40-INTOLERANT]"
	# L-SIG TXOP protection support
	[0x2000]="[LSIG-TXOP-PROT]"
)

declare -A HT_CAPS_DRIVER_FILTERS=(
	# ath1[02]k does not support Greenfield or Delayed Block Ack
	[ath10k_pci]="$(( 0xffff & ~0x0008 & ~0x0100 ))"
	[ath12k_pci]="$(( 0xffff & ~0x0008 & ~0x0100 ))"
)

declare -A VHT_CAPS=(
	# RX LDPC
	[0x00000008]="[RXLDPC]"
	# Short GI for 80 MHz
	[0x00000010]="[SHORT-GI-80]"
	# Short GI for 160/80+80 MHz
	[0x00000020]="[SHORT-GI-160]"
	# TX STBC
	[0x00000040]="[TX-STBC-2BY1]"
	# SU Beamformer capable
	[0x00000800]="[SU-BEAMFORMER]"
	# SU Beamformee capable
	[0x00001000]="[SU-BEAMFORMEE]"
	# MU Beamformer capable
	[0x00080000]="[MU-BEAMFORMER]"
	# MU Beamformee capable
	[0x00100000]="[MU-BEAMFORMEE]"
	# VHT TXOP Power Save
	[0x00200000]="[VHT-TXOP-PS]"
	# +HTC-VHT
	[0x00400000]="[HTC-VHT]"
	# RX antenna pattern consistency
	[0x10000000]="[RX-ANTENNA-PATTERN]"
	# TX antenna pattern consistency
	[0x20000000]="[TX-ANTENNA-PATTERN]"
)

declare -A VHT_CAPS_DRIVER_FILTERS=(
	# ath12k does not support Short GI for 160 MHz
	[ath12k_pci]="$(( 0xffffffff & ~0x00000020 ))"
)

find_interface() {
	local address="${1}"

	local path
	for path in /sys/class/net/*; do
		if [ -s "${path}/address" ] && [ "$(<${path}/address)" = "${address}" ]; then
			basename "${path}"
			return 0
		fi
	done

	return 1;
}

write_config() {
	local interface="${1}"

	# Fetch the PHY
	local phy="$(</sys/class/net/${interface}/phy80211/name)"

	# Fetch the driver
	local driver="$(readlink /sys/class/net/${interface}/device/driver)"
	driver="${driver##*/}"

	local flag
	local ht_flags=0
	local vht_flags=0

	local ht_caps=()
	local vht_caps=()

	# Fetch PHY information
	local line
	while read -r line; do
		case "${line}" in
			"VHT Capabilities"*)
				vht_flags="${line:18:10}"
				;;

			"Capabilities: "*)
				ht_flags="${line:14}"
				;;
		esac
	done <<<"$(iw phy "${phy}" info)"

	# Fix the HT caps because some drivers don't support everything
	# that the actual hardware supports (or have it turned off because of bugs).
	if [ -n "${HT_CAPS_DRIVER_FILTERS[${driver}]}" ]; then
		ht_flags="$(( ${ht_flags} & ${HT_CAPS_DRIVER_FILTERS[${driver}]} ))"
	fi

	# Fix the VHT caps because some drivers don't support everything
	# that the actual hardware supports (or have it turned off because of bugs).
	if [ -n "${VHT_CAPS_DRIVER_FILTERS[${driver}]}" ]; then
		vht_flags="$(( ${vht_flags} & ${VHT_CAPS_DRIVER_FILTERS[${driver}]} ))"
	fi

	# HT Capabilities
	for flag in ${!HT_CAPS[@]}; do
		if (( ${ht_flags} & ${flag} )); then
			ht_caps+=( "${HT_CAPS[${flag}]}" )
		fi
	done

	# VHT Capabilities
	for flag in ${!VHT_CAPS[@]}; do
		if (( ${vht_flags} & ${flag} )); then
			vht_caps+=( "${VHT_CAPS[${flag}]}" )
		fi
	done

	# Supported channel width
	case "$(( (${vht_flags} >> 2) & 0x03 ))" in
		0)
			# Neither 160, nor 80+80 MHz
			;;
		1)
			vht_caps+=( "[VHT160]" )
			;;
		2)
			vht_caps+=( "[VHT160-80PLUS80]" )
			;;
	esac

	# VHT Max MPDU Length
	case "$(( ${vht_flags} & 0x03 ))" in
		0)
			# Default, 3895
			;;
		1)
			vht_caps+=( "[MAX-MPDU-7991]" )
			;;
		2)
			vht_caps+=( "[MAX-MPDU-11454]" )
			;;
	esac

	# RX Spacial Streams
	case "$(( (${vht_flags} >> 8) & 0x03 ))" in
		1)
			vht_caps+=( "[RX-STBC-1]" )
			;;
		2)
			vht_caps+=( "[RX-STBC-12]" )
			;;
		3)
			vht_caps+=( "[RX-STBC-123]" )
			;;
		4)
			vht_caps+=( "[RX-STBC-1234]" )
			;;
	esac

	# Compressed Steering
	case "$(( ${vht_flags} >> 13) & 0x03 ))" in
		2)
			vht_caps+=( "[BF-ANTENNA-2]" )
			;;
		3)
			vht_caps+=( "[BF-ANTENNA-3]" )
			;;
		4)
			vht_caps+=( "[BF-ANTENNA-4]" )
			;;
	esac

	# Sounding Dimension
	case "$(( (${vht_flags} >> 16) & 0x03 ))" in
		2)
			vht_caps+=( "[SOUNDING-DIMENSION-2]" )
			;;
		3)
			vht_caps+=( "[SOUNDING-DIMENSION-3]" )
			;;
		4)
			vht_caps+=( "[SOUNDING-DIMENSION-4]" )
			;;
	esac

	local exponent="$(( (${vht_flags} >> 23) & 0x03 ))"
	if [ "${exponent}" -ge 0 ] && [ "${exponent}" -le 7 ]; then
		vht_caps+=( "[MAX-A-MPDU-LEN-EXP${exponent}]" )
	fi

	# VHT Link Adaptation
	case "$(( (${vht_flags} >> 26) & 0x03 ))" in
		2)
			vht_caps+=( "[VHT-LINK-ADAPT2]" )
			;;
		3)
			vht_caps+=( "[VHT-LINK-ADAPT3]" )
			;;
	esac

	# Header
	echo "# Automatically generated configuration"
	echo "# DO NOT EDIT"

	# Enable logging
	echo "logger_syslog=-1"
	echo "logger_syslog_level=4"

	# Use Netlink
	echo "driver=nl80211"

	# Set the country code
	echo "country_code=${COUNTRY}"
	echo "country3=0x49"

	# Enable 802.11d and 802.11h
	echo "ieee80211d=1"
	echo "ieee80211h=1"

	# Set the channel (if chosen)
	if [ -n "${CHANNEL}" ]; then
		echo "channel=${CHANNEL}"
	fi

	# Always advertise TPC
	echo "local_pwr_constraint=3"
	echo "spectrum_mgmt_required=1"

	# Set mode
	case "${HW_MODE}" in
		ac)
			echo "hw_mode=a"
			echo "ieee80211ac=1"
			echo "ieee80211n=1"
			echo "wmm_enabled=1"
			echo "vht_oper_chwidth=1"
			;;
		an|gn)
			echo "hw_mode=${HW_MODE:0:1}"
			echo "ieee80211n=1"
			echo "wmm_enabled=1"
			;;
		*)
			echo "Unsupported mode '${HW_MODE}'" >&2
			return 1
			;;
	esac

	# Set HT capabilities
	if [ ${#ht_caps[@]} -gt 0 ]; then
		echo "ht_capab=${ht_caps[@]}"
	fi

	# Set VHT capabilities
	if [ ${#vht_caps[@]} -gt 0 ]; then
		echo "vht_capab=${vht_caps[@]}"
	fi

	# Enable authentication
	echo "auth_algs=1"

	# Enable the control interface
	echo "ctrl_interface=/var/run/hostapd"
	echo "ctrl_interface_group=0"

	# Disconnect clients that are too far away
	echo "disassoc_low_ack=1"

	# SSID
	echo "ssid2=\"${SSID}\""
	echo "utf8_ssid=1"

	# Hide the SSID?
	if [ "${HIDESSID}" = "on" ]; then
		echo "ignore_broadcast_ssid=2"
	fi

	# Isolate clients?
	if [ "${CLIENTISOLATION}" = "on" ]; then
		echo "ap_isolate=1"
	fi

	# Disable neighbour scan?
	if [ "${NOSCAN}" = "on" ]; then
		echo "noscan=1"
	else
		echo "noscan=0"
	fi

	# Management Frame Protection (802.11w)
	case "${IEEE80211W}" in
		on)
			echo "ieee80211w=2"

			# Enable beacon protection
			echo "beacon_prot=1"

			# Enable Operating Channel Validation
			echo "ocv=1"
			;;

		optional)
			echo "ieee80211w=1"

			# Enable beacon protection
			echo "beacon_prot=1"

			# Enable OCV in compatibility mode for broken stations
			echo "ocv=2"
			;;
		*)
			echo "ieee80211w=0"
			;;
	esac

	# Encryption
	case "${ENC}" in
		wpa3)
			echo "wpa=2"
			echo "wpa_passphrase=${PWD}"
			echo "wpa_key_mgmt=SAE"
			echo "rsn_pairwise=CCMP"
			;;
		wpa2+3)
			echo "wpa=2"
			echo "wpa_passphrase=${PWD}"
			echo "wpa_key_mgmt=WPA-PSK WPA-PSK-SHA256 SAE"
			echo "rsn_pairwise=CCMP"
			;;
		wpa2)
			echo "wpa=2"
			echo "wpa_passphrase=${PWD}"
			echo "wpa_key_mgmt=WPA-PSK WPA-PSK-SHA256"
			echo "rsn_pairwise=CCMP"
			;;
		wpa1+2)
			echo "wpa=3"
			echo "wpa_passphrase=${PWD}"
			echo "wpa_key_mgmt=WPA-PSK WPA-PSK-SHA256"
			echo "wpa_pairwise=TKIP"
			echo "rsn_pairwise=CCMP"
			;;
		wpa1)
			echo "wpa=1"
			echo "wpa_passphrase=${PWD}"
			echo "wpa_key_mgmt=WPA-PSK WPA-PSK-SHA256"
			echo "wpa_pairwise=TKIP"
			;;
	esac

	# Multi-Band Operation - prefer WiFi over mobile networks
	# This feature requires Management Frame Protection
	case "${IEEE80211W}" in
		on|optional)
			echo "mbo=1"
			echo "mbo_cell_data_conn_pref=1"
			;;
	esac

	# Always enable SSID protection
	echo "ssid_protection=1"

	# Extended Key ID support for Individually Addressed frames
	echo "extended_key_id=1"

	# Fully enable Optimized Connectivity Experience
	echo "oce=7"

	# Enable 802.11u Interworking Support
	echo "interworking=1"

	# 802.11u: We are a private network
	echo "access_network_type=0"

	# 802.11u: We have internet access
	echo "internet=1"

	# 802.11v: Advertise the time
	echo "time_advertisement=2"

	return 0
}

eval $(/usr/local/bin/readhash /var/ipfire/wlanap/settings)

case "${1}" in
	start)
		interface="$(find_interface "${INTERFACE}")"
		if [ -z "${interface}" ]; then
			boot_mesg "Could not find interface with address ${INTERFACE} for wireless access point"
			echo_failure
			exit 1
		fi

		# Write the configuration
		if ! write_config "${interface}" > /etc/hostapd.conf; then
			boot_mesg "Failed to generate configuration"
			echo_failure
			exit 1
		fi

		# Compose the command line
		args=(
			/usr/bin/hostapd
			-s
			-B
			/etc/hostapd.conf
			-i "${interface}"
		)

		# Enable debugging?
		if [ -n "${DEBUG}" ]; then
			args+=( "-ddd" )
		fi

		boot_mesg "Starting hostapd... "
		loadproc "${args[@]}"
		;;

	stop)
		boot_mesg "Stopping hostapd..."
		killproc /usr/bin/hostapd
		evaluate_retval
		;;

	restart)
		${0} stop
		sleep 1
		${0} start
		;;

	status)
		statusproc /usr/bin/hostapd
		;;

	show-config)
		interface="$(find_interface "${INTERFACE}")"
		if [ -z "${interface}" ]; then
			boot_mesg "Could not find interface with address ${INTERFACE} for wireless access point"
			echo_failure
			exit 1
		fi

		write_config "${interface}"
		;;

	*)
		echo "Usage: ${0} {start|stop|restart|status}"
		exit 1
		;;
esac
